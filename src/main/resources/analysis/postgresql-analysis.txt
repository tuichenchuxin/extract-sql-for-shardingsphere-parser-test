$ex$;
$f$ language plpgsql;
$func$;
$outer$;
$proc$ language plpgsql;
' LANGUAGE SQL;
' LANGUAGE plpgsql;
' LANGUAGE plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
' language plpgsql;
';
);
);
** Remember the delete rule on rtest_v1: It says ** DO INSTEAD DELETE FROM rtest_t1 WHERE a = old.a ** So this time both rows with a = 2 must get deleted \p \r delete from rtest_v1 where b = 12;
*/ CREATE VIEW collview1 AS SELECT * FROM collate_test1 WHERE b COLLATE "C" >= 'bbc';
*/ Hoo boy. Still two deep... */ Now just one deep... */ 'deeply nested example' AS sixth;
*/ SELECT 'after multi-line' AS fifth;
*/ SELECT -- continued after the following block comments... /* Deeply nested comment.    This includes a single apostrophe to make sure we aren't decoding this part as a string. SELECT 'deep nest' AS n1;
-5.2 -0.0000000001 0.000000000001 1 1.99999999999999 2 2.00000000000001 3 4 4.5 5 5.5 6 7 8 9 9.99999999999999 10 10.0000000000001 \. UPDATE width_bucket_test SET operand_f8 = operand_num::float8;
/* SELECT 'trailing' as x1; -- inside block comment */ /* This block comment surrounds a query which itself has a block comment... SELECT /* embedded single line */ 'embedded' AS x2;
/* Second level of nesting... SELECT 'deeper nest' as n2;
/* Third level of nesting... SELECT 'deepest nest' as n3;
/* This is an example of SQL which should not execute:  * select 'multi-line';
/* not run by default because it requires tr_TR system locale SET lc_time TO 'tr_TR';
0 \. select * from check_con_tbl;
1	1	1	1	1	1	1	1 1	1	1	1	1	1	1	2 1	1	1	1	1	1	2	2 1	1	1	1	1	2	2	2 1	1	1	1	2	2	2	2 1	1	1	2	2	2	2	2 1	1	2	2	2	2	2	2 1	2	2	2	2	2	2	2 2	2	2	2	2	2	2	2 \. create temp table gstest3 (a integer, b integer, c integer, d integer);
1	1	1	1	1	B0101 3	3	3	null	2	B0100 7	7	7	3	4	B1100 \. SELECT   BIT_AND(i2) AS "1",   BIT_AND(i4) AS "1",   BIT_AND(i8) AS "1",   BIT_AND(i)  AS "?",   BIT_AND(x)  AS "0",   BIT_AND(y)  AS "0100",   BIT_OR(i2)  AS "7",   BIT_OR(i4)  AS "7",   BIT_OR(i8)  AS "7",   BIT_OR(i)   AS "?",   BIT_OR(x)   AS "7",   BIT_OR(y)   AS "1101",   BIT_XOR(i2) AS "5",   BIT_XOR(i4) AS "5",   BIT_XOR(i8) AS "5",   BIT_XOR(i)  AS "?",   BIT_XOR(x)  AS "7",   BIT_XOR(y)  AS "1101" FROM bitwise_test;
1	1	1	1 2	2	2	2 \. alter table gstest3 add primary key (a);
1	4	1 2	3	2 3	2	3 4	1	4 \. CREATE POLICY p1 ON rls_t1 FOR SELECT USING (a % 2 = 0);
1	baz 2	qux \. select tableoid::regclass, * from donothingbrtrig_test;
1	test_1 \. COPY x (b, d) from stdin;
1 2 \. copy parted_stmt_trig1(a) from stdin;
1 \. alter table parted_stmt_trig disable trigger trig_ins_after_parent;
1 \N \. copy check_con_tbl from stdin;
1,"a field with two LFs inside",2 \. CREATE TEMP TABLE testeoc (a text);
1,,"" \. COMMIT;
10	11	12 \. select * from attest;
100	foo	200 101	bar	201 \. COPY itest9 (b, c) FROM stdin;
10001	22	32	42	52 10002	23	33	43	53 10003	24	34	44	54 10004	25	35	45	55 10005	26	36	46	56 \. COPY x (xyz) from stdin;
101	1	aba 102	2	bbb 103	3	ccc 104	4	dad \. CREATE TABLE t2 (c float) INHERITS (t1);
123	999 456	999 \. DELETE FROM main_table WHERE a IN (123, 456);
2	test_2 3	test_3 4	test_4 5	test_5 \. COPY x (a, b, c, d, e) from stdin;
2,'a',,"" \. COMMIT;
2000	230	23	23 \. COPY x from stdin;
2001	231	\N	\N \. COPY x from stdin;
2002	232	40	50	60	70	80 \. COPY x (b, c, d, e) from stdin delimiter ',' null 'x';
201	1	abc	1.1 202	2	bcd	2.2 203	3	cde	3.3 204	4	def	4.4 \. CREATE TABLE t3 (id int not null primary key, c text, b text, a int);
21	22 \. select * from attest;
3 4 \. COPY gtest1 (a, b) FROM stdin;
3 4 \. COPY gtest3 (a, b) FROM stdin;
3,,"" \. ROLLBACK;
30	40 50	60 \. SELECT * FROM main_table ORDER BY a, b;
3000;;c;;
301	1	xxx	X 302	2	yyy	Y 303	3	zzz	Z \. CREATE POLICY p1 ON t1 FOR ALL TO PUBLIC USING (a % 2 = 0); -- be even number CREATE POLICY p2 ON t2 FOR ALL TO PUBLIC USING (a % 2 = 1); -- be odd number ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;
31	32 \. select * from attest;
4000:\X:C:\X:\X 4001:1:empty:: 4002:2:null:\X:\X 4003:3:Backslash:\\:\\ 4004:4:BackslashX:\\X:\\X 4005:5:N:\N:\N 4006:6:BackslashN:\\N:\\N 4007:7:XX:\XX:\XX 4008:8:Delimiter:\::\: \. COPY x TO stdout WHERE a = 1;
41 mon 12 days 360:00 -41 mon -12 days +360:00 -12 days 9 mon -27 days 12:34:56 -3 years 482 days 76:54:32.189 4 mon 14 mon 999 mon 999 days \. SELECT span * 0.3 AS product FROM INTERVAL_MULDIV_TBL;
42	\\0 \0	\0 \. SELECT * FROM testnull;
42 \. select * from defaulttest;
5	10 10	15 15	20 20	25 \. CREATE OR REPLACE VIEW viewtest AS 	SELECT * FROM viewtest_tbl;
5	10 20	20 30	10 50	35 80	15 \. CREATE FUNCTION trigger_func() RETURNS trigger LANGUAGE plpgsql AS ' BEGIN 	RAISE NOTICE ''trigger_func(%) called: action = %, when = %, level = %'', TG_ARGV[0], TG_OP, TG_WHEN, TG_LEVEL;
5	10 50	100 500	1000 \.create function return_unnamed_refcursor() returns refcursor as $$ declare     rc refcursor; begin     open rc for select a from rc_test;     return rc; end $$ language plpgsql;
50003	24	34	44	54 50004	25	35	45	55 50005	26	36	46	56 \. COPY x from stdin WHERE a > 60003;
60001	22	32	42	52 60002	23	33	43	53 60003	24	34	44	54 60004	25	35	45	55 60005	26	36	46	56 \. COPY x from stdin WHERE f > 60003;
9999	\N	\\N	\NN	\N 10000	21	31	41	51 \. COPY x (b, d) from stdin;
:init_range_parted;
:init_range_parted;
:init_range_parted;
:init_range_parted;
:init_range_parted;
:init_range_parted;
:init_range_parted;
:init_range_parted;
:init_range_parted;
:init_range_parted;
:init_range_parted;
:init_range_parted;
:init_range_parted;
:init_range_parted;
:qry;
:qry;
:show_data;
:show_data;
:show_data;
:show_data;
:show_data;
:show_data;
:show_data;
:show_data;
:show_data;
:show_data;
:show_data;
:show_data;
:show_data;
:show_data;
;
;
;
;
</script> </body> </html>', to_tsquery('english', 'sea&foo'), 'HighlightAll=true');
AAA	42 BBB	42 CCC	234 \. drop table child1, child2, child3, parent;
AAA	42 BBB	42 CCC	42 \. create index on parent(b);
AAA	42 BBB	42 CCC	42 \. create or replace function intercept_insert() returns trigger language plpgsql as$$   begin     new.b = new.b + 1000;     return new;   end; $$;
AAA	42 BBB	42 CCC	42 \. drop trigger child1_insert_trig on child1;
ALTER AGGREGATE alt_func1(int) RENAME TO alt_func3;  -- failed (not aggregate) ALTER AGGREGATE alt_func1(int) OWNER TO regress_alter_generic_user3;  -- failed (not aggregate) ALTER AGGREGATE alt_func1(int) SET SCHEMA alt_nsp2;  -- failed (not aggregate) ALTER FUNCTION alt_func1(int) RENAME TO alt_func2;  -- failed (name conflict) ALTER FUNCTION alt_func1(int) RENAME TO alt_func3;  -- OK ALTER FUNCTION alt_func2(int) OWNER TO regress_alter_generic_user2;  -- failed (no role membership) ALTER FUNCTION alt_func2(int) OWNER TO regress_alter_generic_user3;  -- OK ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp1;  -- OK, already there ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp2;  -- OK ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg2;   -- failed (name conflict) ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg3;   -- OK ALTER AGGREGATE alt_agg2(int) OWNER TO regress_alter_generic_user2;  -- failed (no role membership) ALTER AGGREGATE alt_agg2(int) OWNER TO regress_alter_generic_user3;  -- OK ALTER AGGREGATE alt_agg2(int) SET SCHEMA alt_nsp2;  -- OK SET SESSION AUTHORIZATION regress_alter_generic_user2;
ALTER COLLATION "en-x-icu" REFRESH VERSION;
ALTER COLLATION "en_US" REFRESH VERSION;
ALTER COLLATION test0 RENAME TO test11; -- fail ALTER COLLATION test1 RENAME TO test22; -- fail ALTER COLLATION test11 OWNER TO regress_test_role;
ALTER COLLATION test0 RENAME TO test11; -- fail ALTER COLLATION test1 RENAME TO test22; -- fail ALTER COLLATION test11 OWNER TO regress_test_role;
ALTER COLLATION test1 RENAME TO test11;
ALTER COLLATION test1 RENAME TO test11;
ALTER COLLATION test11 OWNER TO nonsense;
ALTER COLLATION test11 OWNER TO nonsense;
ALTER COLLATION test11 SET SCHEMA test_schema;
ALTER COLLATION test11 SET SCHEMA test_schema;
ALTER DEFAULT PRIVILEGES FOR ROLE regress_addr_user IN SCHEMA public GRANT ALL ON TABLES TO regress_addr_user;
ALTER DEFAULT PRIVILEGES FOR ROLE regress_addr_user REVOKE DELETE ON TABLES FROM regress_addr_user;
ALTER DEFAULT PRIVILEGES FOR ROLE regress_dep_user1 IN SCHEMA deptest   GRANT ALL ON TABLES TO regress_dep_user2;
ALTER DEFAULT PRIVILEGES FOR ROLE regress_matview_user   GRANT INSERT ON TABLES TO regress_matview_user;
ALTER DEFAULT PRIVILEGES FOR ROLE regress_matview_user   REVOKE INSERT ON TABLES FROM regress_matview_user;
ALTER DEFAULT PRIVILEGES FOR ROLE regress_priv_user1 REVOKE USAGE ON TYPES FROM public;
ALTER DEFAULT PRIVILEGES FOR ROLE regress_selinto_user 	  GRANT INSERT ON TABLES TO regress_selinto_user;
ALTER DEFAULT PRIVILEGES FOR ROLE regress_selinto_user 	  REVOKE INSERT ON TABLES FROM regress_selinto_user;
ALTER DEFAULT PRIVILEGES GRANT ALL ON FUNCTIONS TO regress_priv_user2;
ALTER DEFAULT PRIVILEGES GRANT ALL ON SCHEMAS TO regress_priv_user2;
ALTER DEFAULT PRIVILEGES GRANT ALL ON SEQUENCES TO regress_priv_user2;
ALTER DEFAULT PRIVILEGES GRANT ALL ON TABLES TO regress_priv_user2;
ALTER DEFAULT PRIVILEGES GRANT ALL ON TYPES TO regress_priv_user2;
ALTER DEFAULT PRIVILEGES GRANT USAGE ON SCHEMAS TO regress_priv_user2;
ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT USAGE ON SCHEMAS TO regress_priv_user2; -- error BEGIN;
ALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11) NOT VALID;
ALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11);
ALTER DOMAIN things VALIDATE CONSTRAINT meow;
ALTER DOMAIN things VALIDATE CONSTRAINT meow;
ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw2;  -- failed (name conflict) ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw3;  -- OK ALTER SERVER alt_fserv1 RENAME TO alt_fserv2;   -- failed (name conflict) ALTER SERVER alt_fserv1 RENAME TO alt_fserv3;   -- OK SELECT fdwname FROM pg_foreign_data_wrapper WHERE fdwname like 'alt_fdw%';
ALTER FOREIGN DATA WRAPPER foo HANDLER invalid_fdw_handler;  -- ERROR ALTER FOREIGN DATA WRAPPER foo HANDLER test_fdw_handler HANDLER anything;  -- ERROR ALTER FOREIGN DATA WRAPPER foo HANDLER test_fdw_handler;
ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD d '5');
ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD d '5');         -- ERROR SET ROLE regress_test_role_super;
ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD e '6');         -- ERROR RESET ROLE;
ALTER FOREIGN DATA WRAPPER foo OPTIONS (DROP a, SET b '3', ADD c '4');
ALTER FOREIGN DATA WRAPPER foo OPTIONS (SET c '4');         -- ERROR ALTER FOREIGN DATA WRAPPER foo OPTIONS (DROP c);            -- ERROR ALTER FOREIGN DATA WRAPPER foo OPTIONS (ADD x '1', DROP x);
ALTER FOREIGN DATA WRAPPER foo OPTIONS (a '1', b '2');
ALTER FOREIGN DATA WRAPPER foo OPTIONS (a '2');
ALTER FOREIGN DATA WRAPPER foo OPTIONS (b '4');             -- ERROR SET ROLE regress_test_role;
ALTER FOREIGN DATA WRAPPER foo OPTIONS (nonexistent 'fdw');         -- ERROR ALTER FOREIGN DATA WRAPPER foo;                             -- ERROR ALTER FOREIGN DATA WRAPPER foo VALIDATOR bar;               -- ERROR ALTER FOREIGN DATA WRAPPER foo NO VALIDATOR;
ALTER FOREIGN DATA WRAPPER foo OWNER TO regress_test_role;  -- ERROR ALTER FOREIGN DATA WRAPPER foo OWNER TO regress_test_role_super;
ALTER FOREIGN DATA WRAPPER foo RENAME TO foo1;
ALTER FOREIGN DATA WRAPPER foo VALIDATOR postgresql_fdw_validator;
ALTER FOREIGN DATA WRAPPER foo1 RENAME TO foo;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c10 integer OPTIONS (p1 'v1');
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c4 integer;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c6 integer;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c7 integer NOT NULL;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c8 integer;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ADD COLUMN c9 integer;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c6 SET NOT NULL;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c7 DROP NOT NULL;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c7 OPTIONS (ADD p1 'v1', ADD p2 'v2'),                         ALTER COLUMN c8 OPTIONS (ADD p1 'v1', ADD p2 'v2');
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c8 OPTIONS (SET p2 'V2', DROP p1);
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c8 SET DATA TYPE text;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 ALTER COLUMN c8 TYPE char(10);
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP COLUMN IF EXISTS no_column;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP COLUMN c9;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP CONSTRAINT IF EXISTS no_const;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 DROP CONSTRAINT ft1_c1_check;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 OPTIONS (DROP delimiter, SET quote '~', ADD escape '@');
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 OWNER TO regress_test_role;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 RENAME TO foreign_table_1;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 RENAME c1 TO foreign_column_1;
ALTER FOREIGN TABLE IF EXISTS doesnt_exist_ft1 SET SCHEMA foreign_schema;
ALTER FOREIGN TABLE foreign_schema.foreign_table_1 	DISABLE TRIGGER trigtest_before_stmt;
ALTER FOREIGN TABLE foreign_schema.foreign_table_1 	ENABLE TRIGGER trigtest_before_stmt;
ALTER FOREIGN TABLE foreign_schema.ft1 RENAME TO foreign_table_1;
ALTER FOREIGN TABLE ft1 ADD COLUMN c10 integer OPTIONS (p1 'v1');
ALTER FOREIGN TABLE ft1 ADD COLUMN c4 integer;
ALTER FOREIGN TABLE ft1 ADD COLUMN c5 integer DEFAULT 0;
ALTER FOREIGN TABLE ft1 ADD COLUMN c6 integer;
ALTER FOREIGN TABLE ft1 ADD COLUMN c7 integer NOT NULL;
ALTER FOREIGN TABLE ft1 ADD COLUMN c8 integer DEFAULT 0;
ALTER FOREIGN TABLE ft1 ADD COLUMN c8 integer;
ALTER FOREIGN TABLE ft1 ADD COLUMN c9 integer;
ALTER FOREIGN TABLE ft1 ADD PRIMARY KEY (c7);                   -- ERROR ALTER FOREIGN TABLE ft1 ADD CONSTRAINT ft1_c9_check CHECK (c9 < 0) NOT VALID;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c1 SET (n_distinct = 100);
ALTER FOREIGN TABLE ft1 ALTER COLUMN c1 SET STATISTICS 10000;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c4 SET DEFAULT 0;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c5 DROP DEFAULT;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c6 SET NOT NULL;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c7 DROP NOT NULL;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 OPTIONS (SET p2 'V2', DROP p1);
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET DATA TYPE integer;	-- ERROR DROP TABLE use_ft1_column_type;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET DATA TYPE text;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET STATISTICS -1;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 SET STORAGE PLAIN;
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE char(10) USING '0'; -- ERROR ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE char(10);
ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE char(10);
ALTER FOREIGN TABLE ft1 ALTER COLUMN xmin OPTIONS (ADD p1 'v1'); -- ERROR ALTER FOREIGN TABLE ft1 ALTER COLUMN c7 OPTIONS (ADD p1 'v1', ADD p2 'v2'),                         ALTER COLUMN c8 OPTIONS (ADD p1 'v1', ADD p2 'v2');
ALTER FOREIGN TABLE ft1 ALTER CONSTRAINT ft1_c9_check DEFERRABLE; -- ERROR ALTER FOREIGN TABLE ft1 DROP CONSTRAINT ft1_c9_check;
ALTER FOREIGN TABLE ft1 DROP COLUMN c9;
ALTER FOREIGN TABLE ft1 DROP COLUMN no_column;                  -- ERROR ALTER FOREIGN TABLE ft1 DROP COLUMN IF EXISTS no_column;
ALTER FOREIGN TABLE ft1 DROP CONSTRAINT no_const;               -- ERROR ALTER FOREIGN TABLE ft1 DROP CONSTRAINT IF EXISTS no_const;
ALTER FOREIGN TABLE ft1 OPTIONS (DROP delimiter, SET quote '~', ADD escape '@');
ALTER FOREIGN TABLE ft1 OWNER TO regress_test_role;
ALTER FOREIGN TABLE ft1 SET SCHEMA foreign_schema;
ALTER FOREIGN TABLE ft1 SET TABLESPACE ts;                      -- ERROR ALTER FOREIGN TABLE foreign_schema.ft1 RENAME c1 TO foreign_column_1;
ALTER FOREIGN TABLE ft2 INHERIT fd_pt1;
ALTER FOREIGN TABLE ft2 INHERIT fd_pt1;
ALTER FOREIGN TABLE ft2 INHERIT fd_pt1;                            -- ERROR ALTER FOREIGN TABLE ft2 ADD CONSTRAINT fd_pt1chk2 CHECK (c2 <> '');
ALTER GROUP regress_priv_group1 ADD USER regress_priv_user4;
ALTER GROUP regress_priv_group2 ADD USER regress_priv_user2;	-- duplicate ALTER GROUP regress_priv_group2 DROP USER regress_priv_user2;
ALTER MATERIALIZED VIEW compressmv ALTER COLUMN x SET COMPRESSION lz4;
ALTER MATERIALIZED VIEW mvtest_tvm SET SCHEMA mvtest_mvschema;
ALTER OPERATOR & (bit, bit) SET ("Restrict" = _int_contsel, "Join" = _int_contjoinsel);
ALTER OPERATOR === (boolean, boolean) SET (COMMUTATOR = !==);
ALTER OPERATOR === (boolean, boolean) SET (COMMUTATOR = ====);
ALTER OPERATOR === (boolean, boolean) SET (JOIN = NONE);
ALTER OPERATOR === (boolean, boolean) SET (JOIN = contjoinsel);
ALTER OPERATOR === (boolean, boolean) SET (JOIN = non_existent_func);
ALTER OPERATOR === (boolean, boolean) SET (NEGATOR = !==);
ALTER OPERATOR === (boolean, boolean) SET (NEGATOR = ====);
ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = NONE);
ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = NONE);
ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = NONE, JOIN = NONE);
ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = contsel);
ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = customcontsel, JOIN = contjoinsel);
ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = non_existent_func);
ALTER OPERATOR @+@(int4, int4) OWNER TO regress_alter_generic_user2;  -- failed (no role membership) ALTER OPERATOR @+@(int4, int4) OWNER TO regress_alter_generic_user3;  -- OK ALTER OPERATOR @-@(int4, int4) SET SCHEMA alt_nsp2;           -- OK SET SESSION AUTHORIZATION regress_alter_generic_user2;
ALTER OPERATOR @+@(int4, int4) OWNER TO regress_alter_generic_user2;  -- failed (not owner) ALTER OPERATOR @-@(int4, int4) OWNER TO regress_alter_generic_user3;  -- failed (no role membership) ALTER OPERATOR @+@(int4, int4) SET SCHEMA alt_nsp2;   -- failed (not owner) RESET SESSION AUTHORIZATION;
ALTER OPERATOR CLASS alt_opc1 USING hash OWNER TO regress_alter_generic_user1;
ALTER OPERATOR CLASS alt_opc1 USING hash OWNER TO regress_alter_generic_user2;
ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user1;
ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user2;
ALTER OPERATOR FAMILY alt_nsp6.alt_opf6 USING btree ADD OPERATOR 1 < (int4, int2);
ALTER OPERATOR FAMILY alt_opf1 USING hash OWNER TO regress_alter_generic_user1;
ALTER OPERATOR FAMILY alt_opf1 USING hash OWNER TO regress_alter_generic_user2;
ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf2;  -- failed (name conflict) ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf3;  -- OK ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user2;  -- failed (no role membership) ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user3;  -- OK ALTER OPERATOR FAMILY alt_opf2 USING hash SET SCHEMA alt_nsp2;  -- OK ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc2;  -- failed (name conflict) ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc3;  -- OK ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user2;  -- failed (no role membership) ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user3;  -- OK ALTER OPERATOR CLASS alt_opc2 USING hash SET SCHEMA alt_nsp2;  -- OK RESET SESSION AUTHORIZATION;
ALTER OPERATOR FAMILY alt_opf10 USING btree ADD OPERATOR 1 < (int4, int4) FOR ORDER BY float_ops;
ALTER OPERATOR FAMILY alt_opf11 USING gist ADD OPERATOR 1 < (int4, int4) FOR ORDER BY float_ops;
ALTER OPERATOR FAMILY alt_opf11 USING gist DROP OPERATOR 1 (int4, int4);
ALTER OPERATOR FAMILY alt_opf12 USING btree ADD FUNCTION 1 fn_opf12(int4, int2);
ALTER OPERATOR FAMILY alt_opf13 USING hash ADD FUNCTION 1 fn_opf13(int4);
ALTER OPERATOR FAMILY alt_opf14 USING btree ADD FUNCTION 1 fn_opf14(int4);
ALTER OPERATOR FAMILY alt_opf15 USING hash ADD FUNCTION 1 fn_opf15(int4, int2);
ALTER OPERATOR FAMILY alt_opf16 USING gist ADD FUNCTION 1 btint42cmp(int4, int2);
ALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4), OPERATOR 1 < (int4, int4); -- operator # appears twice in same statement ALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4); -- operator 1 requested first-time ALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4); -- operator 1 requested again in separate statement ALTER OPERATOR FAMILY alt_opf17 USING btree ADD   OPERATOR 1 < (int4, int2) ,   OPERATOR 2 <= (int4, int2) ,   OPERATOR 3 = (int4, int2) ,   OPERATOR 4 >= (int4, int2) ,   OPERATOR 5 > (int4, int2) ,   FUNCTION 1 btint42cmp(int4, int2) ,   FUNCTION 1 btint42cmp(int4, int2);    -- procedure 1 appears twice in same statement ALTER OPERATOR FAMILY alt_opf17 USING btree ADD   OPERATOR 1 < (int4, int2) ,   OPERATOR 2 <= (int4, int2) ,   OPERATOR 3 = (int4, int2) ,   OPERATOR 4 >= (int4, int2) ,   OPERATOR 5 > (int4, int2) ,   FUNCTION 1 btint42cmp(int4, int2);    -- procedure 1 appears first time ALTER OPERATOR FAMILY alt_opf17 USING btree ADD   OPERATOR 1 < (int4, int2) ,   OPERATOR 2 <= (int4, int2) ,   OPERATOR 3 = (int4, int2) ,   OPERATOR 4 >= (int4, int2) ,   OPERATOR 5 > (int4, int2) ,   FUNCTION 1 btint42cmp(int4, int2);    -- procedure 1 requested again in separate statement DROP OPERATOR FAMILY alt_opf17 USING btree;
ALTER OPERATOR FAMILY alt_opf18 USING btree   ADD FUNCTION 4 (int4, int2) btequalimage(oid);
ALTER OPERATOR FAMILY alt_opf18 USING btree ADD   OPERATOR 1 < (int4, int2) ,   OPERATOR 2 <= (int4, int2) ,   OPERATOR 3 = (int4, int2) ,   OPERATOR 4 >= (int4, int2) ,   OPERATOR 5 > (int4, int2) ,   FUNCTION 1 btint42cmp(int4, int2);
ALTER OPERATOR FAMILY alt_opf18 USING btree DROP FUNCTION 2 (int4, int4);
ALTER OPERATOR FAMILY alt_opf18 USING btree DROP OPERATOR 1 (int4, int4);
ALTER OPERATOR FAMILY alt_opf19 USING btree ADD FUNCTION 5 (int4) btint42cmp(int4, int2);
ALTER OPERATOR FAMILY alt_opf19 USING btree ADD FUNCTION 5 (int4) test_opclass_options_func(internal); -- Ok ALTER OPERATOR FAMILY alt_opf19 USING btree DROP FUNCTION 5 (int4, int4);
ALTER OPERATOR FAMILY alt_opf19 USING btree ADD FUNCTION 5 (int4, int2) btint42cmp(int4, int2);
ALTER OPERATOR FAMILY alt_opf19 USING btree ADD FUNCTION 5 test_opclass_options_func(internal, text[], bool);
ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user1;
ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user2;
ALTER OPERATOR FAMILY alt_opf3 USING hash RENAME TO alt_opf4;	-- failed (not owner) ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf4;  -- OK ALTER OPERATOR FAMILY alt_opf3 USING hash OWNER TO regress_alter_generic_user2;  -- failed (not owner) ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user3;  -- failed (no role membership) ALTER OPERATOR FAMILY alt_opf3 USING hash SET SCHEMA alt_nsp2;  -- failed (not owner) ALTER OPERATOR FAMILY alt_opf2 USING hash SET SCHEMA alt_nsp2;  -- failed (name conflict) ALTER OPERATOR CLASS alt_opc3 USING hash RENAME TO alt_opc4;	-- failed (not owner) ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc4;  -- OK ALTER OPERATOR CLASS alt_opc3 USING hash OWNER TO regress_alter_generic_user2;  -- failed (not owner) ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user3;  -- failed (no role membership) ALTER OPERATOR CLASS alt_opc3 USING hash SET SCHEMA alt_nsp2;  -- failed (not owner) ALTER OPERATOR CLASS alt_opc2 USING hash SET SCHEMA alt_nsp2;  -- failed (name conflict) RESET SESSION AUTHORIZATION;
ALTER OPERATOR FAMILY alt_opf4 USING btree ADD   OPERATOR 1 < (int4, int2) ,   OPERATOR 2 <= (int4, int2) ,   OPERATOR 3 = (int4, int2) ,   OPERATOR 4 >= (int4, int2) ,   OPERATOR 5 > (int4, int2) ,   FUNCTION 1 btint42cmp(int4, int2);
ALTER OPERATOR FAMILY alt_opf4 USING btree DROP   OPERATOR 1 (int4, int2) ,   OPERATOR 2 (int4, int2) ,   OPERATOR 3 (int4, int2) ,   OPERATOR 4 (int4, int2) ,   OPERATOR 5 (int4, int2) ,   FUNCTION 1 (int4, int2) ;
ALTER OPERATOR FAMILY alt_opf4 USING invalid_index_method ADD  OPERATOR 1 < (int4, int2); -- invalid indexing_method ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 6 < (int4, int2); -- operator number should be between 1 and 5 ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 0 < (int4, int2); -- operator number should be between 1 and 5 ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 1 < ; -- operator without argument types ALTER OPERATOR FAMILY alt_opf4 USING btree ADD FUNCTION 0 btint42cmp(int4, int2); -- invalid options parsing function ALTER OPERATOR FAMILY alt_opf4 USING btree ADD FUNCTION 6 btint42cmp(int4, int2); -- function number should be between 1 and 5 ALTER OPERATOR FAMILY alt_opf4 USING btree ADD STORAGE invalid_storage; -- Ensure STORAGE is not a part of ALTER OPERATOR FAMILY DROP OPERATOR FAMILY alt_opf4 USING btree;
ALTER OPERATOR FAMILY alt_opf5 USING btree ADD OPERATOR 1 < (int4, int2), FUNCTION 1 btint42cmp(int4, int2);
ALTER OPERATOR FAMILY alt_opf7 USING btree ADD OPERATOR 1 < (int4, int2);
ALTER OPERATOR FAMILY alt_opf7 USING btree DROP OPERATOR 1 (int4, int2, int8);
ALTER OPERATOR FAMILY alt_opf8 USING btree ADD OPERATOR 1 < (int4, int4);
ALTER OPERATOR FAMILY alt_opf9 USING gist ADD OPERATOR 1 < (int4, int4) FOR ORDER BY float_ops;
ALTER POLICY dep_p1 ON dep1 TO regress_rls_bob,regress_rls_carol;
ALTER POLICY dep_p1 ON dep1 USING (true);
ALTER POLICY p ON tbl1 TO regress_rls_frank USING (true);
ALTER POLICY p1 ON document USING (dauthor = current_user);
ALTER POLICY p1 ON event_trigger_test RENAME TO p2;
ALTER POLICY p1 ON event_trigger_test USING (TRUE);
ALTER POLICY p1 ON s1 USING (a in (select x from v2)); -- using VIEW in RLS policy SET SESSION AUTHORIZATION regress_rls_bob;
ALTER POLICY p1 ON t1 RENAME TO p1; --fail SELECT polname, relname     FROM pg_policy pol     JOIN pg_class pc ON (pc.oid = pol.polrelid)     WHERE relname = 't1';
ALTER POLICY p1 ON t1 RENAME TO p2; --ok SELECT polname, relname     FROM pg_policy pol     JOIN pg_class pc ON (pc.oid = pol.polrelid)     WHERE relname = 't1';
ALTER POLICY p2 ON s2 USING (x % 2 = 0);
ALTER POLICY p2 ON s2 USING (x in (select a from s1 where b like '%d2%'));
ALTER POLICY pp1 ON part_document USING (dauthor = current_user);
ALTER POLICY pp1 ON part_document USING (true);    --fail DROP POLICY pp1 ON part_document;                  --fail SET SESSION AUTHORIZATION regress_rls_alice;
ALTER POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2 WHERE b = y));
ALTER POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2v WHERE b = y));
ALTER POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1v WHERE y = b));
ALTER PUBLICATION testpib_ins_trunct ADD TABLE pub_test.testpub_nopk, testpub_tbl1;
ALTER PUBLICATION testpub1_forschema ADD ALL TABLES IN SCHEMA non_existent_schema;
ALTER PUBLICATION testpub1_forschema ADD ALL TABLES IN SCHEMA pub_test1;
ALTER PUBLICATION testpub1_forschema ADD ALL TABLES IN SCHEMA pub_test2;
ALTER PUBLICATION testpub1_forschema DROP ALL TABLES IN SCHEMA non_existent_schema;
ALTER PUBLICATION testpub1_forschema DROP ALL TABLES IN SCHEMA pub_test1;
ALTER PUBLICATION testpub1_forschema DROP ALL TABLES IN SCHEMA pub_test1;
ALTER PUBLICATION testpub1_forschema DROP ALL TABLES IN SCHEMA pub_test2;
ALTER PUBLICATION testpub1_forschema DROP ALL TABLES IN SCHEMA pub_test2;
ALTER PUBLICATION testpub1_forschema SET ALL TABLES IN SCHEMA non_existent_schema;
ALTER PUBLICATION testpub1_forschema SET ALL TABLES IN SCHEMA pub_test1, pub_test1;
ALTER PUBLICATION testpub1_forschema SET ALL TABLES IN SCHEMA pub_test1, pub_test2;
ALTER PUBLICATION testpub1_forschema SET ALL TABLES IN SCHEMA pub_test1;
ALTER PUBLICATION testpub2 ADD TABLE testpub_tbl1;  -- fail ALTER PUBLICATION testpub3 ADD ALL TABLES IN SCHEMA pub_test;  -- fail SET ROLE regress_publication_user;
ALTER PUBLICATION testpub2 ADD TABLE testpub_tbl1;  -- ok DROP PUBLICATION testpub2;
ALTER PUBLICATION testpub2_forschema DROP ALL TABLES IN SCHEMA pub_test1;
ALTER PUBLICATION testpub3_forschema SET ALL TABLES IN SCHEMA pub_test1;
ALTER PUBLICATION testpub_default ADD TABLE pub_test.testpub_nopk;
ALTER PUBLICATION testpub_default ADD TABLE testpub_tbl1;
ALTER PUBLICATION testpub_default ADD TABLE testpub_view;
ALTER PUBLICATION testpub_default DROP TABLE pub_test.testpub_nopk;
ALTER PUBLICATION testpub_default DROP TABLE testpub_tbl1, pub_test.testpub_nopk;
ALTER PUBLICATION testpub_default OWNER TO regress_publication_user2;
ALTER PUBLICATION testpub_default RENAME TO testpub_dummy;
ALTER PUBLICATION testpub_default RENAME TO testpub_foo;
ALTER PUBLICATION testpub_default SET (publish = 'insert, update, delete');
ALTER PUBLICATION testpub_default SET (publish = update);
ALTER PUBLICATION testpub_default SET TABLE testpub_tbl1;
ALTER PUBLICATION testpub_foo RENAME TO testpub_default;
ALTER PUBLICATION testpub_foralltables ADD ALL TABLES IN SCHEMA pub_test;
ALTER PUBLICATION testpub_foralltables ADD TABLE testpub_tbl2;
ALTER PUBLICATION testpub_foralltables DROP ALL TABLES IN SCHEMA pub_test;
ALTER PUBLICATION testpub_foralltables DROP TABLE testpub_tbl2;
ALTER PUBLICATION testpub_foralltables SET (publish = 'insert, update');
ALTER PUBLICATION testpub_foralltables SET ALL TABLES IN SCHEMA pub_test;
ALTER PUBLICATION testpub_foralltables SET TABLE pub_test.testpub_nopk;
ALTER PUBLICATION testpub_forparted ADD TABLE testpub_parted;
ALTER PUBLICATION testpub_forparted DROP TABLE testpub_parted;
ALTER PUBLICATION testpub_forparted SET (publish_via_partition_root = true);
ALTER PUBLICATION testpub_forparted1 SET (publish='insert');
ALTER PUBLICATION testpub_forschema ADD TABLE pub_test.testpub_nopk;
ALTER PUBLICATION testpub_forschema DROP TABLE pub_test.testpub_nopk;
ALTER PUBLICATION testpub_forschema SET TABLE pub_test.testpub_nopk;
ALTER PUBLICATION testpub_fortable ADD ALL TABLES IN SCHEMA pub_test;
ALTER PUBLICATION testpub_fortable DROP ALL TABLES IN SCHEMA pub_test;
ALTER PUBLICATION testpub_fortable SET ALL TABLES IN SCHEMA pub_test;
ALTER PUBLICATION testpub_fortbl ADD TABLE testpub_tbl1;
ALTER ROUTINE cp_testfunc1(int) RENAME TO cp_testfunc1a;
ALTER ROUTINE cp_testfunc1a RENAME TO cp_testfunc1;
ALTER ROUTINE ptest1(text) RENAME TO ptest1a;
ALTER ROUTINE ptest1a RENAME TO ptest1;
ALTER RULE InsertRule ON rule_v1 RENAME TO NewInsertRule; -- doesn't exist ALTER RULE NewInsertRule ON rule_v1 RENAME TO "_RETURN"; -- already exists ALTER RULE "_RETURN" ON rule_v1 RENAME TO abc; -- ON SELECT rule cannot be renamed DROP VIEW rule_v1;
ALTER RULE InsertRule ON rule_v1 RENAME to NewInsertRule;
ALTER RULE rules_parted_table_insert ON rules_parted_table RENAME TO rules_parted_table_insert_redirect;
ALTER SCHEMA pub_test1 RENAME to pub_test1_renamed;
ALTER SCHEMA pub_test1_renamed RENAME to pub_test1;
ALTER SCHEMA tableam_display OWNER TO regress_display_role;
ALTER SCHEMA test_ns_schema_1 RENAME TO test_ns_schema_renamed;
ALTER SCHEMA testns OWNER TO regress_schemauser2;
ALTER SERVER s0;                                            -- ERROR ALTER SERVER s0 OPTIONS (a '1');                            -- ERROR ALTER SERVER s1 VERSION '1.0' OPTIONS (servername 's1');
ALTER SERVER s1 OWNER TO regress_test_indirect;
ALTER SERVER s1 OWNER TO regress_test_indirect;
ALTER SERVER s1 OWNER TO regress_test_indirect;             -- ERROR RESET ROLE;
ALTER SERVER s1 OWNER TO regress_test_role2;                -- ERROR RESET ROLE;
ALTER SERVER s1 OWNER TO regress_test_role;
ALTER SERVER s2 OWNER TO regress_test_role;
ALTER SERVER s5 OWNER TO regress_test_role;
ALTER SERVER s6 OWNER TO regress_test_indirect;
ALTER SERVER s8new RENAME to s8;
ALTER SERVER t1 OWNER TO regress_test_indirect;
ALTER STATISTICS IF EXISTS ab1_a_b_stats SET STATISTICS 0;
ALTER STATISTICS ab1_a_b_stats RENAME TO ab1_a_b_stats_new;
ALTER STATISTICS ab1_a_b_stats SET STATISTICS -1;
ALTER STATISTICS ab1_a_b_stats SET STATISTICS 0;
ALTER STATISTICS ab1_a_b_stats SET STATISTICS 0;
ALTER STATISTICS alt_stat1 RENAME TO alt_stat2;   -- failed (name conflict) ALTER STATISTICS alt_stat1 RENAME TO alt_stat3;   -- OK ALTER STATISTICS alt_stat2 OWNER TO regress_alter_generic_user2;  -- failed (no role membership) ALTER STATISTICS alt_stat2 OWNER TO regress_alter_generic_user3;  -- OK ALTER STATISTICS alt_stat2 SET SCHEMA alt_nsp2;    -- OK SET SESSION AUTHORIZATION regress_alter_generic_user2;
ALTER STATISTICS alt_stat3 RENAME TO alt_stat4;    -- failed (not owner) ALTER STATISTICS alt_stat1 RENAME TO alt_stat4;    -- OK ALTER STATISTICS alt_stat3 OWNER TO regress_alter_generic_user2; -- failed (not owner) ALTER STATISTICS alt_stat2 OWNER TO regress_alter_generic_user3; -- failed (no role membership) ALTER STATISTICS alt_stat3 SET SCHEMA alt_nsp2;		-- failed (not owner) ALTER STATISTICS alt_stat2 SET SCHEMA alt_nsp2;		-- failed (name conflict) RESET SESSION AUTHORIZATION;
ALTER SUBSCRIPTION regress_doesnotexist CONNECTION 'dbname=regress_doesnotexist2';
ALTER SUBSCRIPTION regress_testsub ADD PUBLICATION testpub WITH (refresh = false);
ALTER SUBSCRIPTION regress_testsub ADD PUBLICATION testpub1, testpub1 WITH (refresh = false);
ALTER SUBSCRIPTION regress_testsub ADD PUBLICATION testpub1, testpub2 WITH (refresh = false);
ALTER SUBSCRIPTION regress_testsub ADD PUBLICATION testpub1, testpub2 WITH (refresh = false);
ALTER SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist2';
ALTER SUBSCRIPTION regress_testsub CONNECTION 'foobar';
ALTER SUBSCRIPTION regress_testsub DISABLE;
ALTER SUBSCRIPTION regress_testsub DISABLE;
ALTER SUBSCRIPTION regress_testsub DROP PUBLICATION testpub, testpub1, testpub2 WITH (refresh = false);
ALTER SUBSCRIPTION regress_testsub DROP PUBLICATION testpub1, testpub1 WITH (refresh = false);
ALTER SUBSCRIPTION regress_testsub DROP PUBLICATION testpub1, testpub2 WITH (refresh = false);
ALTER SUBSCRIPTION regress_testsub DROP PUBLICATION testpub3 WITH (refresh = false);
ALTER SUBSCRIPTION regress_testsub ENABLE;
ALTER SUBSCRIPTION regress_testsub ENABLE;
ALTER SUBSCRIPTION regress_testsub OWNER TO regress_subscription_user2;
ALTER SUBSCRIPTION regress_testsub OWNER TO regress_subscription_user2;
ALTER SUBSCRIPTION regress_testsub REFRESH PUBLICATION;
ALTER SUBSCRIPTION regress_testsub RENAME TO regress_testsub_dummy;
ALTER SUBSCRIPTION regress_testsub RENAME TO regress_testsub_foo;
ALTER SUBSCRIPTION regress_testsub SET (binary = false);
ALTER SUBSCRIPTION regress_testsub SET (create_slot = false);
ALTER SUBSCRIPTION regress_testsub SET (slot_name = '');
ALTER SUBSCRIPTION regress_testsub SET (slot_name = 'newname');
ALTER SUBSCRIPTION regress_testsub SET (slot_name = NONE);
ALTER SUBSCRIPTION regress_testsub SET (slot_name = NONE);
ALTER SUBSCRIPTION regress_testsub SET (slot_name = NONE);
ALTER SUBSCRIPTION regress_testsub SET (slot_name = NONE);
ALTER SUBSCRIPTION regress_testsub SET (slot_name = NONE);
ALTER SUBSCRIPTION regress_testsub SET (slot_name = NONE);
ALTER SUBSCRIPTION regress_testsub SET (streaming = false);
ALTER SUBSCRIPTION regress_testsub SET (streaming = true);
ALTER SUBSCRIPTION regress_testsub SET (two_phase = false);
ALTER SUBSCRIPTION regress_testsub SET PUBLICATION mypub WITH (refresh = true);
ALTER SUBSCRIPTION regress_testsub SET PUBLICATION testpub2, testpub3 WITH (refresh = false);
ALTER SUBSCRIPTION regress_testsub3 ENABLE;
ALTER SUBSCRIPTION regress_testsub3 REFRESH PUBLICATION;
ALTER SUBSCRIPTION regress_testsub_foo RENAME TO regress_testsub;
ALTER SUBSCRIPTION regress_testsub_foo SET (synchronous_commit = foobar);
ALTER SUBSCRIPTION regress_testsub_foo SET (synchronous_commit = local);
ALTER TABLE ONLY gtest30 ALTER COLUMN b DROP EXPRESSION;  -- error ALTER TABLE gtest30_1 ALTER COLUMN b DROP EXPRESSION;  -- error CREATE TABLE gtest26 (     a int PRIMARY KEY,     b int GENERATED ALWAYS AS (a * 2) STORED );
ALTER TABLE ab1 ALTER a SET STATISTICS -1;
ALTER TABLE am_partitioned SET ACCESS METHOD heap2;
ALTER TABLE attmp ALTER COLUMN i RESET (n_distinct_inherited);
ALTER TABLE badcompresstbl ALTER a SET COMPRESSION I_Do_Not_Exist_Compression; -- fails DROP TABLE badcompresstbl;
ALTER TABLE cmdata ALTER COLUMN f1 SET COMPRESSION lz4;
ALTER TABLE cmdata2 ALTER COLUMN f1 SET COMPRESSION default;
ALTER TABLE cmdata2 ALTER COLUMN f1 SET COMPRESSION pglz;
ALTER TABLE cmpart1 ALTER COLUMN f1 SET COMPRESSION pglz;
ALTER TABLE cmpart2 ALTER COLUMN f1 SET COMPRESSION lz4;
ALTER TABLE fd_pt1 ALTER COLUMN c8 SET STATISTICS -1;
ALTER TABLE gtest29 ALTER COLUMN a DROP EXPRESSION;  -- error ALTER TABLE gtest29 ALTER COLUMN a DROP EXPRESSION IF EXISTS;  -- notice ALTER TABLE gtest29 ALTER COLUMN b DROP EXPRESSION;
ALTER TABLE gtest30 ALTER COLUMN b DROP EXPRESSION;
ALTER TABLE heaptable SET ACCESS METHOD heap, SET ACCESS METHOD heap2;
ALTER TABLE heaptable SET ACCESS METHOD heap2;
ALTER TABLE no_index_cleanup SET (vacuum_index_cleanup = off,     toast.vacuum_index_cleanup = yes);
ALTER TABLE no_index_cleanup SET (vacuum_index_cleanup = true,     toast.vacuum_index_cleanup = false);
ALTER TABLE reloptions_test RESET (fillfactor=12);
ALTER TABLE reloptions_test RESET (toast.autovacuum_vacuum_cost_delay);
ALTER TABLE reloptions_test SET (autovacuum_enabled, fillfactor=32);
ALTER TABLE reloptions_test SET (toast.autovacuum_vacuum_cost_delay = 24);
ALTER TABLE test_add_column 	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists 	ADD COLUMN IF NOT EXISTS c3 integer primary key; -- skipping because c3 already exists ALTER TABLE test_add_column 	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists 	ADD COLUMN IF NOT EXISTS c3 integer, -- skipping because c3 already exists 	ADD COLUMN c4 integer REFERENCES test_add_column;
ALTER TABLE test_add_column 	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists 	ADD COLUMN c3 integer primary key;
ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf2;  -- failed (name conflict) ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf3;  -- OK ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regress_alter_generic_user2;  -- failed (no role membership) ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regress_alter_generic_user3;  -- OK ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 SET SCHEMA alt_nsp2;  -- OK SET SESSION AUTHORIZATION regress_alter_generic_user2;
ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 RENAME TO alt_ts_conf4;  -- failed (not owner) ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf4;  -- OK ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 OWNER TO regress_alter_generic_user2;  -- failed (not owner) ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regress_alter_generic_user3;  -- failed (no role membership) ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 SET SCHEMA alt_nsp2;  -- failed (not owner) ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 SET SCHEMA alt_nsp2;  -- failed (name conflict) RESET SESSION AUTHORIZATION;
ALTER TEXT SEARCH CONFIGURATION hunspell_tst ALTER MAPPING 	REPLACE hunspell WITH hunspell_long;
ALTER TEXT SEARCH CONFIGURATION hunspell_tst ALTER MAPPING 	REPLACE hunspell_long WITH hunspell_num;
ALTER TEXT SEARCH CONFIGURATION hunspell_tst ALTER MAPPING 	REPLACE ispell WITH hunspell;
ALTER TEXT SEARCH CONFIGURATION ispell_tst ALTER MAPPING FOR 	word, numword, asciiword, hword, numhword, asciihword, hword_part, hword_numpart, hword_asciipart 	WITH ispell, english_stem;
ALTER TEXT SEARCH CONFIGURATION synonym_tst ALTER MAPPING FOR 	asciiword, hword_asciipart, asciihword 	WITH synonym, english_stem;
ALTER TEXT SEARCH CONFIGURATION thesaurus_tst ALTER MAPPING FOR 	asciiword, hword_asciipart, asciihword 	WITH synonym, thesaurus, english_stem;
ALTER TEXT SEARCH PARSER alt_ts_prs2 SET SCHEMA alt_nsp2;   -- failed (name conflict) CREATE TEXT SEARCH PARSER tspars_case ("Start" = start_function);
ALTER TEXT SEARCH TEMPLATE alt_ts_temp2 SET SCHEMA alt_nsp2;    -- failed (name conflict) CREATE TEXT SEARCH TEMPLATE tstemp_case ("Init" = init_function);
ALTER TRIGGER modified_a ON main_table RENAME TO modified_modified_a;
ALTER TYPE bogon ADD VALUE 'bad';
ALTER TYPE bogon ADD VALUE 'bad';
ALTER TYPE bogon ADD VALUE 'ugly';
ALTER TYPE bogus ADD VALUE 'new';
ALTER TYPE bogus RENAME TO bogon;
ALTER TYPE bogus RENAME TO bogon;
ALTER TYPE bogus RENAME TO bogon;
ALTER TYPE bogus RENAME VALUE 'good' to 'bad';
ALTER TYPE myvarchar SET (     send = myvarcharsend,     receive = myvarcharrecv,     typmod_in = varchartypmodin,     typmod_out = varchartypmodout,     analyze = ts_typanalyze,     subscript = raw_array_subscript_handler );
ALTER TYPE myvarchar SET (storage = extended);
ALTER TYPE myvarchar SET (storage = plain);  -- not allowed ALTER TYPE myvarchar SET (storage = extended);
ALTER TYPE nosuchtype ADD ATTRIBUTE b text; -- fails ALTER TYPE test_type ADD ATTRIBUTE b text;
ALTER TYPE planets ADD VALUE   'plutoplutoplutoplutoplutoplutoplutoplutoplutoplutoplutoplutoplutopluto';
ALTER TYPE planets ADD VALUE 'jupiter' AFTER 'mars';
ALTER TYPE planets ADD VALUE 'mercury' BEFORE 'venus';
ALTER TYPE planets ADD VALUE 'mercury';
ALTER TYPE planets ADD VALUE 'neptune' AFTER 'uranus';
ALTER TYPE planets ADD VALUE 'pluto' AFTER 'zeus';
ALTER TYPE planets ADD VALUE 'saturn' BEFORE 'uranus';
ALTER TYPE planets ADD VALUE 'uranus';
ALTER TYPE planets ADD VALUE IF NOT EXISTS 'mercury';
ALTER TYPE planets ADD VALUE IF NOT EXISTS 'pluto';
ALTER TYPE rainbow RENAME VALUE 'blue' TO 'green';
ALTER TYPE rainbow RENAME VALUE 'red' TO 'crimson';
ALTER TYPE rainbow RENAME VALUE 'red' TO 'crimson';
ALTER TYPE test8a ADD ATTRIBUTE c priv_testdomain1;
ALTER TYPE test8a ALTER ATTRIBUTE b TYPE priv_testdomain1;
ALTER TYPE test8b ADD ATTRIBUTE c priv_testdomain1;
ALTER TYPE test8b ALTER ATTRIBUTE b TYPE priv_testdomain1;
ALTER TYPE test_type ADD ATTRIBUTE b text; -- fails ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE varchar;
ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE integer;
ALTER TYPE test_type DROP ATTRIBUTE a, ADD ATTRIBUTE d boolean;
ALTER TYPE test_type DROP ATTRIBUTE b;
ALTER TYPE test_type DROP ATTRIBUTE c; -- fails ALTER TYPE test_type DROP ATTRIBUTE IF EXISTS c;
ALTER TYPE test_type RENAME ATTRIBUTE a TO aa;
ALTER TYPE test_type RENAME ATTRIBUTE d TO dd;
ALTER TYPE test_type1 ALTER ATTRIBUTE b TYPE varchar; -- fails CREATE TYPE test_type2 AS (a int, b text);
ALTER TYPE test_type2 ADD ATTRIBUTE c text; -- fails ALTER TYPE test_type2 ADD ATTRIBUTE c text CASCADE;
ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar; -- fails ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar CASCADE;
ALTER TYPE test_type2 DROP ATTRIBUTE b; -- fails ALTER TYPE test_type2 DROP ATTRIBUTE b CASCADE;
ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa; -- fails ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa CASCADE;
ALTER TYPE test_type3 DROP ATTRIBUTE a, ADD ATTRIBUTE b int;
ALTER TYPE test_typex DROP ATTRIBUTE a; -- fails ALTER TYPE test_typex DROP ATTRIBUTE a CASCADE;
ALTER TYPE tt_t0 DROP ATTRIBUTE z;
ALTER VIEW attmp_view_new RENAME TO fail;  -- permission denied RESET ROLE;
ALTER VIEW my_property_normal SET (security_barrier=true);
ALTER VIEW my_property_secure SET (security_barrier=false);
ALTER VIEW rls_view OWNER TO regress_rls_bob;
ALTER VIEW rw_view1 ALTER COLUMN bb SET DEFAULT 'View default';
ALTER VIEW rw_view1 SET (check_option=here); -- invalid ALTER VIEW rw_view1 SET (check_option=local);
ALTER VIEW rw_view1 SET (security_barrier = true);
ALTER VIEW rw_view15 ALTER COLUMN upper SET DEFAULT 'NOT SET';
ALTER VIEW rw_view2 SET (check_option=cascaded);
ANALYZE (nonexistent-arg) does_not_exist;
CALL ptest10(a => null, b => 8, c => 2);
CALL ptest10(b => 8, c => 2, a => 0);
CALL ptest10(null, 7, c => 2);
CALL ptest10(null, c => 4, b => 11);
CALL ptest5(10, b => 'Hello');
CALL ptest5(b => 'Hello', a => 10);
CHECKPOINT;
CLOSE ALL;
CLOSE ALL;
CLOSE c;
CLOSE c;
CLOSE foo10;
CLOSE foo11;
CLOSE foo12;
CLOSE foo13;
CLOSE foo14;
CLOSE foo15;
CLOSE foo16;
CLOSE foo17;
CLOSE foo18;
CLOSE foo19;
CLOSE foo1;
CLOSE foo20;
CLOSE foo21;
CLOSE foo22;
CLOSE foo23;
CLOSE foo24;
CLOSE foo25;
CLOSE foo25;
CLOSE foo25ns;
CLOSE foo2;
CLOSE foo3;
CLOSE foo4;
CLOSE foo5;
CLOSE foo6;
CLOSE foo7;
CLOSE foo8;
CLOSE foo9;
CLOSE hsc;
CLOSE tablesample_cur;
CLUSTER abbrev_abort_uuids USING abbrev_abort_uuids__abort_decreasing_idx;
CLUSTER abbrev_abort_uuids USING abbrev_abort_uuids__abort_increasing_idx;
CLUSTER abbrev_abort_uuids USING abbrev_abort_uuids__noabort_decreasing_idx;
CLUSTER abbrev_abort_uuids USING abbrev_abort_uuids__noabort_increasing_idx;
CLUSTER clstr_1;
CLUSTER clstr_1_pkey ON clstr_1;
CLUSTER clstr_2 USING clstr_2_pkey;
CLUSTER clstr_2;
CLUSTER clstr_expression USING clstr_expression_minus_a;
CLUSTER clstr_expression USING clstr_expression_upper_b;
CLUSTER clstr_tst_c ON clstr_tst;
CLUSTER clstrpart USING clstrpart_idx;
CLUSTER clustertest USING clustertest_pkey;
CLUSTER clustertest;
CLUSTER clustertest_pkey ON clustertest;
CLUSTER hs2 using hs1_pkey;
CLUSTER vaccluster;
CLUSTER;
COMMENT ON AGGREGATE newavg (int4) IS 'an agg comment';
COMMENT ON AGGREGATE newavg (int4) IS NULL;
COMMENT ON AGGREGATE newavg_wrong (int4) IS 'an agg comment';
COMMENT ON AGGREGATE newcnt ("any") IS 'an agg(any) comment';
COMMENT ON AGGREGATE newcnt (*) IS 'an agg(*) comment';
COMMENT ON AGGREGATE nosuchagg (*) IS 'should fail';
COMMENT ON COLLATION test0 IS 'US English';
COMMENT ON COLLATION test0 IS 'US English';
COMMENT ON COLUMN comment_test.id IS 'Column ''id'' on comment_test';
COMMENT ON COLUMN comment_test_child.id IS 'Column ''id'' on comment_test_child';
COMMENT ON COLUMN ctlt1.a IS 'A';
COMMENT ON COLUMN ctlt1.b IS 'B';
COMMENT ON COLUMN ctlt2.c IS 'C';
COMMENT ON COLUMN ctlt3.a IS 'A3';
COMMENT ON COLUMN ctlt3.c IS 'C';
COMMENT ON COLUMN default_test_row.f1 IS 'good comment';
COMMENT ON COLUMN default_test_row.f1 IS NULL;
COMMENT ON COLUMN default_test_row.nope IS 'bad comment';
COMMENT ON COLUMN ft1.c1 IS 'foreign column';
COMMENT ON COLUMN ft1.c1 IS 'ft1.c1';
COMMENT ON COLUMN ft1.c1 IS NULL;
COMMENT ON COLUMN parted_col_comment.a IS 'Partition key';
COMMENT ON CONSTRAINT comment_test_child_fk ON comment_test_child IS 'FOREIGN KEY constraint of comment_test_child';
COMMENT ON CONSTRAINT comment_test_pk ON comment_test IS 'PRIMARY KEY constraint of comment_test';
COMMENT ON CONSTRAINT comment_test_positive_col_check ON comment_test IS 'CHECK constraint on comment_test.positive_col';
COMMENT ON CONSTRAINT constrname ON FKTABLE IS 'fk constraint comment';
COMMENT ON CONSTRAINT constrname ON FKTABLE IS NULL;
COMMENT ON CONSTRAINT constrname_wrong ON FKTABLE IS 'fk constraint comment';
COMMENT ON CONSTRAINT ctlt1_a_check ON ctlt1 IS 't1_a_check';
COMMENT ON CONSTRAINT ctlt3_a_check ON ctlt3 IS 't3_a_check';
COMMENT ON CONVERSION myconv IS 'bar';
COMMENT ON CONVERSION myconv IS NULL;
COMMENT ON CONVERSION myconv_bad IS 'foo';
COMMENT ON FOREIGN DATA WRAPPER dummy IS 'useless';
COMMENT ON FOREIGN TABLE ft1 IS 'foreign table';
COMMENT ON FOREIGN TABLE ft1 IS 'ft1';
COMMENT ON FOREIGN TABLE ft1 IS NULL;
COMMENT ON FUNCTION tg_hub_adjustslots(bpchar, integer, integer) IS 'function with args';
COMMENT ON FUNCTION tg_hub_adjustslots(bpchar, integer, integer) IS NULL;
COMMENT ON FUNCTION tg_hub_adjustslots_wrong(bpchar, integer, integer) IS 'function with args';
COMMENT ON INDEX comment_test_child_fk IS 'Index backing the FOREIGN KEY of comment_test_child';
COMMENT ON INDEX comment_test_index IS 'Simple index on comment_test';
COMMENT ON INDEX comment_test_pk IS 'Index backing the PRIMARY KEY of comment_test';
COMMENT ON INDEX ctlt1_b_key IS 'index b_key';
COMMENT ON INDEX ctlt1_pkey IS 'index pkey';
COMMENT ON INDEX six IS 'good index';
COMMENT ON INDEX six IS NULL;
COMMENT ON INDEX six_wrong IS 'bad index';
COMMENT ON INDEX testcomment_idx1 IS 'test comment';
COMMENT ON OPERATOR ###### (NONE, int4) IS 'bad prefix';
COMMENT ON OPERATOR ###### (int4, NONE) IS 'bad postfix';
COMMENT ON OPERATOR ###### (int4, int8) IS 'bad infix';
COMMENT ON PUBLICATION testpub_default IS 'test publication';
COMMENT ON RULE rtest_v1_bad ON rtest_v1 IS 'bad rule';
COMMENT ON RULE rtest_v1_del ON rtest_v1 IS 'delete rule';
COMMENT ON RULE rtest_v1_del ON rtest_v1 IS NULL;
COMMENT ON SEQUENCE asdf IS 'won''t work';
COMMENT ON SEQUENCE sequence_test2 IS 'will work';
COMMENT ON SEQUENCE sequence_test2 IS NULL;
COMMENT ON SERVER s1 IS 'foreign server';
COMMENT ON STATISTICS ab1_a_b_stats IS 'changed comment';
COMMENT ON STATISTICS ab1_a_b_stats IS 'new comment';
COMMENT ON STATISTICS ctlt1_a_b_stat IS 'ab stats';
COMMENT ON STATISTICS ctlt1_expr_stat IS 'ab expr stats';
COMMENT ON SUBSCRIPTION regress_testsub IS 'test subscription';
COMMENT ON TABLE attmp IS 'table comment';
COMMENT ON TABLE attmp IS NULL;
COMMENT ON TABLE attmp_wrong IS 'table comment';
COMMENT ON TABLE parted_col_comment IS 'Am partitioned table';
COMMENT ON TRIGGER check_fkeys2_pkey_bad ON fkeys2 IS 'wrong';
COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS 'right';
COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS NULL;
COMMENT ON TYPE bad IS 'bad comment';
COMMENT ON TYPE default_test_row IS 'good comment';
COMMENT ON TYPE default_test_row IS NULL;
COMMENT ON VIEW noview IS 'no view';
COMMENT ON VIEW toyemp IS 'is a view';
COMMENT ON VIEW toyemp IS NULL;
COPY testnull FROM stdin WITH NULL AS E'\\0';
COPY testnull TO stdout WITH NULL AS E'\\0';
COPY y TO stdout (FORMAT CSV, FORCE_QUOTE (col2), ESCAPE E'\\');
COPY y TO stdout WITH CSV FORCE QUOTE col2 ESCAPE E'\\' ENCODING 'sql_ascii';
CREATE ACCESS METHOD bogus TYPE INDEX HANDLER heap_tableam_handler;
CREATE ACCESS METHOD bogus TYPE INDEX HANDLER int4in;
CREATE ACCESS METHOD bogus TYPE TABLE HANDLER bthandler;
CREATE ACCESS METHOD bogus TYPE TABLE HANDLER int4in;
CREATE ACCESS METHOD gist2 TYPE INDEX HANDLER gisthandler;
CREATE ACCESS METHOD heap2 TYPE TABLE HANDLER heap_tableam_handler;
CREATE ACCESS METHOD heap_psql TYPE TABLE HANDLER heap_tableam_handler;
CREATE AGGREGATE addr_nsp.genaggr(int4) (sfunc = int4pl, stype = int4);
CREATE AGGREGATE alt_agg1 (   sfunc1 = int4pl, basetype = int4, stype1 = int4, initcond = 0 );
CREATE AGGREGATE alt_agg1 (   sfunc1 = int4pl, basetype = int4, stype1 = int4, initcond = 100 );
CREATE AGGREGATE alt_agg2 (   sfunc1 = int4mi, basetype = int4, stype1 = int4, initcond = -100 );
CREATE AGGREGATE alt_agg2 (   sfunc1 = int4mi, basetype = int4, stype1 = int4, initcond = 0 );
CREATE AGGREGATE array_larger_accum (anyarray) (     sfunc = array_larger,     stype = anyarray,     initcond = '{}' );
CREATE AGGREGATE balk(int4) (     SFUNC = balkifnull(int8, int4),     STYPE = int8,     PARALLEL = SAFE,     INITCOND = '0' );
CREATE AGGREGATE balk(int4) (     SFUNC = int4_sum(int8, int4),     STYPE = int8,     COMBINEFUNC = balkifnull(int8, int8),     PARALLEL = SAFE,     INITCOND = '0' );
CREATE AGGREGATE case_agg ( -- old syntax 	"Sfunc1" = int4pl, 	"Basetype" = int4, 	"Stype1" = int4, 	"Initcond1" = '0', 	"Parallel" = safe );
CREATE AGGREGATE case_agg(float8) ( 	"Stype" = internal, 	"Sfunc" = ordered_set_transition, 	"Finalfunc" = percentile_disc_final, 	"Finalfunc_extra" = true, 	"Finalfunc_modify" = read_write, 	"Parallel" = safe );
CREATE AGGREGATE invalidsumdouble (float8) (     stype = float8,     sfunc = float8pl,     mstype = float8,     msfunc = float8pl,     minvfunc = float8mi_n );
CREATE AGGREGATE logging_agg_nonstrict (anyelement) ( 	stype = text, 	sfunc = logging_sfunc_nonstrict, 	mstype = text, 	msfunc = logging_msfunc_nonstrict, 	minvfunc = logging_minvfunc_nonstrict );
CREATE AGGREGATE logging_agg_nonstrict_initcond (anyelement) ( 	stype = text, 	sfunc = logging_sfunc_nonstrict, 	mstype = text, 	msfunc = logging_msfunc_nonstrict, 	minvfunc = logging_minvfunc_nonstrict, 	initcond = 'I', 	minitcond = 'MI' );
CREATE AGGREGATE logging_agg_strict (text) ( 	stype = text, 	sfunc = logging_sfunc_strict, 	mstype = text, 	msfunc = logging_msfunc_strict, 	minvfunc = logging_minvfunc_strict );
CREATE AGGREGATE logging_agg_strict_initcond (anyelement) ( 	stype = text, 	sfunc = logging_sfunc_strict, 	mstype = text, 	msfunc = logging_msfunc_strict, 	minvfunc = logging_minvfunc_strict, 	initcond = 'I', 	minitcond = 'MI' );
CREATE AGGREGATE myaggn01a(*) (SFUNC = stfnp, STYPE = int4[],   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn01b(*) (SFUNC = stfnp, STYPE = int4[],   INITCOND = '{}');
CREATE AGGREGATE myaggn02a(*) (SFUNC = stfnp, STYPE = anyarray,   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn02b(*) (SFUNC = stfnp, STYPE = anyarray,   INITCOND = '{}');
CREATE AGGREGATE myaggn03a(*) (SFUNC = stfp, STYPE = int4[],   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn04a(*) (SFUNC = stfp, STYPE = anyarray,   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn05a(BASETYPE = int, SFUNC = tfnp, STYPE = int[],   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn05b(BASETYPE = int, SFUNC = tfnp, STYPE = int[],   INITCOND = '{}');
CREATE AGGREGATE myaggn06a(BASETYPE = int, SFUNC = tf2p, STYPE = int[],   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn06b(BASETYPE = int, SFUNC = tf2p, STYPE = int[],   INITCOND = '{}');
CREATE AGGREGATE myaggn07a(BASETYPE = anyelement, SFUNC = tfnp, STYPE = int[],   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn07b(BASETYPE = anyelement, SFUNC = tfnp, STYPE = int[],   INITCOND = '{}');
CREATE AGGREGATE myaggn08a(BASETYPE = anyelement, SFUNC = tf2p, STYPE = int[],   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn08b(BASETYPE = anyelement, SFUNC = tf2p, STYPE = int[],   INITCOND = '{}');
CREATE AGGREGATE myaggn09a(BASETYPE = int, SFUNC = tf1p, STYPE = int[],   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn10a(BASETYPE = int, SFUNC = tfp, STYPE = int[],   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn11a(BASETYPE = anyelement, SFUNC = tf1p, STYPE = int[],   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn12a(BASETYPE = anyelement, SFUNC = tfp, STYPE = int[],   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn13a(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn13b(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,   INITCOND = '{}');
CREATE AGGREGATE myaggn14a(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn14b(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,   INITCOND = '{}');
CREATE AGGREGATE myaggn15a(BASETYPE = anyelement, SFUNC = tfnp,   STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn15b(BASETYPE = anyelement, SFUNC = tfnp,   STYPE = anyarray, INITCOND = '{}');
CREATE AGGREGATE myaggn16a(BASETYPE = anyelement, SFUNC = tf2p,   STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn16b(BASETYPE = anyelement, SFUNC = tf2p,   STYPE = anyarray, INITCOND = '{}');
CREATE AGGREGATE myaggn17a(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn18a(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,   FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn19a(BASETYPE = anyelement, SFUNC = tf1p,   STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggn20a(BASETYPE = anyelement, SFUNC = tfp,   STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
CREATE AGGREGATE myaggp01a(*) (SFUNC = stfnp, STYPE = int4[],   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp02a(*) (SFUNC = stfnp, STYPE = anyarray,   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp03a(*) (SFUNC = stfp, STYPE = int4[],   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp03b(*) (SFUNC = stfp, STYPE = int4[],   INITCOND = '{}');
CREATE AGGREGATE myaggp04a(*) (SFUNC = stfp, STYPE = anyarray,   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp04b(*) (SFUNC = stfp, STYPE = anyarray,   INITCOND = '{}');
CREATE AGGREGATE myaggp05a(BASETYPE = int, SFUNC = tfnp, STYPE = int[],   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp06a(BASETYPE = int, SFUNC = tf2p, STYPE = int[],   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp07a(BASETYPE = anyelement, SFUNC = tfnp, STYPE = int[],   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp08a(BASETYPE = anyelement, SFUNC = tf2p, STYPE = int[],   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp09a(BASETYPE = int, SFUNC = tf1p, STYPE = int[],   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp09b(BASETYPE = int, SFUNC = tf1p, STYPE = int[],   INITCOND = '{}');
CREATE AGGREGATE myaggp10a(BASETYPE = int, SFUNC = tfp, STYPE = int[],   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp10b(BASETYPE = int, SFUNC = tfp, STYPE = int[],   INITCOND = '{}');
CREATE AGGREGATE myaggp11a(BASETYPE = anyelement, SFUNC = tf1p, STYPE = int[],   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp11b(BASETYPE = anyelement, SFUNC = tf1p, STYPE = int[],   INITCOND = '{}');
CREATE AGGREGATE myaggp12a(BASETYPE = anyelement, SFUNC = tfp, STYPE = int[],   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp12b(BASETYPE = anyelement, SFUNC = tfp, STYPE = int[],   INITCOND = '{}');
CREATE AGGREGATE myaggp13a(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp14a(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp15a(BASETYPE = anyelement, SFUNC = tfnp,   STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp16a(BASETYPE = anyelement, SFUNC = tf2p,   STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp17a(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp17b(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,   INITCOND = '{}');
CREATE AGGREGATE myaggp18a(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,   FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp18b(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,   INITCOND = '{}');
CREATE AGGREGATE myaggp19a(BASETYPE = anyelement, SFUNC = tf1p,   STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp19b(BASETYPE = anyelement, SFUNC = tf1p,   STYPE = anyarray, INITCOND = '{}');
CREATE AGGREGATE myaggp20a(BASETYPE = anyelement, SFUNC = tfp,   STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
CREATE AGGREGATE myaggp20b(BASETYPE = anyelement, SFUNC = tfp,   STYPE = anyarray, INITCOND = '{}');
CREATE AGGREGATE myavg (numeric) ( 	stype = internal, 	sfunc = numeric_avg_accum, 	finalfunc = numeric_avg );
CREATE AGGREGATE myavg (numeric) ( 	stype = internal, 	sfunc = numeric_avg_accum, 	finalfunc = numeric_avg, 	serialfunc = numeric_avg_serialize, 	deserialfunc = numeric_avg_deserialize, 	combinefunc = numeric_avg_combine, 	finalfunc_modify = shareable  -- just to test a non-default setting );
CREATE AGGREGATE myavg (numeric) ( 	stype = internal, 	sfunc = numeric_avg_accum, 	serialfunc = numeric_avg_deserialize, 	deserialfunc = numeric_avg_deserialize );
CREATE AGGREGATE myavg (numeric) ( 	stype = internal, 	sfunc = numeric_avg_accum, 	serialfunc = numeric_avg_serialize );
CREATE AGGREGATE myavg (numeric) ( 	stype = internal, 	sfunc = numeric_avg_accum, 	serialfunc = numeric_avg_serialize, 	deserialfunc = numeric_avg_deserialize, 	combinefunc = int4larger );
CREATE AGGREGATE myavg (numeric) ( 	stype = internal, 	sfunc = numeric_avg_accum, 	serialfunc = numeric_avg_serialize, 	deserialfunc = numeric_avg_serialize );
CREATE AGGREGATE mysum (int) ( 	stype = int, 	sfunc = int4pl, 	parallel = pear );
CREATE AGGREGATE mysum2(anyelement,anyelement) (SFUNC = sum3,   STYPE = anyelement, INITCOND = '0');
CREATE AGGREGATE newavg (    sfunc = int4_avg_accum, basetype = int4, stype = _int8,    finalfunc = int8_avg,    initcond1 = '{0,0}' );
CREATE AGGREGATE newcnt ("any") (    sfunc = int8inc_any, stype = int8,    initcond = '0' );
CREATE AGGREGATE newcnt (*) (    sfunc = int8inc, stype = int8,    initcond = '0', parallel = safe );
CREATE AGGREGATE newsum (    sfunc1 = int4pl, basetype = int4, stype1 = int4,    initcond1 = '0' );
CREATE AGGREGATE oldcnt (    sfunc = int8inc, basetype = 'ANY', stype = int8,    initcond = '0' );
CREATE AGGREGATE priv_testagg1(int) (sfunc = int4pl, stype = int4);
CREATE AGGREGATE priv_testagg1a(priv_testdomain1) (sfunc = int4_sum, stype = bigint);
CREATE AGGREGATE priv_testagg1b(priv_testdomain1) (sfunc = int4_sum, stype = bigint);
CREATE AGGREGATE schema_two.newton   (BASETYPE = int, SFUNC = schema_two.add, STYPE = int);
CREATE AGGREGATE sum_int_randomrestart (int4) ( 	stype = int4, 	sfunc = int4pl, 	mstype = int4, 	msfunc = int4pl, 	minvfunc = sum_int_randrestart_minvfunc );
CREATE AGGREGATE sumdouble (float8) (     stype = float8,     sfunc = float8pl,     mstype = float8,     msfunc = float8pl,     minvfunc = float8mi );
CREATE AGGREGATE testns.agg1(int) (sfunc = int4pl, stype = int4);
CREATE AGGREGATE testns.agg1(int) (sfunc = int4pl, stype = int4);
CREATE AGGREGATE testns.priv_testagg(int) (sfunc = int4pl, stype = int4);
CREATE AGGREGATE wrongreturntype (float8) (     stype = float8,     sfunc = float8pl,     mstype = float8,     msfunc = float8pl,     minvfunc = float8mi_int );
CREATE CAST (int4 AS casttesttype) WITH FUNCTION int4_casttesttype(int4) AS IMPLICIT;
CREATE CAST (priv_testdomain1 AS priv_testdomain3a) WITH FUNCTION castfunc(int);
CREATE CAST (priv_testdomain1 AS priv_testdomain3b) WITH FUNCTION castfunc(int);
CREATE COLLATION case_insensitive (provider = icu, locale = '@colStrength=secondary', deterministic = false);
CREATE COLLATION case_sensitive (LOCALE = '', LOCALE = "NONSENSE");
CREATE COLLATION case_sensitive (provider = icu, locale = '');
CREATE COLLATION coll_dup_chk (DETERMINISTIC = TRUE, DETERMINISTIC = NONSENSE, LOCALE = '');
CREATE COLLATION coll_dup_chk (FROM = "C", VERSION = "1");
CREATE COLLATION coll_dup_chk (LC_COLLATE = "POSIX", LC_COLLATE = "NONSENSE", LC_CTYPE = "POSIX");
CREATE COLLATION coll_dup_chk (LC_COLLATE = "POSIX", LC_CTYPE = "POSIX", LOCALE = '');
CREATE COLLATION coll_dup_chk (LC_COLLATE = "POSIX", LOCALE = '');
CREATE COLLATION coll_dup_chk (LC_CTYPE = "POSIX", LC_CTYPE = "NONSENSE", LC_COLLATE = "POSIX");
CREATE COLLATION coll_dup_chk (LC_CTYPE = "POSIX", LOCALE = '');
CREATE COLLATION coll_dup_chk (PROVIDER = icu, PROVIDER = NONSENSE, LC_COLLATE = "POSIX", LC_CTYPE = "POSIX");
CREATE COLLATION coll_dup_chk (VERSION = '1', VERSION = "NONSENSE", LOCALE = '');
CREATE COLLATION coll_icu_upgrade FROM "und-x-icu";
CREATE COLLATION ctest_det (locale = 'en_US.utf8', deterministic = true);
CREATE COLLATION ctest_det (provider = icu, locale = '', deterministic = true);
CREATE COLLATION ctest_nondet (locale = 'en_US.utf8', deterministic = false);
CREATE COLLATION ctest_nondet (provider = icu, locale = '', deterministic = false);
CREATE COLLATION ignore_accents (provider = icu, locale = '@colStrength=primary;colCaseLevel=yes', deterministic = false);
CREATE COLLATION mycoll1 FROM "C";
CREATE COLLATION mycoll2 ( LC_COLLATE = "POSIX", LC_CTYPE = "POSIX" );
CREATE COLLATION mycoll3 FROM "default";  -- intentionally unsupported DROP COLLATION mycoll1;
CREATE COLLATION test0 FROM "C";
CREATE COLLATION test0 FROM "C";
CREATE COLLATION test0 FROM "C"; -- fail, duplicate name CREATE COLLATION IF NOT EXISTS test0 FROM "C"; -- ok, skipped CREATE COLLATION IF NOT EXISTS test0 (locale = 'foo'); -- ok, skippeddo $$ BEGIN   EXECUTE 'CREATE COLLATION test1 (lc_collate = ' ||           quote_literal(current_setting('lc_collate')) ||           ', lc_ctype = ' ||           quote_literal(current_setting('lc_ctype')) || ');'; END $$;
CREATE COLLATION test0 FROM "C"; -- fail, duplicate namedo $$ BEGIN   EXECUTE 'CREATE COLLATION test1 (provider = icu, lc_collate = ' ||           quote_literal(current_setting('lc_collate')) ||           ', lc_ctype = ' ||           quote_literal(current_setting('lc_ctype')) || ');'; END $$;
CREATE COLLATION test3 (lc_collate = 'en_US.utf8'); -- fail, need lc_ctype CREATE COLLATION testx (locale = 'nonsense'); -- fail CREATE COLLATION test4 FROM nonsense;
CREATE COLLATION test3 (provider = icu, lc_collate = 'en_US.utf8'); -- fail, need lc_ctype CREATE COLLATION testx (provider = icu, locale = 'nonsense'); /* never fails with ICU */  DROP COLLATION testx;
CREATE COLLATION test4 FROM nonsense;
CREATE COLLATION test5 FROM test0;
CREATE COLLATION test5 FROM test0;
CREATE COLLATION testcoll_backwards (provider = icu, locale = '@colBackwards=yes');
CREATE COLLATION testcoll_de_phonebook (provider = icu, locale = 'de@collation=phonebook');
CREATE COLLATION testcoll_error1 (provider = icu, locale = '@colNumeric=lower');
CREATE COLLATION testcoll_ignore_accents (provider = icu, locale = '@colStrength=primary;colCaseLevel=yes');
CREATE COLLATION testcoll_lower_first (provider = icu, locale = '@colCaseFirst=lower');
CREATE COLLATION testcoll_numeric (provider = icu, locale = '@colNumeric=yes');
CREATE COLLATION testcoll_shifted (provider = icu, locale = '@colAlternate=shifted');
CREATE COLLATION testcoll_upper_first (provider = icu, locale = '@colCaseFirst=upper');
CREATE CONSTRAINT TRIGGER t AFTER INSERT ON sro_trojan_table     INITIALLY DEFERRED FOR EACH ROW EXECUTE PROCEDURE sro_trojan();
CREATE CONSTRAINT TRIGGER trigtest_constraint AFTER INSERT OR UPDATE OR DELETE ON foreign_schema.foreign_table_1 FOR EACH ROW EXECUTE PROCEDURE dummy_trigger();
CREATE EVENT TRIGGER end_rls_command ON ddl_command_end     WHEN TAG IN ('CREATE POLICY', 'ALTER POLICY', 'DROP POLICY') EXECUTE PROCEDURE end_command();
CREATE EVENT TRIGGER has_volatile_rewrite                   ON table_rewrite    EXECUTE PROCEDURE log_rewrite();
CREATE EVENT TRIGGER regress_event_trigger_drop_objects ON sql_drop 	WHEN TAG IN ('drop table', 'drop function', 'drop view', 		'drop owned', 'drop schema', 'alter table') 	EXECUTE PROCEDURE test_evtrig_dropped_objects();
CREATE EVENT TRIGGER regress_event_trigger_report_dropped ON sql_drop     EXECUTE PROCEDURE event_trigger_report_dropped();
CREATE EVENT TRIGGER regress_event_trigger_report_end ON ddl_command_end   EXECUTE PROCEDURE event_trigger_report_end();
CREATE EVENT TRIGGER sql_drop_command ON sql_drop     WHEN TAG IN ('DROP POLICY') EXECUTE PROCEDURE drop_sql_command();
CREATE EVENT TRIGGER start_rls_command ON ddl_command_start     WHEN TAG IN ('CREATE POLICY', 'ALTER POLICY', 'DROP POLICY') EXECUTE PROCEDURE start_command();
CREATE EVENT TRIGGER undroppable ON sql_drop 	EXECUTE PROCEDURE undroppable();
CREATE FOREIGN DATA WRAPPER addr_fdw;
CREATE FOREIGN DATA WRAPPER alt_fdw1;
CREATE FOREIGN DATA WRAPPER alt_fdw2;
CREATE FOREIGN DATA WRAPPER dummy;
CREATE FOREIGN DATA WRAPPER dummy;
CREATE FOREIGN DATA WRAPPER extstats_dummy_fdw;
CREATE FOREIGN DATA WRAPPER fdw_heap2 VALIDATOR postgresql_fdw_validator;
CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1');
CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1', testing '2');   -- ERROR CREATE FOREIGN DATA WRAPPER foo OPTIONS (testing '1', another '2');
CREATE FOREIGN DATA WRAPPER foo VALIDATOR bar;            -- ERROR CREATE FOREIGN DATA WRAPPER foo;
CREATE FOREIGN DATA WRAPPER foo VALIDATOR postgresql_fdw_validator;
CREATE FOREIGN DATA WRAPPER foo;
CREATE FOREIGN DATA WRAPPER foo; -- ERROR RESET ROLE;
CREATE FOREIGN DATA WRAPPER foo; -- duplicate DROP FOREIGN DATA WRAPPER foo;
CREATE FOREIGN DATA WRAPPER foobar;                             -- ERROR ALTER FOREIGN DATA WRAPPER foo OPTIONS (gotcha 'true');         -- ERROR ALTER FOREIGN DATA WRAPPER foo OWNER TO regress_unprivileged_role; -- ERROR DROP FOREIGN DATA WRAPPER foo;                                  -- ERROR GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;   -- ERROR CREATE SERVER s9 FOREIGN DATA WRAPPER foo;                      -- ERROR ALTER SERVER s4 VERSION '0.5';                                  -- ERROR ALTER SERVER s4 OWNER TO regress_unprivileged_role;             -- ERROR DROP SERVER s4;                                                 -- ERROR GRANT USAGE ON FOREIGN SERVER s4 TO regress_test_role;          -- ERROR CREATE USER MAPPING FOR public SERVER s4;                       -- ERROR ALTER USER MAPPING FOR regress_test_role SERVER s6 OPTIONS (gotcha 'true'); -- ERROR DROP USER MAPPING FOR regress_test_role SERVER s6;              -- ERROR RESET ROLE;
CREATE FOREIGN DATA WRAPPER foobar;                             -- ERROR ALTER FOREIGN DATA WRAPPER foo OPTIONS (gotcha 'true');         -- ERROR DROP FOREIGN DATA WRAPPER foo;                                  -- ERROR GRANT USAGE ON FOREIGN DATA WRAPPER postgresql TO regress_test_role; -- WARNING GRANT USAGE ON FOREIGN DATA WRAPPER foo TO regress_test_role;
CREATE FOREIGN DATA WRAPPER postgresql VALIDATOR postgresql_fdw_validator;
CREATE FOREIGN DATA WRAPPER test_fdw HANDLER invalid_fdw_handler;  -- ERROR CREATE FOREIGN DATA WRAPPER test_fdw HANDLER test_fdw_handler HANDLER invalid_fdw_handler;  -- ERROR CREATE FOREIGN DATA WRAPPER test_fdw HANDLER test_fdw_handler;
CREATE FOREIGN TABLE addr_nsp.genftable (a int) SERVER addr_fserv;
CREATE FOREIGN TABLE fd_pt2_1 ( 	c1 integer NOT NULL, 	c2 text, 	c3 date ) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
CREATE FOREIGN TABLE fd_pt2_1 ( 	c1 integer NOT NULL, 	c2 text, 	c3 date, 	c4 char ) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
CREATE FOREIGN TABLE fd_pt2_1 PARTITION OF fd_pt2 FOR VALUES IN (1)   SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
CREATE FOREIGN TABLE foreign_part PARTITION OF temp_parted DEFAULT   SERVER s0;  -- ERROR CREATE FOREIGN TABLE foreign_part (a int) SERVER s0;
CREATE FOREIGN TABLE ft1 ( 	c1 integer OPTIONS ("param 1" 'val1') NOT NULL, 	c2 text OPTIONS (param2 'val2', param3 'val3'), 	c3 date, 	UNIQUE (c3) ) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value'); -- ERROR CREATE FOREIGN TABLE ft1 ( 	c1 integer OPTIONS ("param 1" 'val1') NOT NULL, 	c2 text OPTIONS (param2 'val2', param3 'val3') CHECK (c2 <> ''), 	c3 date, 	CHECK (c3 BETWEEN '1994-01-01'::date AND '1994-01-31'::date) ) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
CREATE FOREIGN TABLE ft1 ( 	c1 integer OPTIONS ("param 1" 'val1') REFERENCES ref_table (id), 	c2 text OPTIONS (param2 'val2', param3 'val3'), 	c3 date ) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value'); -- ERROR DROP TABLE ref_table;
CREATE FOREIGN TABLE ft1 ();                                    -- ERROR CREATE FOREIGN TABLE ft1 () SERVER no_server;                   -- ERROR CREATE FOREIGN TABLE ft1 ( 	c1 integer OPTIONS ("param 1" 'val1') PRIMARY KEY, 	c2 text OPTIONS (param2 'val2', param3 'val3'), 	c3 date ) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value'); -- ERROR CREATE TABLE ref_table (id integer PRIMARY KEY);
CREATE FOREIGN TABLE ft1 (c1 integer NOT NULL) SERVER s0;
CREATE FOREIGN TABLE ft2 ( 	c1 integer NOT NULL, 	c2 text, 	c3 date ) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
CREATE FOREIGN TABLE ft2 ( 	c1 integer NOT NULL, 	c2 text, 	c3 date ) SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
CREATE FOREIGN TABLE ft2 () INHERITS (fd_pt1)   SERVER s0 OPTIONS (delimiter ',', quote '"', "be quoted" 'value');
CREATE FOREIGN TABLE ft3 ( 	c1 integer NOT NULL, 	c2 text, 	c3 date ) INHERITS(ft2)   SERVER s0;
CREATE FOREIGN TABLE ft_part1   PARTITION OF lt1 FOR VALUES FROM (0) TO (1000) SERVER s0;
CREATE FOREIGN TABLE ft_part1   PARTITION OF lt1 FOR VALUES FROM (0) TO (1000) SERVER s0;
CREATE FOREIGN TABLE ft_part1   PARTITION OF lt1 FOR VALUES FROM (0) TO (1000) SERVER s0;     -- ERROR CREATE FOREIGN TABLE ft_part2 (a INT NOT NULL) SERVER s0;
CREATE FOREIGN TABLE ft_part2 (a INT) SERVER s0;
CREATE FOREIGN TABLE ft_part_1_1   PARTITION OF lt1_part1 FOR VALUES FROM (0) TO (100) SERVER s0;
CREATE FOREIGN TABLE ft_part_1_1   PARTITION OF lt1_part1 FOR VALUES FROM (0) TO (100) SERVER s0;
CREATE FOREIGN TABLE ft_part_1_2 (a INT NOT NULL) SERVER s0;
CREATE FOREIGN TABLE ft_part_1_2 (a INT) SERVER s0;
CREATE FOREIGN TABLE tststats.f (a int, b int, c text) SERVER extstats_dummy_srv;
CREATE FOREIGN table tableam_fdw_heapx () SERVER fs_heap2;
CREATE FUNCTION addr_nsp.trig() RETURNS TRIGGER LANGUAGE plpgsql AS $$ BEGIN END; $$;
CREATE FUNCTION alter_op_test_fn(boolean, boolean) RETURNS boolean AS $$ SELECT NULL::BOOLEAN; $$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION balkifnull(int8, int4) RETURNS int8 STRICTLANGUAGE plpgsql AS $$ BEGIN     IF $1 IS NULL THEN        RAISE 'erroneously called with NULL argument';     END IF;     RETURN NULL; END$$;
CREATE FUNCTION base_tbl_trig_fn() RETURNS trigger AS$$ BEGIN   NEW.b := 10;   RETURN NEW; END; $$ LANGUAGE plpgsql;
CREATE FUNCTION castfunc(int) RETURNS priv_testdomain3a AS $$ SELECT $1::priv_testdomain3a $$ LANGUAGE SQL;
CREATE FUNCTION castfunc(int) RETURNS priv_testdomain3b AS $$ SELECT $1::priv_testdomain3b $$ LANGUAGE SQL;
CREATE FUNCTION casttestfunc(casttesttype) RETURNS int4 LANGUAGE SQL AS $$ SELECT 1; $$;
CREATE FUNCTION check_ddl_rewrite(p_tablename regclass, p_ddl text) RETURNS booleanLANGUAGE plpgsql AS $$ DECLARE     v_relfilenode oid; BEGIN     v_relfilenode := relfilenode FROM pg_class WHERE oid = p_tablename;     EXECUTE p_ddl;     RETURN v_relfilenode <> (SELECT relfilenode FROM pg_class WHERE oid = p_tablename); END; $$;
CREATE FUNCTION city_delete() RETURNS trigger LANGUAGE plpgsql AS $$ begin     DELETE FROM city_table WHERE city_id = OLD.city_id;     if NOT FOUND then RETURN NULL; end if;     RETURN OLD; end; $$;
CREATE FUNCTION city_insert() RETURNS trigger LANGUAGE plpgsql AS $$ declare     ctry_id int; begin     if NEW.country_name IS NOT NULL then         SELECT country_id, continent INTO ctry_id, NEW.continent             FROM country_table WHERE country_name = NEW.country_name;         if NOT FOUND then             raise exception 'No such country: "%"', NEW.country_name;         end if;     else         NEW.continent := NULL;     end if;     if NEW.city_id IS NOT NULL then         INSERT INTO city_table             VALUES(NEW.city_id, NEW.city_name, NEW.population, ctry_id);     else         INSERT INTO city_table(city_name, population, country_id)             VALUES(NEW.city_name, NEW.population, ctry_id)             RETURNING city_id INTO NEW.city_id;     end if;     RETURN NEW; end; $$;
CREATE FUNCTION city_update() RETURNS trigger LANGUAGE plpgsql AS $$ declare     ctry_id int; begin     if NEW.country_name IS DISTINCT FROM OLD.country_name then         SELECT country_id, continent INTO ctry_id, NEW.continent             FROM country_table WHERE country_name = NEW.country_name;         if NOT FOUND then             raise exception 'No such country: "%"', NEW.country_name;         end if;         UPDATE city_table SET city_name = NEW.city_name,                               population = NEW.population,                               country_id = ctry_id             WHERE city_id = OLD.city_id;     else         UPDATE city_table SET city_name = NEW.city_name,                               population = NEW.population             WHERE city_id = OLD.city_id;         NEW.continent := OLD.continent;     end if;     if NOT FOUND then RETURN NULL; end if;     RETURN NEW; end; $$;
CREATE FUNCTION comp() RETURNS TEXTAS $$ BEGIN   RETURN (SELECT CASE                WHEN m.id = c.relfilenode THEN 'Unchanged'                ELSE 'Rewritten'                END            FROM m, pg_class AS c, pg_namespace AS s            WHERE c.relname = 't'                AND c.relnamespace = s.oid                AND s.nspname = 'fast_default'); END; $$ LANGUAGE 'plpgsql';
CREATE FUNCTION const_func () RETURNS int AS $$ SELECT 1; $$ LANGUAGE SQL IMMUTABLE;
CREATE FUNCTION create_temp_tab() RETURNS textLANGUAGE plpgsql AS $$ BEGIN   CREATE TEMP TABLE new_table (f1 float8);   INSERT INTO new_table SELECT invert(0.0);   RETURN 'foo'; END $$;
CREATE FUNCTION deptest_func() RETURNS void LANGUAGE plpgsql   AS $$ BEGIN END; $$;
CREATE FUNCTION dummy_trigger() RETURNS TRIGGER AS $$   BEGIN     RETURN NULL;   END $$ language plpgsql;
CREATE FUNCTION dummy_update_func() RETURNS trigger AS $$ BEGIN   RAISE NOTICE 'dummy_update_func(%) called: action = %, old = %, new = %',     TG_ARGV[0], TG_OP, OLD, NEW;   RETURN NEW; END; $$ LANGUAGE plpgsql;
CREATE FUNCTION echo_me(anyenum) RETURNS text AS $$ BEGIN RETURN $1::text || 'omg'; END $$ LANGUAGE plpgsql;
CREATE FUNCTION echo_me(rainbow) RETURNS text AS $$ BEGIN RETURN $1::text || 'wtf'; END $$ LANGUAGE plpgsql;
CREATE FUNCTION float8mi_int(float8, float8) RETURNS int AS $$ SELECT CAST($1 - $2 AS INT); $$ LANGUAGE SQL;
CREATE FUNCTION float8mi_n(float8, float8) RETURNS float8 AS $$ SELECT $1 - $2; $$ LANGUAGE SQL;
CREATE FUNCTION fn_op3(type_op3, int8)RETURNS int8 AS $$     SELECT NULL::int8; $$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION fn_op4(int8, type_op4)RETURNS int8 AS $$     SELECT NULL::int8; $$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION fn_op5(int8, int8)RETURNS int8 AS $$     SELECT NULL::int8; $$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION fn_op6(int8, int8)RETURNS type_op6 AS $$     SELECT NULL::type_op6; $$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION func() RETURNS VOID AS $$ ALTER SUBSCRIPTION regress_testsub SET PUBLICATION mypub WITH (refresh = true) $$ LANGUAGE SQL;
CREATE FUNCTION func_d_1_15() RETURNS trigger AS $$ BEGIN    NEW.c = NEW.c + 1; -- Make even numbers odd, or vice versa    return NEW; END $$ LANGUAGE plpgsql;
CREATE FUNCTION func_parted_mod_b() RETURNS trigger AS $$ BEGIN    NEW.b = NEW.b + 1;    return NEW; END $$ language plpgsql;
CREATE FUNCTION func_parted_mod_b() returns trigger as $$ BEGIN    NEW.b = 2; -- This is changing partition key column.    return NEW; END $$ LANGUAGE plpgsql;
CREATE FUNCTION functest_S_13() RETURNS boolean     BEGIN ATOMIC         SELECT 1;
CREATE FUNCTION functest_S_14() RETURNS bigint     RETURN (SELECT count(*) FROM functestv3);
CREATE FUNCTION functest_S_2(a text[]) RETURNS int     RETURN a[1]::int;
CREATE FUNCTION functest_S_3() RETURNS boolean     RETURN false;
CREATE FUNCTION functest_S_3a() RETURNS boolean     BEGIN ATOMIC         ;;RETURN false;;
CREATE FUNCTION functest_S_xxx(x int) RETURNS int     LANGUAGE SQL     AS $$ SELECT x * 2 $$     RETURN x * 3;
CREATE FUNCTION functest_sri1() RETURNS SETOF int LANGUAGE SQL STABLE AS '     SELECT * FROM functest3;
CREATE FUNCTION fx(x WSlot) RETURNS void AS $$ BEGIN   GET DIAGNOSTICS x = ROW_COUNT;   RETURN; END; $$ LANGUAGE plpgsql;
CREATE FUNCTION get_default_test() RETURNS SETOF default_test_row AS '   SELECT * FROM default_test;
CREATE FUNCTION gf1(a int) RETURNS int AS $$ SELECT a * 3 $$ IMMUTABLE LANGUAGE SQL;
CREATE FUNCTION immut_func (a int) RETURNS int AS $$ SELECT a + random()::int; $$ LANGUAGE SQL;
CREATE FUNCTION int4_casttesttype(int4) RETURNS casttesttype LANGUAGE SQL AS $$ SELECT ('foo'::text || $1::text)::casttesttype; $$;
CREATE FUNCTION invert(x float8) RETURNS float8 LANGUAGE plpgsql AS $$ begin return 1/x; end $$;
CREATE FUNCTION leak2(integer,integer) RETURNS boolean   AS $$begin raise notice 'leak % %', $1, $2; return $1 > $2; end$$   LANGUAGE plpgsql immutable;
CREATE FUNCTION leaker_1(fail BOOL) RETURNS INTEGER AS $$ DECLARE   v_var INTEGER; BEGIN   BEGIN     v_var := (leaker_2(fail)).error_code;   EXCEPTION     WHEN others THEN RETURN 0;   END;   RETURN 1; END; $$ LANGUAGE plpgsql;
CREATE FUNCTION leaker_2(fail BOOL, OUT error_code INTEGER, OUT new_id INTEGER)  RETURNS RECORD AS $$ BEGIN   IF fail THEN     RAISE EXCEPTION 'fail ...';   END IF;   error_code := 1;   new_id := 1;   RETURN; END; $$ LANGUAGE plpgsql;
CREATE FUNCTION log_rewrite() RETURNS event_trigger LANGUAGE plpgsql as $func$ declare    this_schema text;
CREATE FUNCTION logging_minvfunc_nonstrict(text, anyelement) RETURNS text AS $$ SELECT $1 || '-' || quote_nullable($2) $$ LANGUAGE SQL IMMUTABLE;
CREATE FUNCTION logging_minvfunc_strict(text, anyelement) RETURNS text AS $$ SELECT $1 || '-' || quote_nullable($2) $$ LANGUAGE SQL STRICT IMMUTABLE;
CREATE FUNCTION logging_msfunc_nonstrict(text, anyelement) RETURNS text AS $$ SELECT COALESCE($1, '') || '+' || quote_nullable($2) $$ LANGUAGE SQL IMMUTABLE;
CREATE FUNCTION logging_msfunc_strict(text, anyelement) RETURNS text AS $$ SELECT $1 || '+' || quote_nullable($2) $$ LANGUAGE SQL STRICT IMMUTABLE;
CREATE FUNCTION logging_sfunc_nonstrict(text, anyelement) RETURNS text AS $$ SELECT COALESCE($1, '') || '*' || quote_nullable($2) $$ LANGUAGE SQL IMMUTABLE;
CREATE FUNCTION logging_sfunc_strict(text, anyelement) RETURNS text AS $$ SELECT $1 || '*' || quote_nullable($2) $$ LANGUAGE SQL STRICT IMMUTABLE;
CREATE FUNCTION make_ad(int,int) returns arrdomain as   'declare x arrdomain;
CREATE FUNCTION make_some_array(int,int) returns int[] as$$declare x int[];   begin     x[1] := $1;     x[2] := $2;     return x;   end$$ language plpgsql parallel safe;
CREATE FUNCTION make_table() RETURNS VOIDAS $$   CREATE TABLE created_table AS SELECT * FROM int8_tbl; $$ LANGUAGE SQL;
CREATE FUNCTION mvtest_func()  RETURNS void AS $$ BEGIN   CREATE MATERIALIZED VIEW mvtest1 AS SELECT 1 AS x;   CREATE MATERIALIZED VIEW mvtest2 AS SELECT 1 AS x WITH NO DATA; END; $$ LANGUAGE plpgsql;
CREATE FUNCTION my_gen_series(int, int) RETURNS SETOF integer   LANGUAGE internal STRICT IMMUTABLE PARALLEL SAFE   AS $$generate_series_int4$$   SUPPORT test_support_func;
CREATE FUNCTION my_int4_sort(int4,int4) RETURNS int LANGUAGE sql   AS $$ SELECT CASE WHEN $1 = $2 THEN 0 WHEN $1 > $2 THEN 1 ELSE -1 END; $$;
CREATE FUNCTION my_int_eq(int, int) RETURNS bool   LANGUAGE internal STRICT IMMUTABLE PARALLEL SAFE   AS $$int4eq$$;
CREATE FUNCTION mylt (text, text) RETURNS boolean LANGUAGE sql     AS $$ select $1 < $2 $$;
CREATE FUNCTION mylt (text, text) RETURNS boolean LANGUAGE sql     AS $$ select $1 < $2 $$;
CREATE FUNCTION mylt2 (x text, y text) RETURNS boolean LANGUAGE plpgsql AS $$ declare   xx text := x;   yy text := y; begin   return xx < yy; end $$;
CREATE FUNCTION mylt2 (x text, y text) RETURNS boolean LANGUAGE plpgsql AS $$ declare   xx text := x;   yy text := y; begin   return xx < yy; end $$;
CREATE FUNCTION mylt_noninline (text, text) RETURNS boolean LANGUAGE sql     AS $$ select $1 < $2 limit 1 $$;
CREATE FUNCTION mylt_noninline (text, text) RETURNS boolean LANGUAGE sql     AS $$ select $1 < $2 limit 1 $$;
CREATE FUNCTION mylt_plpgsql (text, text) RETURNS boolean LANGUAGE plpgsql     AS $$ begin return $1 < $2; end $$;
CREATE FUNCTION mylt_plpgsql (text, text) RETURNS boolean LANGUAGE plpgsql     AS $$ begin return $1 < $2; end $$;
CREATE FUNCTION mytrigger() RETURNS trigger LANGUAGE plpgsql as $$ begin 	if row(old.*) = row(new.*) then 		raise notice 'row % not changed', new.f1; 	else 		raise notice 'row % changed', new.f1; 	end if; 	return new; end$$;
CREATE FUNCTION myvarcharsend(myvarchar) RETURNS bytea LANGUAGE internal STABLE PARALLEL SAFE STRICT AS 'varcharsend';
CREATE FUNCTION namelen(person_type) RETURNS int LANGUAGE SQL AS $$ SELECT length($1.name) $$;
CREATE FUNCTION nonsimple_expr_test() RETURNS integer AS $$ declare    i integer NOT NULL := 0; begin   begin     i := (SELECT NULL::integer);  -- should throw error   exception     WHEN OTHERS THEN       i := (SELECT 1::integer);   end;   return i; end; $$ LANGUAGE plpgsql;
CREATE FUNCTION nonsimple_expr_test() RETURNS text[] AS $$ DECLARE   arr text[];   lr text;   i integer; BEGIN   arr := array[array['foo','bar'], array['baz', 'quux']];   lr := 'fool';   i := 1;   arr[(SELECT i)][(SELECT i+1)] := (SELECT lr);   RETURN arr; END; $$ LANGUAGE plpgsql;
CREATE FUNCTION pg_temp.f(group_size BIGINT) RETURNS SETOF integer[]AS $$     SELECT array_agg(s) OVER w       FROM generate_series(1,5) s     WINDOW w AS (ORDER BY s ROWS BETWEEN CURRENT ROW AND GROUP_SIZE FOLLOWING) $$ LANGUAGE SQL STABLE;
CREATE FUNCTION plusone(a int) RETURNS INT AS $$ SELECT a+1; $$ LANGUAGE SQL;
CREATE FUNCTION predicate_stable() RETURNS bool IMMUTABLELANGUAGE plpgsql AS $$ BEGIN   EXECUTE 'SELECT txid_current()';   RETURN true; END; $$;
CREATE FUNCTION price_key_from_input(price_input) RETURNS price_key AS $$     SELECT $1.id $$ LANGUAGE SQL;
CREATE FUNCTION price_key_from_table(price) RETURNS price_key AS $$     SELECT $1.id $$ LANGUAGE SQL;
CREATE FUNCTION priv_testfunc5a(a priv_testdomain1) RETURNS int LANGUAGE SQL AS $$ SELECT $1 $$;
CREATE FUNCTION priv_testfunc5b(a priv_testdomain1) RETURNS int LANGUAGE SQL AS $$ SELECT $1 $$;
CREATE FUNCTION priv_testfunc6a(b int) RETURNS priv_testdomain1 LANGUAGE SQL AS $$ SELECT $1::priv_testdomain1 $$;
CREATE FUNCTION priv_testfunc6b(b int) RETURNS priv_testdomain1 LANGUAGE SQL AS $$ SELECT $1::priv_testdomain1 $$;
CREATE FUNCTION recursion_test(int,int) RETURNS text AS ' DECLARE rslt text;
CREATE FUNCTION reraise_test() RETURNS void AS $$ BEGIN    BEGIN        RAISE syntax_error;    EXCEPTION        WHEN syntax_error THEN            BEGIN                raise notice 'exception % thrown in inner block, reraising', sqlerrm;                RAISE;            EXCEPTION                WHEN OTHERS THEN                    raise notice 'RIGHT - exception % caught in inner block', sqlerrm;            END;    END; EXCEPTION    WHEN OTHERS THEN        raise notice 'WRONG - exception % caught in outer block', sqlerrm; END; $$ LANGUAGE plpgsql;
CREATE FUNCTION retset (a int) RETURNS SETOF int AS $$ SELECT 1; $$ LANGUAGE SQL IMMUTABLE;
CREATE FUNCTION rw_view1_aa(x rw_view1)   RETURNS int AS $$ SELECT x.aa $$ LANGUAGE sql;
CREATE FUNCTION rw_view1_trig_fn() RETURNS trigger AS$$ BEGIN   IF TG_OP = 'INSERT' THEN     INSERT INTO base_tbl VALUES (NEW.a, 10);     RETURN NEW;   ELSIF TG_OP = 'UPDATE' THEN     UPDATE base_tbl SET a=NEW.a WHERE a=OLD.a;     RETURN NEW;   ELSIF TG_OP = 'DELETE' THEN     DELETE FROM base_tbl WHERE a=OLD.a;     RETURN OLD;   END IF; END; $$ LANGUAGE plpgsql;
CREATE FUNCTION rw_view1_trig_fn() RETURNS trigger AS$$ BEGIN   IF TG_OP = 'INSERT' THEN     INSERT INTO base_tbl VALUES (NEW.a, NEW.b);     RETURN NEW;   ELSIF TG_OP = 'UPDATE' THEN     UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a;     RETURN NEW;   ELSIF TG_OP = 'DELETE' THEN     DELETE FROM base_tbl WHERE a=OLD.a;     RETURN OLD;   END IF; END; $$ LANGUAGE plpgsql;
CREATE FUNCTION rw_view1_trig_fn() RETURNS trigger AS$$ BEGIN   IF TG_OP = 'INSERT' THEN     UPDATE base_tbl SET b=NEW.b WHERE a=1;     RETURN NULL;   END IF;   RETURN NULL; END; $$ LANGUAGE plpgsql;
CREATE FUNCTION seclabel_four() RETURNS integer AS $$SELECT 4$$ language sql;
CREATE FUNCTION set(tabname name) RETURNS VOIDAS $$ BEGIN   UPDATE m   SET id = (SELECT c.relfilenode             FROM pg_class AS c, pg_namespace AS s             WHERE c.relname = tabname                 AND c.relnamespace = s.oid                 AND s.nspname = 'fast_default'); END; $$ LANGUAGE 'plpgsql';
CREATE FUNCTION snoop(anyelement) RETURNS boolean AS$$ BEGIN   RAISE NOTICE 'snooped value: %', $1;   RETURN true; END; $$ LANGUAGE plpgsql COST 0.000001;
CREATE FUNCTION sum_int_randrestart_minvfunc(int4, int4) RETURNS int4 AS $$ SELECT CASE WHEN random() < 0.2 THEN NULL ELSE $1 - $2 END $$ LANGUAGE SQL STRICT;
CREATE FUNCTION test_ambiguous_funcname(int) returns int as $$ select $1; $$ language sql;
CREATE FUNCTION test_ambiguous_funcname(text) returns text as $$ select $1; $$ language sql;
CREATE FUNCTION tp_chk_data(OUT pktb regclass, OUT pkval int, OUT fktb regclass, OUT fkval int)  RETURNS SETOF record LANGUAGE plpgsql AS $$   BEGIN     RETURN QUERY SELECT       pk.tableoid::regclass, pk.a, fk.tableoid::regclass, fk.a     FROM truncprim pk FULL JOIN truncpart fk USING (a)     ORDER BY 2, 4;   END $$;
CREATE FUNCTION tp_ins_data() RETURNS void LANGUAGE plpgsql AS $$   BEGIN 	INSERT INTO truncprim VALUES (1), (100), (150); 	INSERT INTO truncpart VALUES (1), (100), (150);   END $$;
CREATE FUNCTION truncate_in_subxact() RETURNS VOID AS$$ BEGIN 	TRUNCATE vistest; EXCEPTION   WHEN OTHERS THEN 	INSERT INTO vistest VALUES ('subxact failure'); END; $$ language plpgsql;
CREATE FUNCTION trunctrigger() RETURNS trigger as $$ declare c bigint; begin     execute 'select count(*) from ' || quote_ident(tg_table_name) into c;     insert into trunc_trigger_log values       (TG_OP, TG_LEVEL, TG_WHEN, TG_ARGV[0], tg_table_name, c);     return null; end; $$ LANGUAGE plpgsql;
CREATE FUNCTION update_using_indirect()         RETURNS trigger        LANGUAGE plpgsql AS $$ BEGIN     NEW := make_tuple_indirect(NEW);     RETURN NEW; END$$;
CREATE FUNCTION voidtest1(a int) RETURNS VOID LANGUAGE SQL AS $$ SELECT a + 1 $$;
CREATE FUNCTION voidtest2(a int, b int) RETURNS VOID LANGUAGE SQL AS $$ SELECT voidtest1(a + b) $$;
CREATE FUNCTION voidtest3(a int) RETURNS VOID LANGUAGE SQL AS $$ INSERT INTO sometable VALUES(a + 1) $$;
CREATE FUNCTION voidtest4(a int) RETURNS VOID LANGUAGE SQL AS $$ INSERT INTO sometable VALUES(a - 1) RETURNING f1 $$;
CREATE FUNCTION voidtest5(a int) RETURNS SETOF VOID LANGUAGE SQL AS $$ SELECT generate_series(1, a) $$ STABLE;
CREATE FUNCTION y_trigger() RETURNS trigger AS $$ begin   raise notice 'y_trigger: a = %', new.a;   return new; end; $$ LANGUAGE plpgsql;
CREATE GROUP regress_dep_group;
CREATE GROUP regress_priv_group1;
CREATE GROUP regress_priv_group2 WITH USER regress_priv_user1, regress_priv_user2;
CREATE GROUP regress_test_g1;
CREATE INDEX IF NOT EXISTS ON onek USING btree(unique1 int4_ops);
CREATE INDEX brinidx_bloom ON brintest_bloom USING brin ( 	byteacol bytea_bloom_ops(n_distinct_per_range = -1.1) );
CREATE MATERIALIZED VIEW IF NOT EXISTS mvtest_mv_foo AS SELECT * FROM mvtest_foo_data;
CREATE MATERIALIZED VIEW addr_nsp.genmatview AS SELECT * FROM addr_nsp.gentable;
CREATE MATERIALIZED VIEW compressmv(x) AS SELECT * FROM cmdata1;
CREATE MATERIALIZED VIEW concur_reindex_matview AS SELECT * FROM concur_reindex_tab;
CREATE MATERIALIZED VIEW mat_view_heap_psql USING heap_psql AS SELECT f1 from tbl_heap_psql;
CREATE MATERIALIZED VIEW matview AS SELECT col1 FROM table2;
CREATE MATERIALIZED VIEW matview_ine_tab AS SELECT 1 / 0; -- error CREATE MATERIALIZED VIEW IF NOT EXISTS matview_ine_tab AS   SELECT 1 / 0; -- ok CREATE MATERIALIZED VIEW matview_ine_tab AS   SELECT 1 / 0 WITH NO DATA; -- error CREATE MATERIALIZED VIEW IF NOT EXISTS matview_ine_tab AS   SELECT 1 / 0 WITH NO DATA; -- ok EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE MATERIALIZED VIEW matview_ine_tab AS     SELECT 1 / 0; -- error EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE MATERIALIZED VIEW IF NOT EXISTS matview_ine_tab AS     SELECT 1 / 0; -- ok EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE MATERIALIZED VIEW matview_ine_tab AS     SELECT 1 / 0 WITH NO DATA; -- error EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE MATERIALIZED VIEW IF NOT EXISTS matview_ine_tab AS     SELECT 1 / 0 WITH NO DATA; -- ok DROP MATERIALIZED VIEW matview_ine_tab;
CREATE MATERIALIZED VIEW matview_ine_tab AS SELECT 1;
CREATE MATERIALIZED VIEW matview_schema.mv_nodata1 (a) AS   SELECT generate_series(1, 10) WITH NO DATA;
CREATE MATERIALIZED VIEW matview_schema.mv_withdata1 (a) AS   SELECT generate_series(1, 10) WITH DATA;
CREATE MATERIALIZED VIEW mv_test2 AS SELECT moo, 2*moo FROM mvtest_vt2 UNION ALL SELECT moo, 3*moo FROM mvtest_vt2;
CREATE MATERIALIZED VIEW mv_test3 AS SELECT * FROM mv_test2 WHERE moo = 12345;
CREATE MATERIALIZED VIEW mv_unspecified_types AS   SELECT 42 as i, 42.5 as num, 'foo' as u, 'foo'::unknown as u2, null as n;
CREATE MATERIALIZED VIEW mvtest_bb AS SELECT * FROM mvtest_tvvmv;
CREATE MATERIALIZED VIEW mvtest_boxmv AS SELECT * FROM mvtest_boxes;
CREATE MATERIALIZED VIEW mvtest_mv AS SELECT * FROM mvtest_foo;
CREATE MATERIALIZED VIEW mvtest_mv AS SELECT * FROM mvtest_foo;
CREATE MATERIALIZED VIEW mvtest_mv1 AS SELECT 1 AS col1 WITH NO DATA;
CREATE MATERIALIZED VIEW mvtest_mv2 AS SELECT * FROM mvtest_mv1   WHERE col1 = (SELECT LEAST(col1) FROM mvtest_mv1) WITH NO DATA;
CREATE MATERIALIZED VIEW mvtest_mv_foo AS SELECT * FROM mvtest_foo_data;
CREATE MATERIALIZED VIEW mvtest_mv_foo AS SELECT * FROM mvtest_foo_data;
CREATE MATERIALIZED VIEW mvtest_mv_v (ii, jj, kk) AS SELECT i, j FROM mvtest_v; -- error CREATE MATERIALIZED VIEW mvtest_mv_v (ii, jj) AS SELECT i, j FROM mvtest_v; -- ok CREATE MATERIALIZED VIEW mvtest_mv_v_2 (ii) AS SELECT i, j FROM mvtest_v; -- ok CREATE MATERIALIZED VIEW mvtest_mv_v_3 (ii, jj, kk) AS SELECT i, j FROM mvtest_v WITH NO DATA; -- error CREATE MATERIALIZED VIEW mvtest_mv_v_3 (ii, jj) AS SELECT i, j FROM mvtest_v WITH NO DATA; -- ok CREATE MATERIALIZED VIEW mvtest_mv_v_4 (ii) AS SELECT i, j FROM mvtest_v WITH NO DATA; -- ok ALTER TABLE mvtest_v RENAME COLUMN i TO x;
CREATE MATERIALIZED VIEW mvtest_mv_v AS SELECT a FROM mvtest_v WHERE a <= 5;
CREATE MATERIALIZED VIEW mvtest_tm AS SELECT type, sum(amt) AS totamt FROM mvtest_t GROUP BY type WITH NO DATA;
CREATE MATERIALIZED VIEW mvtest_tmm AS SELECT sum(totamt) AS grandtot FROM mvtest_tm;
CREATE MATERIALIZED VIEW mvtest_tvm AS SELECT * FROM mvtest_tv ORDER BY type;
CREATE MATERIALIZED VIEW mvtest_tvmm AS SELECT sum(totamt) AS grandtot FROM mvtest_tvm;
CREATE MATERIALIZED VIEW mvtest_tvvm AS SELECT * FROM mvtest_tvv;
CREATE MATERIALIZED VIEW ptif_test_matview AS SELECT 1;
CREATE MATERIALIZED VIEW sro_mv AS SELECT mv_action() WITH NO DATA;
CREATE MATERIALIZED VIEW tableam_tblmv_heap2 USING heap2 AS SELECT * FROM tableam_tbl_heap2;
CREATE MATERIALIZED VIEW tableam_tblmv_heapx USING heap2 AS SELECT * FROM tableam_tbl_heapx;
CREATE MATERIALIZED VIEW tid_matview AS SELECT a FROM tid_tab;
CREATE MATERIALIZED VIEW tststats.mv AS SELECT * FROM tststats.t;
CREATE OPERATOR !! (PROCEDURE = priv_testfunc5b, RIGHTARG = priv_testdomain1);
CREATE OPERATOR !+! (PROCEDURE = int4pl, LEFTARG = priv_testdomain1, RIGHTARG = priv_testdomain1);
CREATE OPERATOR !=- (    rightarg = int8,    procedure = factorial );
CREATE OPERATOR !== (         PROCEDURE = int8ne,         LEFTARG = bigint,         RIGHTARG = bigint,         NEGATOR = ===,         COMMUTATOR = !== );
CREATE OPERATOR ## (    leftarg = path,    rightarg = path,    function = path_inter,    commutator = ## );
CREATE OPERATOR #%# (    leftarg = int8,		-- fail, postfix is no longer supported    procedure = factorial );
CREATE OPERATOR #*# (    leftarg = SETOF int8,    procedure = factorial );
CREATE OPERATOR #*# (    leftarg = int8,    rightarg = int8,    procedure = fn_op5 );
CREATE OPERATOR #*# (    leftarg = int8,    rightarg = int8,    procedure = fn_op6 );
CREATE OPERATOR #*# (    leftarg = int8,    rightarg = type_op4,    procedure = fn_op4 );
CREATE OPERATOR #*# (    leftarg = type_op3,    rightarg = int8,    procedure = fn_op3 );
CREATE OPERATOR #*# (    rightarg = SETOF int8,    procedure = factorial );
CREATE OPERATOR #@%# (    procedure = factorial );
CREATE OPERATOR #@%# (    rightarg = int8 );
CREATE OPERATOR #@%# (    rightarg = int8,    procedure = factorial,    invalid_att = int8 );
CREATE OPERATOR <% (    leftarg = point,    rightarg = widget,    procedure = pt_in_widget,    commutator = >% ,    negator = >=% );
CREATE OPERATOR <<< (procedure = leak, leftarg = integer, rightarg = integer,                      restrict = scalarltsel);
CREATE OPERATOR <<< (procedure = op_leak, leftarg = int, rightarg = int,                      restrict = scalarltsel);
CREATE OPERATOR <<< (procedure = op_leak, leftarg = int, rightarg = int,                      restrict = scalarltsel);
CREATE OPERATOR <| (         PROCEDURE = int8lt,         LEFTARG = bigint,         RIGHTARG = bigint );
CREATE OPERATOR = (procedure = ad_eq,                    leftarg = arrdomain, rightarg = arrdomain);
CREATE OPERATOR = (procedure = inline_eq,                    leftarg = foodomain, rightarg = foodomain);
CREATE OPERATOR === ( 	"Leftarg" = box, 	"Rightarg" = box, 	"Procedure" = area_equal_function, 	"Commutator" = ===, 	"Negator" = !==, 	"Restrict" = area_restriction_function, 	"Join" = area_join_function, 	"Hashes", 	"Merges" );
CREATE OPERATOR === (         PROCEDURE = int8eq,         LEFTARG = bigint,         RIGHTARG = bigint,         COMMUTATOR = === );
CREATE OPERATOR === (     LEFTARG = boolean,     RIGHTARG = boolean,     PROCEDURE = alter_op_test_fn,     COMMUTATOR = ===,     NEGATOR = !==,     RESTRICT = customcontsel,     JOIN = contjoinsel,     HASHES, MERGES );
CREATE OPERATOR === (     LEFTARG = boolean,     RIGHTARG = boolean,     PROCEDURE = fn_op2,     COMMUTATOR = ===,     NEGATOR = !==,     RESTRICT = contsel,     JOIN = contjoinsel,     SORT1, SORT2, LTCMP, GTCMP, HASHES, MERGES );
CREATE OPERATOR => (    rightarg = int8,    procedure = factorial );
CREATE OPERATOR >>> (procedure = leak2, leftarg = integer, rightarg = integer,                      restrict = scalargtsel);
CREATE OPERATOR @#@         (leftarg = int8, rightarg = int8, procedure = int8xor);
CREATE OPERATOR @#@ (    rightarg = int8,		-- prefix    procedure = factorial );
CREATE OPERATOR @+@ ( leftarg = int4, rightarg = int4, procedure = int4pl );
CREATE OPERATOR @-@ ( leftarg = int4, rightarg = int4, procedure = int4mi );
CREATE OPERATOR @-@ ( leftarg = int4, rightarg = int4, procedure = int4mi );
CREATE OPERATOR CLASS alt_opc1 FOR TYPE macaddr USING hash AS STORAGE macaddr;
CREATE OPERATOR CLASS alt_opc1 FOR TYPE uuid USING hash AS STORAGE uuid;
CREATE OPERATOR CLASS alt_opc2 FOR TYPE macaddr USING hash AS STORAGE macaddr;
CREATE OPERATOR CLASS alt_opc2 FOR TYPE uuid USING hash AS STORAGE uuid;
CREATE OPERATOR CLASS box_ops DEFAULT 	FOR TYPE box USING gist2 AS 	OPERATOR 1	<<, 	OPERATOR 2	&<, 	OPERATOR 3	&&, 	OPERATOR 4	&>, 	OPERATOR 5	>>, 	OPERATOR 6	~=, 	OPERATOR 7	@>, 	OPERATOR 8	<@, 	OPERATOR 9	&<|, 	OPERATOR 10	<<|, 	OPERATOR 11	|>>, 	OPERATOR 12	|&>, 	FUNCTION 1	gist_box_consistent(internal, box, smallint, oid, internal), 	FUNCTION 2	gist_box_union(internal, internal), 	FUNCTION 5	gist_box_penalty(internal, internal, internal), 	FUNCTION 6	gist_box_picksplit(internal, internal), 	FUNCTION 7	gist_box_same(box, box, internal);
CREATE OPERATOR CLASS test_int4_ops FOR TYPE int4 USING btree AS   OPERATOR 1 < (int4,int4), OPERATOR 2 <= (int4,int4),   OPERATOR 3 = (int4,int4), OPERATOR 4 >= (int4,int4),   OPERATOR 5 > (int4,int4), FUNCTION 1 my_int4_sort(int4,int4);
CREATE OPERATOR FAMILY alt_nsp6.alt_opf6 USING btree;
CREATE OPERATOR FAMILY alt_opf1 USING hash;
CREATE OPERATOR FAMILY alt_opf1 USING hash;
CREATE OPERATOR FAMILY alt_opf10 USING btree;
CREATE OPERATOR FAMILY alt_opf11 USING gist;
CREATE OPERATOR FAMILY alt_opf12 USING btree;
CREATE OPERATOR FAMILY alt_opf13 USING hash;
CREATE OPERATOR FAMILY alt_opf14 USING btree;
CREATE OPERATOR FAMILY alt_opf15 USING hash;
CREATE OPERATOR FAMILY alt_opf16 USING gist;
CREATE OPERATOR FAMILY alt_opf17 USING btree;
CREATE OPERATOR FAMILY alt_opf18 USING btree;
CREATE OPERATOR FAMILY alt_opf19 USING btree;
CREATE OPERATOR FAMILY alt_opf2 USING hash;
CREATE OPERATOR FAMILY alt_opf2 USING hash;
CREATE OPERATOR FAMILY alt_opf4 USING btree;
CREATE OPERATOR FAMILY alt_opf4 USING btree;
CREATE OPERATOR FAMILY alt_opf5 USING btree;
CREATE OPERATOR FAMILY alt_opf7 USING btree;
CREATE OPERATOR FAMILY alt_opf8 USING btree;
CREATE OPERATOR FAMILY alt_opf9 USING gist;
CREATE OPERATOR schema_op1.#*# (    rightarg = int8,    procedure = factorial );
CREATE OPERATOR |> (         PROCEDURE = int8gt,         LEFTARG = bigint,         RIGHTARG = bigint,         NEGATOR = <|,         COMMUTATOR = <| );
CREATE OPERATOR |@| (PROCEDURE = unnest, RIGHTARG = ANYARRAY);
CREATE OR REPLACE AGGREGATE myavg (numeric) ( 	stype = internal, 	sfunc = numeric_avg_accum, 	finalfunc = numeric_avg, 	serialfunc = numeric_avg_serialize, 	deserialfunc = numeric_avg_deserialize, 	combinefunc = numeric_avg_combine, 	finalfunc_modify = shareable  -- just to test a non-default setting );
CREATE OR REPLACE AGGREGATE myavg (numeric) ( 	stype = numeric, 	sfunc = numeric_add );
CREATE OR REPLACE AGGREGATE myavg (numeric) ( 	stype = numeric, 	sfunc = numeric_add, 	finalfunc = numeric_out );
CREATE OR REPLACE AGGREGATE myavg (order by numeric) ( 	stype = numeric, 	sfunc = numeric_add );
CREATE OR REPLACE AGGREGATE sum3 (int8,int8,int8) ( 	stype = int8, 	sfunc = sum4 );
CREATE OR REPLACE FUNCTION  mylt2 (x text, y text) RETURNS boolean LANGUAGE plpgsql AS $$ declare   xx text COLLATE "POSIX" := x;   yy text := y; begin   return xx < yy; end $$;
CREATE OR REPLACE FUNCTION  mylt2 (x text, y text) RETURNS boolean LANGUAGE plpgsql AS $$ declare   xx text COLLATE "POSIX" := x;   yy text := y; begin   return xx < yy; end $$;
CREATE OR REPLACE FUNCTION compare_relfilenode_part(tabname text)   RETURNS TABLE (relname name, relkind "char", state text) AS   $func$   BEGIN     RETURN QUERY EXECUTE       format(         'SELECT  b.relname,                  b.relkind,                  CASE WHEN a.relfilenode = b.relfilenode THEN ''relfilenode is unchanged''                  ELSE ''relfilenode has changed'' END            FROM %I b JOIN pg_class a ON b.relname = a.relname            ORDER BY 1;', tabname);
CREATE OR REPLACE FUNCTION create_relfilenode_part(relname text, indname text)   RETURNS VOID AS   $func$   BEGIN   EXECUTE format('     CREATE TABLE %I AS       SELECT oid, relname, relfilenode, relkind, reltoastrelid       FROM pg_class       WHERE oid IN          (SELECT relid FROM pg_partition_tree(''%I''));', 	 relname, indname);
CREATE OR REPLACE FUNCTION distinct_func(a INT) RETURNS INT AS $$   BEGIN     RETURN a;   END; $$ LANGUAGE plpgsql PARALLEL SAFE;
CREATE OR REPLACE FUNCTION distinct_func(a INT) RETURNS INT AS $$   BEGIN     RETURN a;   END; $$ LANGUAGE plpgsql PARALLEL UNSAFE;
CREATE OR REPLACE FUNCTION drop_sql_command()RETURNS event_trigger AS $$ BEGIN RAISE NOTICE '% - sql_drop', tg_tag; END; $$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION end_command()RETURNS event_trigger AS $$ BEGIN RAISE NOTICE '% - ddl_command_end', tg_tag; END; $$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION fn_op2(boolean, boolean)RETURNS boolean AS $$     SELECT NULL::BOOLEAN; $$ LANGUAGE sql IMMUTABLE;
CREATE OR REPLACE FUNCTION foo(a INT) RETURNS TEXT AS $$ DECLARE res TEXT := '';         i INT; BEGIN   i := 0;   WHILE (i < a) LOOP     res := res || chr(ascii('a') + i);     i := i + 1;   END LOOP;   RETURN res; END; $$ LANGUAGE PLPGSQL STABLE;
CREATE OR REPLACE FUNCTION func_parted_mod_b() returns trigger as $$ BEGIN    raise notice 'Trigger: Got OLD row %, but returning NULL', OLD;    return NULL; END $$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION get_from_partitioned_table(partitioned_table.a%type)RETURNS partitioned_table AS $$ DECLARE     a_val partitioned_table.a%TYPE;     result partitioned_table%ROWTYPE; BEGIN     a_val := $1;     SELECT * INTO result FROM partitioned_table WHERE a = a_val;     RETURN result; END; $$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION leakproof(anyelement) RETURNS boolean AS$$ BEGIN   RETURN true; END; $$ LANGUAGE plpgsql STRICT IMMUTABLE LEAKPROOF;
CREATE OR REPLACE FUNCTION list_partitioned_table()RETURNS SETOF partitioned_table.a%TYPE AS $$ DECLARE     row partitioned_table%ROWTYPE;     a_val partitioned_table.a%TYPE; BEGIN     FOR row IN SELECT * FROM partitioned_table ORDER BY a LOOP         a_val := row.a;         RETURN NEXT a_val;     END LOOP;     RETURN; END; $$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION multi_test_trig() RETURNS triggerLANGUAGE plpgsql AS $$ BEGIN     RAISE NOTICE 'count = %', (SELECT COUNT(*) FROM new_test);     RAISE NOTICE 'count union = %',       (SELECT COUNT(*)        FROM (SELECT * FROM new_test UNION ALL SELECT * FROM new_test) ss);     RETURN NULL; END$$;
CREATE OR REPLACE FUNCTION mytrigger() RETURNS trigger LANGUAGE plpgsql as $$ begin 	if row(old.*) is distinct from row(new.*) then 		raise notice 'row % changed', new.f1; 	else 		raise notice 'row % not changed', new.f1; 	end if; 	return new; end$$;
CREATE OR REPLACE FUNCTION rngfunc() RETURNS TABLE(a int) AS $$ SELECT a FROM generate_series(1,5) a(a) $$ LANGUAGE sql;
CREATE OR REPLACE FUNCTION rngfunc() RETURNS TABLE(a varchar(5)) AS $$ SELECT 'hello'::varchar(5) $$ LANGUAGE sql STABLE;
CREATE OR REPLACE FUNCTION rngfunc(int) RETURNS TABLE(a int, b int)AS $$ SELECT a, b          FROM generate_series(1,$1) a(a),               generate_series(1,$1) b(b) $$ LANGUAGE sql;
CREATE OR REPLACE FUNCTION rngfuncb(in f1 int, inout f2 int, out text) AS $$select $2-1, $1::text || 'z'$$ LANGUAGE sql;
CREATE OR REPLACE FUNCTION rngfuncr(in f1 int, out f2 int, out text) AS $$select $1-1, $1::text || 'z'$$ LANGUAGE sql;
CREATE OR REPLACE FUNCTION schema_two.add(int, int) RETURNS int LANGUAGE plpgsql   CALLED ON NULL INPUT   AS $$ BEGIN RETURN coalesce($1,0) + coalesce($2,0); END; $$;
CREATE OR REPLACE FUNCTION start_command()RETURNS event_trigger AS $$ BEGIN RAISE NOTICE '% - ddl_command_start', tg_tag; END; $$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION test_evtrig_dropped_objects() RETURNS event_triggerLANGUAGE plpgsql AS $$ DECLARE     obj record; BEGIN     FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()     LOOP         IF obj.object_type = 'table' THEN                 EXECUTE format('DROP TABLE IF EXISTS audit_tbls.%I', 					format('%s_%s', obj.schema_name, obj.object_name));         END IF; 	INSERT INTO dropped_objects 		(type, schema, object) VALUES 		(obj.object_type, obj.schema_name, obj.object_identity);     END LOOP; END $$;
CREATE OR REPLACE FUNCTION test_evtrig_no_rewrite() RETURNS event_triggerLANGUAGE plpgsql AS $$ BEGIN   RAISE EXCEPTION 'rewrites not allowed'; END; $$;
CREATE OR REPLACE FUNCTION test_evtrig_no_rewrite() RETURNS event_triggerLANGUAGE plpgsql AS $$ BEGIN   RAISE NOTICE 'Table ''%'' is being rewritten (reason = %)',                pg_event_trigger_table_rewrite_oid()::regclass,                pg_event_trigger_table_rewrite_reason(); END; $$;
CREATE OR REPLACE FUNCTION test_evtrig_no_rewrite() RETURNS event_triggerLANGUAGE plpgsql AS $$ BEGIN   RAISE NOTICE 'Table is being rewritten (reason = %)',                pg_event_trigger_table_rewrite_reason(); END; $$;
CREATE OR REPLACE FUNCTION tgf() RETURNS trigger LANGUAGE plpgsql   AS $$ begin raise exception 'except'; end $$;
CREATE OR REPLACE FUNCTION trigger_data()  RETURNS triggerLANGUAGE plpgsql AS $$ declare 	argstr text; 	relid text; begin 	relid := TG_relid::regclass; 	raise NOTICE 'TG_NAME: %', TG_name; 	raise NOTICE 'TG_WHEN: %', TG_when; 	raise NOTICE 'TG_LEVEL: %', TG_level; 	raise NOTICE 'TG_OP: %', TG_op; 	raise NOTICE 'TG_RELID::regclass: %', relid; 	raise NOTICE 'TG_RELNAME: %', TG_relname; 	raise NOTICE 'TG_TABLE_NAME: %', TG_table_name; 	raise NOTICE 'TG_TABLE_SCHEMA: %', TG_table_schema; 	raise NOTICE 'TG_NARGS: %', TG_nargs; 	argstr := '['; 	for i in 0 .. TG_nargs - 1 loop 		if i > 0 then 			argstr := argstr || ', '; 		end if; 		argstr := argstr || TG_argv[i]; 	end loop; 	argstr := argstr || ']'; 	raise NOTICE 'TG_ARGV: %', argstr; 	if TG_OP != 'INSERT' then 		raise NOTICE 'OLD: %', OLD; 	end if; 	if TG_OP != 'DELETE' then 		raise NOTICE 'NEW: %', NEW; 	end if; 	if TG_OP = 'DELETE' then 		return OLD; 	else 		return NEW; 	end if; end; $$;
CREATE OR REPLACE FUNCTION undroppable() RETURNS event_triggerLANGUAGE plpgsql AS $$ DECLARE 	obj record; BEGIN 	PERFORM 1 FROM pg_tables WHERE tablename = 'undroppable_objs'; 	IF NOT FOUND THEN 		RAISE NOTICE 'table undroppable_objs not found, skipping'; 		RETURN; 	END IF; 	FOR obj IN 		SELECT * FROM pg_event_trigger_dropped_objects() JOIN 			undroppable_objs USING (object_type, object_identity) 	LOOP 		RAISE EXCEPTION 'object % of type % cannot be dropped', 			obj.object_identity, obj.object_type; 	END LOOP; END; $$;
CREATE OR REPLACE FUNCTION view_trigger() RETURNS triggerLANGUAGE plpgsql AS $$ declare     argstr text := ''; begin     for i in 0 .. TG_nargs - 1 loop         if i > 0 then             argstr := argstr || ', ';         end if;         argstr := argstr || TG_argv[i];     end loop;     raise notice '% % % % (%)', TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL, argstr;     if TG_LEVEL = 'ROW' then         if TG_OP = 'INSERT' then             raise NOTICE 'NEW: %', NEW;             INSERT INTO main_table VALUES (NEW.a, NEW.b);             RETURN NEW;         end if;         if TG_OP = 'UPDATE' then             raise NOTICE 'OLD: %, NEW: %', OLD, NEW;             UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b;             if NOT FOUND then RETURN NULL; end if;             RETURN NEW;         end if;         if TG_OP = 'DELETE' then             raise NOTICE 'OLD: %', OLD;             DELETE FROM main_table WHERE a = OLD.a AND b = OLD.b;             if NOT FOUND then RETURN NULL; end if;             RETURN OLD;         end if;     end if;     RETURN NULL; end; $$;
CREATE OR REPLACE FUNCTION y_trigger() RETURNS trigger AS $$ begin   raise notice 'y_trigger';   return null; end; $$ LANGUAGE plpgsql;
CREATE OR REPLACE RULE voo_i AS ON INSERT TO voo DO INSTEAD   INSERT INTO foo VALUES(new.*, 57) RETURNING *;
CREATE OR REPLACE RULE voo_i AS ON INSERT TO voo DO INSTEAD   INSERT INTO foo VALUES(new.*, 57) RETURNING f1, f2;
CREATE POLICY P ON tbl1 TO regress_rls_eve, regress_rls_frank USING (true);
CREATE POLICY blog_1 ON blog USING (id % 2 = 0);
CREATE POLICY coll_p ON coll_t USING (c < ('foo'::text COLLATE "C"));
CREATE POLICY comment_1 ON comment USING (blog_id < 4);
CREATE POLICY d1 ON dependent FOR ALL     TO PUBLIC     USING (x = (SELECT d.x FROM dependee d WHERE d.y = y));
CREATE POLICY dep_p1 ON dep1 TO regress_rls_bob USING (c1 > (select max(dep2.c1) from dep2));
CREATE POLICY genpol ON addr_nsp.gentable;
CREATE POLICY p ON t USING (c % 2 = 1);
CREATE POLICY p ON t USING (max(c)); -- fails: aggregate functions are not allowed in policy expressions ROLLBACK;
CREATE POLICY p0 ON x1 FOR ALL USING (c = current_user);
CREATE POLICY p1 ON b1 USING (a % 2 = 0);
CREATE POLICY p1 ON copy_rel_to USING (a % 2 = 0);
CREATE POLICY p1 ON copy_t USING (a % 2 = 0);
CREATE POLICY p1 ON current_check FOR SELECT USING (currentid % 2 = 0);
CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1 USING (true);
CREATE POLICY p1 ON document AS PERMISSIVE     USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user));
CREATE POLICY p1 ON document AS UGLY     USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user));
CREATE POLICY p1 ON document FOR SELECT USING (true);
CREATE POLICY p1 ON event_trigger_test USING (FALSE);
CREATE POLICY p1 ON r1 FOR SELECT USING (a < 20);
CREATE POLICY p1 ON r1 FOR SELECT USING (false);
CREATE POLICY p1 ON r1 USING (false);
CREATE POLICY p1 ON r1 USING (false);
CREATE POLICY p1 ON r1 USING (true);
CREATE POLICY p1 ON r2 FOR SELECT USING (true);
CREATE POLICY p1 ON r2 USING (false);
CREATE POLICY p1 ON r2 USING (false);
CREATE POLICY p1 ON r2 USING (false);
CREATE POLICY p1 ON rls_tbl USING (EXISTS (SELECT 1 FROM ref_tbl));
CREATE POLICY p1 ON rls_tbl USING (c1 > 5);
CREATE POLICY p1 ON rls_tbl USING (rls_tbl >= ROW(1,1,1));
CREATE POLICY p1 ON rls_tbl_force USING (c1 = 5) WITH CHECK (c1 < 5);
CREATE POLICY p1 ON s1 USING (a in (select x from s2 where y like '%2f%'));
CREATE POLICY p1 ON t1 TO regress_rls_bob USING ((a % 2) = 0);
CREATE POLICY p1 ON t1 USING (a % 2 = 0);
CREATE POLICY p1 ON x1 FOR SELECT USING (a % 2 = 0);
CREATE POLICY p1 ON y1 FOR ALL USING (a % 2 = 0);
CREATE POLICY p1 ON y1 FOR SELECT USING (a % 2 = 1);  --fail CREATE POLICY p1 ON y2 FOR ALL USING (a % 2 = 0);  --OK ALTER TABLE y1 ENABLE ROW LEVEL SECURITY;
CREATE POLICY p1 ON z1 TO regress_rls_group1 USING (a % 2 = 0);
CREATE POLICY p1r ON document AS RESTRICTIVE TO regress_rls_dave     USING (cid <> 44);
CREATE POLICY p2 ON category     USING (CASE WHEN current_user = 'regress_rls_bob' THEN cid IN (11, 33)            WHEN current_user = 'regress_rls_carol' THEN cid IN (22, 44)            ELSE false END);
CREATE POLICY p2 ON current_check FOR DELETE USING (currentid = 4 AND rlsuser = current_user);
CREATE POLICY p2 ON document FOR INSERT WITH CHECK (dauthor = current_user);
CREATE POLICY p2 ON r1 FOR INSERT WITH CHECK (true);
CREATE POLICY p2 ON r1 FOR UPDATE USING (a < 20) WITH CHECK (true);
CREATE POLICY p2 ON r2 FOR INSERT WITH CHECK (false);
CREATE POLICY p2 ON rls_tbl FOR SELECT USING (c1 <= 3);
CREATE POLICY p2 ON rls_tbl_force FOR SELECT USING (c1 = 8);
CREATE POLICY p2 ON s2 USING (x in (select a from s1 where b like '%22%'));
CREATE POLICY p2 ON t1 TO regress_rls_carol USING ((a % 4) = 0);
CREATE POLICY p2 ON x1 FOR INSERT WITH CHECK (a % 2 = 1);
CREATE POLICY p2 ON y1 FOR SELECT USING (a > 2);
CREATE POLICY p2 ON y2 USING (a % 3 = 0);
CREATE POLICY p2 ON z1 TO regress_rls_group2 USING (a % 2 = 1);
CREATE POLICY p2r ON document AS RESTRICTIVE TO regress_rls_dave     USING (cid <> 44 AND cid < 50);
CREATE POLICY p3 ON current_check FOR UPDATE USING (currentid = 4) WITH CHECK (rlsuser = current_user);
CREATE POLICY p3 ON document FOR UPDATE   USING (cid = (SELECT cid from category WHERE cname = 'novel'))   WITH CHECK (dauthor = current_user);
CREATE POLICY p3 ON r1 FOR INSERT WITH CHECK (true);
CREATE POLICY p3 ON r2 FOR UPDATE USING (false);
CREATE POLICY p3 ON rls_tbl FOR UPDATE USING (c1 <= 3) WITH CHECK (c1 > 5);
CREATE POLICY p3 ON rls_tbl_force FOR UPDATE USING (c1 = 8) WITH CHECK (c1 >= 5);
CREATE POLICY p3 ON s1 FOR INSERT WITH CHECK (a = (SELECT a FROM s1));
CREATE POLICY p3 ON x1 FOR UPDATE USING (a % 2 = 0);
CREATE POLICY p3 ON y2 USING (a % 4 = 0);
CREATE POLICY p3_with_all ON document FOR ALL   USING (cid = (SELECT cid from category WHERE cname = 'novel'))   WITH CHECK (dauthor = current_user);
CREATE POLICY p3_with_default ON document FOR UPDATE   USING (cid = (SELECT cid from category WHERE cname = 'novel'));
CREATE POLICY p4 ON r2 FOR DELETE USING (false);
CREATE POLICY p4 ON rls_tbl FOR DELETE USING (c1 <= 3);
CREATE POLICY p4 ON rls_tbl_force FOR DELETE USING (c1 = 8);
CREATE POLICY p4 ON x1 FOR DELETE USING (a < 8);
CREATE POLICY policy_range_parted ON range_parted for UPDATE USING (true) WITH CHECK (c % 2 = 0);
CREATE POLICY policy_range_parted_subplan on range_parted     AS RESTRICTIVE for UPDATE USING (true)     WITH CHECK ((SELECT range_parted.c <= c1 FROM mintab));
CREATE POLICY policy_range_parted_wholerow on range_parted AS RESTRICTIVE for UPDATE USING (true)    WITH CHECK (range_parted = row('b', 10, 112, 1, NULL)::range_parted);
CREATE POLICY pp1 ON part_document AS PERMISSIVE     USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user));
CREATE POLICY pp1r ON part_document AS RESTRICTIVE TO regress_rls_dave     USING (cid < 55);
CREATE POLICY pp3 ON part_document AS RESTRICTIVE     USING ((SELECT dlevel <= seclv FROM uaccount WHERE pguser = current_user));
CREATE POLICY pp3 ON part_document_satire AS RESTRICTIVE     USING (cid < 55);
CREATE POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2v WHERE b = y));
CREATE POLICY r1 ON rec1 USING (x = (SELECT r.x FROM rec1 r WHERE y = r.y));
CREATE POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1 WHERE y = b));
CREATE POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1v WHERE y = b));
CREATE POLICY seeall ON range_parted AS PERMISSIVE FOR SELECT USING (true);
CREATE PROCEDURE addr_nsp.proc(int4) LANGUAGE SQL AS $$ $$;
CREATE PROCEDURE ptest10(IN a int, IN b int, IN c int) LANGUAGE SQL AS $$ SELECT a + b - c $$;
CREATE PROCEDURE ptest11(a OUT int, VARIADIC b int[]) LANGUAGE SQL   AS $$ SELECT b[1] + b[2] $$;
CREATE PROCEDURE ptest8(x text) BEGIN ATOMIC END;
CREATE PROCEDURE ptestx() LANGUAGE SQL STRICT AS $$ INSERT INTO cp_test VALUES (1, 'a') $$;
CREATE PROCEDURE ptestx(a VARIADIC int[], b OUT int) LANGUAGE SQL   AS $$ SELECT a[1] $$;
CREATE PROCEDURE ptestx(a int DEFAULT 42, b OUT int) LANGUAGE SQL   AS $$ SELECT a $$;
CREATE PROCEDURE test_ambiguous_procname(int) as $$ begin end; $$ language plpgsql;
CREATE PROCEDURE test_ambiguous_procname(text) as $$ begin end; $$ language plpgsql;
CREATE PUBLICATION addr_pub FOR TABLE addr_nsp.gentable;
CREATE PUBLICATION addr_pub_schema FOR ALL TABLES IN SCHEMA addr_nsp;
CREATE PUBLICATION pub FOR ALL TABLES IN SCHEMA sch1 WITH (PUBLISH_VIA_PARTITION_ROOT=1);
CREATE PUBLICATION pub FOR ALL TABLES IN SCHEMA sch2 WITH (PUBLISH_VIA_PARTITION_ROOT=0);
CREATE PUBLICATION pub FOR ALL TABLES IN SCHEMA sch2 WITH (PUBLISH_VIA_PARTITION_ROOT=1);
CREATE PUBLICATION pub FOR TABLE sch2.tbl1_part1 WITH (PUBLISH_VIA_PARTITION_ROOT=0);
CREATE PUBLICATION pub FOR TABLE sch2.tbl1_part1 WITH (PUBLISH_VIA_PARTITION_ROOT=1);
CREATE PUBLICATION testpib_ins_trunct WITH (publish = insert);
CREATE PUBLICATION testpub1_forschema FOR ALL TABLES IN SCHEMA pub_test1;
CREATE PUBLICATION testpub1_forschema1 FOR ALL TABLES IN SCHEMA testpub_view;
CREATE PUBLICATION testpub2;  -- fail SET ROLE regress_publication_user;
CREATE PUBLICATION testpub2;  -- ok CREATE PUBLICATION testpub3 FOR ALL TABLES IN SCHEMA pub_test;  -- fail CREATE PUBLICATION testpub3;  -- ok RESET client_min_messages;
CREATE PUBLICATION testpub2_forschema FOR ALL TABLES IN SCHEMA pub_test1, pub_test2, pub_test3;
CREATE PUBLICATION testpub3 FOR TABLE testpub_tbl3;
CREATE PUBLICATION testpub3_forschema FOR ALL TABLES IN SCHEMA CURRENT_SCHEMA;
CREATE PUBLICATION testpub3_forschema;
CREATE PUBLICATION testpub4 FOR TABLE ONLY testpub_tbl3;
CREATE PUBLICATION testpub4_forschema FOR ALL TABLES IN SCHEMA "CURRENT_SCHEMA";
CREATE PUBLICATION testpub5_forschema FOR ALL TABLES IN SCHEMA CURRENT_SCHEMA, "CURRENT_SCHEMA";
CREATE PUBLICATION testpub6_forschema FOR ALL TABLES IN SCHEMA "CURRENT_SCHEMA", CURRENT_SCHEMA;
CREATE PUBLICATION testpub_default;
CREATE PUBLICATION testpub_error FOR pub_test2.tbl1;
CREATE PUBLICATION testpub_for_tbl_schema FOR ALL TABLES IN SCHEMA pub_test, TABLE pub_test.testpub_nopk;
CREATE PUBLICATION testpub_foralltables FOR ALL TABLES WITH (publish = 'insert');
CREATE PUBLICATION testpub_foralltables FOR ALL TABLES;
CREATE PUBLICATION testpub_forparted1;
CREATE PUBLICATION testpub_forparted;
CREATE PUBLICATION testpub_forschema FOR ALL TABLES IN SCHEMA CURRENT_SCHEMA;
CREATE PUBLICATION testpub_forschema FOR ALL TABLES IN SCHEMA non_existent_schema;
CREATE PUBLICATION testpub_forschema FOR ALL TABLES IN SCHEMA pg_catalog;
CREATE PUBLICATION testpub_forschema FOR ALL TABLES IN SCHEMA pub_test;
CREATE PUBLICATION testpub_forschema1 FOR CURRENT_SCHEMA;
CREATE PUBLICATION testpub_forschema1 FOR TABLE CURRENT_SCHEMA;
CREATE PUBLICATION testpub_forschema_fortable FOR ALL TABLES IN SCHEMA pub_test1, TABLE pub_test2.tbl1;
CREATE PUBLICATION testpub_forsystemtbl FOR TABLE pg_publication;
CREATE PUBLICATION testpub_fortable FOR TABLE "CURRENT_SCHEMA"."CURRENT_SCHEMA";
CREATE PUBLICATION testpub_fortable FOR TABLE testpub_tbl1;
CREATE PUBLICATION testpub_fortable_forschema FOR TABLE pub_test2.tbl1, ALL TABLES IN SCHEMA pub_test1;
CREATE PUBLICATION testpub_fortbl FOR TABLE testpub_tbl1, pub_test.testpub_nopk;
CREATE PUBLICATION testpub_fortbl FOR TABLE testpub_tbl1;
CREATE PUBLICATION testpub_fortbl FOR TABLE testpub_view;
CREATE PUBLICATION testpub_fortemptbl FOR TABLE testpub_temptbl;
CREATE PUBLICATION testpub_forunloggedtbl FOR TABLE testpub_unloggedtbl;
CREATE PUBLICATION testpub_xxx WITH (foo);
CREATE PUBLICATION testpub_xxx WITH (publish = 'cluster, vacuum');
CREATE PUBLICATION testpub_xxx WITH (publish_via_partition_root = 'true', publish_via_partition_root = '0');
CREATE PUBLICATION testpubpart_forschema FOR ALL TABLES IN SCHEMA pub_testpart1;
CREATE PUBLICATION testpubpart_forschema FOR ALL TABLES IN SCHEMA pub_testpart2;
CREATE RULE rule1 AS ON INSERT TO ruletest1     DO INSTEAD INSERT INTO ruletest2 VALUES (NEW.*);
CREATE RULE rules_parted_table_insert AS ON INSERT to rules_parted_table     DO INSTEAD INSERT INTO rules_parted_table_1 VALUES (NEW.*);
CREATE RULE voo_i AS ON INSERT TO voo DO INSTEAD   INSERT INTO foo VALUES(new.*, 57);
CREATE SERVER "integer" FOREIGN DATA WRAPPER addr_fdw;
CREATE SERVER addr_fserv FOREIGN DATA WRAPPER addr_fdw;
CREATE SERVER alt_fserv1 FOREIGN DATA WRAPPER alt_fdw1;
CREATE SERVER alt_fserv2 FOREIGN DATA WRAPPER alt_fdw2;
CREATE SERVER extstats_dummy_srv FOREIGN DATA WRAPPER extstats_dummy_fdw;
CREATE SERVER fs_heap2 FOREIGN DATA WRAPPER fdw_heap2 ;
CREATE SERVER s0 FOREIGN DATA WRAPPER dummy;
CREATE SERVER s0 FOREIGN DATA WRAPPER dummy;
CREATE SERVER s1 FOREIGN DATA WRAPPER foo;
CREATE SERVER s1 FOREIGN DATA WRAPPER foo;
CREATE SERVER s1 FOREIGN DATA WRAPPER foo;                  -- ERROR CREATE FOREIGN DATA WRAPPER foo OPTIONS ("test wrapper" 'true');
CREATE SERVER s1 FOREIGN DATA WRAPPER foo;                  -- ERROR CREATE SERVER IF NOT EXISTS s1 FOREIGN DATA WRAPPER foo;	-- No ERROR, just NOTICE CREATE SERVER s2 FOREIGN DATA WRAPPER foo OPTIONS (host 'a', dbname 'b');
CREATE SERVER s10 FOREIGN DATA WRAPPER foo;
CREATE SERVER s3 TYPE 'oracle' FOREIGN DATA WRAPPER foo;
CREATE SERVER s5 VERSION '15.0' FOREIGN DATA WRAPPER foo;
CREATE SERVER s9 FOREIGN DATA WRAPPER foo;
CREATE SERVER s9 FOREIGN DATA WRAPPER postgresql;
CREATE SERVER t1 FOREIGN DATA WRAPPER foo;
CREATE SERVER t1 FOREIGN DATA WRAPPER foo;                 -- ERROR: no usage on FDW RESET ROLE;
CREATE SERVER t2 FOREIGN DATA WRAPPER foo;
CREATE SERVER t2 FOREIGN DATA WRAPPER foo;                 -- ERROR RESET ROLE;
CREATE STATISTICS IF NOT EXISTS ab1_a_b_stats ON a, b FROM ab1;
CREATE STATISTICS IF NOT EXISTS ab1_a_b_stats ON a, b FROM ab1;
CREATE STATISTICS ab1_a_b_c_stats ON a, b, c FROM ab1;
CREATE STATISTICS ab1_a_b_stats ON a, b FROM ab1;
CREATE STATISTICS ab1_a_b_stats ON a, b FROM ab1;
CREATE STATISTICS ab1_b_a_stats ON b, a FROM ab1;
CREATE STATISTICS ab1_b_c_stats ON b, c FROM ab1;
CREATE STATISTICS ab1_exprstat_1 ON (a+b) FROM ab1;
CREATE STATISTICS ab1_exprstat_2 ON (a+b) FROM ab1;
CREATE STATISTICS ab1_exprstat_3 ON (a+b), a FROM ab1;
CREATE STATISTICS ab1_exprstat_4 ON date_trunc('day', d) FROM ab1;
CREATE STATISTICS ab1_exprstat_5 ON date_trunc('day', c) FROM ab1;
CREATE STATISTICS addr_nsp.gentable_stat ON a, b FROM addr_nsp.gentable;
CREATE STATISTICS alt_stat1 ON a, b FROM alt_regress_1;
CREATE STATISTICS alt_stat1 ON a, b FROM alt_regress_2;
CREATE STATISTICS alt_stat2 ON a, b FROM alt_regress_1;
CREATE STATISTICS alt_stat2 ON a, b FROM alt_regress_2;
CREATE STATISTICS ctlt1_a_b_stat ON a,b FROM ctlt1;
CREATE STATISTICS ctlt1_expr_stat ON (a || b) FROM ctlt1;
CREATE STATISTICS expr_stat_comp_1 ON c0, c1 FROM expr_stats_incompatible_test;
CREATE STATISTICS expr_stats_1 (mcv) ON (a+b), (a-b), (2*a), (3*b) FROM expr_stats;
CREATE STATISTICS expr_stats_1 (mcv) ON a, b, (2*a), (3*b), (a+b), (a-b) FROM expr_stats;
CREATE STATISTICS expr_stats_1 (mcv) ON a, b, (b || c), (c || b) FROM expr_stats;
CREATE STATISTICS func_deps_stat (dependencies) ON (a * 2), upper(b), (c + 1) FROM functional_dependencies;
CREATE STATISTICS func_deps_stat (dependencies) ON (mod(a,11)), (mod(b::int, 13)), (mod(c, 7)) FROM functional_dependencies;
CREATE STATISTICS func_deps_stat (dependencies) ON a, b, c FROM functional_dependencies;
CREATE STATISTICS func_deps_stat (dependencies) ON a, b, c FROM functional_dependencies;
CREATE STATISTICS functional_dependencies_multi_1 (dependencies) ON a, b FROM functional_dependencies_multi;
CREATE STATISTICS functional_dependencies_multi_2 (dependencies) ON c, d FROM functional_dependencies_multi;
CREATE STATISTICS mcv_lists_arrays_stats (mcv) ON a, b, c   FROM mcv_lists_arrays;
CREATE STATISTICS mcv_lists_bool_stats (mcv) ON a, b, c   FROM mcv_lists_bool;
CREATE STATISTICS mcv_lists_multi_1 (mcv) ON a, b FROM mcv_lists_multi;
CREATE STATISTICS mcv_lists_multi_2 (mcv) ON c, d FROM mcv_lists_multi;
CREATE STATISTICS mcv_lists_partial_stats (mcv) ON a, b, c   FROM mcv_lists_partial;
CREATE STATISTICS mcv_lists_stats (mcv) ON (mod(a,20)), (mod(b::int,10)), (mod(c,5)) FROM mcv_lists;
CREATE STATISTICS mcv_lists_stats (mcv) ON (mod(a,7)), (mod(b::int,11)), (mod(c,13)) FROM mcv_lists;
CREATE STATISTICS mcv_lists_stats (mcv) ON a, b, c FROM mcv_lists;
CREATE STATISTICS mcv_lists_stats (mcv) ON a, b, c FROM mcv_lists;
CREATE STATISTICS mcv_lists_stats (mcv) ON a, b, c FROM mcv_lists;
CREATE STATISTICS mcv_lists_stats (mcv) ON a, b, d FROM mcv_lists;
CREATE STATISTICS mcv_lists_stats_1 ON (mod(a,20)) FROM mcv_lists;
CREATE STATISTICS mcv_lists_stats_2 ON (mod(b::int,10)) FROM mcv_lists;
CREATE STATISTICS mcv_lists_stats_3 ON (mod(c,5)) FROM mcv_lists;
CREATE STATISTICS mcv_lists_uuid_stats (mcv) ON a, b, c   FROM mcv_lists_uuid;
CREATE STATISTICS regress_schema_2.ab1_a_b_stats ON a, b FROM ab1;
CREATE STATISTICS s10 (ndistinct) ON (a+1), (b+100), (2*c) FROM ndistinct;
CREATE STATISTICS s10 (ndistinct) ON a, b, (2*c) FROM ndistinct;
CREATE STATISTICS s10 ON a, b, c FROM ndistinct;
CREATE STATISTICS s11 (ndistinct) ON a, b FROM ndistinct;
CREATE STATISTICS s11 (ndistinct) ON a, b, (a*5), (b+1) FROM ndistinct;
CREATE STATISTICS s11 (ndistinct) ON a, b, (a*5), (b+1) FROM ndistinct;
CREATE STATISTICS s12 (ndistinct) ON (c * 10), (d - 1) FROM ndistinct;
CREATE STATISTICS s12 (ndistinct) ON a, (b+1), (c * 10) FROM ndistinct;
CREATE STATISTICS s12 (ndistinct) ON c, d FROM ndistinct;
CREATE STATISTICS s12 (ndistinct) ON c, d, (c * 10), (d - 1) FROM ndistinct;
CREATE STATISTICS tst (unrecognized) ON x, y FROM ext_stats_test;
CREATE STATISTICS tst FROM sometab;
CREATE STATISTICS tst ON (x || 'x'), (x || 'x'), (y + 1), (x || 'x'), (x || 'x'), (y + 1), (x || 'x'), (x || 'x'), (y + 1) FROM ext_stats_test;
CREATE STATISTICS tst ON (x || 'x'), (x || 'x'), y FROM ext_stats_test;
CREATE STATISTICS tst ON (y) FROM ext_stats_test; -- single column reference CREATE STATISTICS tst ON y + z FROM ext_stats_test; -- missing parentheses CREATE STATISTICS tst ON (x, y) FROM ext_stats_test; -- tuple expression DROP TABLE ext_stats_test;
CREATE STATISTICS tst ON a, b FROM ext_stats_test;
CREATE STATISTICS tst ON a, b FROM nonexistent;
CREATE STATISTICS tst ON a, b;
CREATE STATISTICS tst ON x, x, y FROM ext_stats_test;
CREATE STATISTICS tst ON x, x, y, x, x, (x || 'x'), (y + 1), (x || 'x'), (x || 'x'), (y + 1) FROM ext_stats_test;
CREATE STATISTICS tst ON x, x, y, x, x, y, x, x, y FROM ext_stats_test;
CREATE STATISTICS tst;
CREATE STATISTICS tststats.priv_test_stats (mcv) ON a, b   FROM tststats.priv_test_tbl;
CREATE STATISTICS tststats.s1 ON a, b FROM tststats.t;
CREATE STATISTICS tststats.s2 ON a, b FROM tststats.ti;
CREATE STATISTICS tststats.s3 ON a, b FROM tststats.s;
CREATE STATISTICS tststats.s4 ON a, b FROM tststats.v;
CREATE STATISTICS tststats.s5 ON a, b FROM tststats.mv;
CREATE STATISTICS tststats.s6 ON a, b FROM tststats.ty;
CREATE STATISTICS tststats.s7 ON a, b FROM tststats.f;
CREATE STATISTICS tststats.s8 ON a, b FROM tststats.pt;
CREATE STATISTICS tststats.s9 ON a, b FROM tststats.pt1;
CREATE SUBSCRIPTION regress_addr_sub CONNECTION '' PUBLICATION bar WITH (connect = false, slot_name = NONE);
CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION foo, testpub, foo WITH (connect = false);
CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION mypub        WITH (connect = false, create_slot = false, copy_data = false);
CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false);
CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false);
CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, binary = true);
CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, streaming = foo);
CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, streaming = true);
CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, streaming = true, two_phase = true);
CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, two_phase = foo);
CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, two_phase = true);
CREATE SUBSCRIPTION regress_testsub CONNECTION 'foo';
CREATE SUBSCRIPTION regress_testsub CONNECTION 'testconn' PUBLICATION testpub WITH (create_slot);
CREATE SUBSCRIPTION regress_testsub CONNECTION 'testconn' PUBLICATION testpub;
CREATE SUBSCRIPTION regress_testsub PUBLICATION foo;
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION foo WITH (connect = false);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, copy_data = true);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, create_slot = true);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, enabled = true);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, create_slot = false);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, create_slot = true);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, enabled = false);
CREATE SUBSCRIPTION regress_testsub2 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, enabled = true);
CREATE SUBSCRIPTION regress_testsub3 CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (slot_name = NONE, connect = false);
CREATE TABLE ;
CREATE TABLE IF NOT EXISTS as_select1 AS EXECUTE select1;
CREATE TABLE IF NOT EXISTS as_select1 AS SELECT * FROM pg_class WHERE relkind = 'r';
CREATE TABLE RANDOM_TBL AS   SELECT count(*) AS random   FROM onek WHERE random() < 1.0/10;
CREATE TABLE \g INSERT INTO foo VALUES(123) foo;
CREATE TABLE as_select1 AS EXECUTE select1;
CREATE TABLE as_select1 AS EXECUTE select1;
CREATE TABLE as_select1 AS SELECT * FROM pg_class WHERE relkind = 'r';
CREATE TABLE as_select1 AS SELECT * FROM pg_class WHERE relkind = 'r';
CREATE TABLE atest12 as   SELECT x AS a, 10001 - x AS b FROM generate_series(1,10000) x;
CREATE TABLE badcompresstbl (a text COMPRESSION I_Do_Not_Exist_Compression); -- fails CREATE TABLE badcompresstbl (a text);
CREATE TABLE bit_defaults(   b1 bit(4) DEFAULT '1001',   b2 bit(4) DEFAULT B'0101',   b3 bit varying(5) DEFAULT '1001',   b4 bit varying(5) DEFAULT B'0101' );
CREATE TABLE cmdata(f1 text COMPRESSION pglz);
CREATE TABLE cmdata1(f1 TEXT COMPRESSION lz4);
CREATE TABLE cmdata2 (LIKE cmdata1 INCLUDING COMPRESSION);
CREATE TABLE cmdata2 (f1 TEXT COMPRESSION pglz, f2 TEXT COMPRESSION lz4);
CREATE TABLE cmdata2 (f1 int COMPRESSION pglz);
CREATE TABLE cmdata2 (f1 text COMPRESSION pglz);
CREATE TABLE cminh(f1 TEXT COMPRESSION lz4) INHERITS(cmdata);
CREATE TABLE cmmove2(f1 text COMPRESSION pglz);
CREATE TABLE cmmove3(f1 text COMPRESSION pglz);
CREATE TABLE cmpart(f1 text COMPRESSION lz4) PARTITION BY HASH(f1);
CREATE TABLE cmpart2(f1 text COMPRESSION pglz);
CREATE TABLE coll_t (c) AS VALUES ('bar'::text);
CREATE TABLE credit_usage (        cid      int references customer(cid),        ymd      date,        usage    int );
CREATE TABLE ctas_ine_tbl AS SELECT 1 / 0; -- error CREATE TABLE IF NOT EXISTS ctas_ine_tbl AS SELECT 1 / 0; -- ok CREATE TABLE ctas_ine_tbl AS SELECT 1 / 0 WITH NO DATA; -- error CREATE TABLE IF NOT EXISTS ctas_ine_tbl AS SELECT 1 / 0 WITH NO DATA; -- ok EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE TABLE ctas_ine_tbl AS SELECT 1 / 0; -- error EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE TABLE IF NOT EXISTS ctas_ine_tbl AS SELECT 1 / 0; -- ok EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE TABLE ctas_ine_tbl AS SELECT 1 / 0 WITH NO DATA; -- error EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE TABLE IF NOT EXISTS ctas_ine_tbl AS SELECT 1 / 0 WITH NO DATA; -- ok PREPARE ctas_ine_query AS SELECT 1 / 0;
CREATE TABLE ctas_ine_tbl AS SELECT 1;
CREATE TABLE ctas_nodata (ii, jj, kk) AS SELECT i, j FROM ctas_base; -- Error CREATE TABLE ctas_nodata (ii, jj, kk) AS SELECT i, j FROM ctas_base WITH NO DATA; -- Error CREATE TABLE ctas_nodata (ii, jj) AS SELECT i, j FROM ctas_base; -- OK CREATE TABLE ctas_nodata_2 (ii, jj) AS SELECT i, j FROM ctas_base WITH NO DATA; -- OK CREATE TABLE ctas_nodata_3 (ii) AS SELECT i, j FROM ctas_base; -- OK CREATE TABLE ctas_nodata_4 (ii) AS SELECT i, j FROM ctas_base WITH NO DATA; -- OK SELECT * FROM ctas_nodata;
CREATE TABLE ctv_data (v, h, c, i, d) AS VALUES    ('v1','h2','foo', 3, '2015-04-01'::date),    ('v2','h1','bar', 3, '2015-01-02'),    ('v1','h0','baz', NULL, '2015-07-12'),    ('v0','h4','qux', 4, '2015-07-15'),    ('v0','h4','dbl', -3, '2014-12-15'),    ('v0',NULL,'qux', 5, '2014-07-15'),    ('v1','h2','quux',7, '2015-04-04');
CREATE TABLE distinct_group_1 AS SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
CREATE TABLE distinct_group_2 AS SELECT DISTINCT (g%1000)::text FROM generate_series(0,9999) g;
CREATE TABLE distinct_hash_1 AS SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
CREATE TABLE distinct_hash_2 AS SELECT DISTINCT (g%1000)::text FROM generate_series(0,9999) g;
CREATE TABLE dupindexcols AS   SELECT unique1 as id, stringu2::text as f1 FROM tenk1;
CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES IN ();
CREATE TABLE fewmore AS SELECT generate_series(1,3) AS data;
CREATE TABLE foo   (id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, 	id3 INTEGER NOT NUL,    id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL);
CREATE TABLE foo( id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL, id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY);
CREATE TABLE foo(id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL);
CREATE TABLE foo(id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL);
CREATE TABLE gtest28b (LIKE gtest28a INCLUDING GENERATED);
CREATE TABLE gtest_err_8 (a int PRIMARY KEY, b int GENERATED BY DEFAULT AS (a * 2) STORED);
CREATE TABLE has_volatile AS SELECT * FROM generate_series(1,10) id;
CREATE TABLE hat_data ( 	hat_name    char(10), 	hat_color   char(10)      -- hat color );
CREATE TABLE hats ( 	hat_name    char(10) primary key, 	hat_color   char(10)      -- hat color );
CREATE TABLE heaptable USING heap AS   SELECT a, repeat(a::text, 100) FROM generate_series(1,9) AS a;
CREATE TABLE i_am_a_failure() USING "";
CREATE TABLE kd_point_tbl AS SELECT * FROM quad_point_tbl;
CREATE TABLE mvtest_foo(a, b) AS VALUES(1, 10);
CREATE TABLE mvtest_foo(a, b, c) AS VALUES(1, 2, 3);
CREATE TABLE mvtest_foo_data AS SELECT i,   i+1 AS tid,   md5(random()::text) AS mv,   md5(random()::text) AS newdata,   md5(random()::text) AS newdata2,   md5(random()::text) AS diff   FROM generate_series(1, 10) i;
CREATE TABLE mvtest_v AS SELECT generate_series(1,10) AS a;
CREATE TABLE onek2 AS SELECT * FROM onek;
CREATE TABLE onek_with_null AS SELECT unique1, unique2 FROM onek;
CREATE TABLE part_7_a_null ( 	c int, 	d int, 	e int, 	LIKE list_parted2,  -- 'a' will have attnum = 4 	CONSTRAINT check_b CHECK (b IS NULL OR b = 'a'), 	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 7) );
CREATE TABLE persons2 OF person_type (     id WITH OPTIONS PRIMARY KEY,     UNIQUE (name) );
CREATE TABLE persons4 OF person_type (     name WITH OPTIONS NOT NULL,     name WITH OPTIONS DEFAULT ''  -- error, specified more than once );
CREATE TABLE prevstats AS SELECT t.seq_scan, t.seq_tup_read, t.idx_scan, t.idx_tup_fetch,        (b.heap_blks_read + b.heap_blks_hit) AS heap_blks,        (b.idx_blks_read + b.idx_blks_hit) AS idx_blks,        pg_stat_get_snapshot_timestamp() as snap_ts   FROM pg_catalog.pg_stat_user_tables AS t,        pg_catalog.pg_statio_user_tables AS b  WHERE t.relname='tenk2' AND b.relname='tenk2';
CREATE TABLE quad_box_tbl_ord_seq1 AS SELECT rank() OVER (ORDER BY b <-> point '123,456') n, b <-> point '123,456' dist, id FROM quad_box_tbl;
CREATE TABLE quad_box_tbl_ord_seq2 AS SELECT rank() OVER (ORDER BY b <-> point '123,456') n, b <-> point '123,456' dist, id FROM quad_box_tbl WHERE b <@ box '((200,300),(500,600))';
CREATE TABLE quad_point_tbl AS     SELECT point(unique1,unique2) AS p FROM tenk1;
CREATE TABLE radix_text_tbl AS     SELECT name AS t FROM road WHERE name !~ '^[0-9]';
CREATE TABLE reindex_after AS SELECT oid, relname, relfilenode, relkind 	FROM pg_class 	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
CREATE TABLE reindex_before AS SELECT oid, relname, relfilenode, relkind, reltoastrelid 	FROM pg_class 	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
CREATE TABLE reindex_temp_before AS SELECT oid, relname, relfilenode, relkind, reltoastrelid   FROM pg_class   WHERE relname IN ('concur_temp_ind_1', 'concur_temp_ind_2');
CREATE TABLE reloptions_test2(i INT) WITH (autovacuum_analyze_scale_factor = -10.0);
CREATE TABLE reloptions_test2(i INT) WITH (fillfactor=-30.1);
CREATE TABLE selinto_schema.tbl_nodata1 (a) AS   SELECT generate_series(1,3) WITH NO DATA;
CREATE TABLE selinto_schema.tbl_nodata3 (a) AS   EXECUTE data_sel WITH NO DATA;
CREATE TABLE selinto_schema.tbl_withdata1 (a)   AS SELECT generate_series(1,3) WITH DATA;
CREATE TABLE selinto_schema.tbl_withdata3 (a) AS   EXECUTE data_sel WITH DATA;
CREATE TABLE shoe_data ( 	shoename   char(10),      -- primary key 	sh_avail   integer,       -- available # of pairs 	slcolor    char(10),      -- preferred shoelace color 	slminlen   float,         -- minimum shoelace length 	slmaxlen   float,         -- maximum shoelace length 	slunit     char(8)        -- length unit );
CREATE TABLE shoelace_data ( 	sl_name    char(10),      -- primary key 	sl_avail   integer,       -- available # of pairs 	sl_color   char(10),      -- shoelace color 	sl_len     float,         -- shoelace length 	sl_unit    char(8)        -- length unit );
CREATE TABLE shoelace_log (         sl_name    char(10),      -- shoelace changed         sl_avail   integer,       -- new available value         log_who    name,          -- who did it         log_when   timestamp      -- when     );
CREATE TABLE t (c) AS VALUES ('bar'::text);
CREATE TABLE t1 AS SELECT 1::int AS a , 2::int AS b FROM generate_series(1,20) q;
CREATE TABLE t3 AS SELECT * FROM t1;
CREATE TABLE tab_core_types AS SELECT   '(11,12)'::point,   '(1,1),(2,2)'::line,   '((11,11),(12,12))'::lseg,   '((11,11),(13,13))'::box,   '((11,12),(13,13),(14,14))'::path AS openedpath,   '[(11,12),(13,13),(14,14)]'::path AS closedpath,   '((11,12),(13,13),(14,14))'::polygon,   '1,1,1'::circle,   'today'::date,   'now'::time,   'now'::timestamp,   'now'::timetz,   'now'::timestamptz,   '12 seconds'::interval,   '{"reason":"because"}'::json,   '{"when":"now"}'::jsonb,   '$.a[*] ? (@ > 2)'::jsonpath,   '127.0.0.1'::inet,   '127.0.0.0/8'::cidr,   '00:01:03:86:1c:ba'::macaddr8,   '00:01:03:86:1c:ba'::macaddr,   2::int2, 4::int4, 8::int8,   4::float4, '8'::float8, pi()::numeric,   'foo'::"char",   'c'::bpchar,   'abc'::varchar,   'name'::name,   'txt'::text,   true::bool,   E'\\xDEADBEEF'::bytea,   B'10001'::bit,   B'10001'::varbit AS varbit,   '12.34'::money,   'abc'::refcursor,   '1 2'::int2vector,   '1 2'::oidvector,   format('%I=UC/%I', USER, USER)::aclitem AS aclitem,   'a fat cat sat on a mat and ate a fat rat'::tsvector,   'fat & rat'::tsquery,   'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'::uuid,   '11'::xid8,   'pg_class'::regclass,   'regtype'::regtype type,   'pg_monitor'::regrole,   'pg_class'::regclass::oid,   '(1,1)'::tid, '2'::xid, '3'::cid,   '10:20:10,14,15'::txid_snapshot,   '10:20:10,14,15'::pg_snapshot,   '16/B374D848'::pg_lsn,   1::information_schema.cardinal_number,   'l'::information_schema.character_data,   'n'::information_schema.sql_identifier,   'now'::information_schema.time_stamp,   'YES'::information_schema.yes_or_no,   'venus'::planets,   'i16'::insenum,   '(1,2)'::int4range, '{(1,2)}'::int4multirange,   '(3,4)'::int8range, '{(3,4)}'::int8multirange,   '(1,2)'::float8range, '{(1,2)}'::float8multirange,   '(3,4)'::numrange, '{(3,4)}'::nummultirange,   '(a,b)'::textrange, '{(a,b)}'::textmultirange,   '(12.34, 56.78)'::cashrange, '{(12.34, 56.78)}'::cashmultirange,   '(2020-01-02, 2021-02-03)'::daterange,   '{(2020-01-02, 2021-02-03)}'::datemultirange,   '(2020-01-02 03:04:05, 2021-02-03 06:07:08)'::tsrange,   '{(2020-01-02 03:04:05, 2021-02-03 06:07:08)}'::tsmultirange,   '(2020-01-02 03:04:05, 2021-02-03 06:07:08)'::tstzrange,   '{(2020-01-02 03:04:05, 2021-02-03 06:07:08)}'::tstzmultirange,   arrayrange(ARRAY[1,2], ARRAY[2,1]),   arraymultirange(arrayrange(ARRAY[1,2], ARRAY[2,1]));
CREATE TABLE tableam_tblas_heap2 USING heap2 AS SELECT * FROM tableam_tbl_heap2;
CREATE TABLE tableam_tblas_heapx AS SELECT * FROM tableam_tbl_heapx;
CREATE TABLE tas_case WITH ("Fillfactor" = 10) AS SELECT 1 a;
CREATE TABLE tbl1 (c) AS VALUES ('bar'::text);
CREATE TABLE temptest(col) ON COMMIT DELETE ROWS AS SELECT 1;
CREATE TABLE test11a AS (SELECT 1::priv_testdomain1 AS a);
CREATE TABLE test11b AS (SELECT 1::priv_testdomain1 AS a);
CREATE TABLE test_like_4c (LIKE test_like_4 INCLUDING GENERATED);
CREATE TABLE test_like_4d (LIKE test_like_4 INCLUDING DEFAULTS INCLUDING GENERATED);
CREATE TABLE test_like_gen_3 (LIKE test_like_gen_1 INCLUDING GENERATED);
CREATE TABLE test_missing_target2 AS SELECT count(*) FROM test_missing_target x, test_missing_target y 	WHERE x.a = y.a 	GROUP BY x.b ORDER BY x.b;
CREATE TABLE test_missing_target3 AS SELECT count(x.b) FROM test_missing_target x, test_missing_target y 	WHERE x.a = y.a 	GROUP BY x.b/2 ORDER BY x.b/2;
CREATE TABLE test_tbl3 (c) AS SELECT '(1)'::test_type3;
CREATE TABLE testxmlschema.test3     AS SELECT true c1,               true::testboolxmldomain c2,               '2013-02-21'::date c3,               '2013-02-21'::testdatexmldomain c4;
CREATE TABLE unit ( 	un_name    char(8),       -- the primary key 	un_fact    float          -- factor to transform to cm );
CREATE TABLE unknowntab ( 	u unknown    -- fail );
CREATE TABLE withoid() WITH OIDS;
CREATE TABLE withz AS SELECT i AS k, (i || ' v')::text v FROM generate_series(1, 16, 3) i;
CREATE TEMP TABLE bug6051 AS   select i from generate_series(1,3) as t(i);
CREATE TEMP TABLE bug6051_3 AS   SELECT a FROM generate_series(11,13) AS a;
CREATE TEMP TABLE department ( 	id INTEGER PRIMARY KEY,  -- department ID 	parent_department INTEGER REFERENCES department, -- upper department ID 	name TEXT -- department name );
CREATE TEMP TABLE filenode_mapping AS SELECT     oid, mapped_oid, reltablespace, relfilenode, relname FROM pg_class,     pg_filenode_relation(reltablespace, pg_relation_filenode(oid)) AS mapped_oid WHERE relkind IN ('r', 'i', 'S', 't', 'm') AND mapped_oid IS DISTINCT FROM oid;
CREATE TEMP TABLE gcircle_tbl AS     SELECT circle(home_base) AS f1 FROM slow_emp4000;
CREATE TEMP TABLE gpolygon_tbl AS     SELECT polygon(home_base) AS f1 FROM slow_emp4000;
CREATE TEMP TABLE kd_point_tbl_ord_idx1 AS SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p FROM kd_point_tbl;
CREATE TEMP TABLE kd_point_tbl_ord_idx2 AS SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
CREATE TEMP TABLE kd_point_tbl_ord_idx3 AS SELECT row_number() OVER (ORDER BY p <-> '333,400') n, p <-> '333,400' dist, p FROM kd_point_tbl WHERE p IS NOT NULL;
CREATE TEMP TABLE pcachetest AS SELECT * FROM int8_tbl ORDER BY 2;
CREATE TEMP TABLE pcachetest AS SELECT * FROM int8_tbl;
CREATE TEMP TABLE quad_box_tbl_ord_idx1 AS SELECT rank() OVER (ORDER BY b <-> point '123,456') n, b <-> point '123,456' dist, id FROM quad_box_tbl;
CREATE TEMP TABLE quad_box_tbl_ord_idx2 AS SELECT rank() OVER (ORDER BY b <-> point '123,456') n, b <-> point '123,456' dist, id FROM quad_box_tbl WHERE b <@ box '((200,300),(500,600))';
CREATE TEMP TABLE quad_point_tbl_ord_idx1 AS SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p FROM quad_point_tbl;
CREATE TEMP TABLE quad_point_tbl_ord_idx2 AS SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
CREATE TEMP TABLE quad_point_tbl_ord_idx3 AS SELECT row_number() OVER (ORDER BY p <-> '333,400') n, p <-> '333,400' dist, p FROM quad_point_tbl WHERE p IS NOT NULL;
CREATE TEMP TABLE quad_point_tbl_ord_seq1 AS SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p FROM quad_point_tbl;
CREATE TEMP TABLE quad_point_tbl_ord_seq2 AS SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
CREATE TEMP TABLE quad_point_tbl_ord_seq3 AS SELECT row_number() OVER (ORDER BY p <-> '333,400') n, p <-> '333,400' dist, p FROM quad_point_tbl WHERE p IS NOT NULL;
CREATE TEMP TABLE quad_poly_tbl_ord_idx2 AS SELECT rank() OVER (ORDER BY p <-> point '123,456') n, p <-> point '123,456' dist, id FROM quad_poly_tbl WHERE p <@ polygon '((300,300),(400,600),(600,500),(700,200))';
CREATE TEMP TABLE quad_poly_tbl_ord_seq2 AS SELECT rank() OVER (ORDER BY p <-> point '123,456') n, p <-> point '123,456' dist, id FROM quad_poly_tbl WHERE p <@ polygon '((300,300),(400,600),(600,500),(700,200))';
CREATE TEMP TABLE rows AS SELECT x, 'txt' || x as y FROM generate_series(1,3) AS x;
CREATE TEMP TABLE rows AS SELECT x, 'txt' || x as y FROM generate_series(1,3) AS x;
CREATE TEMP TABLE temptest(col) ON COMMIT DELETE ROWS AS SELECT 1;
CREATE TEMP TABLE temptest(col) ON COMMIT DROP AS SELECT 1;
CREATE TEMPORARY TABLE foo (id INT4 UNIQUE NOT NULL , idm INT4 UNIQUE NOT NULL, idx INT4 UNIQUE NOT NULL, idy INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL, idz INT4 UNIQUE NOT NULL, idv INT4 UNIQUE NOT NULL);
CREATE TEMPORARY TABLE foo (id INT4 UNIQUE NOT NULL, idx INT4 UNIQUE NOT NULL, idy INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL, idz INT4 UNIQUE NOT NULL, idv INT4 UNIQUE NOT NULL);
CREATE TEMPORARY TABLE foo( id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL, id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY) ;
CREATE TEMPORARY TABLE foo(id INT4 UNIQUE NOT NULL, id2 TEXT NOT NULL PRIMARY KEY, id3 INTEGER NOT NUL, id4 INT4 UNIQUE NOT NULL, id5 TEXT UNIQUE NOT NULL) ;
CREATE TEMPORARY TABLE q5_prep_nodata AS EXECUTE q5(200, 'DTAAAA')     WITH NO DATA;
CREATE TEMPORARY TABLE q5_prep_results AS EXECUTE q5(200, 'DTAAAA');
CREATE TRANSFORM FOR int LANGUAGE SQL ( 	FROM SQL WITH FUNCTION prsd_lextype(internal), 	TO SQL WITH FUNCTION int4recv(internal));
CREATE TRIGGER error_ins_a BEFORE INSERT OF a ON main_table FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_ins_a');
CREATE TRIGGER error_stmt_when BEFORE UPDATE OF a ON main_table FOR EACH STATEMENT WHEN (OLD.* IS DISTINCT FROM NEW.*) EXECUTE PROCEDURE trigger_func('error_stmt_when');
CREATE TRIGGER gtest1 BEFORE DELETE OR UPDATE ON gtest26   FOR EACH ROW   WHEN (OLD.b < 0)  -- ok   EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest2a BEFORE INSERT OR UPDATE ON gtest26   FOR EACH ROW   WHEN (NEW.b < 0)  -- error   EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest2b BEFORE INSERT OR UPDATE ON gtest26   FOR EACH ROW   WHEN (NEW.* IS NOT NULL)  -- error   EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest3 AFTER DELETE OR UPDATE ON gtest26   FOR EACH ROW   WHEN (OLD.b < 0)  -- ok   EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER gtest4 AFTER INSERT OR UPDATE ON gtest26   FOR EACH ROW   WHEN (NEW.b < 0)  -- ok   EXECUTE PROCEDURE gtest_trigger_func();
CREATE TRIGGER modified_any BEFORE UPDATE OF a ON main_table FOR EACH ROW WHEN (OLD.* IS DISTINCT FROM NEW.*) EXECUTE PROCEDURE trigger_func('modified_any');
CREATE TRIGGER trigtest_after_stmt_tt AFTER INSERT OR UPDATE OR DELETE -- ERROR ON foreign_schema.foreign_table_1 REFERENCING NEW TABLE AS new_table FOR EACH STATEMENT EXECUTE PROCEDURE dummy_trigger();
CREATE TYPE city_budget (    internallength = 16,    input = int44in,    output = int44out,    element = int4,    category = 'x',   -- just to verify the system will take it    preferred = true  -- ditto );
CREATE TYPE hash_test_t2 AS (a money, b text);
CREATE TYPE myvarchar (     input = myvarcharin,     output = myvarcharout,     alignment = integer,     storage = main );
CREATE TYPE tt_t0 AS (z inet, x int, y numeric(8,2));
CREATE TYPE unknown_comptype AS ( 	u unknown    -- fail );
CREATE VIEW atest12sbv WITH (security_barrier=true) AS   SELECT * FROM atest12 WHERE b <<< 5;
CREATE VIEW atest12v AS   SELECT * FROM atest12 WHERE b <<< 5;
CREATE VIEW iexit AS    SELECT ih.name, ih.thepath, 	interpt_pp(ih.thepath, r.thepath) AS exit    FROM ihighway ih, ramp r    WHERE ih.thepath ## r.thepath;
CREATE VIEW mysecview5 WITH (security_barrier=100)	-- Error        AS SELECT * FROM tbl1 WHERE a > 100;
CREATE VIEW mysecview6 WITH (invalid_option)		-- Error        AS SELECT * FROM tbl1 WHERE a < 100;
CREATE VIEW street AS    SELECT r.name, r.thepath, c.cname AS cname    FROM ONLY road r, real_city c    WHERE c.outline ## r.thepath;
CREATE VIEW tableam_view_heap2 USING heap2 AS SELECT * FROM tableam_tbl_heap2;
CREATE VIEW xmltableview2 AS SELECT * FROM XMLTABLE(XMLNAMESPACES('http://x.y' AS zz),                       '/zz:rows/zz:row'                       PASSING '<rows xmlns="http://x.y"><row><a>10</a></row></rows>'                       COLUMNS a int PATH 'zz:a');
CREATE foo;
DDD	42 \. drop trigger child1_insert_trig on child1;
DECLARE bc BINARY CURSOR FOR SELECT * FROM tenk1;
DECLARE c CURSOR FOR SELECT * FROM tenk1 JOIN tenk2 USING (unique1);
DECLARE c CURSOR FOR SELECT * FROM tenk2 FOR SHARE;
DECLARE c CURSOR FOR SELECT * FROM tenk2;
DECLARE c CURSOR FOR SELECT * from hash_split_heap WHERE keycol = 1;
DECLARE c CURSOR FOR SELECT ctid, * FROM tidscan WHERE ctid = ANY(ARRAY['(0,1)', '(0,2)']::tid[]);
DECLARE c CURSOR FOR SELECT ctid, * FROM tidscan;
DECLARE c CURSOR FOR SELECT ctid,cmin,* FROM combocidtest;
DECLARE c CURSOR FOR SELECT f1,count(*) FROM uctest GROUP BY f1;
DECLARE c CURSOR FOR SELECT unique2 FROM tenk1 ORDER BY unique2;
DECLARE c CURSOR FOR SELECT unique2/0 FROM tenk1 ORDER BY unique2;
DECLARE c SCROLL CURSOR FOR SELECT ctid FROM tidrangescan WHERE ctid < '(1,0)';
DECLARE c SCROLL CURSOR FOR SELECT noabort_decreasing FROM abbrev_abort_uuids ORDER BY noabort_decreasing;
DECLARE c SCROLL CURSOR FOR SELECT noabort_decreasing FROM abbrev_abort_uuids ORDER BY noabort_decreasing;
DECLARE c1 CURSOR FOR SELECT * FROM uctest FOR UPDATE;
DECLARE c1 CURSOR FOR SELECT * FROM uctest FOR UPDATE;
DECLARE c1 CURSOR FOR SELECT * FROM uctest FOR UPDATE;
DECLARE c1 CURSOR FOR SELECT * FROM uctest a, uctest b WHERE a.f1 = b.f1 + 5 FOR SHARE OF a;
DECLARE c1 CURSOR FOR SELECT * FROM uctest a, uctest b WHERE a.f1 = b.f1 + 5 FOR UPDATE;
DECLARE c1 CURSOR FOR SELECT * FROM uctest a, uctest b WHERE a.f1 = b.f1 + 5;
DECLARE c1 CURSOR FOR SELECT * FROM uctest;
DECLARE c1 CURSOR FOR SELECT * FROM uctest;
DECLARE c1 CURSOR FOR SELECT * FROM uctest;
DECLARE c1 CURSOR FOR SELECT * FROM ucview;
DECLARE c1 CURSOR FOR SELECT MIN(f1) FROM uctest FOR UPDATE;
DECLARE c1 CURSOR FOR SELECT stringu1 FROM onek WHERE stringu1 = 'DZAAAA';
DECLARE c1 INSENSITIVE CURSOR FOR SELECT * FROM uctest;
DECLARE c1 NO SCROLL CURSOR FOR SELECT * FROM cursor FOR UPDATE;
DECLARE c1 SCROLL CURSOR FOR SELECT * FROM current_check;
DECLARE ctt CURSOR FOR SELECT create_temp_tab();
DECLARE current_check_cursor SCROLL CURSOR FOR SELECT * FROM current_check;
DECLARE foo CURSOR FOR SELECT * FROM pxtest4;
DECLARE foo CURSOR FOR SELECT 1 INTO b;
DECLARE foo CURSOR WITH HOLD FOR SELECT 1;
DECLARE foo1 CURSOR WITH HOLD FOR SELECT 1;
DECLARE foo1 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo10 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo11 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo12 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo13 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 50;
DECLARE foo13 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo14 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 51;
DECLARE foo14 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo15 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 52;
DECLARE foo15 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo16 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 53;
DECLARE foo16 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo17 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 54;
DECLARE foo17 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo18 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 55;
DECLARE foo18 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo19 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 56;
DECLARE foo19 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo2 CURSOR WITHOUT HOLD FOR SELECT 1;
DECLARE foo2 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo20 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 57;
DECLARE foo20 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo21 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 58;
DECLARE foo21 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo22 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 59;
DECLARE foo22 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo23 CURSOR FOR    SELECT * FROM onek WHERE unique1 = 60;
DECLARE foo23 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo24 CURSOR FOR    SELECT * FROM onek2 WHERE unique1 = 50;
DECLARE foo24 NO SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo24 NO SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo25 CURSOR FOR    SELECT * FROM onek2 WHERE unique1 = 60;
DECLARE foo25 SCROLL CURSOR WITH HOLD FOR SELECT * FROM tenk2;
DECLARE foo25ns NO SCROLL CURSOR WITH HOLD FOR SELECT * FROM tenk2;
DECLARE foo26 CURSOR WITH HOLD FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo3 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo4 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo5 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo6 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo7 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE foo8 SCROLL CURSOR FOR SELECT * FROM tenk2;
DECLARE foo9 SCROLL CURSOR FOR SELECT * FROM tenk1 ORDER BY unique2;
DECLARE hsc CURSOR FOR select * from hs3;
DECLARE ok CURSOR FOR SELECT * FROM int8_tbl;
DECLARE tablesample_cur SCROLL CURSOR FOR   SELECT id FROM test_tablesample TABLESAMPLE SYSTEM (50) REPEATABLE (0);
DECLARE xc CURSOR WITH HOLD FOR SELECT * FROM testxmlschema.test1 ORDER BY 1, 2;
DELETE FROM arrtest WHERE a[2] IS NULL AND b IS NULL;
DELETE FROM current_check WHERE CURRENT OF c1 RETURNING *;
DELETE FROM current_check WHERE CURRENT OF c1 RETURNING *;
DELETE FROM current_check WHERE CURRENT OF current_check_cursor RETURNING *;
DELETE FROM current_check WHERE CURRENT OF current_check_cursor RETURNING *;
DELETE FROM onek WHERE CURRENT OF c1;
DELETE FROM tenk1 WHERE CURRENT OF c;  -- fail, cursor is on a join ROLLBACK;
DELETE FROM uctest WHERE CURRENT OF c1;
DELETE FROM uctest WHERE CURRENT OF c1;
DELETE FROM uctest WHERE CURRENT OF c1;
DELETE FROM uctest WHERE CURRENT OF c1;  -- fail, no such cursor DECLARE cx CURSOR WITH HOLD FOR SELECT * FROM uctest;
DELETE FROM uctest WHERE CURRENT OF c1; -- fail, no current row ROLLBACK;
DELETE FROM uctest WHERE CURRENT OF c1; -- no-op SELECT * FROM uctest;
DELETE FROM uctest WHERE CURRENT OF c1; -- no-op SELECT * FROM uctest;
DELETE FROM uctest WHERE CURRENT OF c;  -- fail, cursor is on aggregation ROLLBACK;
DELETE FROM uctest WHERE CURRENT OF c;  -- fail, cursor on wrong table ROLLBACK;
DELETE FROM uctest WHERE CURRENT OF c;  -- fail, cursor on wrong table ROLLBACK;
DELETE FROM uctest WHERE CURRENT OF cx;  -- fail, can't use held cursor BEGIN;
DELETE FROM ucview WHERE CURRENT OF c1; -- fail, views not supported ROLLBACK;
DISCARD ALL;
DISCARD SEQUENCES;
DISCARD SEQUENCES;
DISCARD TEMP;
DO $$ -- use DO to protect -- from psql   declare r boolean;   begin     execute $e$ select 2 !=-- comment       1 $e$ into r;     raise info 'r = %', r;   end; $$;
DO $$ BEGIN 	EXECUTE 'EXPLAIN ANALYZE SELECT * INTO TABLE easi FROM int8_tbl'; 	EXECUTE 'EXPLAIN ANALYZE CREATE TABLE easi2 AS SELECT * FROM int8_tbl WITH NO DATA'; END$$;
DO $$ BEGIN     FOR r IN 1..1350 LOOP         DELETE FROM dedup_unique_test_table;         INSERT INTO dedup_unique_test_table SELECT 1;     END LOOP; END$$;
DO $$ BEGIN  SET effective_io_concurrency = 50; EXCEPTION WHEN invalid_parameter_value THEN END $$;
DO $$ DECLARE 	objtype text; 	names	text[]; 	args	text[]; BEGIN 	FOR objtype IN VALUES 		('table'), ('index'), ('sequence'), ('view'), 		('materialized view'), ('foreign table'), 		('table column'), ('foreign table column'), 		('aggregate'), ('function'), ('procedure'), ('type'), ('cast'), 		('table constraint'), ('domain constraint'), ('conversion'), ('default value'), 		('operator'), ('operator class'), ('operator family'), ('rule'), ('trigger'), 		('text search parser'), ('text search dictionary'), 		('text search template'), ('text search configuration'), 		('policy'), ('user mapping'), ('default acl'), ('transform'), 		('operator of access method'), ('function of access method'), 		('publication relation') 	LOOP 		FOR names IN VALUES ('{eins}'), ('{addr_nsp, zwei}'), ('{eins, zwei, drei}') 		LOOP 			FOR args IN VALUES ('{}'), ('{integer}') 			LOOP 				BEGIN 					PERFORM pg_get_object_address(objtype, names, args); 				EXCEPTION WHEN OTHERS THEN 						RAISE WARNING 'error for %,%,%: %', objtype, names, args, sqlerrm; 				END; 			END LOOP; 		END LOOP; 	END LOOP; END; $$;
DO $$ DECLARE 	objtype text; BEGIN 	FOR objtype IN VALUES ('toast table'), ('index column'), ('sequence column'), 		('toast table column'), ('view column'), ('materialized view column') 	LOOP 		BEGIN 			PERFORM pg_get_object_address(objtype, '{one}', '{}'); 		EXCEPTION WHEN invalid_parameter_value THEN 			RAISE WARNING 'error for %: %', objtype, sqlerrm; 		END; 	END LOOP; END; $$;
DO $$ DECLARE 	relname text := reltoastrelid::regclass FROM pg_class WHERE oid = 'tststats.t'::regclass; BEGIN 	EXECUTE 'CREATE STATISTICS tststats.s10 ON a, b FROM ' || relname; EXCEPTION WHEN wrong_object_type THEN 	RAISE NOTICE 'stats on toast table not created'; END; $$;
DO $$ DECLARE   o int;   a int[] := ARRAY[1,2,3,2,3,1,2]; BEGIN   o := array_position(a, 2);   WHILE o IS NOT NULL   LOOP     RAISE NOTICE '%', o;     o := array_position(a, 2, o + 1);   END LOOP; END $$ LANGUAGE plpgsql;
DO $$ DECLARE   xml_declaration text := '<?xml version="1.0" encoding="ISO-8859-1"?>';   degree_symbol text;   res xml[]; BEGIN   IF current_setting('server_encoding') <> 'UTF8' THEN     RAISE LOG 'skip: encoding % unsupported for xpath',       current_setting('server_encoding');     RETURN;   END IF;   degree_symbol := convert_from('\xc2b0', 'UTF8');   res := xpath('text()', (xml_declaration ||     '<x>' || degree_symbol || '</x>')::xml);   IF degree_symbol <> res[1]::text THEN     RAISE 'expected % (%), got % (%)',       degree_symbol, convert_to(degree_symbol, 'UTF8'),       res[1], convert_to(res[1]::text, 'UTF8');   END IF; EXCEPTION   WHEN untranslatable_character   OR undefined_function   OR feature_not_supported THEN     RAISE LOG 'skip: %', SQLERRM; END $$;
DO $$ DECLARE curtid tid; BEGIN   LOOP     INSERT INTO brin_summarize VALUES (1) RETURNING ctid INTO curtid;     EXIT WHEN curtid > tid '(2, 0)';   END LOOP; END; $$;
DO $$ DECLARE curtid tid; BEGIN   LOOP     INSERT INTO brin_summarize_bloom VALUES (1) RETURNING ctid INTO curtid;     EXIT WHEN curtid > tid '(2, 0)';   END LOOP; END; $$;
DO $$ DECLARE curtid tid; BEGIN   LOOP     INSERT INTO brin_summarize_multi VALUES (1) RETURNING ctid INTO curtid;     EXIT WHEN curtid > tid '(2, 0)';   END LOOP; END; $$;
DO $$ DECLARE r record; BEGIN     FOR r IN SELECT rtrim(roomno) AS roomno, comment FROM Room ORDER BY roomno     LOOP         RAISE NOTICE '%, %', r.roomno, r.comment;     END LOOP; END$$;
DO $$ DECLARE r record; BEGIN     FOR r IN SELECT rtrim(roomno) AS roomno, foo FROM Room ORDER BY roomno     LOOP         RAISE NOTICE '%, %', r.roomno, r.comment;     END LOOP; END$$;
DO $$ DECLARE r text[]; BEGIN   r := parse_ident('Schemax.Tabley');   RAISE NOTICE '%', format('%I.%I', r[1], r[2]);   r := parse_ident('"SchemaX"."TableY"');   RAISE NOTICE '%', format('%I.%I', r[1], r[2]); END; $$;
DO $$BEGIN EXECUTE format( 	'ALTER DATABASE %I OWNER TO regress_priv_group2', current_catalog); END$$;
DO $doblock$ declare   fk record;
DO LANGUAGE plpgsql $$begin return 1; end$$;
DROP ACCESS METHOD IF EXISTS no_such_am;
DROP ACCESS METHOD gist2 CASCADE;
DROP ACCESS METHOD gist2;
DROP ACCESS METHOD heap2;
DROP ACCESS METHOD heap_psql;
DROP ACCESS METHOD no_such_am;
DROP AGGREGATE IF EXISTS foo(no_such_schema.no_such_type);
DROP AGGREGATE IF EXISTS foo(no_such_type);
DROP AGGREGATE IF EXISTS no_such_schema.foo(int);
DROP AGGREGATE IF EXISTS test_aggregate_exists(*);
DROP AGGREGATE IF EXISTS test_aggregate_exists(int);
DROP AGGREGATE myavg (numeric);
DROP AGGREGATE myavg (numeric);
DROP AGGREGATE priv_testagg1(int);
DROP AGGREGATE test_aggregate_exists(*);
DROP AGGREGATE test_aggregate_exists(int);
DROP AGGREGATE testns.agg1(int);
DROP AGGREGATE testns.agg1(int);
DROP CAST (priv_testdomain1 AS priv_testdomain3b);
DROP CAST (text AS text);
DROP CAST IF EXISTS (INTEGER AS no_such_schema.bar);
DROP CAST IF EXISTS (INTEGER AS no_such_type2);
DROP CAST IF EXISTS (no_such_schema.foo AS INTEGER);
DROP CAST IF EXISTS (no_such_type1 AS INTEGER);
DROP CAST IF EXISTS (text AS text);
DROP COLLATION IF EXISTS no_such_schema.foo;
DROP COLLATION IF EXISTS test_collation_exists;
DROP COLLATION mycoll2;  -- fail CREATE COLLATION case_coll ("Lc_Collate" = "POSIX", "Lc_Ctype" = "POSIX");
DROP COLLATION test0 RESTRICT; -- fail DROP COLLATION test0 CASCADE;
DROP COLLATION test0 RESTRICT; -- fail DROP COLLATION test0 CASCADE;
DROP COLLATION test0, test_schema.test11, test5;
DROP COLLATION test0, test_schema.test11, test5;
DROP COLLATION test0; -- fail DROP COLLATION IF EXISTS test0;
DROP COLLATION test0; -- fail DROP COLLATION IF EXISTS test0;
DROP EVENT TRIGGER end_rls_command;
DROP EVENT TRIGGER has_volatile_rewrite;
DROP EVENT TRIGGER regress_event_trigger_drop_objects;
DROP EVENT TRIGGER regress_event_trigger_report_dropped;
DROP EVENT TRIGGER regress_event_trigger_report_end;
DROP EVENT TRIGGER sql_drop_command;
DROP EVENT TRIGGER start_rls_command;
DROP EVENT TRIGGER undroppable;
DROP EXTENSION IF EXISTS test_extension_exists;
DROP EXTENSION test_extension_exists;
DROP FOREIGN DATA WRAPPER IF EXISTS test_fdw_exists;
DROP FOREIGN DATA WRAPPER addr_fdw CASCADE;
DROP FOREIGN DATA WRAPPER alt_fdw2 CASCADE;
DROP FOREIGN DATA WRAPPER alt_fdw3 CASCADE;
DROP FOREIGN DATA WRAPPER dummy CASCADE;
DROP FOREIGN DATA WRAPPER dummy;
DROP FOREIGN DATA WRAPPER extstats_dummy_fdw CASCADE;
DROP FOREIGN DATA WRAPPER foo CASCADE;
DROP FOREIGN DATA WRAPPER foo CASCADE;
DROP FOREIGN DATA WRAPPER foo CASCADE;                      -- ERROR RESET ROLE;
DROP FOREIGN DATA WRAPPER foo;
DROP FOREIGN DATA WRAPPER foo;
DROP FOREIGN DATA WRAPPER foo;
DROP FOREIGN DATA WRAPPER nonexistent;                      -- ERROR DROP FOREIGN DATA WRAPPER IF EXISTS nonexistent;
DROP FOREIGN DATA WRAPPER postgresql CASCADE;
DROP FOREIGN DATA WRAPPER test_fdw;
DROP FOREIGN DATA WRAPPER test_fdw_exists;
DROP FOREIGN TABLE IF EXISTS no_such_schema.foo;
DROP FOREIGN TABLE fd_pt2_1;
DROP FOREIGN TABLE foreign_schema.foreign_table_1;
DROP FOREIGN TABLE ft1;
DROP FOREIGN TABLE ft2;
DROP FOREIGN TABLE ft2; -- ERROR DROP FOREIGN TABLE ft2 CASCADE;
DROP FOREIGN TABLE ft_part1, ft_part2;
DROP FOREIGN TABLE ft_part2;
DROP FOREIGN TABLE ft_part_1_1, ft_part_1_2;
DROP FOREIGN TABLE ft_part_1_2;
DROP GROUP IF EXISTS regress_test_g1, regress_test_g2;
DROP GROUP regress_dep_group;
DROP GROUP regress_dep_group;
DROP GROUP regress_priv_group1;
DROP GROUP regress_priv_group2;
DROP GROUP regress_test_g1;
DROP GROUP regress_test_g2;
DROP MATERIALIZED VIEW IF EXISTS no_such_mv;
DROP MATERIALIZED VIEW IF EXISTS no_such_schema.foo;
DROP MATERIALIZED VIEW concur_reindex_matview;
DROP MATERIALIZED VIEW mv_unspecified_types;
DROP MATERIALIZED VIEW mvtest_mv1 CASCADE;
DROP MATERIALIZED VIEW ptif_test_matview;
DROP OPERATOR !! (NONE, priv_testdomain1);
DROP OPERATOR !==(bigint, bigint);
DROP OPERATOR ###### (NONE, int4);
DROP OPERATOR ###### (int4, NONE);
DROP OPERATOR ###### (int4, int8);
DROP OPERATOR <<< (int, int);
DROP OPERATOR <|(bigint, bigint);
DROP OPERATOR === (boolean, boolean);
DROP OPERATOR ===(bigint, bigint);
DROP OPERATOR @#@ (int, int);
DROP OPERATOR @#@ (int8, int8);
DROP OPERATOR CLASS IF EXISTS no_such_schema.widget_ops USING btree;
DROP OPERATOR CLASS IF EXISTS test_operator_class USING btree;
DROP OPERATOR CLASS IF EXISTS test_operator_class USING no_such_am;
DROP OPERATOR CLASS test_int4_ops USING btree;
DROP OPERATOR CLASS test_operator_class USING btree;
DROP OPERATOR CLASS test_operator_class USING no_such_am;
DROP OPERATOR FAMILY IF EXISTS no_such_schema.float_ops USING btree;
DROP OPERATOR FAMILY IF EXISTS test_operator_family USING btree;
DROP OPERATOR FAMILY IF EXISTS test_operator_family USING no_such_am;
DROP OPERATOR FAMILY alt_opf10 USING btree;
DROP OPERATOR FAMILY alt_opf11 USING gist;
DROP OPERATOR FAMILY alt_opf12 USING btree;
DROP OPERATOR FAMILY alt_opf13 USING hash;
DROP OPERATOR FAMILY alt_opf14 USING btree;
DROP OPERATOR FAMILY alt_opf15 USING hash;
DROP OPERATOR FAMILY alt_opf16 USING gist;
DROP OPERATOR FAMILY alt_opf18 USING btree;
DROP OPERATOR FAMILY alt_opf19 USING btree;
DROP OPERATOR FAMILY alt_opf4 USING btree;
DROP OPERATOR FAMILY alt_opf5 USING btree;
DROP OPERATOR FAMILY alt_opf7 USING btree;
DROP OPERATOR FAMILY alt_opf8 USING btree;
DROP OPERATOR FAMILY alt_opf9 USING gist;
DROP OPERATOR FAMILY test_operator_family USING btree;
DROP OPERATOR FAMILY test_operator_family USING no_such_am;
DROP OPERATOR IF EXISTS # (NONE, no_such_schema.no_such_type);
DROP OPERATOR IF EXISTS + (no_such_schema.no_such_type, no_such_schema.no_such_type);
DROP OPERATOR IF EXISTS + (no_such_type, no_such_type);
DROP OPERATOR IF EXISTS @#@ (int, int);
DROP OPERATOR IF EXISTS no_such_schema.+ (int, int);
DROP OPERATOR |>(bigint, bigint);
DROP OWNED BY regress_addr_user;
DROP OWNED BY regress_dep_user0, regress_dep_user2;
DROP OWNED BY regress_dep_user0;
DROP OWNED BY regress_dep_user1;
DROP OWNED BY regress_dep_user1;
DROP OWNED BY regress_dep_user2, regress_dep_user0;
DROP OWNED BY regress_evt_user;
DROP OWNED BY regress_priv_user1;
DROP OWNED BY regress_priv_user2, regress_priv_user2;
DROP OWNED BY regress_rls_dob_role1;
DROP OWNED BY regress_rls_dob_role1;
DROP OWNED BY regress_rls_dob_role1;
DROP OWNED BY regress_rls_dob_role1;
DROP OWNED BY regress_rls_dob_role1;
DROP OWNED BY regress_sro_user;
DROP OWNED BY regress_test_role2 CASCADE;
DROP OWNED BY regress_test_role2;
DROP OWNED BY regress_user_mvtest CASCADE;
DROP POLICY p ON t;
DROP POLICY p ON tbl1;
DROP POLICY p1 ON dob_t1; -- should fail, already gone CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1,regress_rls_dob_role1,regress_rls_dob_role2 USING (true);
DROP POLICY p1 ON dob_t1; -- should fail, already gone CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1,regress_rls_dob_role2 USING (true);
DROP POLICY p1 ON dob_t1; -- should succeed CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1,regress_rls_dob_role1 USING (true);
DROP POLICY p1 ON dob_t1; -- should succeed CREATE POLICY p1 ON dob_t2 TO regress_rls_dob_role1,regress_rls_dob_role2 USING (true);
DROP POLICY p1 ON dob_t2; -- should succeed DROP USER regress_rls_dob_role1;
DROP POLICY p1 ON document;
DROP POLICY p1 ON document;
DROP POLICY p1 ON r2;
DROP POLICY p1r ON document;
DROP POLICY p2 ON document;
DROP POLICY p2 ON event_trigger_test;
DROP POLICY p2 ON t1;
DROP POLICY p3 ON document;
DROP POLICY p3 on s1;
DROP POLICY p3_with_default ON document;
DROP POLICY policy_range_parted ON range_parted;
DROP POLICY policy_range_parted_subplan ON range_parted;
DROP POLICY policy_range_parted_wholerow ON range_parted;
DROP PUBLICATION addr_pub;
DROP PUBLICATION addr_pub_schema;
DROP PUBLICATION pub;
DROP PUBLICATION pub;
DROP PUBLICATION pub;
DROP PUBLICATION pub;
DROP PUBLICATION pub;
DROP PUBLICATION testpib_ins_trunct;
DROP PUBLICATION testpub1_forschema;
DROP PUBLICATION testpub2_forschema;
DROP PUBLICATION testpub3, testpub4;
DROP PUBLICATION testpub3;
DROP PUBLICATION testpub3_forschema, testpub4_forschema, testpub5_forschema, testpub6_forschema, testpub_fortable;
DROP PUBLICATION testpub3_forschema;
DROP PUBLICATION testpub_default;
DROP PUBLICATION testpub_foralltables, testpub_fortable, testpub_forschema;
DROP PUBLICATION testpub_foralltables;
DROP PUBLICATION testpub_forparted, testpub_forparted1;
DROP PUBLICATION testpub_forschema_fortable;
DROP PUBLICATION testpub_fortable_forschema;
DROP PUBLICATION testpub_fortbl;
DROP PUBLICATION testpubpart_forschema;
DROP PUBLICATION testpubpart_forschema;
DROP ROUTINE IF EXISTS test_ambiguous_procname;
DROP ROUTINE cp_testfunc1(int);
DROP RULE IF EXISTS foo ON no_such_schema.bar;
DROP RULE IF EXISTS test_rule_exists ON no_such_schema.no_such_table;
DROP RULE IF EXISTS test_rule_exists ON no_such_table;
DROP RULE IF EXISTS test_rule_exists ON test_exists;
DROP RULE hat_nosert ON hats;
DROP RULE hat_nosert_all ON hats;
DROP RULE hat_upsert ON hats;
DROP RULE test_rule_exists ON no_such_schema.no_such_table;
DROP RULE test_rule_exists ON no_such_table;
DROP RULE test_rule_exists ON test_exists;
DROP RULE test_rule_exists ON test_exists;
DROP RULE y_rule ON y;
DROP RULE y_rule ON y;
DROP SERVER IF EXISTS test_server_exists;
DROP SERVER nonexistent;                                    -- ERROR DROP SERVER IF EXISTS nonexistent;
DROP SERVER s0;
DROP SERVER s2;
DROP SERVER s2;                                             -- ERROR DROP SERVER s1;
DROP SERVER s3;                                             -- ERROR DROP SERVER s3 CASCADE;
DROP SERVER s7;
DROP SERVER test_server_exists;
DROP STATISTICS ab1_a_b_stats;
DROP STATISTICS ab1_a_b_stats;
DROP STATISTICS expr_stats_1;
DROP STATISTICS func_deps_stat;
DROP STATISTICS func_deps_stat;
DROP STATISTICS func_deps_stat;
DROP STATISTICS mcv_lists_stats;
DROP STATISTICS mcv_lists_stats;
DROP STATISTICS mcv_lists_stats;
DROP STATISTICS mcv_lists_stats;
DROP STATISTICS mcv_lists_stats;
DROP STATISTICS mcv_lists_stats_1;
DROP STATISTICS mcv_lists_stats_2;
DROP STATISTICS mcv_lists_stats_3;
DROP STATISTICS regress_schema_2.ab1_a_b_stats;
DROP STATISTICS s10;
DROP STATISTICS s10;
DROP STATISTICS s10;
DROP STATISTICS s11;
DROP STATISTICS s11;
DROP STATISTICS s11;
DROP STATISTICS s12;
DROP STATISTICS s12;
DROP STATISTICS s12;
DROP STATISTICS s12;
DROP SUBSCRIPTION IF EXISTS regress_testsub;
DROP SUBSCRIPTION regress_addr_sub;
DROP SUBSCRIPTION regress_testsub3;
DROP SUBSCRIPTION regress_testsub;
DROP SUBSCRIPTION regress_testsub;
DROP SUBSCRIPTION regress_testsub;
DROP SUBSCRIPTION regress_testsub;
DROP SUBSCRIPTION regress_testsub;
DROP SUBSCRIPTION regress_testsub;
DROP SUBSCRIPTION regress_testsub;
DROP SUBSCRIPTION regress_testsub;  -- fail CREATE SUBSCRIPTION regress_testsub CONNECTION 'dbname=regress_doesnotexist' PUBLICATION testpub WITH (connect = false, binary = foo);
DROP TEXT SEARCH CONFIGURATION IF EXISTS no_such_schema.foo;
DROP TEXT SEARCH CONFIGURATION IF EXISTS test_tsconfig_exists;
DROP TEXT SEARCH CONFIGURATION test_tsconfig_exists;
DROP TEXT SEARCH CONFIGURATION test_tsconfig_exists;
DROP TEXT SEARCH DICTIONARY IF EXISTS no_such_schema.foo;
DROP TEXT SEARCH DICTIONARY IF EXISTS test_tsdict_exists;
DROP TEXT SEARCH DICTIONARY test_tsdict_exists;
DROP TEXT SEARCH DICTIONARY test_tsdict_exists;
DROP TEXT SEARCH PARSER IF EXISTS no_such_schema.foo;
DROP TEXT SEARCH PARSER IF EXISTS test_tsparser_exists;
DROP TEXT SEARCH PARSER test_tsparser_exists;
DROP TEXT SEARCH TEMPLATE IF EXISTS no_such_schema.foo;
DROP TEXT SEARCH TEMPLATE IF EXISTS test_tstemplate_exists;
DROP TEXT SEARCH TEMPLATE test_tstemplate_exists;
DROP TRIGGER IF EXISTS foo ON no_such_schema.bar;
DROP TRIGGER IF EXISTS test_trigger_exists ON no_such_schema.no_such_table;
DROP TRIGGER IF EXISTS test_trigger_exists ON no_such_table;
DROP TRIGGER IF EXISTS test_trigger_exists ON test_exists;
DROP TRIGGER after_upd_a_b_row_trig ON main_table;
DROP TRIGGER after_upd_b_row_trig ON main_table;
DROP TRIGGER after_upd_b_stmt_trig ON main_table;
DROP TRIGGER after_upd_row_trig ON main_table;
DROP TRIGGER before_upd_a_row_trig ON main_table;
DROP TRIGGER c1_delete_trig ON part_c_1_100;
DROP TRIGGER c1_insert_trig ON part_c_1_100;
DROP TRIGGER c1_update_trig ON part_c_1_100;
DROP TRIGGER d15_delete_trig ON part_d_15_20;
DROP TRIGGER d15_insert_trig ON part_d_15_20;
DROP TRIGGER d15_update_trig ON part_d_15_20;
DROP TRIGGER d1_delete_trig ON part_d_1_15;
DROP TRIGGER d1_insert_trig ON part_d_1_15;
DROP TRIGGER d1_update_trig ON part_d_1_15;
DROP TRIGGER delete_a ON main_table;
DROP TRIGGER delete_when ON main_table;
DROP TRIGGER gtest1 ON gtest26;
DROP TRIGGER gtest11 ON gtest26;
DROP TRIGGER gtest2 ON gtest26;
DROP TRIGGER gtest3 ON gtest26;
DROP TRIGGER insert_a ON main_table;
DROP TRIGGER insert_when ON main_table;
DROP TRIGGER instead_of_delete_trig ON main_view;
DROP TRIGGER modified_any ON main_table;
DROP TRIGGER modified_modified_a ON main_table;
DROP TRIGGER parent_delete_trig ON range_parted;
DROP TRIGGER parent_insert_trig ON range_parted;
DROP TRIGGER parent_update_trig ON range_parted;
DROP TRIGGER parted_mod_b ON sub_part1;
DROP TRIGGER rw_view1_ins_trig on base_tbl;
DROP TRIGGER rw_view1_trig ON rw_view1;
DROP TRIGGER show_trigger_data_trig on trigger_test;
DROP TRIGGER t ON trunc_trigger_test;
DROP TRIGGER test_trigger_exists ON no_such_schema.no_such_table;
DROP TRIGGER test_trigger_exists ON no_such_table;
DROP TRIGGER test_trigger_exists ON test_exists;
DROP TRIGGER test_trigger_exists ON test_exists;
DROP TRIGGER trans_deletetrig ON range_parted;
DROP TRIGGER trans_inserttrig ON range_parted;
DROP TRIGGER trans_updatetrig ON range_parted;
DROP TRIGGER transition_table_level2_bad_usage_trigger   ON transition_table_level2;
DROP TRIGGER trig_c1_100 ON part_c_1_100;
DROP TRIGGER trig_d15_20 ON part_d_15_20;
DROP TRIGGER trig_d1_15 ON part_d_1_15;
DROP TRIGGER trig_d_1_15 ON part_d_1_15;
DROP TRIGGER trig_skip_delete ON sub_part2;
DROP TRIGGER trigtest_after_row ON foreign_schema.foreign_table_1;
DROP TRIGGER trigtest_after_stmt ON foreign_schema.foreign_table_1;
DROP TRIGGER trigtest_before_row ON foreign_schema.foreign_table_1;
DROP TRIGGER trigtest_before_stmt ON foreign_schema.foreign_table_1;
DROP TRIGGER y_trig ON y;
DROP TRIGGER y_trig ON y;
DROP TRIGGER y_trig ON y;
DROP TYPE IF EXISTS no_such_schema.foo;
DROP TYPE IF EXISTS test_type_exists;
DROP TYPE IF EXISTS test_type_exists;
DROP TYPE bogus;
DROP TYPE bogus;
DROP TYPE bogus_type;
DROP TYPE collate_dep_test2;
DROP TYPE collate_dep_test2;
DROP TYPE ctlty1;
DROP TYPE double_int;
DROP TYPE gtest_type CASCADE;
DROP TYPE hash_test_t1;
DROP TYPE hash_test_t2;
DROP TYPE j_unordered_pair;
DROP TYPE jb_unordered_pair;
DROP TYPE jsbrec;
DROP TYPE jsbrec_i_not_null;
DROP TYPE jsrec;
DROP TYPE jsrec_i_not_null;
DROP TYPE mood;
DROP TYPE mytype CASCADE;
DROP TYPE person_type CASCADE;
DROP TYPE person_type RESTRICT;
DROP TYPE priv_testtype1; -- ok DROP DOMAIN priv_testdomain1; -- ok SET SESSION AUTHORIZATION regress_priv_user5;
DROP TYPE rainbow;
DROP TYPE shell;     -- fail, type not exist CREATE TYPE myshell;
DROP TYPE test7b;
DROP TYPE test8b;
DROP TYPE test_type;
DROP TYPE test_type_empty;
DROP TYPE test_type_exists;
DROP TYPE test_type_exists;
DROP TYPE test_typex;
ELSE 		RETURN FALSE;
ELSE 		SELECT INTO retval 50, 5::numeric, ''xxx''::text;
ELSE 		SELECT INTO retval 50, 5::numeric, ''xxx''::text;
ELSE         rslt = CAST($1 AS TEXT) || '','' || recursion_test($1 - 1, $2);
EXECUTE cprep;
EXECUTE foo;
EXECUTE hsp;
EXECUTE p1;
EXECUTE p1;		-- To be perform as a view with security-barrier EXECUTE p2;		-- To be perform as a view without security-barrier RESET SESSION AUTHORIZATION;
EXECUTE p2;
EXECUTE pp;
EXECUTE prepstmt;
EXECUTE prepstmt;
EXECUTE prepstmt;
EXECUTE prepstmt;
EXECUTE prepstmt;
EXECUTE q1;
EXECUTE q1;
EXECUTE test \gdesc EXPLAIN EXECUTE test \gdesc SELECT 1 + \gdesc SELECT \gdesc CREATE TABLE bububu(a int) \gdesc TABLE bububu;  -- fail SELECT 1 AS x, 'Hello', 2 AS y, true AS "dirty\name" \gdesc \g SELECT 3 AS x, 'Hello', 4 AS y, true AS "dirty\name" \gdesc \g create temporary table gexec_test(a int, b text, c date, d float);
EXECUTE vprep;
EXECUTE vprep;
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE MATERIALIZED VIEW matview_schema.mv_nodata2 (a) AS   SELECT generate_series(1, 10) WITH NO DATA;
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE MATERIALIZED VIEW matview_schema.mv_withdata2 (a) AS   SELECT generate_series(1, 10) WITH DATA;
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE TABLE ctas_ine_tbl AS EXECUTE ctas_ine_query; -- error EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE TABLE IF NOT EXISTS ctas_ine_tbl AS EXECUTE ctas_ine_query; -- ok DROP TABLE ctas_ine_tbl;
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE TABLE selinto_schema.tbl_nodata2 (a) AS   SELECT generate_series(1,3) WITH NO DATA;
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE TABLE selinto_schema.tbl_nodata4 (a) AS   EXECUTE data_sel WITH NO DATA;
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE TABLE selinto_schema.tbl_withdata2 (a) AS   SELECT generate_series(1,3) WITH DATA;
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)   CREATE TABLE selinto_schema.tbl_withdata4 (a) AS   EXECUTE data_sel WITH DATA;
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF) UPDATE tidscan SET id = -id WHERE CURRENT OF c RETURNING *;
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF) UPDATE tidscan SET id = -id WHERE CURRENT OF c RETURNING *;
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF) UPDATE tidscan SET id = -id WHERE CURRENT OF c RETURNING *;
EXPLAIN (COSTS OFF)   SELECT count(*) FROM dupindexcols     WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
EXPLAIN (COSTS OFF) :qry;
EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
EXPLAIN (COSTS OFF) EXECUTE plancache_test;
EXPLAIN (COSTS OFF) EXECUTE plancache_test;
EXPLAIN (COSTS OFF) EXECUTE plancache_test;
EXPLAIN (COSTS OFF) EXECUTE plancache_test;
EXPLAIN (COSTS OFF) EXECUTE role_inval;
EXPLAIN (COSTS OFF) EXECUTE role_inval;
EXPLAIN (COSTS OFF) EXECUTE role_inval;
EXPLAIN (COSTS OFF) INSERT INTO t2 (SELECT * FROM t1);
EXPLAIN (COSTS OFF) SELECT * FROM atest12 WHERE a >>> 0;
EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y   WHERE x.a = y.b and abs(y.a) <<< 5;
EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y   WHERE x.a = y.b and abs(y.a) <<< 5;
EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y   WHERE x.a = y.b and abs(y.a) <<< 5;
EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y   WHERE x.a = y.b and abs(y.a) <<< 5;
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 &< '(10,4.333334),(5,100)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 &<| '(10,4.3333334),(5,1)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 &> '(40,30),(45,50)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 << '(10,20),(30,40)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 <<| '(10,4.33334),(5,100)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 >> '(30,40),(40,30)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 |&> '(49.99,49.99),(49.99,49.99)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 |>> '(37,38),(39,40)';
EXPLAIN (COSTS OFF) SELECT * FROM box_temp WHERE f1 ~= '(20,20),(40,40)';
EXPLAIN (COSTS OFF) SELECT * FROM circle_tbl WHERE f1 && circle(point(1,-2), 1)     ORDER BY area(f1);
EXPLAIN (COSTS OFF) SELECT * FROM fast_emp4000     WHERE home_base <@ '(200,200),(2000,1000)'::box     ORDER BY (home_base[0])[0];
EXPLAIN (COSTS OFF) SELECT * FROM fast_emp4000     WHERE home_base <@ '(200,200),(2000,1000)'::box     ORDER BY (home_base[0])[0];
EXPLAIN (COSTS OFF) SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
EXPLAIN (COSTS OFF) SELECT * FROM inet_tbl WHERE '192.168.1.0/24'::cidr >> i;
EXPLAIN (COSTS OFF) SELECT * FROM inet_tbl WHERE '192.168.1.0/24'::cidr >>= i;
EXPLAIN (COSTS OFF) SELECT * FROM inet_tbl WHERE i<<'192.168.1.0/24'::cidr;
EXPLAIN (COSTS OFF) SELECT * FROM inet_tbl WHERE i<<='192.168.1.0/24'::cidr;
EXPLAIN (COSTS OFF) SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
EXPLAIN (COSTS OFF) SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
EXPLAIN (COSTS OFF) SELECT * FROM polygon_tbl WHERE f1 @> '((1,1),(2,2),(2,1))'::polygon     ORDER BY (poly_center(f1))[0];
EXPLAIN (COSTS OFF) SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
EXPLAIN (COSTS OFF) SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
EXPLAIN (COSTS OFF) SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
EXPLAIN (COSTS OFF) SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
EXPLAIN (COSTS OFF) SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p <<| '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p <<| '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p |>> '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p |>> '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
EXPLAIN (COSTS OFF) SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p <<| '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p <<| '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p |>> '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p |>> '(5000, 4000)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p && polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p &< polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p &<| polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p &> polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p << polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p <<| polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p >> polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p |&> polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p |>> polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM quad_poly_tbl WHERE p ~= polygon '((200, 300),(210, 310),(230, 290))';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ^@	 'Worth';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ^@	 'Worth';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec                         Ct  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec                         Ct  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec                         Ct  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec                         Ct  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth                         St  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth                         St  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth                         St  ';
EXPLAIN (COSTS OFF) SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth                         St  ';
EXPLAIN (COSTS OFF) SELECT i FROM inet_tbl WHERE i << '192.168.1.0/24'::cidr ORDER BY i;
EXPLAIN (COSTS OFF) SELECT i FROM inet_tbl WHERE i << '192.168.1.0/24'::cidr ORDER BY i;
EXPLAIN (COSTS OFF) SELECT rank() OVER (ORDER BY b <-> point '123,456') n, b <-> point '123,456' dist, id FROM quad_box_tbl WHERE b <@ box '((200,300),(500,600))';
EXPLAIN (COSTS OFF) SELECT rank() OVER (ORDER BY b <-> point '123,456') n, b <-> point '123,456' dist, id FROM quad_box_tbl;
EXPLAIN (COSTS OFF) SELECT rank() OVER (ORDER BY p <-> point '123,456') n, p <-> point '123,456' dist, id FROM quad_poly_tbl WHERE p <@ polygon '((300,300),(400,600),(600,500),(700,200))';
EXPLAIN (COSTS OFF) UPDATE current_check SET payload = payload WHERE CURRENT OF current_check_cursor;
EXPLAIN (VERBOSE, COSTS OFF) INSERT INTO rls_tbl   SELECT * FROM (SELECT b, c FROM rls_tbl ORDER BY a) ss;
EXPLAIN (VERBOSE, COSTS OFF) UPDATE update_test t   SET (a, b) = (SELECT b, a FROM update_test s WHERE s.a = t.a)   WHERE CURRENT_USER = SESSION_USER;
EXPLAIN (costs off)   CREATE MATERIALIZED VIEW mvtest_tm AS SELECT type, sum(amt) AS totamt FROM mvtest_t GROUP BY type WITH NO DATA;
EXPLAIN (costs off)   CREATE MATERIALIZED VIEW mvtest_tvm AS SELECT * FROM mvtest_tv ORDER BY type;
EXPLAIN (costs off)   CREATE MATERIALIZED VIEW mvtest_tvvm AS SELECT * FROM mvtest_tvv;
EXPLAIN (costs off) WITH data(hat_name, hat_color) AS MATERIALIZED (     VALUES ('h8', 'green'),         ('h9', 'blue'),         ('h7', 'forbidden') ) INSERT INTO hats     SELECT * FROM data RETURNING *;
FETCH 1 FROM c1;
FETCH 1 FROM c1;
FETCH 1 FROM c1;
FETCH 1 FROM c1;
FETCH 1 FROM c1;
FETCH 1 FROM c1;
FETCH 1 FROM c1;
FETCH 1 FROM foo24;
FETCH 1 FROM foo24;
FETCH 1 FROM foo;
FETCH 1 FROM foo;
FETCH 1 in foo1;
FETCH 10 FROM c;
FETCH 10 FROM c;
FETCH 10 FROM c;
FETCH 10 FROM c;
FETCH 10 FROM c;
FETCH 10 FROM c;
FETCH 10 in foo10;
FETCH 11 in foo11;
FETCH 12 in foo12;
FETCH 13 in foo13;
FETCH 14 in foo14;
FETCH 15 in foo15;
FETCH 16 in foo16;
FETCH 17 in foo17;
FETCH 18 in foo18;
FETCH 19 in foo19;
FETCH 2 FROM c1;
FETCH 2 in foo2;
FETCH 20 in foo20;
FETCH 21 in foo21;
FETCH 22 in foo22;
FETCH 23 in foo23;
FETCH 3 in foo3;
FETCH 4 in foo4;
FETCH 5 in foo5;
FETCH 6 in foo6;
FETCH 7 in foo7;
FETCH 8 in foo8;
FETCH 9 in foo9;
FETCH ABSOLUTE -1 FROM foo25;
FETCH ABSOLUTE 1 FROM c1;
FETCH ABSOLUTE 1 FROM current_check_cursor;
FETCH ABSOLUTE 1 FROM current_check_cursor;
FETCH ABSOLUTE 12 FROM c1;
FETCH ABSOLUTE 13 FROM c1;
FETCH ABSOLUTE 2 FROM foo24; -- allowed FETCH ABSOLUTE 1 FROM foo24; -- should fail END;
FETCH ABSOLUTE 4 FROM foo25ns;
FETCH ABSOLUTE 4 FROM foo25ns; -- fail SELECT name, statement, is_holdable, is_binary, is_scrollable FROM pg_cursors;
FETCH ABSOLUTE 8 FROM c1;
FETCH ALL FROM c1;
FETCH ALL FROM c1;
FETCH ALL FROM c1;
FETCH ALL FROM c;
FETCH ALL FROM c;
FETCH ALL FROM c;
FETCH BACKWARD 1 FROM c;
FETCH BACKWARD 1 FROM foo24; -- should fail END;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM c;
FETCH BACKWARD FROM foo25;
FETCH FIRST FROM c;
FETCH FIRST FROM tablesample_cur;
FETCH FIRST FROM tablesample_cur;
FETCH FIRST c;
FETCH FROM c1;
FETCH FROM c1;
FETCH FROM foo25;
FETCH FROM foo25;
FETCH FROM foo25;
FETCH FROM foo25ns;
FETCH FROM foo25ns;
FETCH FROM foo25ns;
FETCH FROM foo26;
FETCH LAST FROM c;
FETCH LAST FROM c;
FETCH LAST c;
FETCH NEXT FROM c1;
FETCH NEXT FROM c1;
FETCH NEXT FROM c1;  -- insert not visible COMMIT;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c;
FETCH NEXT FROM c; -- skip one row FETCH NEXT FROM c;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT FROM tablesample_cur;
FETCH NEXT c;
FETCH NEXT c;
FETCH PRIOR c;
FETCH RELATIVE 0 FROM c1;
FETCH RELATIVE 0 FROM c1;
FETCH RELATIVE 0 FROM c1;
FETCH RELATIVE 1 FROM current_check_cursor;
FETCH RELATIVE 1 FROM current_check_cursor;
FETCH all in foo13;
FETCH all in foo14;
FETCH all in foo15;
FETCH all in foo16;
FETCH all in foo17;
FETCH all in foo18;
FETCH all in foo19;
FETCH all in foo20;
FETCH all in foo21;
FETCH all in foo22;
FETCH all in foo23;
FETCH all in foo24;
FETCH all in foo25;
FETCH backward 1 in foo23;
FETCH backward 10 in foo14;
FETCH backward 11 in foo13;
FETCH backward 12 in foo12;
FETCH backward 13 in foo11;
FETCH backward 14 in foo10;
FETCH backward 15 in foo9;
FETCH backward 16 in foo8;
FETCH backward 17 in foo7;
FETCH backward 18 in foo6;
FETCH backward 19 in foo5;
FETCH backward 2 in foo22;
FETCH backward 20 in foo4;
FETCH backward 21 in foo3;
FETCH backward 22 in foo2;
FETCH backward 23 in foo1;
FETCH backward 3 in foo21;
FETCH backward 4 in foo20;
FETCH backward 5 in foo19;
FETCH backward 6 in foo18;
FETCH backward 7 in foo17;
FETCH backward 8 in foo16;
FETCH backward 9 in foo15;
FETCH c1;
FETCH c1;
FETCH c1;
FETCH next from hsc;
FETCH ok;
FETCH ok;  -- should work FETCH ctt; -- error occurs here ROLLBACK TO s1;
FETCH ok;  -- should work FETCH ctt; -- must be rejected COMMIT;
IF FOUND then 		INSERT INTO perform_test VALUES (100, 100);
IF FOUND then 		INSERT INTO perform_test VALUES (100, 100);
IMPORT FOREIGN SCHEMA s1 FROM SERVER s9 INTO public; -- ERROR IMPORT FOREIGN SCHEMA s1 LIMIT TO (t1) FROM SERVER s9 INTO public; --ERROR IMPORT FOREIGN SCHEMA s1 EXCEPT (t1) FROM SERVER s9 INTO public; -- ERROR IMPORT FOREIGN SCHEMA s1 EXCEPT (t1, t2) FROM SERVER s9 INTO public OPTIONS (option1 'value1', option2 'value2'); -- ERROR DROP FOREIGN TABLE no_table;                                    -- ERROR DROP FOREIGN TABLE IF EXISTS no_table;
INSERT INTO 123 VALUES(123);
INSERT INTO BIT_SHIFT_TABLE SELECT b>>1 FROM BIT_SHIFT_TABLE;
INSERT INTO BIT_SHIFT_TABLE SELECT b>>2 FROM BIT_SHIFT_TABLE;
INSERT INTO BIT_SHIFT_TABLE SELECT b>>4 FROM BIT_SHIFT_TABLE;
INSERT INTO BIT_SHIFT_TABLE SELECT b>>8 FROM BIT_SHIFT_TABLE;
INSERT INTO BIT_SHIFT_TABLE VALUES (B'1101100000000000');
INSERT INTO BIT_TABLE VALUES (B'01010101010');
INSERT INTO BIT_TABLE VALUES (B'10'); -- too short INSERT INTO BIT_TABLE VALUES (B'00000000000');
INSERT INTO BIT_TABLE VALUES (B'101011111010'); -- too long SELECT * FROM BIT_TABLE;
INSERT INTO BIT_TABLE VALUES (B'11011000000');
INSERT INTO INET_TBL (c, i) VALUES (cidr('192.168.1.2/30'), '192.168.1.226');
INSERT INTO INET_TBL (c, i) VALUES (cidr('ffff:ffff:ffff:ffff::/24'), '::192.168.1.226');
INSERT INTO LINE_TBL VALUES (line(point '(1,0)', point '(1,0)'));
INSERT INTO LINE_TBL VALUES (line(point '(3,1)', point '(3,2)'));
INSERT INTO LSEG_TBL VALUES (lseg(point(11, 22), point(33,44)));
INSERT INTO RANDOM_TBL (random)   SELECT count(*)   FROM onek WHERE random() < 1.0/10;
INSERT INTO RANDOM_TBL (random)   SELECT count(*)   FROM onek WHERE random() < 1.0/10;
INSERT INTO RANDOM_TBL (random)   SELECT count(*)   FROM onek WHERE random() < 1.0/10;
INSERT INTO T SELECT * FROM generate_series(1, 10) a;
INSERT INTO T SELECT b, b - 10 FROM generate_series(11, 20) a(b);
INSERT INTO T SELECT b, b - 10, (b + 10)::text FROM generate_series(21, 30) a(b);
INSERT INTO TEMP_FLOAT (f1)   SELECT float8(f1) FROM INT2_TBL;
INSERT INTO TEMP_FLOAT (f1)   SELECT float8(f1) FROM INT4_TBL;
INSERT INTO TEMP_GROUP   SELECT 1, (- i.f1), (- f.f1)   FROM INT4_TBL i, FLOAT8_TBL f;
INSERT INTO TEMP_GROUP   SELECT 2, i.f1, f.f1   FROM INT4_TBL i, FLOAT8_TBL f;
INSERT INTO TEMP_INT2 (f1)   SELECT int2(f1) FROM FLOAT8_TBL   WHERE (f1 >= -32767) AND (f1 <= 32767);
INSERT INTO TEMP_INT2 (f1)   SELECT int2(f1) FROM INT4_TBL   WHERE (f1 >= -32767) AND (f1 <= 32767);
INSERT INTO TEMP_INT4 (f1)   SELECT int4(f1) FROM FLOAT8_TBL   WHERE (f1 > -2147483647) AND (f1 < 2147483647);
INSERT INTO TEMP_INT4 (f1)   SELECT int4(f1) FROM INT2_TBL;
INSERT INTO TEMP_TIMESTAMP (f1)   SELECT d1 FROM TIMESTAMP_TBL   WHERE d1 BETWEEN '13-jun-1957' AND '1-jan-1997'    OR d1 BETWEEN '1-jan-1999' AND '1-jan-2010';
INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'0' AS BIT VARYING(6)) >>1 FROM VARBIT_SHIFT_TABLE;
INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'00' AS BIT VARYING(8)) >>2 FROM VARBIT_SHIFT_TABLE;
INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'0000' AS BIT VARYING(12)) >>4 FROM VARBIT_SHIFT_TABLE;
INSERT INTO VARBIT_SHIFT_TABLE SELECT CAST(v || B'00000000' AS BIT VARYING(20)) >>8 FROM VARBIT_SHIFT_TABLE;
INSERT INTO VARBIT_SHIFT_TABLE VALUES (B'11011');
INSERT INTO VARBIT_TABLE VALUES (B'0');
INSERT INTO VARBIT_TABLE VALUES (B'010101');
INSERT INTO VARBIT_TABLE VALUES (B'01010101010');
INSERT INTO VARBIT_TABLE VALUES (B'101011111010'); -- too long SELECT * FROM VARBIT_TABLE;
INSERT INTO ab1 SELECT     generate_series(1,10),     generate_series(1,10),     generate_series('2020-10-01'::timestamp, '2020-10-10'::timestamp, interval '1 day'),     generate_series('2020-10-01'::timestamptz, '2020-10-10'::timestamptz, interval '1 day');
INSERT INTO ab1 SELECT a, a%23 FROM generate_series(1, 1000) a;
INSERT INTO abbrev_abort_uuids (abort_increasing, abort_decreasing, noabort_increasing, noabort_decreasing)     SELECT         ('00000000-0000-0000-0000-'||to_char(g.i, '000000000000FM'))::uuid abort_increasing,         ('00000000-0000-0000-0000-'||to_char(20000 - g.i, '000000000000FM'))::uuid abort_decreasing,         (to_char(g.i % 10009, '00000000FM')||'-0000-0000-0000-'||to_char(g.i, '000000000000FM'))::uuid noabort_increasing,         (to_char(((20000 - g.i) % 10009), '00000000FM')||'-0000-0000-0000-'||to_char(20000 - g.i, '000000000000FM'))::uuid noabort_decreasing     FROM generate_series(0, 20000, 1) g(i);
INSERT INTO abbrev_abort_uuids (abort_increasing, abort_decreasing, noabort_increasing, noabort_decreasing)     SELECT abort_increasing, abort_decreasing, noabort_increasing, noabort_decreasing     FROM abbrev_abort_uuids     WHERE (id < 10 OR id > 19990) AND id % 3 = 0 AND abort_increasing is not null;
INSERT INTO abbrev_abort_uuids DEFAULT VALUES;
INSERT INTO abbrev_abort_uuids DEFAULT VALUES;
INSERT INTO abc VALUES (7)\; COMMIT\; INSERT INTO abc VALUES (8)\; COMMIT AND CHAIN;  -- 7 commit, 8 error INSERT INTO abc VALUES (9)\; ROLLBACK\; INSERT INTO abc VALUES (10)\; ROLLBACK AND CHAIN;  -- 9 rollback, 10 error INSERT INTO abc VALUES (11)\; COMMIT AND CHAIN\; INSERT INTO abc VALUES (12)\; COMMIT;  -- 11 error, 12 not reached INSERT INTO abc VALUES (13)\; ROLLBACK AND CHAIN\; INSERT INTO abc VALUES (14)\; ROLLBACK;  -- 13 error, 14 not reached START TRANSACTION ISOLATION LEVEL REPEATABLE READ\; INSERT INTO abc VALUES (15)\; COMMIT AND CHAIN;  -- 15 ok SHOW transaction_isolation;  -- transaction is active at this point COMMIT;
INSERT INTO alpha_neg SELECT -1.0, i, to_char(i % 10, 'FM0000') FROM generate_series(100, 399) i WHERE i % 10 IN (1, 3, 4, 6, 8, 9);
INSERT INTO alpha_pos SELECT  1.0, i, to_char(i % 10, 'FM0000') FROM generate_series(100, 399) i WHERE i % 10 IN (1, 3, 4, 6, 8, 9);
INSERT INTO array_gin_test SELECT ARRAY[1, g%5, g] FROM generate_series(1, 10000) g;
INSERT INTO arrtest (a, b[1:2], c, d[1:2])    VALUES ('{}', '{3,4}', '{foo,bar}', '{bar,foo}');
INSERT INTO arrtest (a, b[1:2][1:2], c, d, e, f, g)    VALUES ('{11,12,23}', '{{3,4},{4,5}}', '{"foobar"}',            '{{"elt1", "elt2"}}', '{"3.4", "6.7"}',            '{"abc","abcde"}', '{"abc","abcde"}');
INSERT INTO arrtest (a[1:5], b[1:1][1:2][1:2], c, d, f, g)    VALUES ('{1,2,3,4,5}', '{{{0,0},{1,2}}}', '{}', '{}', '{}', '{}');
INSERT INTO arrtest (b[2]) VALUES(now());  -- error, type mismatch INSERT INTO arrtest (b[1:2]) VALUES(now());  -- error, type mismatch SELECT * FROM arrtest;
INSERT INTO b SELECT 1 INTO f;
INSERT INTO b1 (SELECT x, md5(x::text) FROM generate_series(-10,10) x);
INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
INSERT INTO base_tbl SELECT i/10.0 FROM generate_series(1,10) g(i);
INSERT INTO base_tbl_child SELECT * FROM generate_series(1, 8);
INSERT INTO base_tbl_parent SELECT * FROM generate_series(-8, -1);
INSERT INTO beta_neg SELECT -1.0, i, to_char(i % 10, 'FM0000') FROM generate_series(100, 149) i WHERE i % 10 IN (2, 3, 4, 6, 7, 9);
INSERT INTO beta_neg SELECT -1.0, i, to_char(i % 10, 'FM0000') FROM generate_series(200, 299) i WHERE i % 10 IN (2, 3, 4, 6, 7, 9);
INSERT INTO beta_neg SELECT -1.0, i, to_char(i % 10, 'FM0000') FROM generate_series(350, 499) i WHERE i % 10 IN (2, 3, 4, 6, 7, 9);
INSERT INTO beta_pos SELECT  1.0, i, to_char(i % 10, 'FM0000') FROM generate_series(100, 149) i WHERE i % 10 IN (2, 3, 4, 6, 7, 9);
INSERT INTO beta_pos SELECT  1.0, i, to_char(i % 10, 'FM0000') FROM generate_series(200, 299) i WHERE i % 10 IN (2, 3, 4, 6, 7, 9);
INSERT INTO beta_pos SELECT  1.0, i, to_char(i % 10, 'FM0000') FROM generate_series(350, 499) i WHERE i % 10 IN (2, 3, 4, 6, 7, 9);
INSERT INTO bit_defaults DEFAULT VALUES;
INSERT INTO bmscantest   SELECT (r%53), (r%59), 'foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo'   FROM generate_series(1,70000) r;
INSERT INTO box_temp 	SELECT box(point(i, i), point(i * 2, i * 2)) 	FROM generate_series(1, 50) AS i;
INSERT INTO brin_large_range SELECT i FROM generate_series(1,10000) s(i);
INSERT INTO brin_test SELECT x/100,x%100 FROM generate_series(1,10000) x(x);
INSERT INTO brin_test_bloom SELECT x/100,x%100 FROM generate_series(1,10000) x(x);
INSERT INTO brin_test_multi SELECT x/100,x%100 FROM generate_series(1,10000) x(x);
INSERT INTO brintest (inetcol, cidrcol, int4rangecol) SELECT 	inet 'fe80::6e40:8ff:fea9:8c46' + tenthous, 	cidr 'fe80::6e40:8ff:fea9:8c46' + tenthous, 	'empty'::int4range FROM tenk1 ORDER BY thousand, tenthous LIMIT 25;
INSERT INTO brintest SELECT 	repeat(stringu1, 42)::bytea, 	substr(stringu1, 1, 1)::"char", 	stringu1::name, 142857 * tenthous, 	thousand, 	twothousand, 	repeat(stringu1, 42), 	unique1::oid, 	format('(%s,%s)', tenthous, twenty)::tid, 	(four + 1.0)/(hundred+1), 	odd::float8 / (tenthous + 1), 	format('%s:00:%s:00:%s:00', to_hex(odd), to_hex(even), to_hex(hundred))::macaddr, 	inet '10.2.3.4' + tenthous, 	cidr '10.2.3/24' + tenthous, 	substr(stringu1, 1, 1)::bpchar, 	date '1995-08-15' + tenthous, 	time '01:20:30' + thousand * interval '18.5 second', 	timestamp '1942-07-23 03:05:09' + tenthous * interval '36.38 hours', 	timestamptz '1972-10-10 03:00' + thousand * interval '1 hour', 	justify_days(justify_hours(tenthous * interval '12 minutes')), 	timetz '01:30:20' + hundred * interval '15 seconds', 	thousand::bit(10), 	tenthous::bit(16)::varbit, 	tenthous::numeric(36,30) * fivethous * even / (hundred + 1), 	format('%s%s-%s-%s-%s-%s%s%s', to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'))::uuid, 	int4range(thousand, twothousand), 	format('%s/%s%s', odd, even, tenthous)::pg_lsn, 	box(point(odd, even), point(thousand, twothousand)) FROM tenk1 ORDER BY unique2 LIMIT 5 OFFSET 5;
INSERT INTO brintest SELECT 	repeat(stringu1, 8)::bytea, 	substr(stringu1, 1, 1)::"char", 	stringu1::name, 142857 * tenthous, 	thousand, 	twothousand, 	repeat(stringu1, 8), 	unique1::oid, 	format('(%s,%s)', tenthous, twenty)::tid, 	(four + 1.0)/(hundred+1), 	odd::float8 / (tenthous + 1), 	format('%s:00:%s:00:%s:00', to_hex(odd), to_hex(even), to_hex(hundred))::macaddr, 	inet '10.2.3.4/24' + tenthous, 	cidr '10.2.3/24' + tenthous, 	substr(stringu1, 1, 1)::bpchar, 	date '1995-08-15' + tenthous, 	time '01:20:30' + thousand * interval '18.5 second', 	timestamp '1942-07-23 03:05:09' + tenthous * interval '36.38 hours', 	timestamptz '1972-10-10 03:00' + thousand * interval '1 hour', 	justify_days(justify_hours(tenthous * interval '12 minutes')), 	timetz '01:30:20+02' + hundred * interval '15 seconds', 	thousand::bit(10), 	tenthous::bit(16)::varbit, 	tenthous::numeric(36,30) * fivethous * even / (hundred + 1), 	format('%s%s-%s-%s-%s-%s%s%s', to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'))::uuid, 	int4range(thousand, twothousand), 	format('%s/%s%s', odd, even, tenthous)::pg_lsn, 	box(point(odd, even), point(thousand, twothousand)) FROM tenk1 ORDER BY unique2 LIMIT 100;
INSERT INTO brintest_2 VALUES (numrange(0, 2^1000::numeric));
INSERT INTO brintest_bloom (inetcol, cidrcol) SELECT 	inet 'fe80::6e40:8ff:fea9:8c46' + tenthous, 	cidr 'fe80::6e40:8ff:fea9:8c46' + tenthous FROM tenk1 ORDER BY thousand, tenthous LIMIT 25;
INSERT INTO brintest_bloom SELECT 	repeat(stringu1, 42)::bytea, 	substr(stringu1, 1, 1)::"char", 	stringu1::name, 142857 * tenthous, 	thousand, 	twothousand, 	repeat(stringu1, 42), 	unique1::oid, 	(four + 1.0)/(hundred+1), 	odd::float8 / (tenthous + 1), 	format('%s:00:%s:00:%s:00', to_hex(odd), to_hex(even), to_hex(hundred))::macaddr, 	inet '10.2.3.4' + tenthous, 	cidr '10.2.3/24' + tenthous, 	substr(stringu1, 1, 1)::bpchar, 	date '1995-08-15' + tenthous, 	time '01:20:30' + thousand * interval '18.5 second', 	timestamp '1942-07-23 03:05:09' + tenthous * interval '36.38 hours', 	timestamptz '1972-10-10 03:00' + thousand * interval '1 hour', 	justify_days(justify_hours(tenthous * interval '12 minutes')), 	timetz '01:30:20' + hundred * interval '15 seconds', 	tenthous::numeric(36,30) * fivethous * even / (hundred + 1), 	format('%s%s-%s-%s-%s-%s%s%s', to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'))::uuid, 	format('%s/%s%s', odd, even, tenthous)::pg_lsn FROM tenk1 ORDER BY unique2 LIMIT 5 OFFSET 5;
INSERT INTO brintest_bloom SELECT 	repeat(stringu1, 8)::bytea, 	substr(stringu1, 1, 1)::"char", 	stringu1::name, 142857 * tenthous, 	thousand, 	twothousand, 	repeat(stringu1, 8), 	unique1::oid, 	(four + 1.0)/(hundred+1), 	odd::float8 / (tenthous + 1), 	format('%s:00:%s:00:%s:00', to_hex(odd), to_hex(even), to_hex(hundred))::macaddr, 	inet '10.2.3.4/24' + tenthous, 	cidr '10.2.3/24' + tenthous, 	substr(stringu1, 1, 1)::bpchar, 	date '1995-08-15' + tenthous, 	time '01:20:30' + thousand * interval '18.5 second', 	timestamp '1942-07-23 03:05:09' + tenthous * interval '36.38 hours', 	timestamptz '1972-10-10 03:00' + thousand * interval '1 hour', 	justify_days(justify_hours(tenthous * interval '12 minutes')), 	timetz '01:30:20+02' + hundred * interval '15 seconds', 	tenthous::numeric(36,30) * fivethous * even / (hundred + 1), 	format('%s%s-%s-%s-%s-%s%s%s', to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'))::uuid, 	format('%s/%s%s', odd, even, tenthous)::pg_lsn FROM tenk1 ORDER BY unique2 LIMIT 100;
INSERT INTO brintest_multi (inetcol, cidrcol) SELECT 	inet 'fe80::6e40:8ff:fea9:8c46' + tenthous, 	cidr 'fe80::6e40:8ff:fea9:8c46' + tenthous FROM tenk1 ORDER BY thousand, tenthous LIMIT 25;
INSERT INTO brintest_multi SELECT 	142857 * tenthous, 	thousand, 	twothousand, 	unique1::oid, 	format('(%s,%s)', tenthous, twenty)::tid, 	(four + 1.0)/(hundred+1), 	odd::float8 / (tenthous + 1), 	format('%s:00:%s:00:%s:00', to_hex(odd), to_hex(even), to_hex(hundred))::macaddr, 	substr(md5(unique1::text), 1, 16)::macaddr8, 	inet '10.2.3.4' + tenthous, 	cidr '10.2.3/24' + tenthous, 	date '1995-08-15' + tenthous, 	time '01:20:30' + thousand * interval '18.5 second', 	timestamp '1942-07-23 03:05:09' + tenthous * interval '36.38 hours', 	timestamptz '1972-10-10 03:00' + thousand * interval '1 hour', 	justify_days(justify_hours(tenthous * interval '12 minutes')), 	timetz '01:30:20' + hundred * interval '15 seconds', 	tenthous::numeric(36,30) * fivethous * even / (hundred + 1), 	format('%s%s-%s-%s-%s-%s%s%s', to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'))::uuid, 	format('%s/%s%s', odd, even, tenthous)::pg_lsn FROM tenk1 ORDER BY unique2 LIMIT 5 OFFSET 5;
INSERT INTO brintest_multi SELECT 	142857 * tenthous, 	thousand, 	twothousand, 	unique1::oid, 	format('(%s,%s)', tenthous, twenty)::tid, 	(four + 1.0)/(hundred+1), 	odd::float8 / (tenthous + 1), 	format('%s:00:%s:00:%s:00', to_hex(odd), to_hex(even), to_hex(hundred))::macaddr, 	substr(md5(unique1::text), 1, 16)::macaddr8, 	inet '10.2.3.4/24' + tenthous, 	cidr '10.2.3/24' + tenthous, 	date '1995-08-15' + tenthous, 	time '01:20:30' + thousand * interval '18.5 second', 	timestamp '1942-07-23 03:05:09' + tenthous * interval '36.38 hours', 	timestamptz '1972-10-10 03:00' + thousand * interval '1 hour', 	justify_days(justify_hours(tenthous * interval '12 minutes')), 	timetz '01:30:20+02' + hundred * interval '15 seconds', 	tenthous::numeric(36,30) * fivethous * even / (hundred + 1), 	format('%s%s-%s-%s-%s-%s%s%s', to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'))::uuid, 	format('%s/%s%s', odd, even, tenthous)::pg_lsn FROM tenk1 ORDER BY unique2 LIMIT 100;
INSERT INTO clstr_expression(a, b) SELECT g.i % 42, 'prefix'||g.i FROM generate_series(1, 133) g(i);
INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
INSERT INTO clstr_tst_s (b) SELECT b FROM clstr_tst_s;
INSERT INTO cmdata1 SELECT large_val() || repeat('a', 4000);
INSERT INTO cmdata2 SELECT large_val() || repeat('a', 4000);
INSERT INTO cmmove3 SELECT * FROM cmdata1;
INSERT INTO cmmove3 SELECT * FROM cmdata;
INSERT INTO collate_test2 SELECT * FROM collate_test1;
INSERT INTO collate_test2 SELECT * FROM collate_test1;
INSERT INTO collate_test2 SELECT * FROM collate_test1;
INSERT INTO collate_test3 SELECT * FROM collate_test1;
INSERT INTO collate_test3 SELECT * FROM collate_test1;
INSERT INTO collate_test4 SELECT * FROM collate_test1;
INSERT INTO collate_test4 SELECT * FROM collate_test1;
INSERT INTO collate_test4 SELECT * FROM collate_test1;
INSERT INTO collate_test5 SELECT * FROM collate_test1;
INSERT INTO collate_test5 SELECT * FROM collate_test1;
INSERT INTO collate_test5 SELECT * FROM collate_test1;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO combocidtest SELECT 1 LIMIT 0;
INSERT INTO copy_t (SELECT x, md5(x::text) FROM generate_series(0,10) x);
INSERT INTO ctv_data SELECT 1, x, '*' || x FROM generate_series(1,10) x;
INSERT INTO current_check_1 SELECT i, 'p' || i FROM generate_series(1,9) i;
INSERT INTO current_check_2 SELECT i, 'P' || i FROM generate_series(10,19) i;
INSERT INTO datdba_only DEFAULT VALUES;
INSERT INTO datdba_only DEFAULT VALUES;
INSERT INTO dedup_unique_test_table SELECT i FROM generate_series(0,450) i;
INSERT INTO default_test DEFAULT VALUES;
INSERT INTO delete_test_table SELECT i, 1, 2, 3 FROM generate_series(1,1000) i;
INSERT INTO delete_test_table SELECT i, 1, 2, 3 FROM generate_series(1,80000) i;
INSERT INTO domarrtest (testint4arr[1], testint4arr[3]) values (11,22);
INSERT INTO expr_stats SELECT mod(i,10), md5(mod(i,10)::text), md5(mod(i,10)::text) FROM generate_series(1,1000) s(i);
INSERT INTO expr_stats SELECT mod(i,10), mod(i,10), mod(i,10) FROM generate_series(1,1000) s(i);
INSERT INTO expr_stats SELECT mod(i,10), mod(i,10), mod(i,10) FROM generate_series(1,1000) s(i);
INSERT INTO f_star (class, a, c, e, f)    VALUES ('f', 19, 'hi claire'::name, '-5'::int2, '(1,3),(2,4)'::polygon);
INSERT INTO f_star (class, a, c, f)    VALUES ('f', 21, 'hi marcel'::name, '(11,44),(22,55),(33,66)'::polygon);
INSERT INTO f_star (class, a, e, f)    VALUES ('f', 22, '-7'::int2, '(111,555),(222,666),(333,777),(444,888)'::polygon);
INSERT INTO f_star (class, a, f)    VALUES ('f', 26, '(11111,33333),(22222,44444)'::polygon);
INSERT INTO f_star (class, c, e, f)    VALUES ('f', 'hi keith'::name, '-8'::int2, 	   '(1111,3333),(2222,4444)'::polygon);
INSERT INTO f_star (class, c, f)    VALUES ('f', 'hi jeff'::name,            '(111111,333333),(222222,444444)'::polygon);
INSERT INTO f_star (class, e, f)    VALUES ('f', '-11'::int2, '(1111111,3333333),(2222222,4444444)'::polygon);
INSERT INTO f_star (class, f)    VALUES ('f', '(11111111,33333333),(22222222,44444444)'::polygon);
INSERT INTO fast_emp4000 SELECT * FROM slow_emp4000;
INSERT INTO foo SELECT f1+10, f2, f3+99 FROM foo   RETURNING *, f1+112 IN (SELECT q1 FROM int8_tbl) AS subplan,     EXISTS(SELECT * FROM int4_tbl) AS initplan;
INSERT INTO functional_dependencies (a, b, c, filler1)      SELECT i, i, i, i FROM generate_series(1,5000) s(i);
INSERT INTO functional_dependencies (a, b, c, filler1)      SELECT mod(i, 5), mod(i, 7), mod(i, 11), i FROM generate_series(1,1000) s(i);
INSERT INTO functional_dependencies (a, b, c, filler1)      SELECT mod(i,100), mod(i,50), mod(i,25), i FROM generate_series(1,5000) s(i);
INSERT INTO functional_dependencies_multi (a, b, c, d)     SELECT          mod(i,7),          mod(i,7),          mod(i,11),          mod(i,11)     FROM generate_series(1,5000) s(i);
INSERT INTO hash_split_heap SELECT 1 FROM generate_series(1, 500) a;
INSERT INTO hash_split_heap SELECT 1 FROM generate_series(1, 5000) a;
INSERT INTO hash_split_heap SELECT a/2 FROM generate_series(1, 25000) a;
INSERT INTO hobbies_r (name, person)    SELECT 'basketball', p.name    FROM person p    WHERE p.name = 'joe' or p.name = 'sally';
INSERT INTO hobbies_r (name, person)    SELECT 'posthacking', p.name    FROM person* p    WHERE p.name = 'mike' or p.name = 'jeff';
INSERT INTO idxpart (a, b, c) SELECT i, i, i FROM generate_series(1, 50) i;
INSERT INTO ihighway    SELECT *    FROM road    WHERE name ~ 'I- .*';
INSERT INTO inhf DEFAULT VALUES;
INSERT INTO iportaltest (i, d, p)    VALUES (1, 3.567, '(3.0,1.0),(4.0,2.0)'::polygon);
INSERT INTO iportaltest (i, d, p)    VALUES (2, 89.05, '(4.0,2.0),(3.0,1.0)'::polygon);
INSERT INTO itest1 DEFAULT VALUES;
INSERT INTO itest1 DEFAULT VALUES;
INSERT INTO itest2 DEFAULT VALUES;
INSERT INTO itest2 DEFAULT VALUES;
INSERT INTO itest3 DEFAULT VALUES;
INSERT INTO itest3 DEFAULT VALUES;
INSERT INTO itest4 DEFAULT VALUES;
INSERT INTO itest4 DEFAULT VALUES;
INSERT INTO itest4 DEFAULT VALUES;
INSERT INTO itest6 DEFAULT VALUES;
INSERT INTO itest6 DEFAULT VALUES;
INSERT INTO itest6 DEFAULT VALUES;
INSERT INTO itest7 DEFAULT VALUES;
INSERT INTO itest7c DEFAULT VALUES;
INSERT INTO itest8 DEFAULT VALUES;
INSERT INTO itestv10 DEFAULT VALUES;
INSERT INTO itestv10 DEFAULT VALUES;
INSERT INTO itestv11 DEFAULT VALUES;
INSERT INTO itestv11 DEFAULT VALUES;
INSERT INTO jsbpoptest SELECT '{ 	"jsa": [1, "2", null, 4], 	"rec": {"a": "abc", "c": "01.02.2003", "x": 43.2}, 	"reca": [{"a": "abc", "b": 456}, null, {"c": "01.02.2003", "x": 43.2}] }'::jsonb FROM generate_series(1, 3);
INSERT INTO jspoptest SELECT '{ 	"jsa": [1, "2", null, 4], 	"rec": {"a": "abc", "c": "01.02.2003", "x": 43.2}, 	"reca": [{"a": "abc", "b": 456}, null, {"c": "01.02.2003", "x": 43.2}] }'::json FROM generate_series(1, 3);
INSERT INTO large_tuple_test (select 1, NULL);
INSERT INTO large_tuple_test (select 2, repeat('a', 1000));
INSERT INTO large_tuple_test (select 3, NULL);
INSERT INTO large_tuple_test (select 4, repeat('a', 8126));
INSERT INTO main_table DEFAULT VALUES;
INSERT INTO mcv_lists (a, b, c) SELECT 1, 2, 3 FROM generate_series(1,1000) s(i);
INSERT INTO mcv_lists (a, b, c, d)      SELECT          NULL, -- always NULL          (CASE WHEN mod(i,2) = 0 THEN NULL ELSE 'x' END),          (CASE WHEN mod(i,2) = 0 THEN NULL ELSE 0 END),          (CASE WHEN mod(i,2) = 0 THEN NULL ELSE 'x' END)      FROM generate_series(1,5000) s(i);
INSERT INTO mcv_lists (a, b, c, filler1)      SELECT          (CASE WHEN mod(i,100) = 1 THEN NULL ELSE mod(i,100) END),          (CASE WHEN mod(i,50) = 1  THEN NULL ELSE mod(i,50) END),          (CASE WHEN mod(i,25) = 1  THEN NULL ELSE mod(i,25) END),          i      FROM generate_series(1,5000) s(i);
INSERT INTO mcv_lists (a, b, c, filler1)      SELECT i, i, i, i FROM generate_series(1,1000) s(i);
INSERT INTO mcv_lists (a, b, c, filler1)      SELECT i, i, i, i FROM generate_series(1,1000) s(i);
INSERT INTO mcv_lists (a, b, c, filler1)      SELECT mod(i,100), mod(i,50), mod(i,25), i FROM generate_series(1,5000) s(i);
INSERT INTO mcv_lists (a, b, c, filler1)      SELECT mod(i,37), mod(i,41), mod(i,43), mod(i,47) FROM generate_series(1,5000) s(i);
INSERT INTO mcv_lists_arrays (a, b, c)      SELECT          ARRAY[md5((i/100)::text), md5((i/100-1)::text), md5((i/100+1)::text)],          ARRAY[(i/100-1)::numeric/1000, (i/100)::numeric/1000, (i/100+1)::numeric/1000],          ARRAY[(i/100-1), i/100, (i/100+1)]      FROM generate_series(1,5000) s(i);
INSERT INTO mcv_lists_bool (a, b, c)      SELECT          (mod(i,2) = 0), (mod(i,4) = 0), (mod(i,8) = 0)      FROM generate_series(1,10000) s(i);
INSERT INTO mcv_lists_multi (a, b, c, d)     SELECT          mod(i,5),          mod(i,5),          mod(i,7),          mod(i,7)     FROM generate_series(1,5000) s(i);
INSERT INTO mcv_lists_partial (a, b, c)      SELECT          i,          i,          i      FROM generate_series(0,3999) s(i);
INSERT INTO mcv_lists_partial (a, b, c)      SELECT          i,          i,          i      FROM generate_series(0,99) s(i);
INSERT INTO mcv_lists_partial (a, b, c)      SELECT          mod(i,10),          mod(i,10),          mod(i,10)      FROM generate_series(0,999) s(i);
INSERT INTO mcv_lists_uuid (a, b, c)      SELECT          md5(mod(i,100)::text)::uuid,          md5(mod(i,50)::text)::uuid,          md5(mod(i,25)::text)::uuid      FROM generate_series(1,5000) s(i);
INSERT INTO mvtest_foo SELECT * FROM mvtest_foo;
INSERT INTO ndistinct (a, b, c, d)      SELECT mod(i,3), mod(i,9), mod(i,5), mod(i,20)        FROM generate_series(1,1000) s(i);
INSERT INTO ndistinct (a, b, c, filler1)      SELECT i/100, i/100, i/100, cash_words((i/100)::money)        FROM generate_series(1,1000) s(i);
INSERT INTO ndistinct (a, b, c, filler1)      SELECT mod(i,13), mod(i,17), mod(i,19),             cash_words(mod(i,23)::int::money)        FROM generate_series(1,1000) s(i);
INSERT INTO nulltest DEFAULT VALUES;
INSERT INTO num_result SELECT id, 0, LN(ABS(val))     FROM num_data     WHERE val != '0.0';
INSERT INTO num_result SELECT id, 0, LN(ABS(val))     FROM num_data     WHERE val != '0.0';
INSERT INTO num_result SELECT id, 0, LOG('10'::numeric, ABS(val))     FROM num_data     WHERE val != '0.0';
INSERT INTO num_result SELECT id, 0, LOG(numeric '10', ABS(val))     FROM num_data     WHERE val != '0.0';
INSERT INTO num_result SELECT id, 0, POW(numeric '10', LN(ABS(round(val,1000))))     FROM num_data     WHERE val != '0.0';
INSERT INTO num_result SELECT id, 0, POWER(numeric '10', LN(ABS(round(val,200))))     FROM num_data     WHERE val != '0.0';
INSERT INTO num_result SELECT id, 0, SQRT(ABS(val))     FROM num_data;
INSERT INTO num_result SELECT id, 0, SQRT(ABS(val))     FROM num_data;
INSERT INTO num_result SELECT t1.id, t2.id, round(t1.val * t2.val, 30)     FROM num_data t1, num_data t2;
INSERT INTO num_result SELECT t1.id, t2.id, round(t1.val * t2.val, 30)     FROM num_data t1, num_data t2;
INSERT INTO num_result SELECT t1.id, t2.id, round(t1.val + t2.val, 10)     FROM num_data t1, num_data t2;
INSERT INTO num_result SELECT t1.id, t2.id, round(t1.val + t2.val, 10)     FROM num_data t1, num_data t2;
INSERT INTO num_result SELECT t1.id, t2.id, round(t1.val - t2.val, 40)     FROM num_data t1, num_data t2;
INSERT INTO num_result SELECT t1.id, t2.id, round(t1.val - t2.val, 40)     FROM num_data t1, num_data t2;
INSERT INTO num_result SELECT t1.id, t2.id, round(t1.val / t2.val, 80)     FROM num_data t1, num_data t2     WHERE t2.val != '0.0';
INSERT INTO num_result SELECT t1.id, t2.id, round(t1.val / t2.val, 80)     FROM num_data t1, num_data t2     WHERE t2.val != '0.0';
INSERT INTO num_result SELECT t1.id, t2.id, t1.val * t2.val     FROM num_data t1, num_data t2;
INSERT INTO num_result SELECT t1.id, t2.id, t1.val * t2.val     FROM num_data t1, num_data t2;
INSERT INTO num_result SELECT t1.id, t2.id, t1.val + t2.val     FROM num_data t1, num_data t2;
INSERT INTO num_result SELECT t1.id, t2.id, t1.val + t2.val     FROM num_data t1, num_data t2;
INSERT INTO num_result SELECT t1.id, t2.id, t1.val - t2.val     FROM num_data t1, num_data t2;
INSERT INTO num_result SELECT t1.id, t2.id, t1.val - t2.val     FROM num_data t1, num_data t2;
INSERT INTO num_result SELECT t1.id, t2.id, t1.val / t2.val     FROM num_data t1, num_data t2     WHERE t2.val != '0.0';
INSERT INTO num_result SELECT t1.id, t2.id, t1.val / t2.val     FROM num_data t1, num_data t2     WHERE t2.val != '0.0';
INSERT INTO num_variance SELECT 9e131071 + x FROM generate_series(1, 5) x;
INSERT INTO nummultirange_test VALUES(nummultirange(numrange(1.1, 2.2)));
INSERT INTO nummultirange_test VALUES(nummultirange(numrange(1.7, 1.7, '[]'), numrange(1.7, 1.9)));
INSERT INTO nummultirange_test VALUES(nummultirange(numrange(1.7, 1.7, '[]'), numrange(1.9, 2.1)));
INSERT INTO nummultirange_test VALUES(nummultirange(variadic '{}'::numrange[]));
INSERT INTO nummultirange_test2 VALUES(nummultirange(numrange(1.1, 2.2)));
INSERT INTO nummultirange_test2 VALUES(nummultirange(numrange(1.1, 2.2)));
INSERT INTO nummultirange_test2 VALUES(nummultirange(numrange(1.1, 2.2,'()')));
INSERT INTO numrange_test VALUES(numrange(1.1, 2.2));
INSERT INTO numrange_test VALUES(numrange(1.7, 1.7, '[]'));
INSERT INTO numrange_test2 VALUES(numrange(1.1, 2.2));
INSERT INTO numrange_test2 VALUES(numrange(1.1, 2.2));
INSERT INTO numrange_test2 VALUES(numrange(1.1, 2.2,'()'));
INSERT INTO pagg_tab SELECT i % 20, i % 30, to_char(i % 12, 'FM0000'), i % 30 FROM generate_series(0, 2999) i;
INSERT INTO pagg_tab1 SELECT i % 30, i % 20 FROM generate_series(0, 299, 2) i;
INSERT INTO pagg_tab2 SELECT i % 20, i % 30 FROM generate_series(0, 299, 3) i;
INSERT INTO pagg_tab_m SELECT i % 30, i % 40, i % 50 FROM generate_series(0, 2999) i;
INSERT INTO pagg_tab_ml SELECT i % 30, i % 10, to_char(i % 4, 'FM0000') FROM generate_series(0, 29999) i;
INSERT INTO pagg_tab_para SELECT i % 30, i % 20 FROM generate_series(0, 29999) i;
INSERT INTO pht1 SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(0, 599, 2) i;
INSERT INTO pht1_e SELECT i, i, 'A' || to_char(i/50, 'FM0000') FROM generate_series(0, 299, 2) i;
INSERT INTO pht2 SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(0, 599, 3) i;
INSERT INTO plt1 SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(0, 599, 2) i;
INSERT INTO plt1_adv SELECT i, i, to_char(i % 10, 'FM0000') FROM generate_series(1, 299) i WHERE i % 10 IN (1, 2, 3, 4, 5);
INSERT INTO plt1_adv SELECT i, i, to_char(i % 10, 'FM0000') FROM generate_series(1, 299) i WHERE i % 10 IN (1, 3);
INSERT INTO plt1_adv SELECT i, i, to_char(i % 10, 'FM0000') FROM generate_series(1, 299) i WHERE i % 10 IN (1, 3, 4, 6, 8, 9);
INSERT INTO plt1_adv SELECT i, i, to_char(i % 5, 'FM0000') FROM generate_series(0, 24) i;
INSERT INTO plt1_e SELECT i, i, 'A' || to_char(i/50, 'FM0000') FROM generate_series(0, 599, 2) i;
INSERT INTO plt2 SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(0, 599, 3) i;
INSERT INTO plt2_adv SELECT i, i, to_char(i % 10, 'FM0000') FROM generate_series(1, 299) i WHERE i % 10 IN (1, 2, 3, 4, 5);
INSERT INTO plt2_adv SELECT i, i, to_char(i % 10, 'FM0000') FROM generate_series(1, 299) i WHERE i % 10 IN (1, 3);
INSERT INTO plt2_adv SELECT i, i, to_char(i % 10, 'FM0000') FROM generate_series(1, 299) i WHERE i % 10 IN (2, 3, 4, 6, 7, 9);
INSERT INTO plt2_adv SELECT i, i, to_char(i % 10, 'FM0000') FROM generate_series(1, 299) i WHERE i % 10 IN (4, 5, 6);
INSERT INTO plt2_adv SELECT i, i, to_char(i % 10, 'FM0000') FROM generate_series(1, 299) i WHERE i % 10 IN (4, 6);
INSERT INTO plt2_adv SELECT i, i, to_char(i % 10, 'FM0000') FROM generate_series(1, 299) i WHERE i % 10 IN (7, 9);
INSERT INTO plt2_adv SELECT i, i, to_char(i % 5, 'FM0000') FROM generate_series(0, 24) i WHERE i % 5 IN (2, 3, 4);
INSERT INTO plt3_adv SELECT i, i, to_char(i % 10, 'FM0000') FROM generate_series(1, 299) i WHERE i % 10 IN (4, 6, 7, 9);
INSERT INTO plt3_adv SELECT i, i, to_char(i % 5, 'FM0000') FROM generate_series(0, 24) i WHERE i % 5 IN (1, 3, 4);
INSERT INTO point_gist_tbl SELECT '(0,0)' FROM generate_series(0,1000);
INSERT INTO point_tbl(f1[0]) VALUES(0) RETURNING *;
INSERT INTO prt1 SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 2 = 0;
INSERT INTO prt1_adv SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(100, 399) i;
INSERT INTO prt1_adv SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(100, 399) i;
INSERT INTO prt1_e SELECT i, i, i % 25 FROM generate_series(0, 599, 2) i;
INSERT INTO prt1_l SELECT i, i % 25, to_char(i % 4, 'FM0000') FROM generate_series(0, 599, 2) i;
INSERT INTO prt1_m SELECT i, i, i % 25 FROM generate_series(0, 599, 2) i;
INSERT INTO prt1_n SELECT i, i, to_char(i, 'FM0000') FROM generate_series(0, 499, 2) i;
INSERT INTO prt2 SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 3 = 0;
INSERT INTO prt2_adv SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(100, 399) i;
INSERT INTO prt2_adv SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(350, 499) i;
INSERT INTO prt2_adv SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(500, 599) i;
INSERT INTO prt2_adv_p1 SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(100, 149) i;
INSERT INTO prt2_adv_p2 SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(200, 299) i;
INSERT INTO prt2_adv_p3 SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(350, 499) i;
INSERT INTO prt2_e SELECT i, i, i % 25 FROM generate_series(0, 599, 3) i;
INSERT INTO prt2_l SELECT i % 25, i, to_char(i % 4, 'FM0000') FROM generate_series(0, 599, 3) i;
INSERT INTO prt2_m SELECT i, i, i % 25 FROM generate_series(0, 599, 3) i;
INSERT INTO prt2_n SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(0, 599, 2) i;
INSERT INTO prt2_n SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(0, 599, 2) i;
INSERT INTO prt3_adv SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(200, 399) i;
INSERT INTO prt4_n SELECT i, i, to_char(i, 'FM0000') FROM generate_series(0, 599, 2) i;
INSERT INTO pvactst SELECT i, array[1,2,3], point(i, i+1) FROM generate_series(1,1000) i;
INSERT INTO quad_box_tbl   SELECT (x - 1) * 100 + y, box(point(x * 10, y * 10), point(x * 10 + 5, y * 10 + 5))   FROM generate_series(1, 100) x,        generate_series(1, 100) y;
INSERT INTO quad_box_tbl   SELECT i, '((200, 300),(210, 310))'   FROM generate_series(10001, 11000) AS i;
INSERT INTO quad_point_tbl     SELECT '(333.0,400.0)'::point FROM generate_series(1,1000);
INSERT INTO quad_poly_tbl 	SELECT (x - 1) * 100 + y, polygon(circle(point(x * 10, y * 10), 1 + (x + y) % 10)) 	FROM generate_series(1, 100) x, 		 generate_series(1, 100) y;
INSERT INTO quad_poly_tbl 	SELECT i, polygon '((200, 300),(210, 310),(230, 290))' 	FROM generate_series(10001, 11000) AS i;
INSERT INTO radix_text_tbl     SELECT 'P0123456789abcdef' FROM generate_series(1,1000);
INSERT INTO ref_tbl SELECT * FROM generate_series(1,10);
INSERT INTO reindex_before SELECT oid, 'pg_toast_TABLE', relfilenode, relkind, reltoastrelid FROM pg_class WHERE oid IN 	(SELECT reltoastrelid FROM reindex_before WHERE reltoastrelid > 0);
INSERT INTO reindex_before SELECT oid, 'pg_toast_TABLE_index', relfilenode, relkind, reltoastrelid FROM pg_class where oid in 	(select indexrelid from pg_index where indrelid in 		(select reltoastrelid from reindex_before where reltoastrelid > 0));
INSERT INTO rls_tbl   SELECT * FROM (SELECT b, c FROM rls_tbl ORDER BY a) ss;
INSERT INTO rls_tbl SELECT 10, 20, 30;
INSERT INTO rls_tbl SELECT x/10 FROM generate_series(1, 100) x;
INSERT INTO s1 (SELECT x, md5(x::text) FROM generate_series(-10,10) x);
INSERT INTO s2 (SELECT x, md5(x::text) FROM generate_series(-6,6) x);
INSERT INTO serializable_update_tab SELECT a, repeat('xyzxz', 100), 'new' 	FROM generate_series(1, 50) a;
INSERT INTO shighway    SELECT *    FROM road    WHERE name ~ 'State Hwy.*';
INSERT INTO t DEFAULT VALUES;
INSERT INTO t1 (SELECT x, md5(x::text) FROM generate_series(0,20) x);
INSERT INTO t1 SELECT i,i,'t1' FROM generate_series(1,10) g(i);
INSERT INTO t11 SELECT i,i,'t11','t11d' FROM generate_series(1,10) g(i);
INSERT INTO t111 SELECT i,i,'t111','t111d','{1,1,1}'::int[] FROM generate_series(1,10) g(i);
INSERT INTO t12 SELECT i,i,'t12','{1,2}'::int[] FROM generate_series(1,10) g(i);
INSERT INTO t2 (SELECT * FROM t1);
INSERT INTO table1 SELECT generate_series(1,400);
INSERT INTO table2 SELECT generate_series(1,400), 'abc';
INSERT INTO tbl SELECT 1, 2, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
INSERT INTO tbl SELECT 1, 2, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
INSERT INTO tbl SELECT 1, 2, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
INSERT INTO tbl SELECT 1, 2, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
INSERT INTO tbl SELECT 1, 2, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
INSERT INTO tbl SELECT 1, NULL, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
INSERT INTO tbl SELECT 1, NULL, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
INSERT INTO tbl SELECT x, 2*x, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
INSERT INTO tbl SELECT x, 2*x, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
INSERT INTO tbl SELECT x, 2*x, 3*x, box('4,4,4,4') FROM generate_series(1,1000) AS x;
INSERT INTO tbl SELECT x, 2*x, NULL, NULL FROM generate_series(1,10) AS x;
INSERT INTO tbl SELECT x, 2*x, NULL, NULL FROM generate_series(1,10) AS x;
INSERT INTO tbl SELECT x, 2*x, NULL, NULL FROM generate_series(1,300) AS x;
INSERT INTO tbl_gist SELECT x, 2*x, 3*x, box(point(3*x,2*x),point(3*x+1,2*x+1)) FROM generate_series(1,10) AS x;
INSERT INTO tbl_gist SELECT x, 2*x, 3*x, box(point(x,x+1),point(2*x,2*x+1)) FROM generate_series(1,10) AS x;
INSERT INTO tbl_gist SELECT x, 2*x, 3*x, box(point(x,x+1),point(2*x,2*x+1)) FROM generate_series(1,10) AS x;
INSERT INTO tbl_gist SELECT x, 2*x, 3*x, box(point(x,x+1),point(2*x,2*x+1)) FROM generate_series(1,10) AS x;
INSERT INTO tbl_gist SELECT x, 2*x, 3*x, box(point(x,x+1),point(2*x,2*x+1)) FROM generate_series(1,10) AS x;
INSERT INTO tbl_gist SELECT x, 2*x, 3*x, box(point(x,x+1),point(2*x,2*x+1)) FROM generate_series(1,10) AS x;
INSERT INTO tbl_gist SELECT x, 2*x, 3*x, box(point(x,x+1),point(2*x,2*x+1)) FROM generate_series(1,8000) AS x;
INSERT INTO tbl_gist SELECT x, 2*x, 3*x, box(point(x,x+1),point(2*x,2*x+1)) FROM generate_series(1,8000) AS x;
INSERT INTO tbl_include_box SELECT 1, 2*x, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
INSERT INTO tbl_include_box_pk SELECT 1, 2, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
INSERT INTO tbl_include_pk SELECT 1, 2*x, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
INSERT INTO tbl_include_reg SELECT x, 2*x, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
INSERT INTO tbl_include_unique1 SELECT x, 2*x, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
INSERT INTO tbl_include_unique2 SELECT 1, 2, 3*x, box('4,4,4,4') FROM generate_series(1,10) AS x;
INSERT INTO tenk2 SELECT * FROM tenk1;
INSERT INTO test6 VALUES (1, U&'\00E4bc');
INSERT INTO test6 VALUES (2, U&'\0061\0308bc');
INSERT INTO test6a VALUES (1, ARRAY[U&'\00E4bc']);
INSERT INTO test6a VALUES (2, ARRAY[U&'\0061\0308bc']);
INSERT INTO test_mark_restore(col1, col2, col12)    SELECT a.i, b.i, a.i * b.i FROM generate_series(1, 500) a(i), generate_series(1, 5) b(i);
INSERT INTO test_ns_schema_1.abc DEFAULT VALUES;
INSERT INTO test_ns_schema_1.abc DEFAULT VALUES;
INSERT INTO test_ns_schema_1.abc DEFAULT VALUES;
INSERT INTO test_tablesample   SELECT i, repeat(i::text, 200) FROM generate_series(0, 9) s(i);
INSERT INTO tidrangescan SELECT i,repeat('x', 100) FROM generate_series(1,200) AS s(i);
INSERT INTO transition_table_level1 (level1_no)   SELECT generate_series(1,200);
INSERT INTO transition_table_level1(level1_no)   SELECT generate_series(201,1000);
INSERT INTO transition_table_level2 (level2_no, parent_no)   SELECT level2_no, level2_no / 50 + 1 AS parent_no     FROM generate_series(1,9999) level2_no;
INSERT INTO transition_table_status (level, node_no, status)   SELECT 1, level1_no, 0 FROM transition_table_level1;
INSERT INTO transition_table_status (level, node_no, status)   SELECT 2, level2_no, 0 FROM transition_table_level2;
INSERT INTO trunc_stats_test DEFAULT VALUES;
INSERT INTO trunc_stats_test DEFAULT VALUES;
INSERT INTO trunc_stats_test DEFAULT VALUES;
INSERT INTO trunc_stats_test1 DEFAULT VALUES;
INSERT INTO trunc_stats_test1 DEFAULT VALUES;
INSERT INTO trunc_stats_test1 DEFAULT VALUES;
INSERT INTO trunc_stats_test1 DEFAULT VALUES;
INSERT INTO trunc_stats_test2 DEFAULT VALUES;
INSERT INTO trunc_stats_test2 DEFAULT VALUES;
INSERT INTO trunc_stats_test2 DEFAULT VALUES;
INSERT INTO trunc_stats_test2 DEFAULT VALUES;
INSERT INTO trunc_stats_test3 DEFAULT VALUES;
INSERT INTO trunc_stats_test3 DEFAULT VALUES;
INSERT INTO trunc_stats_test3 DEFAULT VALUES;
INSERT INTO trunc_stats_test3 DEFAULT VALUES;
INSERT INTO trunc_stats_test3 DEFAULT VALUES;
INSERT INTO trunc_stats_test4 DEFAULT VALUES;
INSERT INTO trunc_stats_test4 DEFAULT VALUES;
INSERT INTO trunc_stats_test4 DEFAULT VALUES;
INSERT INTO truncate_a DEFAULT VALUES;
INSERT INTO truncate_a DEFAULT VALUES;
INSERT INTO truncate_a DEFAULT VALUES;
INSERT INTO truncate_a DEFAULT VALUES;
INSERT INTO truncate_a DEFAULT VALUES;
INSERT INTO truncate_a DEFAULT VALUES;
INSERT INTO truncate_a DEFAULT VALUES;
INSERT INTO truncate_a DEFAULT VALUES;
INSERT INTO truncate_a DEFAULT VALUES;
INSERT INTO truncate_b DEFAULT VALUES;
INSERT INTO truncate_b DEFAULT VALUES;
INSERT INTO truncate_b DEFAULT VALUES;
INSERT INTO truncate_b DEFAULT VALUES;
INSERT INTO truncate_b DEFAULT VALUES;
INSERT INTO truncate_b DEFAULT VALUES;
INSERT INTO tststats.priv_test_tbl      SELECT mod(i,5), mod(i,10) FROM generate_series(1,100) s(i);
INSERT INTO update_test SELECT a,b+1,c FROM update_test;
INSERT INTO vacparted_i SELECT i, 'test_'|| i from generate_series(1,10) i;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT * FROM vactst;
INSERT INTO vactst SELECT generate_series(1, 300);
INSERT INTO vactst SELECT generate_series(301, 400);
INSERT INTO y SELECT generate_series(1, 10);
INSERT INTO y SELECT generate_series(1, 10);
INSERT INTO y SELECT generate_series(1, 10);
INSERT INTO y SELECT generate_series(1, 3);
INSERT INTO y2 (SELECT x, md5(x::text) FROM generate_series(0,20) x);
LISTEN foo_event;
LISTEN notify_async2;
LOCK TABLE ONLY lock_tbl1;
LOCK TABLE fast_emp4000;
LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should fail ROLLBACK;
LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should fail ROLLBACK;
LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should pass COMMIT;
LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should pass COMMIT;
LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should pass COMMIT;
LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail ROLLBACK;
LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail ROLLBACK;
LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail ROLLBACK;
LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail ROLLBACK;
LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should pass COMMIT;
LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should fail ROLLBACK;
LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass COMMIT;
LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass COMMIT;
LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass COMMIT;
LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass COMMIT;
LOCK TABLE lock_tbl1 * IN ACCESS EXCLUSIVE MODE;
LOCK TABLE lock_tbl1 * IN ACCESS EXCLUSIVE MODE;
LOCK TABLE lock_tbl1 IN ACCESS EXCLUSIVE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN ACCESS EXCLUSIVE MODE;
LOCK TABLE lock_tbl1 IN ACCESS SHARE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN ACCESS SHARE MODE;
LOCK TABLE lock_tbl1 IN EXCLUSIVE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN EXCLUSIVE MODE;
LOCK TABLE lock_tbl1 IN ROW EXCLUSIVE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN ROW EXCLUSIVE MODE;
LOCK TABLE lock_tbl1 IN ROW SHARE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN SHARE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN SHARE MODE;
LOCK TABLE lock_tbl1 IN SHARE ROW EXCLUSIVE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN SHARE UPDATE EXCLUSIVE MODE NOWAIT;
LOCK TABLE lock_tbl1 IN SHARE UPDATE EXCLUSIVE MODE;
LOCK TABLE lock_tbl2;
LOCK TABLE lock_view1 IN EXCLUSIVE MODE;
LOCK TABLE lock_view2 IN EXCLUSIVE MODE;
LOCK TABLE lock_view2 IN EXCLUSIVE MODE;
LOCK TABLE lock_view3 IN EXCLUSIVE MODE;
LOCK TABLE lock_view4 IN EXCLUSIVE MODE;
LOCK TABLE lock_view5 IN EXCLUSIVE MODE;
LOCK TABLE lock_view6 IN EXCLUSIVE MODE;
LOCK TABLE lock_view7 IN EXCLUSIVE MODE;
LOCK atest1 IN ACCESS EXCLUSIVE MODE;
LOCK atest2 IN ACCESS EXCLUSIVE MODE; -- fail COMMIT;
LOCK atest2 IN ACCESS EXCLUSIVE MODE; -- ok COMMIT;
LOCK atestc;
LOCK atestp1;
LOCK hs1 IN ACCESS EXCLUSIVE MODE;
LOCK hs1 IN ACCESS SHARE MODE;
LOCK hs1 IN EXCLUSIVE MODE;
LOCK hs1 IN ROW EXCLUSIVE MODE;
LOCK hs1 IN ROW SHARE MODE;
LOCK hs1 IN SHARE MODE;
LOCK hs1 IN SHARE ROW EXCLUSIVE MODE;
LOCK hs1 IN SHARE UPDATE EXCLUSIVE MODE;
LOCK hs1;
LOCK lock_tbl1 IN ROW SHARE MODE;
LOCK lock_tbl1 IN SHARE ROW EXCLUSIVE MODE;
MOVE BACKWARD 10000 FROM c;
MOVE BACKWARD ALL FROM c;
MOVE BACKWARD ALL IN c1;
MOVE BACKWARD ALL IN xc;
MOVE FORWARD ALL FROM c;
NOTIFY notify_async2;
PERFORM perform_simple_func(5);
PERFORM perform_simple_func(50);
PREPARE TRANSACTION 'foo1';
PREPARE TRANSACTION 'foo2';
PREPARE TRANSACTION 'foo3';
PREPARE TRANSACTION 'foo3';
PREPARE TRANSACTION 'foo4';
PREPARE TRANSACTION 'foo5';
PREPARE TRANSACTION 'foo6';  -- fails BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
PREPARE TRANSACTION 'foobar';
PREPARE TRANSACTION 'foobar';
PREPARE TRANSACTION 'regress-one';
PREPARE TRANSACTION 'regress-two';
PREPARE TRANSACTION 'twophase_search';
REASSIGN OWNED BY regress_dep_user0 TO regress_dep_user1;
REASSIGN OWNED BY regress_dep_user1 TO regress_dep_user0;
REASSIGN OWNED BY regress_dep_user1 TO regress_dep_user2;
REASSIGN OWNED BY regress_test_role TO regress_test_role2;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_boxmv;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv_foo;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv_v;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tm;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tvmm WITH NO DATA;
REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tvmm;
REFRESH MATERIALIZED VIEW matview_schema.mv_nodata2;
REFRESH MATERIALIZED VIEW matview_schema.mv_withdata2;
REFRESH MATERIALIZED VIEW mvtest_mv;
REFRESH MATERIALIZED VIEW mvtest_mv;
REFRESH MATERIALIZED VIEW mvtest_mv_foo;
REFRESH MATERIALIZED VIEW mvtest_mv_v;
REFRESH MATERIALIZED VIEW mvtest_mv_v_2;
REFRESH MATERIALIZED VIEW mvtest_mv_v_3;
REFRESH MATERIALIZED VIEW mvtest_mv_v_4;
REFRESH MATERIALIZED VIEW mvtest_tm;
REFRESH MATERIALIZED VIEW mvtest_tmm;
REFRESH MATERIALIZED VIEW mvtest_tvm;
REFRESH MATERIALIZED VIEW mvtest_tvmm;
REFRESH MATERIALIZED VIEW mvtest_tvvm;
REFRESH MATERIALIZED VIEW sro_mv;
REFRESH MATERIALIZED VIEW sro_mv;
REFRESH MATERIALIZED VIEW tid_matview;
REINDEX INDEX CONCURRENTLY  concur_reindex_tab3_c2_excl;  -- error REINDEX TABLE CONCURRENTLY concur_reindex_tab3;  -- succeeds with warning INSERT INTO concur_reindex_tab3 VALUES  (4, '[2,4]');
REINDEX INDEX CONCURRENTLY concur_reindex_ind1;
REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
REINDEX INDEX CONCURRENTLY concur_reindex_part_index;
REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_1;
REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_2;
REINDEX INDEX CONCURRENTLY concur_temp_ind_1;
REINDEX INDEX CONCURRENTLY concur_temp_ind_1;
REINDEX INDEX CONCURRENTLY concur_temp_ind_2;
REINDEX INDEX CONCURRENTLY concur_temp_ind_3;
REINDEX INDEX concur_reindex_part; -- error REINDEX INDEX CONCURRENTLY concur_reindex_part; -- error REINDEX INDEX concur_reindex_part_10; -- error REINDEX INDEX CONCURRENTLY concur_reindex_part_10; -- error BEGIN;
REINDEX INDEX concur_reindex_part_index;
REINDEX INDEX concur_reindex_part_index;
REINDEX INDEX hash_split_index;
REINDEX INDEX pg_class_oid_index; -- mapped, non-shared, critical REINDEX INDEX pg_class_relname_nsp_index; -- mapped, non-shared, non-critical REINDEX INDEX pg_index_indexrelid_index; -- non-mapped, non-shared, critical REINDEX INDEX pg_index_indrelid_index; -- non-mapped, non-shared, non-critical REINDEX INDEX pg_database_oid_index; -- mapped, shared, critical REINDEX INDEX pg_shdescription_o_c_index; -- mapped, shared, non-critical ROLLBACK;
REINDEX INDEX pg_toast.pg_toast_1260_index;
REINDEX INDEX tbl_c1_c2_c3_c4_key;
REINDEX INDEX tbl_gist_idx;
REINDEX INDEX unlogged1_pkey;
REINDEX INDEX unlogged2_pkey;
REINDEX SCHEMA CONCURRENTLY schema_to_reindex;
REINDEX SCHEMA schema_to_reindex;
REINDEX SCHEMA schema_to_reindex;
REINDEX SCHEMA schema_to_reindex;
REINDEX SCHEMA schema_to_reindex; -- failure, cannot run in a transaction END;
REINDEX SCHEMA schema_to_reindex; -- failure, schema does not exist CREATE SCHEMA schema_to_reindex;
REINDEX TABLE CONCURRENTLY concur_appclass_tab;
REINDEX TABLE CONCURRENTLY concur_clustered;
REINDEX TABLE CONCURRENTLY concur_exprs_tab;
REINDEX TABLE CONCURRENTLY concur_reindex_matview;
REINDEX TABLE CONCURRENTLY concur_reindex_part;
REINDEX TABLE CONCURRENTLY concur_reindex_part_0_1;
REINDEX TABLE CONCURRENTLY concur_reindex_part_0_2;
REINDEX TABLE CONCURRENTLY concur_reindex_tab4;
REINDEX TABLE CONCURRENTLY concur_reindex_tab;
REINDEX TABLE CONCURRENTLY concur_reindex_tab;
REINDEX TABLE CONCURRENTLY concur_replident;
REINDEX TABLE CONCURRENTLY concur_temp_tab_1;
REINDEX TABLE CONCURRENTLY concur_temp_tab_2;
REINDEX TABLE CONCURRENTLY pg_class; -- no catalog relation REINDEX INDEX CONCURRENTLY pg_class_oid_index; -- no catalog index REINDEX TABLE CONCURRENTLY pg_toast.pg_toast_1260; -- no catalog toast table REINDEX INDEX CONCURRENTLY pg_toast.pg_toast_1260_index; -- no catalog toast index REINDEX SYSTEM CONCURRENTLY postgres; -- not allowed for SYSTEM REINDEX SCHEMA CONCURRENTLY pg_catalog;
REINDEX TABLE CONCURRENTLY testcomment ;
REINDEX TABLE concur_heap;
REINDEX TABLE concur_heap;
REINDEX TABLE concur_reindex_part;
REINDEX TABLE concur_reindex_part;
REINDEX TABLE concur_reindex_part_index; -- error REINDEX TABLE CONCURRENTLY concur_reindex_part_index; -- error REINDEX TABLE concur_reindex_part_index_10; -- error REINDEX TABLE CONCURRENTLY concur_reindex_part_index_10; -- error BEGIN;
REINDEX TABLE concur_reindex_tab; -- notice REINDEX (CONCURRENTLY) TABLE concur_reindex_tab; -- notice ALTER TABLE concur_reindex_tab ADD COLUMN c2 text; -- add toast index CREATE UNIQUE INDEX concur_reindex_ind1 ON concur_reindex_tab(c1);
REINDEX TABLE hs2;
REINDEX TABLE pg_class; -- mapped, non-shared, critical REINDEX TABLE pg_index; -- non-mapped, non-shared, critical REINDEX TABLE pg_operator; -- non-mapped, non-shared, critical REINDEX TABLE pg_database; -- mapped, shared, critical REINDEX TABLE pg_shdescription; -- mapped, shared non-critical REINDEX INDEX pg_class_oid_index; -- mapped, non-shared, critical REINDEX INDEX pg_class_relname_nsp_index; -- mapped, non-shared, non-critical REINDEX INDEX pg_index_indexrelid_index; -- non-mapped, non-shared, critical REINDEX INDEX pg_index_indrelid_index; -- non-mapped, non-shared, non-critical REINDEX INDEX pg_database_oid_index; -- mapped, shared, critical REINDEX INDEX pg_shdescription_o_c_index; -- mapped, shared, non-critical BEGIN;
REINDEX TABLE pg_toast.pg_toast_1260;
REINDEX TABLE testcomment;
RESET TIME ZONE;
RESET TIME ZONE;
RETURN NEXT retval;
RETURN NEXT retval;
RETURN NEXT retval;
RETURN NEXT retval;
RETURN NULL;
RETURN TRUE;
RETURN retval;
RETURN retval;
RETURN rslt;
RETURN;
RETURN;
RETURN;
RETURN;
RETURN;
REVOKE ALL ON FUNCTION int8(integer) FROM PUBLIC;
SECURITY LABEL ON TABLE seclabel_tbl1 IS 'classified';			-- fail SECURITY LABEL FOR 'dummy' ON TABLE seclabel_tbl1 IS 'classified';		-- fail SECURITY LABEL ON TABLE seclabel_tbl1 IS '...invalid label...';		-- fail SECURITY LABEL ON TABLE seclabel_tbl3 IS 'unclassified';			-- fail SECURITY LABEL ON ROLE regress_seclabel_user1 IS 'classified';			-- fail SECURITY LABEL FOR 'dummy' ON ROLE regress_seclabel_user1 IS 'classified';		-- fail SECURITY LABEL ON ROLE regress_seclabel_user1 IS '...invalid label...';		-- fail SECURITY LABEL ON ROLE regress_seclabel_user3 IS 'unclassified';			-- fail DROP FUNCTION seclabel_four();
SELECT 	i::text || ':' || COALESCE(v::text, 'NULL') as row, 	logging_agg_strict(v::text) 		over wnd as inverse, 	logging_agg_strict(v::text || CASE WHEN random() < 0 then '?' ELSE '' END) 		over wnd as noinverse FROM (VALUES 	(1, 'a'), 	(2, 'b'), 	(3, 'c') ) AS t(i, v) WINDOW wnd AS (ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) ORDER BY i;
SELECT 	i::text || ':' || COALESCE(v::text, 'NULL') as row, 	logging_agg_strict(v::text) filter(where true) 		over wnd as inverse, 	logging_agg_strict(v::text) filter(where random() >= 0) 		over wnd as noinverse FROM (VALUES 	(1, 'a'), 	(2, 'b'), 	(3, 'c') ) AS t(i, v) WINDOW wnd AS (ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) ORDER BY i;
SELECT 	p::text || ',' || i::text || ':' || 		CASE WHEN f THEN COALESCE(v::text, 'NULL') ELSE '-' END as row, 	logging_agg_nonstrict(v) filter(where f) over wnd as nstrict_filt, 	logging_agg_nonstrict_initcond(v) filter(where f) over wnd as nstrict_init_filt, 	logging_agg_strict(v::text) filter(where f) over wnd as strict_filt, 	logging_agg_strict_initcond(v) filter(where f) over wnd as strict_init_filt FROM (VALUES 	(1, 1, true,  NULL), 	(1, 2, false, 'a'), 	(1, 3, true,  'b'), 	(1, 4, false, NULL), 	(1, 5, false, NULL), 	(1, 6, false, 'c'), 	(2, 1, false, NULL), 	(2, 2, true,  'x'), 	(3, 1, true,  'z') ) AS t(p, i, f, v) WINDOW wnd AS (PARTITION BY p ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) ORDER BY p, i;
SELECT 	p::text || ',' || i::text || ':' || COALESCE(v::text, 'NULL') AS row, 	logging_agg_nonstrict(v) over wnd as nstrict, 	logging_agg_nonstrict_initcond(v) over wnd as nstrict_init, 	logging_agg_strict(v::text) over wnd as strict, 	logging_agg_strict_initcond(v) over wnd as strict_init FROM (VALUES 	(1, 1, NULL), 	(1, 2, 'a'), 	(1, 3, 'b'), 	(1, 4, NULL), 	(1, 5, NULL), 	(1, 6, 'c'), 	(2, 1, NULL), 	(2, 2, 'x'), 	(3, 1, 'z') ) AS t(p, i, v) WINDOW wnd AS (PARTITION BY P ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) ORDER BY p, i;
SELECT   (SELECT n      FROM (VALUES (1)) AS x,           (SELECT n FROM generate_series(1,10) AS n              ORDER BY n LIMIT 1 OFFSET s-1) AS y) AS z   FROM generate_series(1,10) AS s;
SELECT   str,   interval,   date_trunc(str, ts) = date_bin(interval::interval, ts, timestamp '0055-06-17 BC') AS equal FROM (   VALUES   ('week', '7 d'),   ('day', '1 d'),   ('hour', '1 h'),   ('minute', '1 m'),   ('second', '1 s'),   ('millisecond', '1 ms'),   ('microsecond', '1 us') ) intervals (str, interval), (VALUES (timestamp '0055-6-10 15:44:17.71393 BC')) ts (ts);
SELECT   str,   interval,   date_trunc(str, ts) = date_bin(interval::interval, ts, timestamp '2000-01-01 BC') AS equal FROM (   VALUES   ('week', '7 d'),   ('day', '1 d'),   ('hour', '1 h'),   ('minute', '1 m'),   ('second', '1 s'),   ('millisecond', '1 ms'),   ('microsecond', '1 us') ) intervals (str, interval), (VALUES (timestamp '0055-6-10 15:44:17.71393 BC')) ts (ts);
SELECT   str,   interval,   date_trunc(str, ts) = date_bin(interval::interval, ts, timestamp '2001-01-01') AS equal FROM (   VALUES   ('week', '7 d'),   ('day', '1 d'),   ('hour', '1 h'),   ('minute', '1 m'),   ('second', '1 s'),   ('millisecond', '1 ms'),   ('microsecond', '1 us') ) intervals (str, interval), (VALUES (timestamp '2020-02-29 15:44:17.71393')) ts (ts);
SELECT   str,   interval,   date_trunc(str, ts) = date_bin(interval::interval, ts, timestamp '2020-03-02') AS equal FROM (   VALUES   ('week', '7 d'),   ('day', '1 d'),   ('hour', '1 h'),   ('minute', '1 m'),   ('second', '1 s'),   ('millisecond', '1 ms'),   ('microsecond', '1 us') ) intervals (str, interval), (VALUES (timestamp '2020-02-29 15:44:17.71393')) ts (ts);
SELECT  thousand 		FROM onek WHERE thousand < 5 		ORDER BY thousand FETCH FIRST 1 ROW WITH TIES FOR UPDATE SKIP LOCKED;
SELECT  thousand 		FROM onek WHERE thousand < 5 		ORDER BY thousand FETCH FIRST 1 ROW WITH TIES;
SELECT  thousand 		FROM onek WHERE thousand < 5 		ORDER BY thousand FETCH FIRST 2 ROW ONLY;
SELECT  thousand 		FROM onek WHERE thousand < 5 		ORDER BY thousand FETCH FIRST 2 ROW WITH TIES;
SELECT  thousand 		FROM onek WHERE thousand < 5 		ORDER BY thousand FETCH FIRST ROWS WITH TIES;
SELECT '    08:00:2b:01:02:03     '::macaddr8;
SELECT '    08:00:2b:01:02:03'::macaddr8;
SELECT '    08:00:2b:01:02:03:04:05     '::macaddr8;
SELECT '    08:00:2b:01:02:03:04:05'::macaddr8;
SELECT '    true   '::text::boolean AS true,        '     FALSE'::text::boolean AS false;
SELECT ' 1 '::tsquery;
SELECT ' 1 '::tsvector;
SELECT ' 1'::tsquery;
SELECT ' 1'::tsvector;
SELECT '!!!b'::tsquery;
SELECT '!!a & !!b'::tsquery;
SELECT '!!a & b'::tsquery;
SELECT '!!b'::tsquery;
SELECT '!(!1|!2)'::tsquery;
SELECT '!(!1|2)'::tsquery;
SELECT '!(!b)'::tsquery;
SELECT '!(1&2)'::tsquery;
SELECT '!(1)&2'::tsquery;
SELECT '!(1|!2)'::tsquery;
SELECT '!(1|2)&3'::tsquery;
SELECT '!(1|2)'::tsquery;
SELECT '!1&!2'::tsquery;
SELECT '!1&2'::tsquery;
SELECT '!1'::tsquery;
SELECT '!1|!2'::tsquery;
SELECT '!1|(2&3)'::tsquery;
SELECT '!1|2&3'::tsquery;
SELECT '!1|2'::tsquery;
SELECT '''1 2'''::tsquery;
SELECT '''1 2'''::tsvector;
SELECT ''::text AS two, unique1, unique2, stringu1 		FROM onek WHERE unique1 > 50 		FETCH FIRST 2 ROW WITH TIES;
SELECT '(!1|2)&3'::tsquery;
SELECT '($123,456.78)'::money;
SELECT '(1&2)'::tsquery;
SELECT '(1)'::money;
SELECT '(1|2)&3'::tsquery;
SELECT '-12345'::money;
SELECT '-1234567890'::money;
SELECT '-12345678901234567'::money::numeric;
SELECT '-12345678901234567'::money;
SELECT '-123456789012345678'::money;
SELECT '-92233720368547758.08'::money::numeric;
SELECT '-92233720368547758.08'::money;
SELECT '-92233720368547758.085'::money;
SELECT '-92233720368547758.09'::money;
SELECT '-9223372036854775808'::money;
SELECT '08:00:2b:01:02:03     '::macaddr8;
SELECT '08:00:2b:01:02:03:04:05     '::macaddr8;
SELECT '1 '::tsquery;
SELECT '1 '::tsvector;
SELECT '1 2'::tsvector;
SELECT '1&!2'::tsquery;
SELECT '1&(2&(4&(5&6)))'::tsquery;
SELECT '1&(2&(4&(5|!6)))'::tsquery;
SELECT '1&(2&(4&(5|6)))'::tsquery;
SELECT '1&(2)'::tsquery;
SELECT '1&2&4&5&6'::tsquery;
SELECT '1&2'::tsquery;
SELECT '1'::tsvector;
SELECT '123    08:00:2b:01:02:03'::macaddr8; -- invalid SELECT '08:00:2b:01:02:03  123'::macaddr8; -- invalid SELECT '123    08:00:2b:01:02:03:04:05'::macaddr8; -- invalid SELECT '08:00:2b:01:02:03:04:05  123'::macaddr8; -- invalid SELECT '08:00:2b:01:02:03:04:05:06:07'::macaddr8; -- invalid SELECT '08-00-2b-01-02-03-04-05-06-07'::macaddr8; -- invalid SELECT '08002b:01020304050607'::macaddr8; -- invalid SELECT '08002b01020304050607'::macaddr8; -- invalid SELECT '0z002b0102030405'::macaddr8; -- invalid SELECT '08002b010203xyza'::macaddr8; -- invalid SELECT '08:00-2b:01:02:03:04:05'::macaddr8; -- invalid SELECT '08:00-2b:01:02:03:04:05'::macaddr8; -- invalid SELECT '08:00:2b:01.02:03:04:05'::macaddr8; -- invalid SELECT '08:00:2b:01.02:03:04:05'::macaddr8; -- invalid SELECT macaddr8_set7bit('00:08:2b:01:02:03'::macaddr8);
SELECT '1234567890'::money;
SELECT '12345678901234567'::money::numeric;
SELECT '12345678901234567'::money;
SELECT '123456789012345678'::money;
SELECT '126::1'::inet - '127::2'::inet;
SELECT '127.0.0.1'::inet + 10000000000;
SELECT '127.0.0.1'::inet + 257;
SELECT '127.0.0.1'::inet - 10000000000;
SELECT '127.0.0.2'::inet  - ('127.0.0.2'::inet + 500);
SELECT '127.0.0.2'::inet  - ('127.0.0.2'::inet - 500);
SELECT '127::1'::inet + 10000000000;
SELECT '127::1'::inet + 257;
SELECT '127::1'::inet - '126::2'::inet;
SELECT '127::1'::inet - '127::2'::inet;
SELECT '127::2'::inet  - ('127::2'::inet + 500);
SELECT '127::2'::inet  - ('127::2'::inet - 500);
SELECT '1|!2&3'::tsquery;
SELECT '1|!2'::tsquery;
SELECT '1|(2&3)'::tsquery;
SELECT '1|(2|(4|(5|6)))'::tsquery;
SELECT '1|2&!3'::tsquery;
SELECT '1|2&3'::tsquery;
SELECT '1|2'::tsquery;
SELECT '1|2|4|5|6'::tsquery;
SELECT '878.08'::money / 11::bigint;
SELECT '878.08'::money / 11::float4;
SELECT '878.08'::money / 11::float8;
SELECT '878.08'::money / 11::int;
SELECT '878.08'::money / 11::smallint;
SELECT '90000000000000099.00'::money / 10::bigint;
SELECT '90000000000000099.00'::money / 10::int;
SELECT '90000000000000099.00'::money / 10::smallint;
SELECT '92233720368547758.07'::money::numeric;
SELECT '92233720368547758.07'::money;
SELECT '92233720368547758.075'::money;
SELECT '92233720368547758.08'::money;
SELECT '9223372036854775807'::money;
SELECT 'TrUe'::text::boolean AS true, 'fAlse'::text::boolean AS false;
SELECT 'a & !!b'::tsquery;
SELECT 'a & g' <-> 'b & d'::tsquery;
SELECT 'a & g' <-> 'b <-> d'::tsquery;
SELECT 'a & g' <-> 'b | d'::tsquery;
SELECT 'a b:89  ca:23A,64b cb:80c d:34c'::tsvector @@ 'd:AC & c:*C' as "true";
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & c:*C' as "false";
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & c:*CB' as "true";
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca' as "true";
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:A' as "true";
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:B' as "true";
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:C' as "false";
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:CB' as "true";
SELECT 'a b:89  ca:23A,64c cb:80b d:34c'::tsvector @@ 'd:AC & c:*B' as "true";
SELECT 'a b:89  ca:23A,64c cb:80b d:34c'::tsvector @@ 'd:AC & c:*C' as "true";
SELECT 'a | f | g' < 'b & c'::tsquery as "false";
SELECT 'a | f' < 'b & c'::tsquery as "false";
SELECT 'a | ff' < 'b & c'::tsquery as "false";
SELECT 'a' < 'b & c'::tsquery as "true";
SELECT 'a' <-> 'b & d'::tsquery;
SELECT 'a' > 'b & c'::tsquery as "false";
SELECT 'a:* & nbb:*ac | doo:a* | goo'::tsquery;
SELECT 'a:1 b:2'::tsvector @@ 'a <-> b'::tsquery AS "true";
SELECT 'a:1 b:2'::tsvector @@ 'a <0> b'::tsquery AS "false";
SELECT 'a:1 b:2'::tsvector @@ 'a <1> b'::tsquery AS "true";
SELECT 'a:1 b:2'::tsvector @@ 'a <2> b'::tsquery AS "false";
SELECT 'a:1 b:3'::tsvector @@ 'a <-> b'::tsquery AS "false";
SELECT 'a:1 b:3'::tsvector @@ 'a <0> a:*'::tsquery AS "true";
SELECT 'a:1 b:3'::tsvector @@ 'a <0> b'::tsquery AS "false";
SELECT 'a:1 b:3'::tsvector @@ 'a <1> b'::tsquery AS "false";
SELECT 'a:1 b:3'::tsvector @@ 'a <2> b'::tsquery AS "true";
SELECT 'a:1 b:3'::tsvector @@ 'a <3> b'::tsquery AS "false";
SELECT 'a:3A b:2a'::tsvector || 'ba:1234 a:1B';
SELECT 'a_c'::bytea LIKE 'a$__'::bytea ESCAPE '$'::bytea AS "true";
SELECT 'a_c'::bytea NOT LIKE 'a$__'::bytea ESCAPE '$'::bytea AS "false";
SELECT 'abc'::bytea LIKE '_b_'::bytea AS "true";
SELECT 'abc'::bytea NOT LIKE '_b_'::bytea AS "false";
SELECT 'abcd%' SIMILAR TO '_bcd#%' ESCAPE '#' AS true;
SELECT 'abcd\efg' SIMILAR TO '_bcd\%' ESCAPE '' AS true;
SELECT 'abcdefg' SIMILAR TO '_bcd#%' ESCAPE '#' AS false;
SELECT 'abcdefg' SIMILAR TO '_bcd%' AS true;
SELECT 'abcdefg' SIMILAR TO '_bcd%' ESCAPE NULL AS null;
SELECT 'abcdefg' SIMILAR TO '_bcd\%' AS false;
SELECT 'abcdefg' SIMILAR TO 'bcd%' AS false;
SELECT 'a' ~ U&'a\24D0' AS t;
SELECT 'a' ~ U&'a\24D1' AS f;
SELECT 'empty'::numrange && nummultirange();
SELECT 'empty'::numrange && nummultirange(numrange(1,2));
SELECT 'empty'::numrange &< nummultirange();
SELECT 'empty'::numrange &< nummultirange(numrange(1,2));
SELECT 'empty'::numrange &> nummultirange();
SELECT 'empty'::numrange &> nummultirange(numrange(1,2));
SELECT 'empty'::numrange -|- nummultirange();
SELECT 'empty'::numrange -|- nummultirange(numrange(1,2));
SELECT 'empty'::numrange <@ nummultirange();
SELECT 'foo & bar'::tsquery && 'asd | fg';
SELECT 'foo & bar'::tsquery && 'asd';
SELECT 'foo & bar'::tsquery || !!'asd & fg'::tsquery;
SELECT 'foo & bar'::tsquery || 'asd & fg';
SELECT 'supeanova supernova'::tsvector @@ 'super'::tsquery AS "false";
SELECT 'supeanova supernova'::tsvector @@ 'super:*'::tsquery AS "true";
SELECT 'supernova'::tsvector @@ 'super'::tsquery AS "false";
SELECT 'supernova'::tsvector @@ 'super:*'::tsquery AS "true";
SELECT 'supeznova supernova'::tsvector @@ 'super'::tsquery AS "false";
SELECT 'supeznova supernova'::tsvector @@ 'super:*'::tsquery AS "true";
SELECT 'wa:1A wb:2D'::tsvector @@ 'w:*D <-> w:*A'::tsquery as "false";
SELECT 'wa:1A'::tsvector @@ '!w:*A'::tsquery as "false";
SELECT 'wa:1A'::tsvector @@ '!w:*D'::tsquery as "true";
SELECT 'wa:1A'::tsvector @@ 'w:*A'::tsquery as "true";
SELECT 'wa:1A'::tsvector @@ 'w:*D'::tsquery as "false";
SELECT 'wa:1D wb:2A'::tsvector @@ 'w:*D & w:*A'::tsquery as "true";
SELECT 'wa:1D wb:2A'::tsvector @@ 'w:*D <-> w:*A'::tsquery as "true";
SELECT ('127.0.0.1'::inet + 257) - 257;
SELECT ('127::1'::inet + 257) - 257;
SELECT ((-1::int2<<15)+1::int2)::text;
SELECT ((-1::int4<<31)+1)::text;
SELECT ((-1::int8<<63)+1)::text;
SELECT (-12345)::money;
SELECT (-1234567890)::int4::money;
SELECT (-1234567890)::money;
SELECT (-12345678901234567)::int8::money;
SELECT (-12345678901234567)::money;
SELECT (-12345678901234567)::numeric::money;
SELECT (-1::int2<<15)::text;
SELECT (-1::int4<<31)::text;
SELECT (-1::int8<<63)::text;
SELECT (@@ f1) AS center    FROM POLYGON_TBL    WHERE (# f1) > 2;
SELECT (SELECT generate_series(1,3) LIMIT 1 OFFSET few.id) FROM few;
SELECT (SELECT generate_series(1,3) LIMIT 1 OFFSET g.i) FROM generate_series(0,3) g(i);
SELECT (SELECT p FROM kd_point_tbl ORDER BY p <-> pt, p <-> '0,0' LIMIT 1) FROM (VALUES (point '1,2'), (NULL), ('1234,5678')) pts(pt);
SELECT (json_populate_record(NULL::jsrec, js)).* FROM jspoptest;
SELECT (jsonb_populate_record(NULL::jsbrec, js)).* FROM jsbpoptest;
SELECT (time '00:00', interval '1 hour')   OVERLAPS (time '00:30', interval '1 hour') AS "True";
SELECT (time '00:00', interval '1 hour')   OVERLAPS (time '01:30', interval '1 day') AS "False";
SELECT (time '00:00', interval '1 hour')   OVERLAPS (time '01:30', interval '1 hour') AS "False";
SELECT (time '00:00', time '01:00')   OVERLAPS (time '00:30', time '01:30') AS "True";
SELECT (timestamp with time zone '2000-11-26', timestamp with time zone '2000-11-27')   OVERLAPS (timestamp with time zone '2000-11-27 12:00', timestamp with time zone '2000-11-30') AS "False";
SELECT (timestamp with time zone '2000-11-27', interval '12 hours')   OVERLAPS (timestamp with time zone '2000-11-27 12:00', interval '12 hours') AS "False";
SELECT (timestamp with time zone '2000-11-27', interval '12 hours')   OVERLAPS (timestamp with time zone '2000-11-27 12:00', timestamp with time zone '2000-11-30') AS "False";
SELECT (timestamp with time zone '2000-11-27', interval '12 hours')   OVERLAPS (timestamp with time zone '2000-11-27', interval '12 hours') AS "True";
SELECT (timestamp with time zone '2000-11-27', timestamp with time zone '2000-11-28')   OVERLAPS (timestamp with time zone '2000-11-27 12:00', interval '1 day') AS "True";
SELECT (timestamp with time zone '2000-11-27', timestamp with time zone '2000-11-28')   OVERLAPS (timestamp with time zone '2000-11-27 12:00', timestamp with time zone '2000-11-30') AS "True";
SELECT (timestamp with time zone 'today' = (timestamp with time zone 'tomorrow' - interval '1 day')) as "True";
SELECT (timestamp with time zone 'today' = (timestamp with time zone 'yesterday' + interval '1 day')) as "True";
SELECT (timestamp with time zone 'tomorrow' = (timestamp with time zone 'yesterday' + interval '2 days')) as "True";
SELECT (timestamp with time zone 'tomorrow' > 'now') as "True";
SELECT (timestamp without time zone '10:30 today' = (timestamp without time zone 'yesterday' + interval '1 day 10 hr 30 min')) as "True";
SELECT (timestamp without time zone '12:34:56 yesterday' = (timestamp without time zone 'tomorrow' - interval '2 days - 12:34:56')) as "True";
SELECT (timestamp without time zone '16:00:00 tomorrow' = (timestamp without time zone 'today' + interval '1 day 16 hours')) as "True";
SELECT (timestamp without time zone '2000-11-26', timestamp without time zone '2000-11-27')   OVERLAPS (timestamp without time zone '2000-11-27 12:00', timestamp without time zone '2000-11-30') AS "False";
SELECT (timestamp without time zone '2000-11-27', interval '12 hours')   OVERLAPS (timestamp without time zone '2000-11-27 12:00', interval '12 hours') AS "False";
SELECT (timestamp without time zone '2000-11-27', interval '12 hours')   OVERLAPS (timestamp without time zone '2000-11-27 12:00', timestamp without time zone '2000-11-30') AS "False";
SELECT (timestamp without time zone '2000-11-27', interval '12 hours')   OVERLAPS (timestamp without time zone '2000-11-27', interval '12 hours') AS "True";
SELECT (timestamp without time zone '2000-11-27', timestamp without time zone '2000-11-28')   OVERLAPS (timestamp without time zone '2000-11-27 12:00', interval '1 day') AS "True";
SELECT (timestamp without time zone '2000-11-27', timestamp without time zone '2000-11-28')   OVERLAPS (timestamp without time zone '2000-11-27 12:00', timestamp without time zone '2000-11-30') AS "True";
SELECT (timestamp without time zone 'today 10:30' = (timestamp without time zone 'yesterday' + interval '1 day 10 hr 30 min')) as "True";
SELECT (timestamp without time zone 'today' = (timestamp without time zone 'tomorrow' - interval '1 day')) as "True";
SELECT (timestamp without time zone 'today' = (timestamp without time zone 'yesterday' + interval '1 day')) as "True";
SELECT (timestamp without time zone 'tomorrow 16:00:00' = (timestamp without time zone 'today' + interval '1 day 16 hours')) as "True";
SELECT (timestamp without time zone 'tomorrow' = (timestamp without time zone 'yesterday' + interval '2 days')) as "True";
SELECT (timestamp without time zone 'tomorrow' > 'now') as "True";
SELECT (timestamp without time zone 'yesterday 12:34:56' = (timestamp without time zone 'tomorrow' - interval '2 days - 12:34:56')) as "True";
SELECT *    FROM arrtest    WHERE a[1] < 5 and          c = '{"foobar"}'::_name;
SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN ROWS FROM( rngfunc_sql(11,13), rngfunc_mat(11,13) ) WITH ORDINALITY AS f(i1,s1,i2,s2,o) ON (r+i1+i2)<100;
SELECT * FROM (VALUES (1),(2),(3)) v(r), ROWS FROM( rngfunc_sql(10+r,13), rngfunc_mat(10+r,13) );
SELECT * FROM (VALUES (1),(2),(3)) v(r), ROWS FROM( rngfunc_sql(10+r,13), rngfunc_mat(11,11) );
SELECT * FROM (VALUES (1),(2),(3)) v(r), ROWS FROM( rngfunc_sql(11,11), rngfunc_mat(10+r,13) );
SELECT * FROM INTERVAL_TBL    WHERE INTERVAL_TBL.f1 < interval '@ 1 day';
SELECT * FROM INTERVAL_TBL    WHERE INTERVAL_TBL.f1 <= interval '@ 5 hours';
SELECT * FROM INTERVAL_TBL    WHERE INTERVAL_TBL.f1 <> interval '@ 10 days';
SELECT * FROM INTERVAL_TBL    WHERE INTERVAL_TBL.f1 = interval '@ 34 years';
SELECT * FROM INTERVAL_TBL    WHERE INTERVAL_TBL.f1 > interval '@ 3 seconds ago';
SELECT * FROM INTERVAL_TBL    WHERE INTERVAL_TBL.f1 >= interval '@ 1 month';
SELECT * FROM ROWS FROM(get_users(), generate_series(10,11)) WITH ORDINALITY;
SELECT * FROM XMLTABLE('*' PASSING '<a>a</a>' COLUMNS a xml PATH '.', b text PATH '.', c text PATH '"hi"', d boolean PATH '. = "a"', e integer PATH 'string-length(.)');
SELECT * FROM XMLTABLE('.'                        PASSING '<foo/>'                        COLUMNS a text PATH 'foo/namespace::node()');
SELECT * FROM XMLTABLE(XMLNAMESPACES('http://x.y' AS zz),                       '/zz:rows/zz:row'                       PASSING '<rows xmlns="http://x.y"><row><a>10</a></row></rows>'                       COLUMNS a int PATH 'zz:a');
SELECT * FROM XMLTABLE(XMLNAMESPACES(DEFAULT 'http://x.y'),                       '/rows/row'                       PASSING '<rows xmlns="http://x.y"><row><a>10</a></row></rows>'                       COLUMNS a int PATH 'a');
SELECT * FROM box_temp WHERE f1 &< '(10,4.333334),(5,100)';
SELECT * FROM box_temp WHERE f1 &<| '(10,4.3333334),(5,1)';
SELECT * FROM box_temp WHERE f1 &> '(40,30),(45,50)';
SELECT * FROM box_temp WHERE f1 << '(10,20),(30,40)';
SELECT * FROM box_temp WHERE f1 <<| '(10,4.33334),(5,100)';
SELECT * FROM box_temp WHERE f1 >> '(30,40),(40,30)';
SELECT * FROM box_temp WHERE f1 |&> '(49.99,49.99),(49.99,49.99)';
SELECT * FROM box_temp WHERE f1 |>> '(37,38),(39,40)';
SELECT * FROM box_temp WHERE f1 ~= '(20,20),(40,40)';
SELECT * FROM circle_tbl WHERE f1 && circle(point(1,-2), 1)     ORDER BY area(f1);
SELECT * FROM circle_tbl WHERE f1 && circle(point(1,-2), 1)     ORDER BY area(f1);
SELECT * FROM fast_emp4000     WHERE home_base <@ '(200,200),(2000,1000)'::box     ORDER BY (home_base[0])[0];
SELECT * FROM fast_emp4000     WHERE home_base <@ '(200,200),(2000,1000)'::box     ORDER BY (home_base[0])[0];
SELECT * FROM fast_emp4000     WHERE home_base <@ '(200,200),(2000,1000)'::box     ORDER BY (home_base[0])[0];
SELECT * FROM generate_series(1,2) r1, generate_series(r1,3) r2, ROWS FROM( rngfunc_sql(10+r1,13), rngfunc_mat(10+r2,13) );
SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
SELECT * FROM inet_tbl WHERE '192.168.1.0/24'::cidr >> i;
SELECT * FROM inet_tbl WHERE '192.168.1.0/24'::cidr >>= i;
SELECT * FROM inet_tbl WHERE i && '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i && '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i < '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i < '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i << '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i << '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i <<= '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i <<= '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i <= '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i <= '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i <> '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i <> '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i = '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i = '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i > '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i > '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i >= '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i >= '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i >> '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i >> '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i >>= '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i >>= '192.168.1.0/24'::cidr ORDER BY i;
SELECT * FROM inet_tbl WHERE i<<'192.168.1.0/24'::cidr;
SELECT * FROM inet_tbl WHERE i<<='192.168.1.0/24'::cidr;
SELECT * FROM nummultirange_test WHERE multirange_contains_range(nmr, numrange(4.0, 4.2));
SELECT * FROM nummultirange_test WHERE multirange_overlaps_multirange(nmr, nummultirange(numrange(4.0, 4.2), numrange(6.0, 7.0)));
SELECT * FROM nummultirange_test WHERE multirange_overlaps_range(nmr, numrange(4.0, 4.2));
SELECT * FROM nummultirange_test WHERE nmr && nummultirange(numrange(4.0, 4.2), numrange(6.0, 7.0));
SELECT * FROM nummultirange_test WHERE nmr && nummultirange(numrange(6.0, 7.0));
SELECT * FROM nummultirange_test WHERE nmr && nummultirange(numrange(6.0, 7.0), numrange(8.0, 9.0));
SELECT * FROM nummultirange_test WHERE nmr && numrange(4.0, 4.2);
SELECT * FROM nummultirange_test WHERE numrange(4.0, 4.2) && nmr;
SELECT * FROM nummultirange_test WHERE numrange(4.0, 4.2) <@ nmr;
SELECT * FROM nummultirange_test WHERE range_contained_by_multirange(numrange(4.0, 4.2), nmr);
SELECT * FROM nummultirange_test WHERE range_overlaps_multirange(numrange(4.0, 4.2), nmr);
SELECT * FROM numrange_test WHERE range_contained_by(numrange(-1e7,-10000.1), nr);
SELECT * FROM numrange_test WHERE range_contains(nr, numrange(1.9,1.91));
SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
SELECT * FROM polygon_tbl WHERE f1 @> '((1,1),(2,2),(2,1))'::polygon     ORDER BY (poly_center(f1))[0];
SELECT * FROM polygon_tbl WHERE f1 @> '((1,1),(2,2),(2,1))'::polygon     ORDER BY (poly_center(f1))[0];
SELECT * FROM rank() OVER (ORDER BY random());
SELECT * FROM rls_tbl WHERE a <<< 1000;
SELECT * FROM tststats.priv_test_tbl WHERE a <<< 0 AND b <<< 0; -- Permission denied DELETE FROM tststats.priv_test_tbl WHERE a <<< 0 AND b <<< 0; -- Permission denied RESET SESSION AUTHORIZATION;
SELECT * FROM tststats.priv_test_tbl WHERE a <<< 0 AND b <<< 0; -- Should not leak DELETE FROM tststats.priv_test_tbl WHERE a <<< 0 AND b <<< 0; -- Should not leak DROP OPERATOR <<< (int, int);
SELECT * FROM tststats.priv_test_view WHERE a <<< 0 AND b <<< 0; -- Should not leak DELETE FROM tststats.priv_test_view WHERE a <<< 0 AND b <<< 0; -- Should not leak RESET SESSION AUTHORIZATION;
SELECT * FROM unnest('base hidden rebel spaceship strike'::tsvector);
SELECT * FROM unnest('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);
SELECT * FROM xmltable('/root' passing '<root><element>a1a<!-- aaaa -->a2a<?aaaaa?> <!--z-->  bbbb<x>xxx</x>cccc</element></root>' COLUMNS element text PATH 'element/text()'); -- should fail select * from xmltable('d/r' passing '<d><r><c><![CDATA[<hello> &"<>!<a>foo</a>]]></c></r><r><c>2</c></r></d>' columns c text);
SELECT 1 LIMIT generate_series(1,3);
SELECT 10 !=-;
SELECT 12345678901234567::int8::money;
SELECT 12345678901234567::money;
SELECT 12345678901234567::numeric::money;
SELECT 1234567890::int4::money;
SELECT 1234567890::money;
SELECT 1\; BEGIN\; SAVEPOINT sp\; ROLLBACK TO SAVEPOINT sp\; COMMIT;
SELECT 1\; COMMIT\; SAVEPOINT sp;
SELECT 1\; COMMIT\; VACUUM;
SELECT 1\; SAVEPOINT sp;
SELECT 1\; SELECT 2\; SELECT 3;
SELECT 2 !=-- comment to be removed by psql   1;
SELECT 2\; RELEASE SAVEPOINT sp\; SELECT 3;
SELECT CAST('42' AS text COLLATE "C");
SELECT CAST('42' AS text COLLATE "C");
SELECT CAST('42' AS text COLLATE "C");
SELECT CAST(CAST(date 'today' + time with time zone '05:30'             + interval '02:01' AS time with time zone) AS time) AS "07:31:00";
SELECT CAST(cast(date 'today' + time with time zone '03:30'   + interval '1 month 04:01' as timestamp without time zone) AS time) AS "07:31:00";
SELECT CAST(interval '02:03' AS time with time zone) AS "02:03:00-08";
SELECT CAST(interval '02:03' AS time) AS "02:03:00";
SELECT CAST(time '01:02' AS interval) AS "+01:02";
SELECT CAST(time with time zone '01:02-08' AS interval) AS "+00:01";
SELECT COUNT(*) FROM point_gist_tbl WHERE f1 <@ '(0.0000009,0.0000009),(0.0000009,0.0000009)'::box;
SELECT COUNT(*) FROM point_gist_tbl WHERE f1 <@ '(0.0000009,0.0000009),(0.0000009,0.0000009)'::box;
SELECT COUNT(*) FROM point_gist_tbl WHERE f1 ~= '(0.0000009,0.0000009)'::point;
SELECT COUNT(*) FROM point_gist_tbl WHERE f1 ~= '(0.0000009,0.0000009)'::point;
SELECT COUNT(*) FROM point_gist_tbl WHERE f1 ~= '(0.0000018,0.0000018)'::point;
SELECT COUNT(*) FROM point_gist_tbl WHERE f1 ~= '(0.0000018,0.0000018)'::point;
SELECT DATE_TRUNC('MILLENNIUM', TIMESTAMP '1970-03-20 04:30:00.00000'); -- 1001 SELECT DATE_TRUNC('MILLENNIUM', DATE '1970-03-20'); -- 1001-01-01 SELECT DATE_TRUNC('CENTURY', TIMESTAMP '1970-03-20 04:30:00.00000'); -- 1901 SELECT DATE_TRUNC('CENTURY', DATE '1970-03-20'); -- 1901 SELECT DATE_TRUNC('CENTURY', DATE '2004-08-10'); -- 2001-01-01 SELECT DATE_TRUNC('CENTURY', DATE '0002-02-04'); -- 0001-01-01 SELECT DATE_TRUNC('CENTURY', DATE '0055-08-10 BC'); -- 0100-01-01 BC SELECT DATE_TRUNC('DECADE', DATE '1993-12-25'); -- 1990-01-01 SELECT DATE_TRUNC('DECADE', DATE '0004-12-25'); -- 0001-01-01 BC SELECT DATE_TRUNC('DECADE', DATE '0002-12-31 BC'); -- 0011-01-01 BC select 'infinity'::date, '-infinity'::date;
SELECT DISTINCT p1.proargtypes[0]::regtype, p2.proargtypes[0]::regtype FROM pg_proc AS p1, pg_proc AS p2 WHERE p1.oid != p2.oid AND     p1.prosrc = p2.prosrc AND     p1.prolang = 12 AND p2.prolang = 12 AND     p1.prokind != 'a' AND p2.prokind != 'a' AND     p1.prosrc NOT LIKE E'range\\_constructor_' AND     p2.prosrc NOT LIKE E'range\\_constructor_' AND     p1.prosrc NOT LIKE E'multirange\\_constructor_' AND     p2.prosrc NOT LIKE E'multirange\\_constructor_' AND     (p1.proargtypes[0] < p2.proargtypes[0]) ORDER BY 1, 2;
SELECT DISTINCT p1.proargtypes[1]::regtype, p2.proargtypes[1]::regtype FROM pg_proc AS p1, pg_proc AS p2 WHERE p1.oid != p2.oid AND     p1.prosrc = p2.prosrc AND     p1.prolang = 12 AND p2.prolang = 12 AND     p1.prokind != 'a' AND p2.prokind != 'a' AND     p1.prosrc NOT LIKE E'range\\_constructor_' AND     p2.prosrc NOT LIKE E'range\\_constructor_' AND     p1.prosrc NOT LIKE E'multirange\\_constructor_' AND     p2.prosrc NOT LIKE E'multirange\\_constructor_' AND     (p1.proargtypes[1] < p2.proargtypes[1]) ORDER BY 1, 2;
SELECT DISTINCT p1.proargtypes[2]::regtype, p2.proargtypes[2]::regtype FROM pg_proc AS p1, pg_proc AS p2 WHERE p1.oid != p2.oid AND     p1.prosrc = p2.prosrc AND     p1.prolang = 12 AND p2.prolang = 12 AND     p1.prokind != 'a' AND p2.prokind != 'a' AND     (p1.proargtypes[2] < p2.proargtypes[2]) ORDER BY 1, 2;
SELECT DISTINCT p1.proargtypes[3]::regtype, p2.proargtypes[3]::regtype FROM pg_proc AS p1, pg_proc AS p2 WHERE p1.oid != p2.oid AND     p1.prosrc = p2.prosrc AND     p1.prolang = 12 AND p2.prolang = 12 AND     p1.prokind != 'a' AND p2.prokind != 'a' AND     (p1.proargtypes[3] < p2.proargtypes[3]) ORDER BY 1, 2;
SELECT DISTINCT p1.proargtypes[4]::regtype, p2.proargtypes[4]::regtype FROM pg_proc AS p1, pg_proc AS p2 WHERE p1.oid != p2.oid AND     p1.prosrc = p2.prosrc AND     p1.prolang = 12 AND p2.prolang = 12 AND     p1.prokind != 'a' AND p2.prokind != 'a' AND     (p1.proargtypes[4] < p2.proargtypes[4]) ORDER BY 1, 2;
SELECT DISTINCT p1.proargtypes[5]::regtype, p2.proargtypes[5]::regtype FROM pg_proc AS p1, pg_proc AS p2 WHERE p1.oid != p2.oid AND     p1.prosrc = p2.prosrc AND     p1.prolang = 12 AND p2.prolang = 12 AND     p1.prokind != 'a' AND p2.prokind != 'a' AND     (p1.proargtypes[5] < p2.proargtypes[5]) ORDER BY 1, 2;
SELECT DISTINCT p1.proargtypes[6]::regtype, p2.proargtypes[6]::regtype FROM pg_proc AS p1, pg_proc AS p2 WHERE p1.oid != p2.oid AND     p1.prosrc = p2.prosrc AND     p1.prolang = 12 AND p2.prolang = 12 AND     p1.prokind != 'a' AND p2.prokind != 'a' AND     (p1.proargtypes[6] < p2.proargtypes[6]) ORDER BY 1, 2;
SELECT DISTINCT p1.proargtypes[7]::regtype, p2.proargtypes[7]::regtype FROM pg_proc AS p1, pg_proc AS p2 WHERE p1.oid != p2.oid AND     p1.prosrc = p2.prosrc AND     p1.prolang = 12 AND p2.prolang = 12 AND     p1.prokind != 'a' AND p2.prokind != 'a' AND     (p1.proargtypes[7] < p2.proargtypes[7]) ORDER BY 1, 2;
SELECT E'''1 \\''2'' '' 3'' 4 '::tsvector;
SELECT E'''1 \\''2'' 3'::tsvector;
SELECT E'''1 \\''2'''::tsquery;
SELECT E'''1 \\''2'''::tsvector;
SELECT E'''1 \\''2''3'::tsvector;
SELECT E'1&(''2''&('' 4''&(\\|5 | ''6 \\'' !|&'')))'::tsquery;
SELECT E'DeAdBeEf'::bytea;
SELECT E'DeAdBeEf'::bytea;
SELECT E'De\123dBeEf'::bytea;
SELECT E'De\\000dBeEf'::bytea;
SELECT E'De\\000dBeEf'::bytea;
SELECT E'De\\123dBeEf'::bytea;
SELECT E'De\\123dBeEf'::bytea;
SELECT E'De\\678dBeEf'::bytea;
SELECT E'\\x De Ad Be Ef '::bytea;
SELECT E'\\x De Ad Be Ef '::bytea;
SELECT E'\\xDe00BeEf'::bytea;
SELECT E'\\xDe00BeEf'::bytea;
SELECT E'\\xDeAdBeE'::bytea;
SELECT E'\\xDeAdBeEf'::bytea;
SELECT E'\\xDeAdBeEf'::bytea;
SELECT E'\\xDeAdBeEx'::bytea;
SELECT EXTRACT(CENTURY       FROM DATE '2020-08-11');
SELECT EXTRACT(CENTURY FROM INTERVAL '-100 y');
SELECT EXTRACT(CENTURY FROM INTERVAL '-99 y');
SELECT EXTRACT(CENTURY FROM INTERVAL '100 y');
SELECT EXTRACT(CENTURY FROM INTERVAL '99 y');
SELECT EXTRACT(DAY           FROM DATE '2020-08-11');
SELECT EXTRACT(DAY         FROM TIME '2020-05-26 13:30:25.575401');  -- error SELECT EXTRACT(FORTNIGHT   FROM TIME '2020-05-26 13:30:25.575401');  -- error SELECT EXTRACT(TIMEZONE    FROM TIME '2020-05-26 13:30:25.575401');  -- error SELECT EXTRACT(EPOCH       FROM TIME '2020-05-26 13:30:25.575401');
SELECT EXTRACT(DAY         FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');  -- error SELECT EXTRACT(FORTNIGHT   FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');  -- error SELECT EXTRACT(TIMEZONE    FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04:30');
SELECT EXTRACT(DAY FROM DATE 'infinity');      -- NULL SELECT EXTRACT(DAY FROM DATE '-infinity');     -- NULL SELECT EXTRACT(DAY           FROM DATE 'infinity');    -- NULL SELECT EXTRACT(MONTH         FROM DATE 'infinity');    -- NULL SELECT EXTRACT(QUARTER       FROM DATE 'infinity');    -- NULL SELECT EXTRACT(WEEK          FROM DATE 'infinity');    -- NULL SELECT EXTRACT(DOW           FROM DATE 'infinity');    -- NULL SELECT EXTRACT(ISODOW        FROM DATE 'infinity');    -- NULL SELECT EXTRACT(DOY           FROM DATE 'infinity');    -- NULL SELECT EXTRACT(EPOCH FROM DATE 'infinity');         --  Infinity SELECT EXTRACT(EPOCH FROM DATE '-infinity');        -- -Infinity SELECT EXTRACT(YEAR       FROM DATE 'infinity');    --  Infinity SELECT EXTRACT(DECADE     FROM DATE 'infinity');    --  Infinity SELECT EXTRACT(CENTURY    FROM DATE 'infinity');    --  Infinity SELECT EXTRACT(MILLENNIUM FROM DATE 'infinity');    --  Infinity SELECT EXTRACT(JULIAN     FROM DATE 'infinity');    --  Infinity SELECT EXTRACT(ISOYEAR    FROM DATE 'infinity');    --  Infinity SELECT EXTRACT(EPOCH      FROM DATE 'infinity');    --  Infinity SELECT EXTRACT(MICROSEC  FROM DATE 'infinity');     -- error select make_date(2013, 7, 15);
SELECT EXTRACT(DECADE        FROM DATE '2020-08-11');
SELECT EXTRACT(DECADE FROM INTERVAL '-100 y');
SELECT EXTRACT(DECADE FROM INTERVAL '-99 y');
SELECT EXTRACT(DECADE FROM INTERVAL '99 y');
SELECT EXTRACT(DOW           FROM DATE '2020-08-11');
SELECT EXTRACT(DOW           FROM DATE '2020-08-16');
SELECT EXTRACT(DOY           FROM DATE '2020-08-11');
SELECT EXTRACT(EPOCH         FROM DATE '2020-08-11');
SELECT EXTRACT(EPOCH       FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
SELECT EXTRACT(EPOCH FROM DATE        '1970-01-01');     --  0 SELECT EXTRACT(CENTURY FROM DATE '0101-12-31 BC'); -- -2 SELECT EXTRACT(CENTURY FROM DATE '0100-12-31 BC'); -- -1 SELECT EXTRACT(CENTURY FROM DATE '0001-12-31 BC'); -- -1 SELECT EXTRACT(CENTURY FROM DATE '0001-01-01');    --  1 SELECT EXTRACT(CENTURY FROM DATE '0001-01-01 AD'); --  1 SELECT EXTRACT(CENTURY FROM DATE '1900-12-31');    -- 19 SELECT EXTRACT(CENTURY FROM DATE '1901-01-01');    -- 20 SELECT EXTRACT(CENTURY FROM DATE '2000-12-31');    -- 20 SELECT EXTRACT(CENTURY FROM DATE '2001-01-01');    -- 21 SELECT EXTRACT(CENTURY FROM CURRENT_DATE)>=21 AS True;     -- true SELECT EXTRACT(MILLENNIUM FROM DATE '0001-12-31 BC'); -- -1 SELECT EXTRACT(MILLENNIUM FROM DATE '0001-01-01 AD'); --  1 SELECT EXTRACT(MILLENNIUM FROM DATE '1000-12-31');    --  1 SELECT EXTRACT(MILLENNIUM FROM DATE '1001-01-01');    --  2 SELECT EXTRACT(MILLENNIUM FROM DATE '2000-12-31');    --  2 SELECT EXTRACT(MILLENNIUM FROM DATE '2001-01-01');    --  3 SELECT EXTRACT(MILLENNIUM FROM CURRENT_DATE);         --  3 SELECT EXTRACT(DECADE FROM DATE '1994-12-25');    -- 199 SELECT EXTRACT(DECADE FROM DATE '0010-01-01');    --   1 SELECT EXTRACT(DECADE FROM DATE '0009-12-31');    --   0 SELECT EXTRACT(DECADE FROM DATE '0001-01-01 BC'); --   0 SELECT EXTRACT(DECADE FROM DATE '0002-12-31 BC'); --  -1 SELECT EXTRACT(DECADE FROM DATE '0011-01-01 BC'); --  -1 SELECT EXTRACT(DECADE FROM DATE '0012-12-31 BC'); --  -2 SELECT EXTRACT(MICROSECONDS  FROM DATE '2020-08-11');
SELECT EXTRACT(FORTNIGHT FROM INTERVAL '2 days');  -- error SELECT EXTRACT(TIMEZONE FROM INTERVAL '2 days');  -- error SELECT EXTRACT(DECADE FROM INTERVAL '100 y');
SELECT EXTRACT(HOUR          FROM DATE '2020-08-11');
SELECT EXTRACT(HOUR        FROM TIME '2020-05-26 13:30:25.575401');
SELECT EXTRACT(HOUR        FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
SELECT EXTRACT(ISODOW        FROM DATE '2020-08-11');
SELECT EXTRACT(ISODOW        FROM DATE '2020-08-16');
SELECT EXTRACT(ISOYEAR       FROM DATE '2020-08-11 BC');
SELECT EXTRACT(ISOYEAR       FROM DATE '2020-08-11');
SELECT EXTRACT(JULIAN        FROM DATE '2020-08-11');
SELECT EXTRACT(MICROSECOND FROM TIME '2020-05-26 13:30:25.575401');
SELECT EXTRACT(MICROSECOND FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
SELECT EXTRACT(MILLENNIUM    FROM DATE '2020-08-11');
SELECT EXTRACT(MILLISECOND FROM TIME '2020-05-26 13:30:25.575401');
SELECT EXTRACT(MILLISECOND FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
SELECT EXTRACT(MILLISECONDS  FROM DATE '2020-08-11');
SELECT EXTRACT(MINUTE        FROM DATE '2020-08-11');
SELECT EXTRACT(MINUTE      FROM TIME '2020-05-26 13:30:25.575401');
SELECT EXTRACT(MINUTE      FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
SELECT EXTRACT(MONTH         FROM DATE '2020-08-11');
SELECT EXTRACT(QUARTER       FROM DATE '2020-08-11');
SELECT EXTRACT(SECOND        FROM DATE '2020-08-11');
SELECT EXTRACT(SECOND      FROM TIME '2020-05-26 13:30:25.575401');
SELECT EXTRACT(SECOND      FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
SELECT EXTRACT(TIMEZONE      FROM DATE '2020-08-11');
SELECT EXTRACT(TIMEZONE_H    FROM DATE '2020-08-11');
SELECT EXTRACT(TIMEZONE_HOUR   FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04:30');
SELECT EXTRACT(TIMEZONE_M    FROM DATE '2020-08-11');
SELECT EXTRACT(TIMEZONE_MINUTE FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04:30');
SELECT EXTRACT(WEEK          FROM DATE '2020-08-11');
SELECT EXTRACT(YEAR          FROM DATE '2020-08-11 BC');
SELECT EXTRACT(YEAR          FROM DATE '2020-08-11');
SELECT NOT :{?no_such_var} AS no_such_var_is_not_defined;
SELECT POSITION(B'1010' IN B'0000101');   -- 0 SELECT POSITION(B'1010' IN B'00001010');  -- 5 SELECT POSITION(B'1010' IN B'00000101');  -- 0 SELECT POSITION(B'1010' IN B'000001010');  -- 6 SELECT POSITION(B'' IN B'00001010');  -- 1 SELECT POSITION(B'0' IN B'');  -- 0 SELECT POSITION(B'' IN B'');  -- 0 SELECT POSITION(B'101101' IN B'001011011011011000');  -- 3 SELECT POSITION(B'10110110' IN B'001011011011010');  -- 3 SELECT POSITION(B'1011011011011' IN B'001011011011011');  -- 3 SELECT POSITION(B'1011011011011' IN B'00001011011011011');  -- 5 SELECT POSITION(B'11101011' IN B'11101011'); -- 1 SELECT POSITION(B'11101011' IN B'011101011'); -- 2 SELECT POSITION(B'11101011' IN B'00011101011'); -- 4 SELECT POSITION(B'11101011' IN B'0000011101011'); -- 6 SELECT POSITION(B'111010110' IN B'111010110'); -- 1 SELECT POSITION(B'111010110' IN B'0111010110'); -- 2 SELECT POSITION(B'111010110' IN B'000111010110'); -- 4 SELECT POSITION(B'111010110' IN B'00000111010110'); -- 6 SELECT POSITION(B'111010110' IN B'11101011'); -- 0 SELECT POSITION(B'111010110' IN B'011101011'); -- 0 SELECT POSITION(B'111010110' IN B'00011101011'); -- 0 SELECT POSITION(B'111010110' IN B'0000011101011'); -- 0 SELECT POSITION(B'111010110' IN B'111010110'); -- 1 SELECT POSITION(B'111010110' IN B'0111010110'); -- 2 SELECT POSITION(B'111010110' IN B'000111010110'); -- 4 SELECT POSITION(B'111010110' IN B'00000111010110'); -- 6 SELECT POSITION(B'111010110' IN B'000001110101111101011'); -- 0 SELECT POSITION(B'111010110' IN B'0000001110101111101011'); -- 0 SELECT POSITION(B'111010110' IN B'000000001110101111101011'); -- 0 SELECT POSITION(B'111010110' IN B'00000000001110101111101011'); -- 0 SELECT POSITION(B'111010110' IN B'0000011101011111010110'); -- 14 SELECT POSITION(B'111010110' IN B'00000011101011111010110'); -- 15 SELECT POSITION(B'111010110' IN B'0000000011101011111010110'); -- 17 SELECT POSITION(B'111010110' IN B'000000000011101011111010110'); -- 19 SELECT POSITION(B'000000000011101011111010110' IN B'000000000011101011111010110'); -- 1 SELECT POSITION(B'00000000011101011111010110' IN B'000000000011101011111010110'); -- 2 SELECT POSITION(B'0000000000011101011111010110' IN B'000000000011101011111010110'); -- 0 CREATE TABLE BIT_SHIFT_TABLE(b BIT(16));
SELECT POSITION(B'1101' IN b),        POSITION(B'11011' IN b),        b        FROM BIT_SHIFT_TABLE ;
SELECT POSITION(B'1101' IN v),        POSITION(B'11011' IN v),        v        FROM VARBIT_SHIFT_TABLE ;
SELECT ROW(x.*) FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE J1_TBL.t = 'one';
SELECT SUBSTRING('01010101'::varbit FROM -10 FOR -2147483646) AS "error";
SELECT SUBSTRING('01010101'::varbit FROM -10 FOR 2147483646) AS "01010101";
SELECT SUBSTRING('01010101'::varbit FROM 2 FOR 2147483646) AS "1010101";
SELECT SUBSTRING('1234567890'::bytea FROM 3) "34567890";
SELECT SUBSTRING('1234567890'::bytea FROM 4 FOR 3) AS "456";
SELECT SUBSTRING('abcdefg' SIMILAR '#"(b_d)#"%' ESCAPE '#') IS NULL AS "True";
SELECT SUBSTRING('abcdefg' SIMILAR '%' ESCAPE NULL) IS NULL AS "True";
SELECT SUBSTRING('abcdefg' SIMILAR 'a#"%#"g' ESCAPE '#') AS "bcdef";
SELECT SUBSTRING('abcdefg' SIMILAR 'a#"%#"x|g' ESCAPE '#') AS "bcdef";
SELECT SUBSTRING('abcdefg' SIMILAR 'a#"%g' ESCAPE '#') AS "bcdefg";
SELECT SUBSTRING('abcdefg' SIMILAR 'a#"%|ab#"g' ESCAPE '#') AS "bcdef";
SELECT SUBSTRING('abcdefg' SIMILAR 'a#"(b_d)#"%' ESCAPE '#') AS "bcd";
SELECT SUBSTRING('abcdefg' SIMILAR 'a%g' ESCAPE '#') AS "abcdefg";
SELECT SUBSTRING('abcdefg' SIMILAR 'a*#"%#"g*#"x' ESCAPE '#') AS "error";
SELECT SUBSTRING('abcdefg' SIMILAR 'a*#"%#"g*' ESCAPE '#') AS "abcdefg";
SELECT SUBSTRING('abcdefg' SIMILAR 'a|b#"%#"g' ESCAPE '#') AS "bcdef";
SELECT SUBSTRING('abcdefg' SIMILAR NULL ESCAPE '#') IS NULL AS "True";
SELECT SUBSTRING('string'::bytea FROM -10 FOR -2147483646) AS "error";
SELECT SUBSTRING('string'::bytea FROM -10 FOR 2147483646) AS "string";
SELECT SUBSTRING('string'::bytea FROM 2 FOR 2147483646) AS "tring";
SELECT SUBSTRING(NULL SIMILAR '%' ESCAPE '#') IS NULL AS "True";
SELECT U&' \' UESCAPE '!' AS "tricky";
SELECT U&' \' UESCAPE '!' AS "tricky";
SELECT U&'\00E4\24D1c' IS NFC NORMALIZED AS test_nfc;
SELECT U&'a\\b' AS "a\b";
SELECT U&'d!0061t\+000061' UESCAPE '!' AS U&"d*0061t\+000061" UESCAPE '*';
SELECT U&'d!0061t\+000061' UESCAPE '!' AS U&"d*0061t\+000061" UESCAPE '*';
SELECT U&'d\0061t\+000061' AS U&"d\0061t\+000061";
SELECT U&'d\0061t\+000061' AS U&"d\0061t\+000061";
SELECT U&'wrong: +0061' UESCAPE '+';
SELECT U&'wrong: +0061' UESCAPE '+';
SELECT U&'wrong: +0061' UESCAPE +;
SELECT U&'wrong: \+0061';
SELECT U&'wrong: \+0061';
SELECT U&'wrong: \+00db99\+000061';
SELECT U&'wrong: \+2FFFFF';
SELECT U&'wrong: \061';
SELECT U&'wrong: \061';
SELECT U&'wrong: \db99';
SELECT U&'wrong: \db99\0061';
SELECT U&'wrong: \db99\\';
SELECT U&'wrong: \db99xy';
SELECT a FROM (VALUES   ('0.0.0.0/0'::inet),   ('0.0.0.0/1'::inet),   ('0.0.0.0/32'::inet),   ('0.0.0.1/0'::inet),   ('0.0.0.1/1'::inet),   ('127.126.127.127/0'::inet),   ('127.127.127.127/0'::inet),   ('127.128.127.127/0'::inet),   ('192.168.1.0/24'::inet),   ('192.168.1.0/25'::inet),   ('192.168.1.1/23'::inet),   ('192.168.1.1/5'::inet),   ('192.168.1.1/6'::inet),   ('192.168.1.1/25'::inet),   ('192.168.1.2/25'::inet),   ('192.168.1.1/26'::inet),   ('192.168.1.2/26'::inet),   ('192.168.1.2/23'::inet),   ('192.168.1.255/5'::inet),   ('192.168.1.255/6'::inet),   ('192.168.1.3/1'::inet),   ('192.168.1.3/23'::inet),   ('192.168.1.4/0'::inet),   ('192.168.1.5/0'::inet),   ('255.0.0.0/0'::inet),   ('255.1.0.0/0'::inet),   ('255.2.0.0/0'::inet),   ('255.255.000.000/0'::inet),   ('255.255.000.000/0'::inet),   ('255.255.000.000/15'::inet),   ('255.255.000.000/16'::inet),   ('255.255.255.254/32'::inet),   ('255.255.255.000/32'::inet),   ('255.255.255.001/31'::inet),   ('255.255.255.002/31'::inet),   ('255.255.255.003/31'::inet),   ('255.255.255.003/32'::inet),   ('255.255.255.001/32'::inet),   ('255.255.255.255/0'::inet),   ('255.255.255.255/0'::inet),   ('255.255.255.255/0'::inet),   ('255.255.255.255/1'::inet),   ('255.255.255.255/16'::inet),   ('255.255.255.255/16'::inet),   ('255.255.255.255/31'::inet),   ('255.255.255.255/32'::inet),   ('255.255.255.253/32'::inet),   ('255.255.255.252/32'::inet),   ('255.3.0.0/0'::inet),   ('0000:0000:0000:0000:0000:0000:0000:0000/0'::inet),   ('0000:0000:0000:0000:0000:0000:0000:0000/128'::inet),   ('0000:0000:0000:0000:0000:0000:0000:0001/128'::inet),   ('10:23::f1/64'::inet),   ('10:23::f1/65'::inet),   ('10:23::ffff'::inet),   ('127::1'::inet),   ('127::2'::inet),   ('8000:0000:0000:0000:0000:0000:0000:0000/1'::inet),   ('::1:ffff:ffff:ffff:ffff/128'::inet),   ('::2:ffff:ffff:ffff:ffff/128'::inet),   ('::4:3:2:0/24'::inet),   ('::4:3:2:1/24'::inet),   ('::4:3:2:2/24'::inet),   ('ffff:83e7:f118:57dc:6093:6d92:689d:58cf/70'::inet),   ('ffff:84b0:4775:536e:c3ed:7116:a6d6:34f0/44'::inet),   ('ffff:8566:f84:5867:47f1:7867:d2ba:8a1a/69'::inet),   ('ffff:8883:f028:7d2:4d68:d510:7d6b:ac43/73'::inet),   ('ffff:8ae8:7c14:65b3:196:8e4a:89ae:fb30/89'::inet),   ('ffff:8dd0:646:694c:7c16:7e35:6a26:171/104'::inet),   ('ffff:8eef:cbf:700:eda3:ae32:f4b4:318b/121'::inet),   ('ffff:90e7:e744:664:a93:8efe:1f25:7663/122'::inet),   ('ffff:9597:c69c:8b24:57a:8639:ec78:6026/111'::inet),   ('ffff:9e86:79ea:f16e:df31:8e4d:7783:532e/88'::inet),   ('ffff:a0c7:82d3:24de:f762:6e1f:316d:3fb2/23'::inet),   ('ffff:fffa:ffff:ffff:ffff:ffff:ffff:ffff/0'::inet),   ('ffff:fffb:ffff:ffff:ffff:ffff:ffff:ffff/0'::inet),   ('ffff:fffc:ffff:ffff:ffff:ffff:ffff:ffff/0'::inet),   ('ffff:fffd:ffff:ffff:ffff:ffff:ffff:ffff/0'::inet),   ('ffff:fffe:ffff:ffff:ffff:ffff:ffff:ffff/0'::inet),   ('ffff:ffff:ffff:fffa:ffff:ffff:ffff:ffff/0'::inet),   ('ffff:ffff:ffff:fffb:ffff:ffff:ffff:ffff/0'::inet),   ('ffff:ffff:ffff:fffc:ffff:ffff:ffff:ffff/0'::inet),   ('ffff:ffff:ffff:fffd::/128'::inet),   ('ffff:ffff:ffff:fffd:ffff:ffff:ffff:ffff/0'::inet),   ('ffff:ffff:ffff:fffe::/128'::inet),   ('ffff:ffff:ffff:fffe:ffff:ffff:ffff:ffff/0'::inet),   ('ffff:ffff:ffff:ffff:4:3:2:0/24'::inet),   ('ffff:ffff:ffff:ffff:4:3:2:1/24'::inet),   ('ffff:ffff:ffff:ffff:4:3:2:2/24'::inet),   ('ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff/0'::inet),   ('ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff/128'::inet) ) AS i(a) ORDER BY a;
SELECT a FROM arrtest WHERE a[2] IS NULL;
SELECT a, b, gcd(a, b), gcd(a, -b), gcd(-b, a), gcd(-b, -a) FROM (VALUES (0::numeric, 0::numeric),              (0::numeric, numeric 'NaN'),              (0::numeric, 46375::numeric),              (433125::numeric, 46375::numeric),              (43312.5::numeric, 4637.5::numeric),              (4331.250::numeric, 463.75000::numeric),              ('inf', '0'),              ('inf', '42'),              ('inf', 'inf')      ) AS v(a, b);
SELECT a,a<<4 AS "a<<4",b,b>>2 AS "b>>2" FROM bit_table;
SELECT a,a<<4 AS "a<<4",b,b>>2 AS "b>>2" FROM varbit_table;
SELECT a,b, lcm(a, b), lcm(a, -b), lcm(-b, a), lcm(-b, -a) FROM (VALUES (0::numeric, 0::numeric),              (0::numeric, numeric 'NaN'),              (0::numeric, 13272::numeric),              (13272::numeric, 13272::numeric),              (423282::numeric, 13272::numeric),              (42328.2::numeric, 1327.2::numeric),              (4232.820::numeric, 132.72000::numeric),              ('inf', '0'),              ('inf', '42'),              ('inf', 'inf')      ) AS v(a, b);
SELECT a.aggfnoid, p.proname FROM pg_aggregate as a, pg_proc as p WHERE a.aggcombinefn = p.oid AND     (p.pronargs != 2 OR      p.prorettype != p.proargtypes[0] OR      p.prorettype != p.proargtypes[1] OR      NOT binary_coercible(a.aggtranstype, p.proargtypes[0]));
SELECT a.aggfnoid, p.proname FROM pg_aggregate as a, pg_proc as p WHERE a.aggdeserialfn = p.oid AND     (p.prorettype != 'internal'::regtype OR p.pronargs != 2 OR      p.proargtypes[0] != 'bytea'::regtype OR      p.proargtypes[1] != 'internal'::regtype OR      NOT p.proisstrict);
SELECT a.aggfnoid, p.proname FROM pg_aggregate as a, pg_proc as p WHERE a.aggserialfn = p.oid AND     (p.prorettype != 'bytea'::regtype OR p.pronargs != 1 OR      p.proargtypes[0] != 'internal'::regtype OR      NOT p.proisstrict);
SELECT a.aggfnoid::oid, o.oid FROM pg_operator AS o, pg_aggregate AS a, pg_proc AS p WHERE a.aggfnoid = p.oid AND a.aggsortop = o.oid AND     (oprkind != 'b' OR oprresult != 'boolean'::regtype      OR oprleft != p.proargtypes[0] OR oprright != p.proargtypes[0]);
SELECT a.aggfnoid::oid, p.proname, pfn.oid, pfn.proname FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS pfn WHERE a.aggfnoid = p.oid AND     a.aggfinalfn = pfn.oid AND     (pfn.proretset OR      NOT binary_coercible(pfn.prorettype, p.prorettype) OR      NOT binary_coercible(a.aggtranstype, pfn.proargtypes[0]) OR      CASE WHEN a.aggfinalextra THEN pfn.pronargs != p.pronargs + 1           ELSE pfn.pronargs != a.aggnumdirectargs + 1 END      OR (pfn.pronargs > 1 AND          NOT binary_coercible(p.proargtypes[0], pfn.proargtypes[1]))      OR (pfn.pronargs > 2 AND          NOT binary_coercible(p.proargtypes[1], pfn.proargtypes[2]))      OR (pfn.pronargs > 3 AND          NOT binary_coercible(p.proargtypes[2], pfn.proargtypes[3]))      OR (pfn.pronargs > 4)     );
SELECT a.aggfnoid::oid, p.proname, pfn.oid, pfn.proname FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS pfn WHERE a.aggfnoid = p.oid AND     a.aggmfinalfn = pfn.oid AND     (pfn.proretset OR      NOT binary_coercible(pfn.prorettype, p.prorettype) OR      NOT binary_coercible(a.aggmtranstype, pfn.proargtypes[0]) OR      CASE WHEN a.aggmfinalextra THEN pfn.pronargs != p.pronargs + 1           ELSE pfn.pronargs != a.aggnumdirectargs + 1 END      OR (pfn.pronargs > 1 AND          NOT binary_coercible(p.proargtypes[0], pfn.proargtypes[1]))      OR (pfn.pronargs > 2 AND          NOT binary_coercible(p.proargtypes[1], pfn.proargtypes[2]))      OR (pfn.pronargs > 3 AND          NOT binary_coercible(p.proargtypes[2], pfn.proargtypes[3]))      OR (pfn.pronargs > 4)     );
SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr WHERE a.aggfnoid = p.oid AND     a.aggminvtransfn = ptr.oid AND     (ptr.proretset      OR NOT (ptr.pronargs =              CASE WHEN a.aggkind = 'n' THEN p.pronargs + 1              ELSE greatest(p.pronargs - a.aggnumdirectargs, 1) + 1 END)      OR NOT binary_coercible(ptr.prorettype, a.aggmtranstype)      OR NOT binary_coercible(a.aggmtranstype, ptr.proargtypes[0])      OR (p.pronargs > 0 AND          NOT binary_coercible(p.proargtypes[0], ptr.proargtypes[1]))      OR (p.pronargs > 1 AND          NOT binary_coercible(p.proargtypes[1], ptr.proargtypes[2]))      OR (p.pronargs > 2 AND          NOT binary_coercible(p.proargtypes[2], ptr.proargtypes[3]))      OR (p.pronargs > 3)     );
SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr WHERE a.aggfnoid = p.oid AND     a.aggmtransfn = ptr.oid AND     (ptr.proretset      OR NOT (ptr.pronargs =              CASE WHEN a.aggkind = 'n' THEN p.pronargs + 1              ELSE greatest(p.pronargs - a.aggnumdirectargs, 1) + 1 END)      OR NOT binary_coercible(ptr.prorettype, a.aggmtranstype)      OR NOT binary_coercible(a.aggmtranstype, ptr.proargtypes[0])      OR (p.pronargs > 0 AND          NOT binary_coercible(p.proargtypes[0], ptr.proargtypes[1]))      OR (p.pronargs > 1 AND          NOT binary_coercible(p.proargtypes[1], ptr.proargtypes[2]))      OR (p.pronargs > 2 AND          NOT binary_coercible(p.proargtypes[2], ptr.proargtypes[3]))      OR (p.pronargs > 3)     );
SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr WHERE a.aggfnoid = p.oid AND     a.aggmtransfn = ptr.oid AND ptr.proisstrict AND     a.aggminitval IS NULL AND     NOT binary_coercible(p.proargtypes[0], a.aggmtranstype);
SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr WHERE a.aggfnoid = p.oid AND     a.aggtransfn = ptr.oid AND     (ptr.proretset      OR NOT (ptr.pronargs =              CASE WHEN a.aggkind = 'n' THEN p.pronargs + 1              ELSE greatest(p.pronargs - a.aggnumdirectargs, 1) + 1 END)      OR NOT binary_coercible(ptr.prorettype, a.aggtranstype)      OR NOT binary_coercible(a.aggtranstype, ptr.proargtypes[0])      OR (p.pronargs > 0 AND          NOT binary_coercible(p.proargtypes[0], ptr.proargtypes[1]))      OR (p.pronargs > 1 AND          NOT binary_coercible(p.proargtypes[1], ptr.proargtypes[2]))      OR (p.pronargs > 2 AND          NOT binary_coercible(p.proargtypes[2], ptr.proargtypes[3]))      OR (p.pronargs > 3)     );
SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr WHERE a.aggfnoid = p.oid AND     a.aggtransfn = ptr.oid AND ptr.proisstrict AND     a.agginitval IS NULL AND     NOT binary_coercible(p.proargtypes[0], a.aggtranstype);
SELECT a[1:3],           b[1:1][1:2][1:2],           c[1:2],           d[1:1][1:2]    FROM arrtest;
SELECT a[1:3],           b[1:1][1:2][1:2],           c[1:2],           d[1:1][2:2]    FROM arrtest;
SELECT a[1], b[1][1][1], c[1], d[1][1], e[0]    FROM arrtest;
SELECT a[2:], b[2:][2:] FROM arrtest_s;
SELECT a[:3], b[:2][:2] FROM arrtest_s;
SELECT a[:], b[:] FROM arrtest_s;
SELECT abort_increasing, abort_decreasing FROM abbrev_abort_uuids ORDER BY abort_decreasing NULLS FIRST OFFSET 20000 - 4;
SELECT abort_increasing, abort_decreasing FROM abbrev_abort_uuids ORDER BY abort_increasing OFFSET 20000 - 4;
SELECT acosh(float8 '-infinity');
SELECT acosh(float8 '2');
SELECT acosh(float8 'nan');
SELECT array_to_json(array_agg(q),false)   FROM ( SELECT $$a$$ || x AS b, y AS c,                ARRAY[ROW(x.*,ARRAY[1,2,3]),                ROW(y.*,ARRAY[4,5,6])] AS z          FROM generate_series(1,2) x,               generate_series(4,5) y) q;
SELECT arrtest.a[1],           arrtest.b[1][1][1],           arrtest.c[1],           arrtest.d[1][1],           arrtest.e[0]    FROM arrtest;
SELECT asinh(float8 '-infinity');
SELECT asinh(float8 '1');
SELECT asinh(float8 'infinity');
SELECT asinh(float8 'nan');
SELECT atanh(float8 '-infinity');
SELECT atanh(float8 '0.5');
SELECT atanh(float8 'infinity');
SELECT atanh(float8 'nan');
SELECT b, b >> 1 AS bsr, b << 1 AS bsl        FROM BIT_SHIFT_TABLE ;
SELECT b, b >> 8 AS bsr8, b << 8 AS bsl8        FROM BIT_SHIFT_TABLE ;
SELECT b.f1    FROM BOX_TBL b    WHERE b.f1 && box '(2.5,2.5,1.0,1.0)';
SELECT b.f1    FROM BOX_TBL b    WHERE b.f1 < box '(3.0,3.0,5.0,5.0)';
SELECT b.f1    FROM BOX_TBL b    WHERE b.f1 << box '(3.0,3.0,5.0,5.0)';
SELECT b.f1    FROM BOX_TBL b    WHERE b.f1 <= box '(3.0,3.0,5.0,5.0)';
SELECT b.f1    FROM BOX_TBL b    WHERE b.f1 = box '(3.0,3.0,5.0,5.0)';
SELECT b.f1    FROM BOX_TBL b    WHERE box '(0,0,3,3)' @> b.f1;
SELECT b.f1    FROM BOX_TBL b    WHERE box '(1,1,3,3)' ~= b.f1;
SELECT b.f1    FROM BOX_TBL b    WHERE box '(3.0,3.0,5.0,5.0)' >> b.f1;
SELECT b.f1, p.f1, b.f1 * p.f1 FROM BOX_TBL b, POINT_TBL p WHERE p.f1[0] > 1000;
SELECT b.f1, p.f1, b.f1 * p.f1 FROM BOX_TBL b, POINT_TBL p WHERE p.f1[0] BETWEEN 1 AND 1000;
SELECT b.f1, p.f1, b.f1 / p.f1 FROM BOX_TBL b, POINT_TBL p WHERE p.f1[0] BETWEEN 1 AND 1000;
SELECT b1.*    FROM BOX_TBL b1    WHERE b1.f1 &< box '(2.0,2.0,2.5,2.5)';
SELECT b1.*    FROM BOX_TBL b1    WHERE b1.f1 &> box '(2.0,2.0,2.5,2.5)';
SELECT b1.*, b2.*    FROM BOX_TBL b1, BOX_TBL b2    WHERE b1.f1 @> b2.f1 and not b1.f1 ~= b2.f1;
SELECT b1.f1, b2.f1, b1.f1 # b2.f1 FROM BOX_TBL b1, BOX_TBL b2;
SELECT b1.f1, b2.f1, b1.f1 <^ b2.f1 FROM BOX_TBL b1, BOX_TBL b2;
SELECT b1.f1, b2.f1, b1.f1 >^ b2.f1 FROM BOX_TBL b1, BOX_TBL b2;
SELECT b::bit(15), b::bit(15) >> 1 AS bsr, b::bit(15) << 1 AS bsl        FROM BIT_SHIFT_TABLE ;
SELECT b::bit(15), b::bit(15) >> 8 AS bsr8, b::bit(15) << 8 AS bsl8        FROM BIT_SHIFT_TABLE ;
SELECT b[1:1][2][2],        d[1:1][2]    FROM arrtest;
SELECT bit_count('\x1234567890'::bytea);
SELECT bit_count(B'0101011100'::bit(10));
SELECT bit_count(B'1111111111'::bit(10));
SELECT bool '   f           ' AS false;
SELECT bool '0' AS false;
SELECT bool '1' AS true;
SELECT bool 'f' < bool 't' AS true;
SELECT bool 'f' <= bool 't' AS true;
SELECT bool 'false' AS false;
SELECT bool 'n' AS false;
SELECT bool 'no' AS false;
SELECT bool 'of' AS false;
SELECT bool 'off' AS false;
SELECT bool 'on' AS true;
SELECT bool 't' <> bool 'f' AS true;
SELECT bool 't' = bool 'f' AS false;
SELECT bool 't' > bool 'f' AS true;
SELECT bool 't' >= bool 'f' AS true;
SELECT bool 't' AS true;
SELECT bool 't' and bool 'f' AS false;
SELECT bool 't' or bool 'f' AS true;
SELECT bool 'true' AS true;
SELECT bool 'y' AS true;
SELECT bool 'yes' AS true;
SELECT btrim(''::bytea, E'\\000'::bytea);
SELECT btrim(E'\\000trim\\000'::bytea, ''::bytea);
SELECT btrim(E'\\000trim\\000'::bytea, E'\\000'::bytea);
SELECT c AS cidr, abbrev(c) FROM INET_TBL;
SELECT c AS cidr, broadcast(c),   i AS inet, broadcast(i) FROM INET_TBL;
SELECT c AS cidr, i AS inet FROM INET_TBL   WHERE c = i;
SELECT c AS cidr, i AS inet FROM INET_TBL;
SELECT c AS cidr, masklen(c) AS "masklen(cidr)",   i AS inet, masklen(i) AS "masklen(inet)" FROM INET_TBL   WHERE masklen(c) <= 8;
SELECT c AS cidr, masklen(c) AS "masklen(cidr)",   i AS inet, masklen(i) AS "masklen(inet)" FROM INET_TBL;
SELECT c AS cidr, network(c) AS "network(cidr)",   i AS inet, network(i) AS "network(inet)" FROM INET_TBL;
SELECT c.* FROM pg_cast c, pg_proc p WHERE c.castfunc = p.oid AND     ((p.pronargs > 1 AND p.proargtypes[1] != 'int4'::regtype) OR      (p.pronargs > 2 AND p.proargtypes[2] != 'bool'::regtype));
SELECT c.* FROM pg_cast c, pg_proc p WHERE c.castfunc = p.oid AND     (p.pronargs < 1 OR p.pronargs > 3      OR NOT (binary_coercible(c.castsource, p.proargtypes[0])              OR (c.castsource = 'character'::regtype AND                  p.proargtypes[0] = 'text'::regtype))      OR NOT binary_coercible(p.prorettype, c.casttarget));
SELECT c.f1, p.f1, c.f1 / p.f1 FROM CIRCLE_TBL c, POINT_TBL p WHERE p.f1 ~= '(0,0)'::point;
SELECT c.f1, p.f1, c.f1 / p.f1 FROM CIRCLE_TBL c, POINT_TBL p WHERE p.f1[0] > 1000;
SELECT c.f1, p.f1, c.f1 / p.f1 FROM CIRCLE_TBL c, POINT_TBL p WHERE p.f1[0] BETWEEN 1 AND 1000;
SELECT c0 FROM ONLY expr_stats_incompatible_test WHERE (   upper('x') LIKE ('x'||('[0,1]'::int4range))   AND   (c0 IN (0, 1) OR c1) );
SELECT c1.f1 AS circle, p1.f1 AS point, (p1.f1 <-> c1.f1) AS distance    FROM CIRCLE_TBL c1, POINT_TBL p1    WHERE (p1.f1 <-> c1.f1) > 0    ORDER BY distance, area(c1.f1), p1.f1[0];
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 &< c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 &<| c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 &> c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 << c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 <<| c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 >> c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 |&> c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 |>> c2.f1;
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 ~= c2.f1;
SELECT check_ddl_rewrite('rewrite_test', $$     ALTER TABLE rewrite_test         ADD COLUMN empty3 text,         ADD COLUMN notempty3_norewrite int default 42; $$);
SELECT check_ddl_rewrite('rewrite_test', $$     ALTER TABLE rewrite_test         ADD COLUMN empty5 text,         ADD COLUMN notempty5_norewrite int default 42,         ADD COLUMN notempty5_rewrite serial; $$);
SELECT check_ddl_rewrite('rewrite_test', $$     ALTER TABLE rewrite_test         ADD COLUMN notempty2_rewrite serial,         ADD COLUMN empty2 text; $$);
SELECT check_ddl_rewrite('rewrite_test', $$     ALTER TABLE rewrite_test         ADD COLUMN notempty4_norewrite int default 42,         ADD COLUMN empty4 text; $$);
SELECT check_ddl_rewrite('rewrite_test', $$     ALTER TABLE rewrite_test         ADD COLUMN notempty6_rewrite serial,         ADD COLUMN empty6 text,         ADD COLUMN notempty6_norewrite int default 42; $$);
SELECT check_ddl_rewrite('rewrite_test', $$   ALTER TABLE rewrite_test       ADD COLUMN empty1 text,       ADD COLUMN notempty1_rewrite serial; $$);
SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test'::regclass ORDER BY 1, 2;
SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test'::regclass ORDER BY 1, 2;
SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test_child'::regclass ORDER BY 1, 2;
SELECT cosh(float8 '-infinity');
SELECT cosh(float8 '1');
SELECT cosh(float8 'infinity');
SELECT cosh(float8 'nan');
SELECT count(*) AS One FROM TIMESTAMPTZ_TBL WHERE d1 = timestamp with time zone 'today';
SELECT count(*) AS One FROM TIMESTAMPTZ_TBL WHERE d1 = timestamp with time zone 'tomorrow EST';
SELECT count(*) AS One FROM TIMESTAMPTZ_TBL WHERE d1 = timestamp with time zone 'tomorrow zulu';
SELECT count(*) AS One FROM TIMESTAMPTZ_TBL WHERE d1 = timestamp with time zone 'tomorrow';
SELECT count(*) AS One FROM TIMESTAMPTZ_TBL WHERE d1 = timestamp with time zone 'yesterday';
SELECT count(*) AS One FROM TIMESTAMP_TBL WHERE d1 = timestamp without time zone 'today';
SELECT count(*) AS One FROM TIMESTAMP_TBL WHERE d1 = timestamp without time zone 'yesterday';
SELECT count(*) AS Three FROM TIMESTAMP_TBL WHERE d1 = timestamp without time zone 'tomorrow';
SELECT count(*) AS two FROM TIMESTAMPTZ_TBL WHERE d1 = timestamp(2) with time zone 'now';
SELECT count(*) AS two FROM TIMESTAMP_TBL WHERE d1 = timestamp(2) without time zone 'now';
SELECT count(*) FROM dupindexcols   WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
SELECT count(*) FROM kd_point_tbl WHERE p <<| '(5000, 4000)';
SELECT count(*) FROM kd_point_tbl WHERE p <<| '(5000, 4000)';
SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
SELECT count(*) FROM kd_point_tbl WHERE p |>> '(5000, 4000)';
SELECT count(*) FROM kd_point_tbl WHERE p |>> '(5000, 4000)';
SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)';
SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)';
SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)';
SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)';
SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
SELECT count(*) FROM quad_box_tbl WHERE b &&  box '((100,200),(300,500))';
SELECT count(*) FROM quad_box_tbl WHERE b &<  box '((100,200),(300,500))';
SELECT count(*) FROM quad_box_tbl WHERE b &<| box '((100,200),(300,500))';
SELECT count(*) FROM quad_box_tbl WHERE b &>  box '((100,200),(300,500))';
SELECT count(*) FROM quad_box_tbl WHERE b <<  box '((100,200),(300,500))';
SELECT count(*) FROM quad_box_tbl WHERE b <<| box '((100,200),(300,500))';
SELECT count(*) FROM quad_box_tbl WHERE b >>  box '((100,200),(300,500))';
SELECT count(*) FROM quad_box_tbl WHERE b >>  box '((100,200),(300,500))';
SELECT count(*) FROM quad_box_tbl WHERE b |&> box '((100,200),(300,500))';
SELECT count(*) FROM quad_box_tbl WHERE b |>> box '((100,200),(300,500))';
SELECT count(*) FROM quad_box_tbl WHERE b ~=  box '((200,300),(205,305))';
SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p <<| '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p <<| '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p <<| '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p |>> '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p |>> '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p |>> '(5000, 4000)';
SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
SELECT count(*) FROM quad_poly_tbl WHERE p && polygon '((300,300),(400,600),(600,500),(700,200))';
SELECT count(*) FROM quad_poly_tbl WHERE p &< polygon '((300,300),(400,600),(600,500),(700,200))';
SELECT count(*) FROM quad_poly_tbl WHERE p &<| polygon '((300,300),(400,600),(600,500),(700,200))';
SELECT count(*) FROM quad_poly_tbl WHERE p &> polygon '((300,300),(400,600),(600,500),(700,200))';
SELECT count(*) FROM quad_poly_tbl WHERE p << polygon '((300,300),(400,600),(600,500),(700,200))';
SELECT count(*) FROM quad_poly_tbl WHERE p <<| polygon '((300,300),(400,600),(600,500),(700,200))';
SELECT count(*) FROM quad_poly_tbl WHERE p >> polygon '((300,300),(400,600),(600,500),(700,200))';
SELECT count(*) FROM quad_poly_tbl WHERE p |&> polygon '((300,300),(400,600),(600,500),(700,200))';
SELECT count(*) FROM quad_poly_tbl WHERE p |>> polygon '((300,300),(400,600),(600,500),(700,200))';
SELECT count(*) FROM quad_poly_tbl WHERE p ~= polygon '((200, 300),(210, 310),(230, 290))';
SELECT count(*) FROM radix_text_tbl WHERE t ^@	 'Worth';
SELECT count(*) FROM radix_text_tbl WHERE t ^@	 'Worth';
SELECT count(*) FROM radix_text_tbl WHERE t ^@  'Worth';
SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec                         Ct  ';
SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec                         Ct  ';
SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec                         Ct  ';
SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec                         Ct  ';
SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec                         Ct  ';
SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec                         Ct  ';
SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth                         St  ';
SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth                         St  ';
SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth                         St  ';
SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth                         St  ';
SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth                         St  ';
SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth                         St  ';
SELECT d.f1 AS "timestamp",    timestamp with time zone '1980-01-06 00:00 GMT' AS gpstime_zero,    d.f1 - timestamp with time zone '1980-01-06 00:00 GMT' AS difference   FROM TEMP_TIMESTAMP d   ORDER BY difference;
SELECT d1 + interval '1 year' AS one_year FROM TIMESTAMPTZ_TBL;
SELECT d1 + interval '1 year' AS one_year FROM TIMESTAMP_TBL;
SELECT d1 FROM TIMESTAMPTZ_TBL    WHERE d1 != timestamp with time zone '1997-01-02';
SELECT d1 FROM TIMESTAMPTZ_TBL    WHERE d1 < timestamp with time zone '1997-01-02';
SELECT d1 FROM TIMESTAMPTZ_TBL    WHERE d1 <= timestamp with time zone '1997-01-02';
SELECT d1 FROM TIMESTAMPTZ_TBL    WHERE d1 = timestamp with time zone '1997-01-02';
SELECT d1 FROM TIMESTAMPTZ_TBL    WHERE d1 >= timestamp with time zone '1997-01-02';
SELECT d1 FROM TIMESTAMP_TBL    WHERE d1 != timestamp without time zone '1997-01-02';
SELECT d1 FROM TIMESTAMP_TBL    WHERE d1 < timestamp without time zone '1997-01-02';
SELECT d1 FROM TIMESTAMP_TBL    WHERE d1 <= timestamp without time zone '1997-01-02';
SELECT d1 FROM TIMESTAMP_TBL    WHERE d1 = timestamp without time zone '1997-01-02';
SELECT d1 FROM TIMESTAMP_TBL    WHERE d1 >= timestamp without time zone '1997-01-02';
SELECT d1 as "timestamp",    date_part( 'isoyear', d1) AS isoyear, date_part( 'week', d1) AS week,    date_part( 'isodow', d1) AS isodow, date_part( 'dow', d1) AS dow,    date_part( 'doy', d1) AS doy    FROM TIMESTAMP_TBL;
SELECT d1 as "timestamp",    date_part( 'quarter', d1) AS quarter, date_part( 'msec', d1) AS msec,    date_part( 'usec', d1) AS usec    FROM TIMESTAMP_TBL;
SELECT d1 as timestamptz,    date_part( 'isoyear', d1) AS isoyear, date_part( 'week', d1) AS week,    date_part( 'isodow', d1) AS isodow, date_part( 'dow', d1) AS dow,    date_part( 'doy', d1) AS doy    FROM TIMESTAMPTZ_TBL;
SELECT d1 as timestamptz,    date_part( 'quarter', d1) AS quarter, date_part( 'msec', d1) AS msec,    date_part( 'usec', d1) AS usec    FROM TIMESTAMPTZ_TBL;
SELECT date_bin('-2 days'::interval, timestamp '1970-01-01 01:00:00' , timestamp '1970-01-01 00:00:00');
SELECT date_bin('-2 days'::interval, timestamp with time zone '1970-01-01 01:00:00+00' , timestamp with time zone '1970-01-01 00:00:00+00');
SELECT date_bin('0 days'::interval, timestamp '1970-01-01 01:00:00' , timestamp '1970-01-01 00:00:00');
SELECT date_bin('0 days'::interval, timestamp with time zone '1970-01-01 01:00:00+00' , timestamp with time zone '1970-01-01 00:00:00+00');
SELECT date_bin('5 min'::interval, timestamp '2020-02-01 01:01:01', timestamp '2020-02-01 00:02:30');
SELECT date_bin('5 months'::interval, timestamp '2020-02-01 01:01:01', timestamp '2001-01-01');
SELECT date_bin('5 months'::interval, timestamp with time zone '2020-02-01 01:01:01+00', timestamp with time zone '2001-01-01+00');
SELECT date_bin('5 years'::interval,  timestamp '2020-02-01 01:01:01', timestamp '2001-01-01');
SELECT date_bin('5 years'::interval,  timestamp with time zone '2020-02-01 01:01:01+00', timestamp with time zone '2001-01-01+00');
SELECT date_part('epoch',       TIME '2020-05-26 13:30:25.575401');
SELECT date_part('epoch',       TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
SELECT date_part('microsecond', TIME '2020-05-26 13:30:25.575401');
SELECT date_part('microsecond', TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
SELECT date_part('millisecond', TIME '2020-05-26 13:30:25.575401');
SELECT date_part('millisecond', TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
SELECT date_part('second',      TIME '2020-05-26 13:30:25.575401');
SELECT date_part('second',      TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
SELECT date_trunc( 'week', timestamp '2004-02-29 15:44:17.71393' ) AS week_trunc;
SELECT date_trunc( 'week', timestamp with time zone '2004-02-29 15:44:17.71393' ) AS week_trunc;
SELECT date_trunc('day', timestamp with time zone '2001-02-16 20:38:40+00', 'Australia/Sydney') as sydney_trunc;  -- zone name SELECT date_trunc('day', timestamp with time zone '2001-02-16 20:38:40+00', 'GMT') as gmt_trunc;  -- fixed-offset abbreviation SELECT date_trunc('day', timestamp with time zone '2001-02-16 20:38:40+00', 'VET') as vet_trunc;  -- variable-offset abbreviation SELECT   str,   interval,   date_trunc(str, ts, 'Australia/Sydney') = date_bin(interval::interval, ts, timestamp with time zone '2001-01-01+11') AS equal FROM (   VALUES   ('day', '1 d'),   ('hour', '1 h'),   ('minute', '1 m'),   ('second', '1 s'),   ('millisecond', '1 ms'),   ('microsecond', '1 us') ) intervals (str, interval), (VALUES (timestamptz '2020-02-29 15:44:17.71393+00')) ts (ts);
SELECT decode(encode(('\x' || repeat('1234567890abcdef0001', 7))::bytea,                      'base64'), 'base64');
SELECT dup(int4range(4,7));
SELECT dup(numrange(4,7));
SELECT encode(('\x' || repeat('1234567890abcdef0001', 7))::bytea, 'base64');
SELECT encode(overlay(E'Th\\000omas'::bytea placing E'Th\\001omas'::bytea from 2),'escape');
SELECT encode(overlay(E'Th\\000omas'::bytea placing E'\\002\\003'::bytea from 5 for 3),'escape');
SELECT encode(overlay(E'Th\\000omas'::bytea placing E'\\002\\003'::bytea from 8),'escape');
SELECT extract(epoch from interval '1000000000 days');
SELECT f.f1, @f.f1 AS abs_f1    FROM FLOAT8_TBL f;
SELECT f.f1, @f.f1 AS abs_f1 FROM FLOAT4_TBL f;
SELECT f.f1, |/f.f1 AS sqrt_f1    FROM FLOAT8_TBL f    WHERE f.f1 > '0.0';
SELECT f.f1, ||/f.f1 AS cbrt_f1 FROM FLOAT8_TBL f;
SELECT f1 AS "timestamp", date(f1) AS date   FROM TEMP_TIMESTAMP   WHERE f1 <> timestamp 'now'   ORDER BY date, "timestamp";
SELECT f1 AS open_path, polygon( pclose(f1)) AS polygon    FROM PATH_TBL    WHERE isopen(f1);
SELECT f1 as "date",     date_part('year', f1) AS year,     date_part('month', f1) AS month,     date_part('day', f1) AS day,     date_part('quarter', f1) AS quarter,     date_part('decade', f1) AS decade,     date_part('century', f1) AS century,     date_part('millennium', f1) AS millennium,     date_part('isoyear', f1) AS isoyear,     date_part('week', f1) AS week,     date_part('dow', f1) AS dow,     date_part('isodow', f1) AS isodow,     date_part('doy', f1) AS doy,     date_part('julian', f1) AS julian,     date_part('epoch', f1) AS epoch     FROM date_tbl;
SELECT f1,     EXTRACT(MICROSECOND FROM f1) AS MICROSECOND,     EXTRACT(MILLISECOND FROM f1) AS MILLISECOND,     EXTRACT(SECOND FROM f1) AS SECOND,     EXTRACT(MINUTE FROM f1) AS MINUTE,     EXTRACT(HOUR FROM f1) AS HOUR,     EXTRACT(DAY FROM f1) AS DAY,     EXTRACT(MONTH FROM f1) AS MONTH,     EXTRACT(QUARTER FROM f1) AS QUARTER,     EXTRACT(YEAR FROM f1) AS YEAR,     EXTRACT(DECADE FROM f1) AS DECADE,     EXTRACT(CENTURY FROM f1) AS CENTURY,     EXTRACT(MILLENNIUM FROM f1) AS MILLENNIUM,     EXTRACT(EPOCH FROM f1) AS EPOCH     FROM INTERVAL_TBL;
SELECT f1,     date_part('microsecond', f1) AS microsecond,     date_part('millisecond', f1) AS millisecond,     date_part('second', f1) AS second,     date_part('epoch', f1) AS epoch     FROM INTERVAL_TBL;
SELECT f1, @-@ f1 FROM PATH_TBL;
SELECT f1, f1::INTERVAL DAY TO MINUTE AS "minutes",   (f1 + INTERVAL '1 month')::INTERVAL MONTH::INTERVAL YEAR AS "years"   FROM interval_tbl;
SELECT f1, f1::box FROM POLYGON_TBL;
SELECT f1, f1::path FROM POLYGON_TBL;
SELECT f1, f1::polygon FROM CIRCLE_TBL WHERE f1 >= '<(0,0),1>';
SELECT f1, f1::polygon FROM PATH_TBL WHERE isclosed(f1);
SELECT f1, f1::polygon FROM PATH_TBL WHERE isopen(f1);
SELECT f1, polygon(1, f1) FROM CIRCLE_TBL WHERE f1 >= '<(0,0),1>';
SELECT f1, polygon(10, f1) FROM CIRCLE_TBL WHERE f1 < '<(0,0),1>';
SELECT f1, polygon(8, f1) FROM CIRCLE_TBL WHERE f1 >= '<(0,0),1>';
SELECT f1::box 	FROM POINT_TBL;
SELECT f1[0:] FROM POINT_TBL;
SELECT f1[:1] FROM POINT_TBL;
SELECT f1[:] FROM POINT_TBL;
SELECT false AS false;
SELECT foo, length(foo) FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', $re$\s*$re$) AS foo;
SELECT foo, length(foo) FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', $re$\s+$re$) AS foo;
SELECT get_bit('\x1234567890abcdef00'::bytea, 43);
SELECT get_bit('\x1234567890abcdef00'::bytea, 99);  -- error SELECT set_bit('\x1234567890abcdef00'::bytea, 43, 0);
SELECT get_bit(B'0101011000100', 10);
SELECT get_byte('\x1234567890abcdef00'::bytea, 99);  -- error SELECT set_byte('\x1234567890abcdef00'::bytea, 7, 11);
SELECT i AS inet, host(i), text(i), family(i) FROM INET_TBL;
SELECT i FROM inet_tbl WHERE i << '192.168.1.0/24'::cidr ORDER BY i;
SELECT i FROM inet_tbl WHERE i << '192.168.1.0/24'::cidr ORDER BY i;
SELECT i,        to_char(i * interval '1mon', 'rm'),        to_char(i * interval '1mon', 'RM')     FROM generate_series(-13, 13) i;
SELECT i, c,   i < c AS lt, i <= c AS le, i = c AS eq,   i >= c AS ge, i > c AS gt, i <> c AS ne,   i << c AS sb, i <<= c AS sbe,   i >> c AS sup, i >>= c AS spe,   i && c AS ovr   FROM INET_TBL;
SELECT i, ~i AS "~i" FROM inet_tbl;
SELECT i,SUM(v::money) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)   FROM (VALUES(1,'1.10'),(2,'2.20'),(3,NULL),(4,NULL)) t(i,v);
SELECT i.* FROM INT2_TBL i WHERE (i.f1 % int2 '2') = int2 '1';
SELECT i.* FROM INT2_TBL i WHERE (i.f1 % int4 '2') = int2 '0';
SELECT i.* FROM INT2_TBL i WHERE i.f1 < int2 '0';
SELECT i.* FROM INT2_TBL i WHERE i.f1 < int4 '0';
SELECT i.* FROM INT2_TBL i WHERE i.f1 <= int2 '0';
SELECT i.* FROM INT2_TBL i WHERE i.f1 <= int4 '0';
SELECT i.* FROM INT2_TBL i WHERE i.f1 <> int2 '0';
SELECT i.* FROM INT2_TBL i WHERE i.f1 <> int4 '0';
SELECT i.* FROM INT2_TBL i WHERE i.f1 = int2 '0';
SELECT i.* FROM INT2_TBL i WHERE i.f1 = int4 '0';
SELECT i.* FROM INT2_TBL i WHERE i.f1 > int2 '0';
SELECT i.* FROM INT2_TBL i WHERE i.f1 > int4 '0';
SELECT i.* FROM INT2_TBL i WHERE i.f1 >= int2 '0';
SELECT i.* FROM INT2_TBL i WHERE i.f1 >= int4 '0';
SELECT i.* FROM INT4_TBL i WHERE (i.f1 % int2 '2') = int2 '1';
SELECT i.* FROM INT4_TBL i WHERE (i.f1 % int4 '2') = int2 '0';
SELECT i.* FROM INT4_TBL i WHERE i.f1 < int2 '0';
SELECT i.* FROM INT4_TBL i WHERE i.f1 < int4 '0';
SELECT i.* FROM INT4_TBL i WHERE i.f1 <= int2 '0';
SELECT i.* FROM INT4_TBL i WHERE i.f1 <= int4 '0';
SELECT i.* FROM INT4_TBL i WHERE i.f1 <> int2 '0';
SELECT i.* FROM INT4_TBL i WHERE i.f1 <> int4 '0';
SELECT i.* FROM INT4_TBL i WHERE i.f1 = int2 '0';
SELECT i.* FROM INT4_TBL i WHERE i.f1 = int4 '0';
SELECT i.* FROM INT4_TBL i WHERE i.f1 > int2 '0';
SELECT i.* FROM INT4_TBL i WHERE i.f1 > int4 '0';
SELECT i.* FROM INT4_TBL i WHERE i.f1 >= int2 '0';
SELECT i.* FROM INT4_TBL i WHERE i.f1 >= int4 '0';
SELECT i.f1, i.f1 * int2 '2' AS x FROM INT2_TBL i WHERE abs(f1) < 16384;
SELECT i.f1, i.f1 * int2 '2' AS x FROM INT2_TBL i;
SELECT i.f1, i.f1 * int2 '2' AS x FROM INT4_TBL i WHERE abs(f1) < 1073741824;
SELECT i.f1, i.f1 * int2 '2' AS x FROM INT4_TBL i;
SELECT i.f1, i.f1 * int4 '2' AS x FROM INT2_TBL i;
SELECT i.f1, i.f1 * int4 '2' AS x FROM INT4_TBL i WHERE abs(f1) < 1073741824;
SELECT i.f1, i.f1 * int4 '2' AS x FROM INT4_TBL i;
SELECT i.f1, i.f1 + int2 '2' AS x FROM INT2_TBL i WHERE f1 < 32766;
SELECT i.f1, i.f1 + int2 '2' AS x FROM INT2_TBL i;
SELECT i.f1, i.f1 + int2 '2' AS x FROM INT4_TBL i WHERE f1 < 2147483646;
SELECT i.f1, i.f1 + int2 '2' AS x FROM INT4_TBL i;
SELECT i.f1, i.f1 + int4 '2' AS x FROM INT2_TBL i;
SELECT i.f1, i.f1 + int4 '2' AS x FROM INT4_TBL i WHERE f1 < 2147483646;
SELECT i.f1, i.f1 + int4 '2' AS x FROM INT4_TBL i;
SELECT i.f1, i.f1 / int2 '2' AS x FROM INT2_TBL i;
SELECT i.f1, i.f1 / int2 '2' AS x FROM INT4_TBL i;
SELECT i.f1, i.f1 / int4 '2' AS x FROM INT2_TBL i;
SELECT i.f1, i.f1 / int4 '2' AS x FROM INT4_TBL i;
SELECT json_agg(q)   FROM ( SELECT $$a$$ || x AS b, y AS c,                ARRAY[ROW(x.*,ARRAY[1,2,3]),                ROW(y.*,ARRAY[4,5,6])] AS z          FROM generate_series(1,2) x,               generate_series(4,5) y) q;
SELECT jsonb_agg(q)   FROM ( SELECT $$a$$ || x AS b, y AS c,                ARRAY[ROW(x.*,ARRAY[1,2,3]),                ROW(y.*,ARRAY[4,5,6])] AS z          FROM generate_series(1,2) x,               generate_series(4,5) y) q;
SELECT jsonb_path_exists('[{"a": 1}, {"a": 2}, {"a": 3}, {"a": 5}]', '$[*] ? (@.a > $min && @.a < $max)', vars => '{"min": 1, "max": 4}');
SELECT jsonb_path_exists('[{"a": 1}, {"a": 2}, {"a": 3}, {"a": 5}]', '$[*] ? (@.a > $min && @.a < $max)', vars => '{"min": 3, "max": 4}');
SELECT jsonb_path_match('"a"', '$', silent => false);
SELECT jsonb_path_match('1', '$', silent => false);
SELECT jsonb_path_match('1', '$', silent => true);
SELECT jsonb_path_match('[true, true]', '$[*]', silent => false);
SELECT jsonb_path_match('[true]', '$', silent => false);
SELECT jsonb_path_match('false', '$', silent => false);
SELECT jsonb_path_match('null', '$', silent => false);
SELECT jsonb_path_match('true', '$', silent => false);
SELECT jsonb_path_match('{}', '$', silent => false);
SELECT jsonb_path_match('{}', 'lax $.a', silent => false);
SELECT jsonb_path_match('{}', 'strict $.a', silent => false);
SELECT jsonb_path_match('{}', 'strict $.a', silent => true);
SELECT jsonb_path_query_array('[{"a": 1}, {"a": 2}, {"a": 3}, {"a": 5}]', '$[*].a ? (@ > $min && @ < $max)', vars => '{"min": 1, "max": 4}');
SELECT jsonb_path_query_array('[{"a": 1}, {"a": 2}, {"a": 3}, {"a": 5}]', '$[*].a ? (@ > $min && @ < $max)', vars => '{"min": 3, "max": 4}');
SELECT jsonb_path_query_first('[{"a": 1}, {"a": 2}, {"a": 3}, {"a": 5}]', '$[*].a ? (@ > $min && @ < $max)', vars => '{"min": 1, "max": 4}');
SELECT jsonb_path_query_first('[{"a": 1}, {"a": 2}, {"a": 3}, {"a": 5}]', '$[*].a ? (@ > $min && @ < $max)', vars => '{"min": 3, "max": 4}');
SELECT jsonb_path_query_first('[{"a": 1}, {"a": 2}, {}]', 'strict $[*].a', silent => true);
SELECT jsonb_typeof('["a", 1]') AS array;
SELECT jsonb_typeof('[]') AS array;
SELECT jsonb_typeof('false') AS boolean;
SELECT jsonb_typeof('true') AS boolean;
SELECT justify_days(interval '6 months 36 days 5 hours 4 minutes 3 seconds') as "7 mons 6 days 5 hours 4 mins 3 seconds";
SELECT justify_hours(interval '6 months 3 days 52 hours 3 minutes 2 seconds') as "6 mons 5 days 4 hours 3 mins 2 seconds";
SELECT justify_interval(interval '1 month -1 hour') as "1 month -1 hour";
SELECT l.s, b.f1 FROM LINE_TBL l, BOX_TBL b WHERE l.s ?# b.f1;
SELECT l.s, b.f1 FROM LSEG_TBL l, BOX_TBL b WHERE l.s ?# b.f1;
SELECT l.s, b.f1, l.s ## b.f1 FROM LINE_TBL l, BOX_TBL b;
SELECT l.s, b.f1, l.s ## b.f1 FROM LSEG_TBL l, BOX_TBL b;
SELECT l.s, l1.s FROM LSEG_TBL l, LINE_TBL l1 WHERE l.s ?# l1.s;
SELECT l.s, l1.s, l.s ## l1.s FROM LINE_TBL l, LSEG_TBL l1;
SELECT l.s, l1.s, l.s ## l1.s FROM LSEG_TBL l, LINE_TBL l1;
SELECT l1.s, l2.s FROM LINE_TBL l1, LINE_TBL l2 WHERE l1.s ?# l2.s;
SELECT l1.s, l2.s, l1.s # l2.s FROM LINE_TBL l1, LINE_TBL l2;
SELECT l1.s, l2.s, l1.s # l2.s FROM LSEG_TBL l1, LSEG_TBL l2;
SELECT l1.s, l2.s, l1.s ## l2.s FROM LSEG_TBL l1, LSEG_TBL l2;
SELECT length(a[1]), length(a[2]) from parse_ident('"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx".yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy') as a ;
SELECT lexeme, positions[1] from unnest('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);
SELECT m / '2'::money FROM money_data;
SELECT name, #thepath FROM iexit ORDER BY name COLLATE "C", 2;
SELECT noabort_increasing, noabort_decreasing FROM abbrev_abort_uuids ORDER BY noabort_decreasing NULLS FIRST OFFSET 20000 - 4;
SELECT noabort_increasing, noabort_decreasing FROM abbrev_abort_uuids ORDER BY noabort_increasing OFFSET 20000 - 4;
SELECT normalize(U&'\0061\0308\24D1c') = U&'\00E4\24D1c' COLLATE "C" AS test_default;
SELECT normalize(U&'\0061\0308\24D1c', NFC) = U&'\00E4\24D1c' COLLATE "C" AS test_nfc;
SELECT normalize(U&'\0061\0308\24D1c', NFKC) = U&'\00E4bc' COLLATE "C" AS test_nfkc;
SELECT normalize(U&'\00E4\24D1c', NFD) = U&'\0061\0308\24D1c' COLLATE "C" AS test_nfd;
SELECT normalize(U&'\00E4\24D1c', NFKD) = U&'\0061\0308bc' COLLATE "C" AS test_nfkd;
SELECT normalize(U&'\00E4bc', NFC) = U&'\00E4bc' COLLATE "C" AS test_nfc_idem;
SELECT not bool 'f' AS true;
SELECT npoints(f1) AS npoints, f1 AS polygon    FROM POLYGON_TBL;
SELECT num, val,     val IS NFC NORMALIZED AS NFC,     val IS NFD NORMALIZED AS NFD,     val IS NFKC NORMALIZED AS NFKC,     val IS NFKD NORMALIZED AS NFKD FROM   (VALUES (1, U&'\00E4bc'),           (2, U&'\0061\0308bc'),           (3, U&'\00E4\24D1c'),           (4, U&'\0061\0308\24D1c'),           (5, '')) vals (num, val) ORDER BY num;
SELECT num_nonnulls(1, 2, NULL::text, NULL::point, '', int8 '9', 1.0 / NULL);
SELECT num_nulls(1, 2, NULL::text, NULL::point, '', int8 '9', 1.0 / NULL);
SELECT nummultirange() && 'empty'::numrange;
SELECT nummultirange() && nummultirange(numrange(1,2));
SELECT nummultirange() &< 'empty'::numrange;
SELECT nummultirange() &< nummultirange();
SELECT nummultirange() &< nummultirange(numrange(1,2));
SELECT nummultirange() &> 'empty'::numrange;
SELECT nummultirange() &> nummultirange();
SELECT nummultirange() &> nummultirange(numrange(1,2));
SELECT nummultirange() * nummultirange(numrange(1,2));
SELECT nummultirange() + nummultirange(numrange(1,2));
SELECT nummultirange() - nummultirange(numrange(1,2));
SELECT nummultirange() -|- 'empty'::numrange;
SELECT nummultirange() -|- nummultirange(numrange(1,2));
SELECT nummultirange() @> 'empty'::numrange;
SELECT nummultirange(numrange(-4,-2), numrange(1,5)) <@ numrange(1,9);
SELECT nummultirange(numrange(-4,-2), numrange(1,5)) @> numrange(1,5);
SELECT nummultirange(numrange(1,2)) && 'empty'::numrange;
SELECT nummultirange(numrange(1,2)) && nummultirange();
SELECT nummultirange(numrange(1,2)) &< 'empty'::numrange;
SELECT nummultirange(numrange(1,2)) &< nummultirange();
SELECT nummultirange(numrange(1,2)) &< nummultirange(numrange(3,4));
SELECT nummultirange(numrange(1,2)) &< numrange(3,4);
SELECT nummultirange(numrange(1,2)) &> 'empty'::numrange;
SELECT nummultirange(numrange(1,2)) &> nummultirange();
SELECT nummultirange(numrange(1,2)) * nummultirange();
SELECT nummultirange(numrange(1,2)) + nummultirange();
SELECT nummultirange(numrange(1,2)) + nummultirange(numrange(1,2));
SELECT nummultirange(numrange(1,2)) + nummultirange(numrange(2,4));
SELECT nummultirange(numrange(1,2)) + nummultirange(numrange(3,4));
SELECT nummultirange(numrange(1,2)) - nummultirange();
SELECT nummultirange(numrange(1,2)) - nummultirange(numrange(1,2));
SELECT nummultirange(numrange(1,2)) - nummultirange(numrange(2,4));
SELECT nummultirange(numrange(1,2)) - nummultirange(numrange(3,4));
SELECT nummultirange(numrange(1,2)) -|- 'empty'::numrange;
SELECT nummultirange(numrange(1,2)) -|- nummultirange();
SELECT nummultirange(numrange(1,2)) -|- nummultirange(numrange(2,4));
SELECT nummultirange(numrange(1,2)) -|- nummultirange(numrange(2,4), numrange(6,7));
SELECT nummultirange(numrange(1,2)) -|- nummultirange(numrange(3,4));
SELECT nummultirange(numrange(1,2)) -|- numrange(2,4);
SELECT nummultirange(numrange(1,2)) -|- numrange(3,4);
SELECT nummultirange(numrange(1,2)) <@ numrange(null,null);
SELECT nummultirange(numrange(1,2), numrange(3,4)) - nummultirange();
SELECT nummultirange(numrange(1,2), numrange(3.5,8)) && nummultirange(numrange(3,4));
SELECT nummultirange(numrange(1,2), numrange(3.5,8)) && numrange(3,4);
SELECT nummultirange(numrange(1,2), numrange(4,5)) + nummultirange(numrange(0,9));
SELECT nummultirange(numrange(1,2), numrange(4,5)) + nummultirange(numrange(2,4));
SELECT nummultirange(numrange(1,2), numrange(4,5)) + nummultirange(numrange(3,4));
SELECT nummultirange(numrange(1,2), numrange(4,5)) - nummultirange(numrange(-2,0));
SELECT nummultirange(numrange(1,2), numrange(4,5)) - nummultirange(numrange(-2,0), numrange(8,9));
SELECT nummultirange(numrange(1,2), numrange(4,5)) - nummultirange(numrange(0,9));
SELECT nummultirange(numrange(1,2), numrange(4,5)) - nummultirange(numrange(2,4));
SELECT nummultirange(numrange(1,2), numrange(4,5)) - nummultirange(numrange(3,5));
SELECT nummultirange(numrange(1,2), numrange(4,5)) - nummultirange(numrange(8,9));
SELECT nummultirange(numrange(1,2), numrange(5,6)) -|- nummultirange(numrange(3,4));
SELECT nummultirange(numrange(1,2), numrange(5,6)) -|- nummultirange(numrange(6,7));
SELECT nummultirange(numrange(1,2), numrange(5,6)) -|- nummultirange(numrange(8,9));
SELECT nummultirange(numrange(1,2), numrange(7,8)) && nummultirange(numrange(3,4));
SELECT nummultirange(numrange(1,3), numrange(4,5)) - nummultirange(numrange(2,9));
SELECT nummultirange(numrange(1,4)) &< nummultirange(numrange(3,4));
SELECT nummultirange(numrange(1,4)) &< numrange(3,4);
SELECT nummultirange(numrange(1,4)) - nummultirange(numrange(0,2));
SELECT nummultirange(numrange(1,4)) - nummultirange(numrange(0,8));
SELECT nummultirange(numrange(1,4)) - nummultirange(numrange(1,2));
SELECT nummultirange(numrange(1,4)) - nummultirange(numrange(2,3));
SELECT nummultirange(numrange(1,4)) <@ numrange(1,5);
SELECT nummultirange(numrange(1,5)) <@ numrange(1,5);
SELECT nummultirange(numrange(1,5)) @> numrange(1,4);
SELECT nummultirange(numrange(1,5)) @> numrange(1,5);
SELECT nummultirange(numrange(1,5)) @> numrange(3,9);
SELECT nummultirange(numrange(1,5)) @> numrange(8,9);
SELECT nummultirange(numrange(1,5), numrange(6,10)) <@ numrange(1,9);
SELECT nummultirange(numrange(1,5), numrange(6,9)) <@ numrange(1,9);
SELECT nummultirange(numrange(1,5), numrange(6,9)) @> numrange(6,7);
SELECT nummultirange(numrange(1,5), numrange(8,9)) <@ numrange(1,9);
SELECT nummultirange(numrange(1,5), numrange(8,9)) @> numrange(1,5);
SELECT nummultirange(numrange(1,5), numrange(8,9)) @> numrange(6,7);
SELECT nummultirange(numrange(1,6)) &< nummultirange(numrange(3,4));
SELECT nummultirange(numrange(1,6)) &< numrange(3,4);
SELECT nummultirange(numrange(1,8)) - nummultirange(numrange(0,2), numrange(3,4));
SELECT nummultirange(numrange(1,8)) - nummultirange(numrange(2,3), numrange(5,null));
SELECT nummultirange(numrange(2,null)) <@ numrange(null,null);
SELECT nummultirange(numrange(3,4)) && nummultirange(numrange(1,2), numrange(3.5,8));
SELECT nummultirange(numrange(3,4)) && nummultirange(numrange(1,2), numrange(7,8));
SELECT nummultirange(numrange(3,4)) &> nummultirange(numrange(1,2));
SELECT nummultirange(numrange(3,4)) &> nummultirange(numrange(1,4));
SELECT nummultirange(numrange(3,4)) &> nummultirange(numrange(1,6));
SELECT nummultirange(numrange(3,4)) &> nummultirange(numrange(3.5,6));
SELECT nummultirange(numrange(3,4)) &> nummultirange(numrange(6,7));
SELECT nummultirange(numrange(3,4)) &> numrange(1,2);
SELECT nummultirange(numrange(3,4)) &> numrange(1,4);
SELECT nummultirange(numrange(3,4)) &> numrange(1,6);
SELECT nummultirange(numrange(3,4)) &> numrange(3.5,6);
SELECT nummultirange(numrange(3,4)) &> numrange(6,7);
SELECT nummultirange(numrange(3,9)) <@ numrange(1,5);
SELECT nummultirange(numrange(3,null)) <@ numrange(5,null);
SELECT nummultirange(numrange(3.5,6)) &< nummultirange(numrange(3,4));
SELECT nummultirange(numrange(3.5,6)) &< numrange(3,4);
SELECT nummultirange(numrange(5,null)) @> numrange(3,null);
SELECT nummultirange(numrange(5,null)) @> numrange(8,null);
SELECT nummultirange(numrange(6,7)) &< nummultirange(numrange(3,4));
SELECT nummultirange(numrange(6,7)) &< numrange(3,4);
SELECT nummultirange(numrange(8,9)) <@ numrange(1,5);
SELECT nummultirange(numrange(8,null)) <@ numrange(5,null);
SELECT nummultirange(numrange(null,2)) <@ numrange(null,null);
SELECT nummultirange(numrange(null,3)) <@ numrange(null,5);
SELECT nummultirange(numrange(null,5)) @> numrange(null,3);
SELECT nummultirange(numrange(null,5)) @> numrange(null,8);
SELECT nummultirange(numrange(null,8)) <@ numrange(null,5);
SELECT nummultirange(numrange(null,null)) @> numrange(1,2);
SELECT nummultirange(numrange(null,null)) @> numrange(2,null);
SELECT nummultirange(numrange(null,null)) @> numrange(null,2);
SELECT numnode( 'new & york | qwery'::tsquery );
SELECT numnode( 'new & york'::tsquery );
SELECT numnode( 'new'::tsquery );
SELECT oid::regprocedure, provariadic::regtype, proargtypes::regtype[] FROM pg_proc WHERE provariadic != 0 AND case proargtypes[array_length(proargtypes, 1)-1] 	WHEN '"any"'::regtype THEN '"any"'::regtype 	WHEN 'anyarray'::regtype THEN 'anyelement'::regtype 	WHEN 'anycompatiblearray'::regtype THEN 'anycompatible'::regtype 	ELSE (SELECT t.oid 		  FROM pg_type t 		  WHERE t.typarray = proargtypes[array_length(proargtypes, 1)-1]) 	END  != provariadic;
SELECT overlay(B'0101011100' placing '001' from 11);
SELECT overlay(B'0101011100' placing '001' from 20);
SELECT overlay(B'0101011100' placing '101' from 6);
SELECT p.* FROM POINT_TBL p    WHERE box '(0,0,100,100)' @> p.f1;
SELECT p.* FROM POINT_TBL p    WHERE not box '(0,0,100,100)' @> p.f1;
SELECT p.* FROM POINT_TBL p WHERE '(0.0,0.0)' >> p.f1;
SELECT p.* FROM POINT_TBL p WHERE '(0.0,0.0)' |>> p.f1;
SELECT p.* FROM POINT_TBL p WHERE p.f1 << '(0.0, 0.0)';
SELECT p.* FROM POINT_TBL p WHERE p.f1 <<| '(0.0, 0.0)';
SELECT p.* FROM POINT_TBL p WHERE p.f1 ~= '(5.1, 34.5)';
SELECT p.f1, b.f1, p.f1 ## b.f1 FROM POINT_TBL p, BOX_TBL b;
SELECT p.f1, l.s, l.s # p.f1 AS intersection    FROM LSEG_TBL l, POINT_TBL p;
SELECT p.f1, l.s, p.f1 ## l.s FROM POINT_TBL p, LINE_TBL l;
SELECT p.f1, l.s, p.f1 ## l.s FROM POINT_TBL p, LSEG_TBL l;
SELECT p.f1, p.f1 <-> point '(0,0)' AS dist    FROM POINT_TBL p    ORDER BY dist;
SELECT p.f1, p1.f1, p.f1 / p1.f1 FROM PATH_TBL p, POINT_TBL p1 WHERE p1.f1 ~= '(0,0)'::point;
SELECT p.f1, p1.f1, p.f1 / p1.f1 FROM PATH_TBL p, POINT_TBL p1 WHERE p1.f1[0] BETWEEN 1 AND 1000;
SELECT p.oid, p.proname, c.oid, c.conname FROM pg_proc p, pg_conversion c WHERE p.oid = c.conproc AND     (p.prorettype != 'int4'::regtype OR p.proretset OR      p.pronargs != 6 OR      p.proargtypes[0] != 'int4'::regtype OR      p.proargtypes[1] != 'int4'::regtype OR      p.proargtypes[2] != 'cstring'::regtype OR      p.proargtypes[3] != 'internal'::regtype OR      p.proargtypes[4] != 'int4'::regtype OR      p.proargtypes[5] != 'bool'::regtype);
SELECT p1.f1    FROM POINT_TBL p1    WHERE ishorizontal(p1.f1, point '(0,0)');
SELECT p1.f1    FROM POINT_TBL p1    WHERE isvertical(p1.f1, point '(5.1,34.5)');
SELECT p1.f1 AS point1, p2.f1 AS point2, (p1.f1 <-> p2.f1) AS distance    FROM POINT_TBL p1, POINT_TBL p2    WHERE (p1.f1 <-> p2.f1) > 3 and p1.f1 << p2.f1    ORDER BY distance, p1.f1[0], p2.f1[0];
SELECT p1.f1 AS point1, p2.f1 AS point2, (p1.f1 <-> p2.f1) AS distance    FROM POINT_TBL p1, POINT_TBL p2    WHERE (p1.f1 <-> p2.f1) > 3 and p1.f1 << p2.f1 and p1.f1 |>> p2.f1    ORDER BY distance;
SELECT p1.f1 AS point1, p2.f1 AS point2, p1.f1 <-> p2.f1 AS dist    FROM POINT_TBL p1, POINT_TBL p2    ORDER BY dist, p1.f1[0], p2.f1[0];
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 &< p2.f1;
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 &<| p2.f1;
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 &> p2.f1;
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 << p2.f1;
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 <<| p2.f1;
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 >> p2.f1;
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 |&> p2.f1;
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 |>> p2.f1;
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 ~= p2.f1;
SELECT p1.f1, p2.f1, line(p1.f1, p2.f1)   FROM POINT_TBL p1, POINT_TBL p2 WHERE p1.f1 <> p2.f1;
SELECT p1.f1, p2.f1, p1.f1 * p2.f1 FROM POINT_TBL p1, POINT_TBL p2 WHERE p1.f1[0] < 1;
SELECT p1.f1, p2.f1, p1.f1 * p2.f1 FROM POINT_TBL p1, POINT_TBL p2 WHERE p1.f1[0] BETWEEN 1 AND 1000;
SELECT p1.f1, p2.f1, p1.f1 / p2.f1 FROM POINT_TBL p1, POINT_TBL p2 WHERE p2.f1 ~= '(0,0)'::point;
SELECT p1.f1, p2.f1, p1.f1 / p2.f1 FROM POINT_TBL p1, POINT_TBL p2 WHERE p2.f1[0] > 1000;
SELECT p1.f1, p2.f1, p1.f1 / p2.f1 FROM POINT_TBL p1, POINT_TBL p2 WHERE p2.f1[0] BETWEEN 1 AND 1000;
SELECT p1.oid, p1.amname, p2.oid, p2.proname FROM pg_am AS p1, pg_proc AS p2 WHERE p2.oid = p1.amhandler AND p1.amtype = 'i' AND     (p2.prorettype != 'index_am_handler'::regtype      OR p2.proretset      OR p2.pronargs != 1      OR p2.proargtypes[0] != 'internal'::regtype);
SELECT p1.oid, p1.amname, p2.oid, p2.proname FROM pg_am AS p1, pg_proc AS p2 WHERE p2.oid = p1.amhandler AND p1.amtype = 's' AND     (p2.prorettype != 'table_am_handler'::regtype      OR p2.proretset      OR p2.pronargs != 1      OR p2.proargtypes[0] != 'internal'::regtype);
SELECT p1.oid, p1.conname FROM pg_conversion as p1 WHERE condefault AND     convert('ABC'::bytea, pg_encoding_to_char(conforencoding),             pg_encoding_to_char(contoencoding)) != 'ABC';
SELECT p1.oid, p1.oprname, p2.oid, p2.proname FROM pg_operator AS p1, pg_proc AS p2 WHERE p1.oprcode = p2.oid AND     p1.oprkind = 'b' AND     (p2.pronargs != 2      OR NOT binary_coercible(p2.prorettype, p1.oprresult)      OR NOT binary_coercible(p1.oprleft, p2.proargtypes[0])      OR NOT binary_coercible(p1.oprright, p2.proargtypes[1]));
SELECT p1.oid, p1.oprname, p2.oid, p2.proname FROM pg_operator AS p1, pg_proc AS p2 WHERE p1.oprcode = p2.oid AND     p1.oprkind = 'l' AND     (p2.pronargs != 1      OR NOT binary_coercible(p2.prorettype, p1.oprresult)      OR NOT binary_coercible(p1.oprright, p2.proargtypes[0])      OR p1.oprleft != 0);
SELECT p1.oid, p1.oprname, p2.oid, p2.proname FROM pg_operator AS p1, pg_proc AS p2 WHERE p1.oprjoin = p2.oid AND     (p1.oprkind != 'b' OR p1.oprresult != 'bool'::regtype OR      p2.prorettype != 'float8'::regtype OR p2.proretset OR      p2.pronargs != 5 OR      p2.proargtypes[0] != 'internal'::regtype OR      p2.proargtypes[1] != 'oid'::regtype OR      p2.proargtypes[2] != 'internal'::regtype OR      p2.proargtypes[3] != 'int2'::regtype OR      p2.proargtypes[4] != 'internal'::regtype);
SELECT p1.oid, p1.oprname, p2.oid, p2.proname FROM pg_operator AS p1, pg_proc AS p2 WHERE p1.oprrest = p2.oid AND     (p1.oprresult != 'bool'::regtype OR      p2.prorettype != 'float8'::regtype OR p2.proretset OR      p2.pronargs != 4 OR      p2.proargtypes[0] != 'internal'::regtype OR      p2.proargtypes[1] != 'oid'::regtype OR      p2.proargtypes[2] != 'internal'::regtype OR      p2.proargtypes[3] != 'int4'::regtype);
SELECT p1.oid, p1.proname, p1.proargtypes, p1.proallargtypes, p1.proargmodes FROM pg_proc as p1 WHERE proallargtypes IS NOT NULL AND   ARRAY(SELECT unnest(proargtypes)) <>   ARRAY(SELECT proallargtypes[i]         FROM generate_series(1, array_length(proallargtypes, 1)) g(i)         WHERE proargmodes IS NULL OR proargmodes[i] IN ('i', 'b', 'v'));
SELECT p1.oid, p1.proname, p2.oid, p2.proname FROM pg_proc AS p1, pg_proc AS p2 WHERE p2.oid = p1.prosupport AND     (p2.prorettype != 'internal'::regtype OR p2.proretset OR p2.pronargs != 1      OR p2.proargtypes[0] != 'internal'::regtype);
SELECT p1.oid, p1.typname, p2.oid, p2.proname FROM pg_type AS p1, pg_proc AS p2 WHERE p1.typanalyze = p2.oid AND NOT     (p2.pronargs = 1 AND      p2.proargtypes[0] = 'internal'::regtype AND      p2.prorettype = 'bool'::regtype AND NOT p2.proretset);
SELECT p1.oid, p1.typname, p2.oid, p2.proname FROM pg_type AS p1, pg_proc AS p2 WHERE p1.typinput = p2.oid AND NOT     ((p2.pronargs = 1 AND p2.proargtypes[0] = 'cstring'::regtype) OR      (p2.pronargs = 2 AND p2.proargtypes[0] = 'cstring'::regtype AND       p2.proargtypes[1] = 'oid'::regtype) OR      (p2.pronargs = 3 AND p2.proargtypes[0] = 'cstring'::regtype AND       p2.proargtypes[1] = 'oid'::regtype AND       p2.proargtypes[2] = 'int4'::regtype));
SELECT p1.oid, p1.typname, p2.oid, p2.proname FROM pg_type AS p1, pg_proc AS p2 WHERE p1.typmodin = p2.oid AND NOT     (p2.pronargs = 1 AND      p2.proargtypes[0] = 'cstring[]'::regtype AND      p2.prorettype = 'int4'::regtype AND NOT p2.proretset);
SELECT p1.oid, p1.typname, p2.oid, p2.proname FROM pg_type AS p1, pg_proc AS p2 WHERE p1.typmodout = p2.oid AND NOT     (p2.pronargs = 1 AND      p2.proargtypes[0] = 'int4'::regtype AND      p2.prorettype = 'cstring'::regtype AND NOT p2.proretset);
SELECT p1.oid, p1.typname, p2.oid, p2.proname FROM pg_type AS p1, pg_proc AS p2 WHERE p1.typoutput = p2.oid AND p1.typtype in ('b', 'p') AND NOT     (p2.pronargs = 1 AND      (p2.proargtypes[0] = p1.oid OR       (p2.oid = 'array_out'::regproc AND        p1.typelem != 0 AND p1.typlen = -1))) ORDER BY 1;
SELECT p1.oid, p1.typname, p2.oid, p2.proname FROM pg_type AS p1, pg_proc AS p2 WHERE p1.typreceive = p2.oid AND NOT     ((p2.pronargs = 1 AND p2.proargtypes[0] = 'internal'::regtype) OR      (p2.pronargs = 2 AND p2.proargtypes[0] = 'internal'::regtype AND       p2.proargtypes[1] = 'oid'::regtype) OR      (p2.pronargs = 3 AND p2.proargtypes[0] = 'internal'::regtype AND       p2.proargtypes[1] = 'oid'::regtype AND       p2.proargtypes[2] = 'int4'::regtype));
SELECT p1.oid, p1.typname, p2.oid, p2.proname FROM pg_type AS p1, pg_proc AS p2 WHERE p1.typsend = p2.oid AND p1.typtype in ('b', 'p') AND NOT     (p2.pronargs = 1 AND      (p2.proargtypes[0] = p1.oid OR       (p2.oid = 'array_send'::regproc AND        p1.typelem != 0 AND p1.typlen = -1))) ORDER BY 1;
SELECT p1.rngtypid, p1.rngsubtype, p.proname FROM pg_range p1 JOIN pg_proc p ON p.oid = p1.rngcanonical WHERE pronargs != 1 OR proargtypes[0] != rngtypid OR prorettype != rngtypid;
SELECT p1.rngtypid, p1.rngsubtype, p.proname FROM pg_range p1 JOIN pg_proc p ON p.oid = p1.rngsubdiff WHERE pronargs != 2     OR proargtypes[0] != rngsubtype OR proargtypes[1] != rngsubtype     OR prorettype != 'pg_catalog.float8'::regtype;
SELECT pg_current_xact_id() \gset SELECT pg_current_xact_id_if_assigned() IS NOT DISTINCT FROM xid8 :'pg_current_xact_id';
SELECT pg_xact_status(:inprogress::text::xid8) AS inprogress;
SELECT pg_xact_status(:rolledback::text::xid8) AS rolledback;
SELECT plainto_tsquery('english', 'foo bar') || !!plainto_tsquery('english', 'asd fg');
SELECT power(float8 '-0.1', float8 '-inf');
SELECT power(float8 '-0.1', float8 'inf');
SELECT power(float8 '-1', float8 '-inf');
SELECT power(float8 '-1', float8 'NaN');
SELECT power(float8 '-1', float8 'inf');
SELECT power(float8 '-1.1', float8 '-inf');
SELECT power(float8 '-1.1', float8 'inf');
SELECT power(float8 '-inf', float8 '-2') = '0';
SELECT power(float8 '-inf', float8 '-3');
SELECT power(float8 '-inf', float8 '-inf');
SELECT power(float8 '-inf', float8 '0');
SELECT power(float8 '-inf', float8 '2');
SELECT power(float8 '-inf', float8 '3');
SELECT power(float8 '-inf', float8 '3.5');
SELECT power(float8 '-inf', float8 'inf');
SELECT power(float8 '0', float8 '-inf');
SELECT power(float8 '0', float8 'inf');
SELECT power(float8 '0.1', float8 '-inf');
SELECT power(float8 '0.1', float8 'inf');
SELECT power(float8 '1', float8 '-inf');
SELECT power(float8 '1', float8 'NaN');
SELECT power(float8 '1', float8 'inf');
SELECT power(float8 '1.1', float8 '-inf');
SELECT power(float8 '1.1', float8 'inf');
SELECT power(float8 '144', float8 '0.5');
SELECT power(float8 '144', float8 'NaN');
SELECT power(float8 'NaN', float8 '0');
SELECT power(float8 'NaN', float8 '0.5');
SELECT power(float8 'NaN', float8 'NaN');
SELECT power(float8 'inf', float8 '-2');
SELECT power(float8 'inf', float8 '-inf');
SELECT power(float8 'inf', float8 '0');
SELECT power(float8 'inf', float8 '2');
SELECT power(float8 'inf', float8 'inf');
SELECT q1, float8(q1) FROM INT8_TBL;
SELECT q1, q1 << 2 AS "shl", q1 >> 3 AS "shr" FROM INT8_TBL;
SELECT q1, q2, q1 & q2 AS "and", q1 | q2 AS "or", q1 # q2 AS "xor", ~q1 AS "not" FROM INT8_TBL;
SELECT q1, q2, q1 / q2 AS divide, q1 % q2 AS mod FROM INT8_TBL;
SELECT q2, float8(q2) FROM INT8_TBL;
SELECT range_merge(nummultirange(numrange(1,2)));
SELECT range_merge(nummultirange(numrange(1,2), numrange(7,8)));
SELECT rank() OVER (PARTITION BY four, ORDER BY ten) FROM tenk1;
SELECT regexp_matches('foObARbEqUEbAz', $re$(bar)(beque)$re$, 'i');
SELECT regexp_matches('foobarbequebaz', $re$(bar)(.*)(beque)$re$);
SELECT regexp_matches('foobarbequebaz', $re$(bar)(.+)(beque)$re$);
SELECT regexp_matches('foobarbequebaz', $re$(bar)(.+)?(beque)$re$);
SELECT regexp_matches('foobarbequebaz', $re$(bar)(beque)$re$, 'gz');
SELECT regexp_matches('foobarbequebaz', $re$(bar)(beque){2,1}$re$);
SELECT regexp_matches('foobarbequebaz', $re$(barbeque$re$);
SELECT regexp_matches('foobarbequebaz', $re$barbeque$re$);
SELECT regexp_matches('foobarbequebazilbarfbonk', $re$(b[^b]+)(b[^b]+)$re$, 'g');
SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', $re$\s*$re$);
SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', $re$\s+$re$);
SELECT relname, attname, attcollation FROM pg_class c, pg_attribute a WHERE c.oid = attrelid AND c.oid < 16384 AND     c.relkind != 'v' AND  -- we don't care about columns in views     attcollation != 0 AND     attcollation != (SELECT oid FROM pg_collation WHERE collname = 'C');
SELECT reloptions FROM pg_class WHERE oid = :toast_oid;
SELECT reloptions FROM pg_class WHERE oid = :toast_oid;
SELECT reltoastrelid as toast_oid 	FROM pg_class WHERE oid = 'reloptions_test'::regclass \gset SELECT reloptions FROM pg_class WHERE oid = :toast_oid;
SELECT row_to_json(q) FROM (SELECT $$a$$ || x AS b,          y AS c,          ARRAY[ROW(x.*,ARRAY[1,2,3]),                ROW(y.*,ARRAY[4,5,6])] AS z       FROM generate_series(1,2) x,            generate_series(4,5) y) q;
SELECT row_to_json(q,true) FROM (SELECT $$a$$ || x AS b,          y AS c,          ARRAY[ROW(x.*,ARRAY[1,2,3]),                ROW(y.*,ARRAY[4,5,6])] AS z       FROM generate_series(1,2) x,            generate_series(4,5) y) q;
SELECT row_to_json(x.*) FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE J1_TBL.t = 'one';
SELECT s, @-@ s FROM LSEG_TBL;
SELECT s, s::point FROM LSEG_TBL;
SELECT set_bit('\x1234567890abcdef00'::bytea, 99, 0);  -- error SELECT get_byte('\x1234567890abcdef00'::bytea, 3);
SELECT set_bit(B'0101011000100100', 15, 1);
SELECT set_bit(B'0101011000100100', 16, 1);	-- fail SELECT overlay(B'0101011100' placing '001' from 2 for 3);
SELECT set_byte('\x1234567890abcdef00'::bytea, 99, 11);  -- error set escape_string_warning = off;
SELECT set_masklen(inet(text(i)), 24) FROM INET_TBL;
SELECT setweight('a asd w:5,6,12B,13A zxc'::tsvector, 'c', ARRAY['a', 'zxc', '', NULL]);
SELECT setweight('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567'::tsvector, 'c');
SELECT setweight('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567'::tsvector, 'c', '{a,zxc}');
SELECT setweight('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567'::tsvector, 'c', '{a}');
SELECT setweight('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567'::tsvector, 'c', '{a}');
SELECT setweight('w:12B w:13* w:12,5,6 a:1,3* a:3 w asd:1dc asd zxc:81,567,222A'::tsvector, 'c');
SELECT sinh(float8 '-infinity');
SELECT sinh(float8 '1');
SELECT sinh(float8 'infinity');
SELECT sinh(float8 'nan');
SELECT sqrt(float8 '64') AS eight;
SELECT strip('base hidden rebel spaceship strike'::tsvector);
SELECT strip('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);
SELECT strip('w:12B w:13* w:12,5,6 a:1,3* a:3 w asd:1dc asd'::tsvector);
SELECT strip('wa:1A'::tsvector) @@ '!w:*A'::tsquery as "false";
SELECT strip('wa:1A'::tsvector) @@ '!w:*D'::tsquery as "false";
SELECT strip('wa:1A'::tsvector) @@ 'w:*A'::tsquery as "true";
SELECT strip('wa:1A'::tsvector) @@ 'w:*D'::tsquery as "true";
SELECT t.f[1][3][1] AS "131", t.f[2][2][1] AS "221" FROM (   SELECT ARRAY[[[111,112],[121,122],[131,132]],[[211,212],[221,122],[231,232]]] AS f ) AS t;
SELECT tanh(float8 '-infinity');
SELECT tanh(float8 '1');
SELECT tanh(float8 'infinity');
SELECT tanh(float8 'nan');
SELECT test_future_xid_status((:inprogress + 10000)::text::xid8);
SELECT test_future_xid_status(:inprogress + 10000);
SELECT text 'this is a text string' = text 'this is a text strin' AS false;
SELECT text 'this is a text string' = text 'this is a text string' AS true;
SELECT timestamptz(date '1994-01-01', time '10:00') AS "Jan_01_1994_9am";
SELECT timestamptz(date '1994-01-01', time '11:00') AS "Jan_01_1994_10am";
SELECT timestamptz(date '1994-01-01', time with time zone '10:00-8') AS "Jan_01_1994_10am";
SELECT timestamptz(date '1994-01-01', time with time zone '11:00-5') AS "Jan_01_1994_8am";
SELECT timestamptz(date '1994-01-01', time with time zone '11:00-5') AS "Jan_01_1994_8am";
SELECT timestamptz(date '1994-01-01', time with time zone '11:00-8') AS "Jan_01_1994_11am";
SELECT to_char(date '2010-02-01', 'DD TMMON YYYY' COLLATE "tr_TR");
SELECT to_char(date '2010-02-01', 'DD TMMON YYYY');
SELECT to_char(date '2010-04-01', 'DD TMMON YYYY' COLLATE "tr-x-icu");
SELECT to_char(date '2010-04-01', 'DD TMMON YYYY' COLLATE "tr_TR");
SELECT to_char(date '2010-04-01', 'DD TMMON YYYY');
SELECT to_char(date '2010-04-01', 'DD TMMON YYYY');
SELECT trim(E'\\000'::bytea from E'\\000Tom\\000'::bytea);
SELECT trim(leading E'\\000'::bytea from E'\\000Tom\\000'::bytea);
SELECT trim(trailing E'\\000'::bytea from E'\\000Tom\\000'::bytea);
SELECT true AS true;
SELECT true::boolean::text AS true, false::boolean::text AS false;
SELECT ts_delete('base hidden rebel spaceship strike'::tsvector, 'spaceship');
SELECT ts_delete('base hidden rebel spaceship strike'::tsvector, ARRAY['spaceship','leya','rebel', '', NULL]);
SELECT ts_delete('base hidden rebel spaceship strike'::tsvector, ARRAY['spaceship','leya','rebel','rebel']);
SELECT ts_delete('base hidden rebel spaceship strike'::tsvector, ARRAY['spaceship','leya','rebel']);
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, 'bas');
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, 'base');
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, 'bases');
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, 'spaceship');
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, ARRAY['spaceshi','rebel']);
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, ARRAY['spaceship','leya','rebel']);
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, ARRAY['spaceship','rebel']);
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, ARRAY['spaceships','rebel']);
SELECT ts_filter('base hidden rebel spaceship strike'::tsvector, '{a,b,NULL}');
SELECT ts_filter('base hidden rebel spaceship strike'::tsvector, '{a}');
SELECT ts_filter('base:7A empir:17 evil:15 first:11 galact:16 hidden:6A rebel:1A spaceship:2A strike:3A victori:12 won:9'::tsvector, '{a}');
SELECT ts_headline('english', ' <html> <!-- some comment --> <body> Sea view wow <u>foo bar</u> <i>qq</i> <a href="http://www.google.com/foo.bar.html" target="_blank">YES &nbsp;</a> ff-bg <script>        document.write(15);
SELECT ts_headline('english', ' Day after day, day after day,   We stuck, nor breath nor motion, As idle as a painted Ship   Upon a painted Ocean. Water, water, every where   And all the boards did shrink;
SELECT ts_headline('english', ' Day after day, day after day,   We stuck, nor breath nor motion, As idle as a painted Ship   Upon a painted Ocean. Water, water, every where   And all the boards did shrink;
SELECT ts_headline('english', ' Day after day, day after day,   We stuck, nor breath nor motion, As idle as a painted Ship   Upon a painted Ocean. Water, water, every where   And all the boards did shrink;
SELECT ts_headline('english', ' Day after day, day after day,   We stuck, nor breath nor motion, As idle as a painted Ship   Upon a painted Ocean. Water, water, every where   And all the boards did shrink;
SELECT ts_headline('english', ' Day after day, day after day,   We stuck, nor breath nor motion, As idle as a painted Ship   Upon a painted Ocean. Water, water, every where   And all the boards did shrink;
SELECT ts_headline('english', ' Day after day, day after day,   We stuck, nor breath nor motion, As idle as a painted Ship   Upon a painted Ocean. Water, water, every where   And all the boards did shrink;
SELECT ts_headline('english', ' Day after day, day after day,   We stuck, nor breath nor motion, As idle as a painted Ship   Upon a painted Ocean. Water, water, every where   And all the boards did shrink;
SELECT ts_headline('english', ' Day after day, day after day,   We stuck, nor breath nor motion, As idle as a painted Ship   Upon a painted Ocean. Water, water, every where   And all the boards did shrink;
SELECT ts_headline('english', ' Day after day, day after day,   We stuck, nor breath nor motion, As idle as a painted Ship   Upon a painted Ocean. Water, water, every where   And all the boards did shrink;
SELECT ts_rank(' a:1 s:2 d g'::tsvector, 'a & s');
SELECT ts_rank(' a:1 s:2 d g'::tsvector, 'a | s');
SELECT ts_rank(' a:1 s:2B d g'::tsvector, 'a & s');
SELECT ts_rank(' a:1 s:2B d g'::tsvector, 'a | s');
SELECT ts_rank(' a:1 s:2C d g'::tsvector, 'a & s');
SELECT ts_rank(' a:1 s:2C d g'::tsvector, 'a | s');
SELECT ts_rank(' a:1 sa:2C d g'::tsvector, 'a | s');
SELECT ts_rank(' a:1 sa:2C d g'::tsvector, 'a | s:*');
SELECT ts_rank(' a:1 sa:2C d g'::tsvector, 'a | sa:*');
SELECT ts_rank_cd(' a:1 b:2 s:3A d:2A g'::tsvector, 'a <2> s:A');
SELECT ts_rank_cd(' a:1 s:2 d g'::tsvector, 'a & s');
SELECT ts_rank_cd(' a:1 s:2 d g'::tsvector, 'a <-> s');
SELECT ts_rank_cd(' a:1 s:2 d g'::tsvector, 'a | s');
SELECT ts_rank_cd(' a:1 s:2 d:2A g'::tsvector, 'a <-> s');
SELECT ts_rank_cd(' a:1 s:2,3A d:2A g'::tsvector, 'a <2> s:A');
SELECT ts_rank_cd(' a:1 s:2A d g'::tsvector, 'a <-> s');
SELECT ts_rank_cd(' a:1 s:2B d g'::tsvector, 'a & s');
SELECT ts_rank_cd(' a:1 s:2B d g'::tsvector, 'a | s');
SELECT ts_rank_cd(' a:1 s:2C d g'::tsvector, 'a & s');
SELECT ts_rank_cd(' a:1 s:2C d g'::tsvector, 'a <-> s');
SELECT ts_rank_cd(' a:1 s:2C d g'::tsvector, 'a | s');
SELECT ts_rank_cd(' a:1 sa:2A sb:2D g'::tsvector, 'a <-> s:* <-> sa:A');
SELECT ts_rank_cd(' a:1 sa:2A sb:2D g'::tsvector, 'a <-> s:* <-> sa:B');
SELECT ts_rank_cd(' a:1 sa:2A sb:2D g'::tsvector, 'a <-> s:*');
SELECT ts_rank_cd(' a:1 sa:2C d g'::tsvector, 'a | s');
SELECT ts_rank_cd(' a:1 sa:2C d g'::tsvector, 'a | s:*');
SELECT ts_rank_cd(' a:1 sa:2C d g'::tsvector, 'a | sa:*');
SELECT ts_rank_cd(' a:1 sa:2D sb:2A g'::tsvector, 'a <-> s:*');
SELECT ts_rank_cd(' a:1 sa:3C sab:2c d g'::tsvector, 'a | sa:*');
SELECT ts_rank_cd(to_tsvector('english', ' Day after day, day after day,   We stuck, nor breath nor motion, As idle as a painted Ship   Upon a painted Ocean. Water, water, every where   And all the boards did shrink;
SELECT ts_rank_cd(to_tsvector('english', ' Day after day, day after day,   We stuck, nor breath nor motion, As idle as a painted Ship   Upon a painted Ocean. Water, water, every where   And all the boards did shrink;
SELECT ts_rank_cd(to_tsvector('english', ' Day after day, day after day,   We stuck, nor breath nor motion, As idle as a painted Ship   Upon a painted Ocean. Water, water, every where   And all the boards did shrink;
SELECT ts_rank_cd(to_tsvector('english', ' Day after day, day after day,   We stuck, nor breath nor motion, As idle as a painted Ship   Upon a painted Ocean. Water, water, every where   And all the boards did shrink;
SELECT ts_rewrite('foo & bar & qq & new & york',  'new & york'::tsquery, 'big & apple | nyc | new & york & city');
SELECT tsvector_to_array('base hidden rebel spaceship strike'::tsvector);
SELECT tsvector_to_array('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);
SELECT tsvectorin(tsvectorout($$'\\as' ab\c ab\\c AB\\\c ab\\\\c$$::tsvector));
SELECT txid_current() \gset SELECT txid_current_if_assigned() IS NOT DISTINCT FROM BIGINT :'txid_current';
SELECT txid_status(:inprogress) AS inprogress;
SELECT txid_status(:rolledback) AS rolledback;
SELECT unnest('base hidden rebel spaceship strike'::tsvector);
SELECT unnest('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);
SELECT v as value, hash_aclitem(v)::bit(32) as standard,        hash_aclitem_extended(v, 0)::bit(32) as extended0,        hash_aclitem_extended(v, 1)::bit(32) as extended1 FROM   (SELECT DISTINCT(relacl[1]) FROM pg_class LIMIT 10) x(v) WHERE  hash_aclitem(v)::bit(32) != hash_aclitem_extended(v, 0)::bit(32)        OR hash_aclitem(v)::bit(32) = hash_aclitem_extended(v, 1)::bit(32);
SELECT v as value, hash_array(v)::bit(32) as standard FROM   (VALUES ('{0}'::money[])) x(v);
SELECT v as value, hash_array_extended(v, 0)::bit(32) as extended0 FROM   (VALUES ('{0}'::money[])) x(v);
SELECT v as value, hash_range(v)::bit(32) as standard,        hash_range_extended(v, 0)::bit(32) as extended0,        hash_range_extended(v, 1)::bit(32) as extended1 FROM   (VALUES (int4range(10, 20)), (int4range(23, 43)),         (int4range(5675, 550273)),         (int4range(550274, 1550274)), (int4range(1550275, 208112489))) x(v) WHERE  hash_range(v)::bit(32) != hash_range_extended(v, 0)::bit(32)        OR hash_range(v)::bit(32) = hash_range_extended(v, 1)::bit(32);
SELECT v as value, hashinet(v)::bit(32) as standard,        hashinetextended(v, 0)::bit(32) as extended0,        hashinetextended(v, 1)::bit(32) as extended1 FROM   (VALUES (NULL::inet), ('192.168.100.128/25'), ('192.168.100.0/8'),         ('172.168.10.126/16'), ('172.18.103.126/24'), ('192.188.13.16/32')) x(v) WHERE  hashinet(v)::bit(32) != hashinetextended(v, 0)::bit(32)        OR hashinet(v)::bit(32) = hashinetextended(v, 1)::bit(32);
SELECT v as value, hashmacaddr(v)::bit(32) as standard,        hashmacaddrextended(v, 0)::bit(32) as extended0,        hashmacaddrextended(v, 1)::bit(32) as extended1 FROM   (VALUES (NULL::macaddr), ('08:00:2b:01:02:04'), ('08:00:2b:01:02:04'),         ('e2:7f:51:3e:70:49'), ('d6:a9:4a:78:1c:d5'),         ('ea:29:b1:5e:1f:a5')) x(v) WHERE  hashmacaddr(v)::bit(32) != hashmacaddrextended(v, 0)::bit(32)        OR hashmacaddr(v)::bit(32) = hashmacaddrextended(v, 1)::bit(32);
SELECT v as value, hashmacaddr8(v)::bit(32) as standard,        hashmacaddr8extended(v, 0)::bit(32) as extended0,        hashmacaddr8extended(v, 1)::bit(32) as extended1 FROM   (VALUES (NULL::macaddr8), ('08:00:2b:01:02:04:36:49'),         ('08:00:2b:01:02:04:f0:e8'), ('e2:7f:51:3e:70:49:16:29'),         ('d6:a9:4a:78:1c:d5:47:32'), ('ea:29:b1:5e:1f:a5')) x(v) WHERE  hashmacaddr8(v)::bit(32) != hashmacaddr8extended(v, 0)::bit(32)        OR hashmacaddr8(v)::bit(32) = hashmacaddr8extended(v, 1)::bit(32);
SELECT v, v >> 1 AS vsr, v << 1 AS vsl        FROM VARBIT_SHIFT_TABLE ;
SELECT v, v >> 8 AS vsr8, v << 8 AS vsl8        FROM VARBIT_SHIFT_TABLE ;
SELECT xmlelement(name foo, bytea 'bar');
SELECT xmlelement(name foo, bytea 'bar');
SELECT ||/ float8 '27' AS three;
SHOW DateStyle;
SHOW DateStyle;
SHOW DateStyle;
SHOW DateStyle;
SHOW DateStyle;
SHOW TIME ZONE;
SHOW TimeZone;  -- Many of these tests depend on the prevailing setting SELECT timestamp with time zone '20011227 040506+08';
SHOW allow_system_table_mods;
SHOW custom.my.qualified.guc;
SHOW custom.my_guc;
SHOW custom.my_guc;  -- error, not known yet SET custom.my_guc = 42;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW datestyle;
SHOW track_counts;  -- must be on SET enable_seqscan TO on;
SHOW transaction_deferrable;
SHOW transaction_deferrable;
SHOW transaction_deferrable;
SHOW transaction_deferrable;
SHOW transaction_deferrable;
SHOW transaction_deferrable;
SHOW transaction_deferrable;
SHOW transaction_deferrable;
SHOW transaction_deferrable;
SHOW transaction_deferrable;
SHOW transaction_isolation;
SHOW transaction_isolation;
SHOW transaction_isolation;
SHOW transaction_isolation;
SHOW transaction_read_only;
SHOW transaction_read_only;
SHOW transaction_read_only;
SHOW transaction_read_only;
SHOW transaction_read_only;
SHOW transaction_read_only;
SHOW transaction_read_only;
SHOW transaction_read_only;
SHOW transaction_read_only;
SHOW transaction_read_only;
SHOW transaction_read_only;  -- off COMMIT;
SHOW transaction_read_only;  -- off SAVEPOINT y;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
SHOW vacuum_cost_delay;
TRUE	null	FALSE	null FALSE	TRUE	null	null null	TRUE	FALSE	null \. SELECT   BOOL_AND(b1)     AS "f",   BOOL_AND(b2)     AS "t",   BOOL_AND(b3)     AS "f",   BOOL_AND(b4)     AS "n",   BOOL_AND(NOT b2) AS "f",   BOOL_AND(NOT b3) AS "t" FROM bool_test;
TRUNCATE ONLY trunc_fb, ONLY trunc_fa;
UNLISTEN *;
UNLISTEN *;
UNLISTEN a;
UNLISTEN notify_async2;
UPDATE arrtest   SET a[1:2] = '{16,25}'   WHERE NOT a = '{}'::_int2;
UPDATE arrtest   SET b[1:1][1:1][1:2] = '{113, 117}',       b[1:1][1:2][2:2] = '{142, 147}'   WHERE array_dims(b) = '[1:1][1:2][1:2]';
UPDATE arrtest   SET c[1:NULL] = '{"can''t assign"}'   WHERE array_dims(c) is not null;
UPDATE arrtest   SET c[2:2] = '{"new_word"}'   WHERE array_dims(c) is not null;
UPDATE arrtest   SET c[NULL:1] = '{"can''t assign"}'   WHERE array_dims(c) is not null;
UPDATE arrtest   SET c[NULL] = '{"can''t assign"}'   WHERE array_dims(c) is not null;
UPDATE arrtest SET a[4] = NULL WHERE a[2] IS NULL;
UPDATE arrtest SET e[0] = '1.1';
UPDATE arrtest SET e[1] = '2.2';
UPDATE arrtest_s SET a[3:] = '{23, 24, 25}', b[2:][2:] = '{{25,26}, {28,29}}';
UPDATE arrtest_s SET a[:3] = '{11, 12, 13}', b[:2][:2] = '{{11,12}, {14,15}}'   WHERE array_lower(a,1) = 1;
UPDATE arrtest_s SET a[:] = '{11, 12, 13, 14, 15}';
UPDATE arrtest_s SET a[:] = '{11, 12, 13, 14, 15}';  -- fail, no good with null SELECT f1[0:1] FROM POINT_TBL;
UPDATE arrtest_s SET a[:] = '{23, 24, 25}';  -- fail, too small INSERT INTO arrtest_s VALUES(NULL, NULL);
UPDATE current_check SET payload = payload || '_new' WHERE CURRENT OF current_check_cursor RETURNING *;
UPDATE current_check SET payload = payload || '_new' WHERE CURRENT OF current_check_cursor RETURNING *;
UPDATE point_tbl SET f1[0] = -10, f1[1] = -10 WHERE f1::text = '(10,10)'::point::text RETURNING *;
UPDATE point_tbl SET f1[0] = 10 WHERE f1 IS NULL RETURNING *;
UPDATE point_tbl SET f1[0] = NULL WHERE f1::text = '(10,10)'::point::text RETURNING *;
UPDATE point_tbl SET f1[3] = 10 WHERE f1::text = '(-10,-10)'::point::text RETURNING *;
UPDATE price     SET active = true, price = input_prices.price     FROM unnest(ARRAY[(10, 123.00), (11, 99.99)]::price_input[]) input_prices     WHERE price_key_from_table(price.*) = price_key_from_input(input_prices.*);
UPDATE rw_view1 SET arr[1] = 42, arr[2] = 77 WHERE a = 3;
UPDATE uctest SET f1 = 8 WHERE CURRENT OF c1;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;  -- fail ROLLBACK;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1;  -- fail ROLLBACK;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1; -- no-op SELECT * FROM uctest;
UPDATE uctest SET f1 = f1 + 10 WHERE CURRENT OF c1; -- no-op SELECT * FROM uctest;
UPDATE update_test   SET (b,a) = (select a,b from update_test where b = 41 and c = 'car')   WHERE a = 100 AND b = 20;
UPDATE update_test SET (a,b) = (v.*) FROM (VALUES(21, 101)) AS v(i, j)   WHERE update_test.a = v.i;
UPDATE update_test SET (a,b) = ROW(v.*) FROM (VALUES(21, 100)) AS v(i, j)   WHERE update_test.a = v.i;
UPDATE update_test SET (b,a) = (select a+1,b from update_test where a = 1000)   WHERE a = 11;
UPDATE update_test SET (b,a) = (select a+1,b from update_test);
UPDATE update_test SET (c,b) = ('car', a+b), a = a + 1 WHERE a = 10;
UPDATE update_test SET (c,b) = ('car', a+b), b = a + 1 WHERE a = 10;
UPDATE update_test SET (c,b,a) = ('bugle', b+11, DEFAULT) WHERE c = 'foo';
UPDATE update_test o   SET (b,a) = (select a+1,b from update_test i                where i.a=o.a and i.b=o.b and i.c is not distinct from o.c);
UPDATE update_test t   SET (a, b) = (SELECT b, a FROM update_test s WHERE s.a = t.a)   WHERE CURRENT_USER = SESSION_USER;
WITH    x AS (SELECT proname, proowner, procost::numeric, pronargs,                 array_to_string(proargnames,',') as proargnames,                 case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes            FROM pg_proc WHERE proname = 'f_leak'),    y AS (SELECT xmlelement(name proc,                            xmlforest(proname, proowner,                                      procost, pronargs,                                      proargnames, proargtypes)) as proc            FROM x),    z AS (SELECT xmltable.*            FROM y,                 LATERAL xmltable('/proc' PASSING proc                                  COLUMNS proname name,                                          proowner oid,                                          procost float,                                          pronargs int,                                          proargnames text,                                          proargtypes text))    SELECT * FROM z    EXCEPT SELECT * FROM x;
WITH    x AS (SELECT proname, proowner, procost::numeric, pronargs,                 array_to_string(proargnames,',') as proargnames,                 case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes            FROM pg_proc),    y AS (SELECT xmlelement(name data,                            xmlagg(xmlelement(name proc,                                              xmlforest(proname, proowner, procost,                                                        pronargs, proargnames, proargtypes)))) as doc            FROM x),    z AS (SELECT xmltable.*            FROM y,                 LATERAL xmltable('/data/proc' PASSING doc                                  COLUMNS proname name,                                          proowner oid,                                          procost float,                                          pronargs int,                                          proargnames text,                                          proargtypes text))    SELECT * FROM z    EXCEPT SELECT * FROM x;
WITH RECURSIVE outermost(x) AS (   WITH innermost as (SELECT 2 FROM outermost) -- fail     SELECT * FROM innermost     UNION SELECT * from outermost ) SELECT * FROM outermost ORDER BY 1;
WITH RECURSIVE t(id, path) AS (     VALUES(1,ARRAY[]::integer[]) UNION ALL     SELECT tree.id, t.path || tree.id     FROM tree JOIN t ON (tree.parent_id = t.id) ) SELECT t1.*, t2.* FROM t AS t1 JOIN t AS t2 ON 	(t1.path[1] = t2.path[1] AND 	array_upper(t1.path,1) = 1 AND 	array_upper(t2.path,1) > 1) 	ORDER BY t1.id, t2.id;
WITH RECURSIVE t(id, path) AS (     VALUES(1,ARRAY[]::integer[]) UNION ALL     SELECT tree.id, t.path || tree.id     FROM tree JOIN t ON (tree.parent_id = t.id) ) SELECT t1.id, count(t2.*) FROM t AS t1 JOIN t AS t2 ON 	(t1.path[1] = t2.path[1] AND 	array_upper(t1.path,1) = 1 AND 	array_upper(t2.path,1) > 1) 	GROUP BY t1.id 	ORDER BY t1.id;
WITH RECURSIVE t(id, path) AS (     VALUES(1,ARRAY[]::integer[]) UNION ALL     SELECT tree.id, t.path || tree.id     FROM tree JOIN t ON (tree.parent_id = t.id) ) SELECT t1.id, t2.path, t2 FROM t AS t1 JOIN t AS t2 ON (t1.id=t2.id);
WITH RECURSIVE t(n) AS (     VALUES (1::money) UNION     SELECT n+1::money FROM t WHERE n < 100::money ) SELECT sum(n) FROM t;
WITH data(hat_name, hat_color) AS MATERIALIZED (     VALUES ('h8', 'green'),         ('h9', 'blue'),         ('h7', 'forbidden') ) INSERT INTO hats     SELECT * FROM data RETURNING *;
WITH objects (type, name, args) AS (VALUES 				('table', '{addr_nsp, gentable}'::text[], '{}'::text[]), 				('table', '{addr_nsp, parttable}'::text[], '{}'::text[]), 				('index', '{addr_nsp, gentable_pkey}', '{}'), 				('index', '{addr_nsp, parttable_pkey}', '{}'), 				('sequence', '{addr_nsp, gentable_a_seq}', '{}'), 				('view', '{addr_nsp, genview}', '{}'), 				('materialized view', '{addr_nsp, genmatview}', '{}'), 				('foreign table', '{addr_nsp, genftable}', '{}'), 				('table column', '{addr_nsp, gentable, b}', '{}'), 				('foreign table column', '{addr_nsp, genftable, a}', '{}'), 				('aggregate', '{addr_nsp, genaggr}', '{int4}'), 				('function', '{pg_catalog, pg_identify_object}', '{pg_catalog.oid, pg_catalog.oid, int4}'), 				('procedure', '{addr_nsp, proc}', '{int4}'), 				('type', '{pg_catalog._int4}', '{}'), 				('type', '{addr_nsp.gendomain}', '{}'), 				('type', '{addr_nsp.gencomptype}', '{}'), 				('type', '{addr_nsp.genenum}', '{}'), 				('cast', '{int8}', '{int4}'), 				('collation', '{default}', '{}'), 				('table constraint', '{addr_nsp, gentable, a_chk}', '{}'), 				('domain constraint', '{addr_nsp.gendomain}', '{domconstr}'), 				('conversion', '{pg_catalog, koi8_r_to_mic}', '{}'), 				('default value', '{addr_nsp, gentable, b}', '{}'), 				('language', '{plpgsql}', '{}'), 				('operator', '{+}', '{int4, int4}'), 				('operator class', '{btree, int4_ops}', '{}'), 				('operator family', '{btree, integer_ops}', '{}'), 				('operator of access method', '{btree,integer_ops,1}', '{integer,integer}'), 				('function of access method', '{btree,integer_ops,2}', '{integer,integer}'), 				('rule', '{addr_nsp, genview, _RETURN}', '{}'), 				('trigger', '{addr_nsp, gentable, t}', '{}'), 				('schema', '{addr_nsp}', '{}'), 				('text search parser', '{addr_ts_prs}', '{}'), 				('text search dictionary', '{addr_ts_dict}', '{}'), 				('text search template', '{addr_ts_temp}', '{}'), 				('text search configuration', '{addr_ts_conf}', '{}'), 				('role', '{regress_addr_user}', '{}'), 				('foreign-data wrapper', '{addr_fdw}', '{}'), 				('server', '{addr_fserv}', '{}'), 				('user mapping', '{regress_addr_user}', '{integer}'), 				('default acl', '{regress_addr_user,public}', '{r}'), 				('default acl', '{regress_addr_user}', '{r}'), 				('policy', '{addr_nsp, gentable, genpol}', '{}'), 				('transform', '{int}', '{sql}'), 				('access method', '{btree}', '{}'), 				('publication', '{addr_pub}', '{}'), 				('publication namespace', '{addr_nsp}', '{addr_pub_schema}'), 				('publication relation', '{addr_nsp, gentable}', '{addr_pub}'), 				('subscription', '{regress_addr_sub}', '{}'), 				('statistics object', '{addr_nsp, gentable_stat}', '{}')         ) SELECT (pg_identify_object(addr1.classid, addr1.objid, addr1.objsubid)).*, 	ROW(pg_identify_object(addr1.classid, addr1.objid, addr1.objsubid)) = 	ROW(pg_identify_object(addr2.classid, addr2.objid, addr2.objsubid)) 	  FROM objects, pg_get_object_address(type, name, args) addr1, 			pg_identify_object_as_address(classid, objid, objsubid) ioa(typ,nms,args), 			pg_get_object_address(typ, nms, ioa.args) as addr2 	ORDER BY addr1.classid, addr1.objid, addr1.objsubid;
WITH outermost(x) AS (   SELECT 1   UNION (WITH innermost as (SELECT 2)          SELECT * FROM outermost  -- fail          UNION SELECT * FROM innermost) ) SELECT * FROM outermost ORDER BY 1;
WITH rand_value AS (SELECT string_agg(md5((-i)::text),'') AS val FROM generate_series(1,60) s(i)) INSERT INTO brintest_3 SELECT val, val, val, val FROM rand_value;
WITH rand_value AS (SELECT string_agg(md5(i::text),'') AS val FROM generate_series(1,60) s(i)) INSERT INTO brintest_3 SELECT val, val, val, val FROM rand_value;
WITH str(j, num) AS ( 	SELECT jsonb_build_object('s', s), num 	FROM unnest('{"", "a", "ab", "abc", "abcd", "b", "A", "AB", "ABC", "ABc", "ABcD", "B"}'::text[]) WITH ORDINALITY AS a(s, num) ) SELECT 	s1.j, s2.j, 	jsonb_path_query_first(s1.j, '$.s < $s', vars => s2.j) lt, 	jsonb_path_query_first(s1.j, '$.s <= $s', vars => s2.j) le, 	jsonb_path_query_first(s1.j, '$.s == $s', vars => s2.j) eq, 	jsonb_path_query_first(s1.j, '$.s >= $s', vars => s2.j) ge, 	jsonb_path_query_first(s1.j, '$.s > $s', vars => s2.j) gt FROM str s1, str s2 ORDER BY s1.num, s2.num;
WITH t AS ( 	SELECT a FROM y ) INSERT INTO y SELECT a+20 FROM t RETURNING *;
WITH t AS (     DELETE FROM y     WHERE a <= 10     RETURNING * ) INSERT INTO y SELECT -a FROM t RETURNING *;
WITH t1 AS ( DELETE FROM bug6051 RETURNING * ) INSERT INTO bug6051 SELECT * FROM t1;
WITH t1 AS ( DELETE FROM bug6051 RETURNING * ) INSERT INTO bug6051 SELECT * FROM t1;
WITH t1 AS ( DELETE FROM bug6051 RETURNING * ) INSERT INTO bug6051 SELECT * FROM t1;
WITH t1 AS ( DELETE FROM bug6051_3 RETURNING * )   INSERT INTO bug6051_3 SELECT * FROM t1;
WITH v(exp) AS   (VALUES(-16379),(-16378),(-1234),(-789),(-45),(-5),(-4),(-3),(-2),(-1),(0),          (1),(2),(3),(4),(5),(38),(275),(2345),(45678),(131070),(131071)) SELECT exp,   to_char(('1.2345e'||exp)::numeric, '9.999EEEE') as numeric FROM v;
WITH v(val) AS   (VALUES('0'::numeric),('-4.2'),('4.2e9'),('1.2e-5'),('inf'),('-inf'),('nan')) SELECT val,   to_char(val, '9.999EEEE') as numeric,   to_char(val::float8, '9.999EEEE') as float8,   to_char(val::float4, '9.999EEEE') as float4 FROM v;
WITH v(val) AS   (VALUES('0'::numeric),('-4.2'),('4.2e9'),('1.2e-5'),('inf'),('-inf'),('nan')) SELECT val,   to_char(val, 'MI99.99') as numeric,   to_char(val::float8, 'MI99.99') as float8,   to_char(val::float4, 'MI99.99') as float4 FROM v;
WITH v(val) AS   (VALUES('0'::numeric),('-4.2'),('4.2e9'),('1.2e-5'),('inf'),('-inf'),('nan')) SELECT val,   to_char(val, 'MI9999999999.99') as numeric,   to_char(val::float8, 'MI9999999999.99') as float8,   to_char(val::float4, 'MI9999999999.99') as float4 FROM v;
WITH v(x) AS   (VALUES('0'::numeric),('1'),('-1'),('4.2'),('inf'),('-inf'),('nan')) SELECT x1, x2,   x1 / x2 AS quot,   x1 % x2 AS mod,   div(x1, x2) AS div FROM v AS v1(x1), v AS v2(x2) WHERE x2 != 0;
Water, water, every where,   Nor any drop to drink. S. T. Coleridge (1772-1834) '), to_tsquery('english', 'breath&motion&water'));
Water, water, every where,   Nor any drop to drink. S. T. Coleridge (1772-1834) '), to_tsquery('english', 'ocean'));
Water, water, every where,   Nor any drop to drink. S. T. Coleridge (1772-1834) '), to_tsquery('english', 'paint&water'));
Water, water, every where,   Nor any drop to drink. S. T. Coleridge (1772-1834) '), to_tsquery('english', 'painted <-> Ship'));
Water, water, every where,   Nor any drop to drink. S. T. Coleridge (1772-1834) ', phraseto_tsquery('english', 'idle as a painted Ship'));
Water, water, every where,   Nor any drop to drink. S. T. Coleridge (1772-1834) ', phraseto_tsquery('english', 'painted Ocean'));
Water, water, every where,   Nor any drop to drink. S. T. Coleridge (1772-1834) ', to_tsquery('english', 'Coleridge & stuck'), 'MaxFragments=2');
Water, water, every where,   Nor any drop to drink. S. T. Coleridge (1772-1834) ', to_tsquery('english', 'Coleridge & stuck'), 'MaxFragments=2,FragmentDelimiter=***');
Water, water, every where,   Nor any drop to drink. S. T. Coleridge (1772-1834) ', to_tsquery('english', 'breath&motion&water'));
Water, water, every where,   Nor any drop to drink. S. T. Coleridge (1772-1834) ', to_tsquery('english', 'ocean & seahorse'), 'MaxFragments=1');
Water, water, every where,   Nor any drop to drink. S. T. Coleridge (1772-1834) ', to_tsquery('english', 'ocean'));
Water, water, every where,   Nor any drop to drink. S. T. Coleridge (1772-1834) ', to_tsquery('english', 'ocean'), 'MaxFragments=1');
Water, water, every where,   Nor any drop to drink. S. T. Coleridge (1772-1834) ', to_tsquery('english', 'paint&water'));
X0F	X10 X1F	X11 X2F	X12 X3F	X13 X8F	X04 X000F	X0010 X0123	XFFFF X2468	X2468 XFA50	X05AF X1234	XFFF5 \. SELECT a, b, ~a AS "~ a", a & b AS "a & b",        a | b AS "a | b", a # b AS "a # b" FROM varbit_table;
X0F00	X1000 X1F00	X1100 X2F00	X1200 X3F00	X1300 X8F00	X0400 X000F	X0010 X0123	XFFFF X2468	X2468 XFA50	X05AF X1234	XFFF5 \. SELECT a,b,~a AS "~ a",a & b AS "a & b", 	a|b AS "a | b", a # b AS "a # b" FROM bit_table;
\. COPY x from stdin WITH DELIMITER AS ':' NULL AS E'\\X' ENCODING 'sql_ascii';
\. COPY x from stdin;
\a\t CREATE TABLE ruletest_tbl (a int, b int);
\a\t SELECT p1.oid::regprocedure FROM pg_proc p1 JOIN pg_namespace pn      ON pronamespace = pn.oid WHERE nspname = 'pg_catalog' AND proleakproof ORDER BY 1;
\a\t SELECT relname, nspname  FROM pg_class c LEFT JOIN pg_namespace n ON n.oid = relnamespace JOIN pg_attribute a ON (attrelid = c.oid AND attname = 'oid')  WHERE relkind = 'r' and c.oid < 16384      AND ((nspname ~ '^pg_') IS NOT FALSE)      AND NOT EXISTS (SELECT 1 FROM pg_index i WHERE indrelid = c.oid                      AND indkey[0] = a.attnum AND indnatts = 1                      AND indisunique AND indimmediate);
\a\t SELECT relname, relhasindex    FROM pg_class c LEFT JOIN pg_namespace n ON n.oid = relnamespace    WHERE relkind IN ('r', 'p') AND (nspname ~ '^pg_temp_') IS NOT TRUE    ORDER BY relname;
\a\t SELECT viewname, definition FROM pg_views WHERE schemaname IN ('pg_catalog', 'public') ORDER BY viewname;
\a\t select proname, oid from pg_catalog.pg_proc where proname in (   'lo_open',   'lo_close',   'lo_creat',   'lo_create',   'lo_unlink',   'lo_lseek',   'lo_lseek64',   'lo_tell',   'lo_tell64',   'lo_truncate',   'lo_truncate64',   'loread',   'lowrite') and pronamespace = (select oid from pg_catalog.pg_namespace                     where nspname = 'pg_catalog') order by 1;
\c - CREATE ROLE regress_readallstats;
\c - CREATE ROLE regress_schemauser1 superuser login;
\c - CREATE SCHEMA testns;
\c - CREATE SCHEMA testns;
\c - CREATE SEQUENCE x_seq;
\c - CREATE TYPE priv_testtype1 AS (a int, b text);
\c - DROP AGGREGATE priv_testagg1b(priv_testdomain1);
\c - DROP ROLE regress_schemauser1;
\c - REFRESH MATERIALIZED VIEW sro_mv;
\c - REFRESH MATERIALIZED VIEW sro_mv;
\c - REVOKE ALL PRIVILEGES ON LANGUAGE sql FROM PUBLIC;
\c - SELECT gid FROM pg_prepared_xacts;
\c - SELECT oid, pg_get_userbyid(lomowner) ownername, lomacl FROM pg_largeobject_metadata WHERE oid >= 1000 AND oid < 3000 ORDER BY oid;
\c - SELECT wait_for_stats();
\c - SET SESSION AUTHORIZATION regress_priv_user1;
\c - SET lo_compat_privileges = false;	-- default setting SET SESSION AUTHORIZATION regress_priv_user4;
\c - SET search_path TO 'pg_temp';
\c - select has_table_privilege(current_user,'pg_authid','select');
\c - set session role regress_priv_user1;
\c DROP ROLE regress_foreign_data_user;
\c REVOKE DELETE ON lock_table FROM regress_locktable_user;
\c REVOKE INSERT ON lock_table FROM regress_locktable_user;
\c REVOKE SELECT ON lock_table FROM regress_locktable_user;
\c REVOKE TRUNCATE ON lock_table FROM regress_locktable_user;
\c REVOKE UPDATE ON lock_table FROM regress_locktable_user;
\c SELECT * FROM temptest;
\c drop sequence x_seq;
\copy (delete from copydml_test where t = 'g' returning id) to stdout;
\copy (insert into copydml_test (t) values ('f') returning id) to stdout;
\copy (update copydml_test set t = 'g' where t = 'f' returning id) to stdout;
\copy test1 to stdout \copy v_test1 to stdout \copy (select "id",'id','id""'||t,(id + 1)*id,t,"test1"."t" from test1 where id=3) to stdout drop table test2;
\copy y TO stdout (FORMAT CSV) \copy y TO stdout (FORMAT CSV, QUOTE '''', DELIMITER '|') \copy y TO stdout (FORMAT CSV, FORCE_QUOTE (col2), ESCAPE E'\\') \copy y TO stdout (FORMAT CSV, FORCE_QUOTE *) CREATE TEMP TABLE testnl (a int, b text, c int);
\crosstabview SELECT v, to_char(d, 'Mon') AS "month name", EXTRACT(month FROM d) AS num,  count(*) FROM ctv_data  GROUP BY 1,2,3 ORDER BY 1  \crosstabview v "month name" 4 num SELECT EXTRACT(year FROM d) AS year, to_char(d,'Mon') AS """month"" name",   EXTRACT(month FROM d) AS month,   format('sum=%s avg=%s', sum(i), avg(i)::numeric(2,1))   FROM ctv_data   GROUP BY EXTRACT(year FROM d), to_char(d,'Mon'), EXTRACT(month FROM d) ORDER BY month \crosstabview """month"" name" year format year SELECT v, h, string_agg(c, E'\n') FROM ctv_data GROUP BY v, h ORDER BY 1,2,3  \crosstabview 1 2 3 SELECT v,h, string_agg(c, E'\n') AS c, row_number() OVER(ORDER BY h) AS r FROM ctv_data GROUP BY v, h ORDER BY 1,3,2  \crosstabview v h c r SELECT v, h, string_agg(c, E'\n') AS c, row_number() OVER(ORDER BY h DESC) AS r FROM ctv_data GROUP BY v, h ORDER BY 1,3,2  \crosstabview v h c r SELECT v,h, string_agg(c, E'\n') AS c, row_number() OVER(ORDER BY h NULLS LAST) AS r FROM ctv_data GROUP BY v, h ORDER BY 1,3,2  \crosstabview v h c r SELECT null,null \crosstabview SELECT null,null,null \crosstabview \pset null '#null#' SELECT v,h, string_agg(i::text, E'\n') AS i FROM ctv_data GROUP BY v, h ORDER BY h,v  \crosstabview v h i \pset null '' SELECT v,h,string_agg(i::text, E'\n'), string_agg(c, E'\n') FROM ctv_data GROUP BY v, h ORDER BY h,v  \crosstabview 2 1 4 SELECT v,h, string_agg(i::text, E'\n') AS i, string_agg(c, E'\n') AS c FROM ctv_data GROUP BY v, h ORDER BY h,v  \crosstabview 1 "h" 4 SELECT 1 as "22", 2 as b, 3 as "Foo"  \crosstabview "22" B "Foo" SELECT v,h,c,i FROM ctv_data  \crosstabview v h j SELECT 1 as "22", 2 as b, 3 as "Foo"  \crosstabview 1 2 Foo SELECT 1 as "22", 2 as b, 3 as "Foo"  \crosstabview 1 "B" "Foo" SELECT v,h,i,c FROM ctv_data  \crosstabview 2 1 5 SELECT v,h,i,c FROM ctv_data  \crosstabview 2 h 4 SELECT a,a,1 FROM generate_series(1,3000) AS a  \crosstabview SELECT 1 \crosstabview DROP TABLE ctv_data;
\echo 'error:' :ERROR \echo 'error code:' :SQLSTATE \echo 'last error message:' :LAST_ERROR_MESSAGE \set VERBOSITY default SELECT 3 AS three, 4 AS four \gdesc \echo 'error:' :ERROR \echo 'error code:' :SQLSTATE \echo 'number of rows:' :ROW_COUNT SELECT 4 AS \gdesc \echo 'error:' :ERROR \echo 'error code:' :SQLSTATE \echo 'number of rows:' :ROW_COUNT \echo 'last error message:' :LAST_ERROR_MESSAGE \echo 'last error code:' :LAST_ERROR_SQLSTATE \set FETCH_COUNT 10 select unique2 from tenk1 order by unique2 limit 19;
\echo 'error:' :ERROR \echo 'error code:' :SQLSTATE \echo 'last error message:' :LAST_ERROR_MESSAGE \set VERBOSITY sqlstate SELECT 1/0;
\echo 'error:' :ERROR \echo 'error code:' :SQLSTATE \echo 'number of rows:' :ROW_COUNT SELECT 1 UNION;
\echo 'error:' :ERROR \echo 'error code:' :SQLSTATE \echo 'number of rows:' :ROW_COUNT \echo 'last error message:' :LAST_ERROR_MESSAGE \echo 'last error code:' :LAST_ERROR_SQLSTATE ;
\echo 'error:' :ERROR \echo 'error code:' :SQLSTATE \echo 'number of rows:' :ROW_COUNT \echo 'last error message:' :LAST_ERROR_MESSAGE \echo 'last error code:' :LAST_ERROR_SQLSTATE DROP TABLE this_table_does_not_exist;
\echo 'error:' :ERROR \echo 'error code:' :SQLSTATE \echo 'number of rows:' :ROW_COUNT \echo 'last error message:' :LAST_ERROR_MESSAGE \echo 'last error code:' :LAST_ERROR_SQLSTATE \set VERBOSITY terse SELECT 1 UNION;
\echo 'error:' :ERROR \echo 'error code:' :SQLSTATE \echo 'number of rows:' :ROW_COUNT \echo 'last error message:' :LAST_ERROR_MESSAGE \echo 'last error code:' :LAST_ERROR_SQLSTATE \unset FETCH_COUNT create schema testpart;
\echo 'error:' :ERROR \echo 'error code:' :SQLSTATE \echo 'number of rows:' :ROW_COUNT select 1/(15-unique2) from tenk1 order by unique2 limit 19;
\else   not okay;
\if true 	\if 1 		\if yes 			\if on 				\echo 'all true' 			\else 				\echo 'should not print #1-1' 			\endif 		\else 			\echo 'should not print #1-2' 		\endif 	\else 		\echo 'should not print #1-3' 	\endif \else 	\echo 'should not print #1-4' \endif \if false 	\echo 'should not print #2-1' \elif 0 	\echo 'should not print #2-2' \elif no 	\echo 'should not print #2-3' \elif off 	\echo 'should not print #2-4' \else 	\echo 'all false' \endif \if true 	\echo 'should print #2-5' \elif true 	\echo 'should not print #2-6' \elif false 	\echo 'should not print #2-7' \else 	\echo 'should not print #2-8' \endif \if true 	\echo 'first thing true' \else 	\echo 'should not print #3-1' \endif \if false 	\echo 'should not print #4-1' \elif true 	\echo 'second thing true' \else 	\echo 'should not print #5-1' \endif \if invalid boolean expression 	\echo 'will not print #6-1' \else 	\echo 'will print anyway #6-2' \endif \endif \else \elif \if true \else \else \endif \if false \else \elif \endif \if false     \if false         \echo 'should not print #7-1'     \else         \echo 'should not print #7-2'     \endif     \echo 'should not print #7-3' \else     \echo 'should print #7-4' \endif \set foo bar \echo :foo :'foo' :"foo" \pset fieldsep | `nosuchcommand` :foo :'foo' :"foo" \set try_to_quit '\\q' \if false 	:try_to_quit 	\echo `nosuchcommand` :foo :'foo' :"foo" 	\pset fieldsep | `nosuchcommand` :foo :'foo' :"foo" 	\a 	\C arg1 	\c arg1 arg2 arg3 arg4 	\cd arg1 	\conninfo 	\copy arg1 arg2 arg3 arg4 arg5 arg6 	\copyright 	SELECT 1 as one, 2, 3 \crosstabview 	\e arg1 arg2 	\ef whole_line 	\ev whole_line 	\echo arg1 arg2 arg3 arg4 arg5 	\echo arg1 	\encoding arg1 	\errverbose 	\f arg1 	\g arg1 	\gx arg1 	\gexec 	SELECT 1 AS one \gset 	\h 	\? 	\html 	\i arg1 	\ir arg1 	\l arg1 	\lo arg1 arg2 	\lo_list 	\o arg1 	\p 	\password arg1 	\prompt arg1 arg2 	\pset arg1 arg2 	\q 	\reset 	\s arg1 	\set arg1 arg2 arg3 arg4 arg5 arg6 arg7 	\setenv arg1 arg2 	\sf whole_line 	\sv whole_line 	\t arg1 	\T arg1 	\timing arg1 	\unset arg1 	\w arg1 	\watch arg1 	\x arg1 	\w |/no/such/file \else 	\z \else 	\echo 'should print #8-1' \endif \set i 1 \if :{?i}   \echo '#9-1 ok, variable i is defined' \else   \echo 'should not print #9-2' \endif \if :{?no_such_variable}   \echo 'should not print #10-1' \else   \echo '#10-2 ok, variable no_such_variable is not defined' \endif SELECT :{?i} AS i_is_defined;
\p SELECT 2 \r \p SELECT 3 \p UNION SELECT 4 \p UNION SELECT 5 ORDER BY 1;
\pset border 1 \pset format unaligned execute q;
\pset border 1 \pset format unaligned execute q;
\pset border 1 \pset format unaligned execute q;
\pset border 1 \pset format unaligned execute q;
\pset border 1 \pset format unaligned execute q;
\pset border 1 \pset format unaligned execute q;
\pset border 1 \pset format unaligned execute q;
\pset border 1 \pset format unaligned execute q;
\pset border 1 \pset format unaligned execute q;
\pset border 1 execute q;
\pset border 1 execute q;
\pset border 1 execute q;
\pset border 1 execute q;
\pset border 1 execute q;
\pset border 1 execute q;
\pset border 1 execute q;
\pset border 1 execute q;
\pset border 1 execute q;
\pset border 1 execute q;
\pset border 2 \pset format unaligned execute q;
\pset border 2 \pset format unaligned execute q;
\pset border 2 \pset format unaligned execute q;
\pset border 2 \pset format unaligned execute q;
\pset border 2 \pset format unaligned execute q;
\pset border 2 \pset format unaligned execute q;
\pset border 2 \pset format unaligned execute q;
\pset border 2 \pset format unaligned execute q;
\pset border 2 \pset format unaligned execute q;
\pset border 2 execute q;
\pset border 2 execute q;
\pset border 2 execute q;
\pset border 2 execute q;
\pset border 2 execute q;
\pset border 2 execute q;
\pset border 2 execute q;
\pset border 2 execute q;
\pset border 3 execute q;
\pset border 3 execute q;
\pset border 3 execute q;
\pset border 3 execute q;
\pset csv_fieldsep '' \pset csv_fieldsep '\0' \pset csv_fieldsep '\n' \pset csv_fieldsep '\r' \pset csv_fieldsep '"' \pset csv_fieldsep ',,' \pset csv_fieldsep ',' \pset format html \pset border 1 \pset expanded off \pset tuples_only true \pset tuples_only false \pset expanded on \pset tuples_only true \pset tuples_only false prepare q as   select 'some"text' as "a&title", E'  <foo>\n<bar>' as "junk",          '   ' as "empty", n as int   from generate_series(1,2) as n;
\pset csv_fieldsep '.' select '\' as d1, '' as d2;
\pset csv_fieldsep ';' select 'comma,comma' as comma, 'semi;semi' as semi;
\pset expanded off \pset border 0 execute q;
\pset expanded off \pset border 0 execute q;
\pset expanded off \pset border 0 execute q;
\pset expanded off \pset border 0 execute q;
\pset expanded off \pset border 0 execute q;
\pset expanded off execute q;
\pset expanded off select 'comma,comma' as comma, 'semi;semi' as semi;
\pset expanded on \pset border 0 \pset format unaligned execute q;
\pset expanded on \pset border 0 execute q;
\pset expanded on \pset border 0 execute q;
\pset expanded on \pset border 0 execute q;
\pset expanded on \pset columns 20 \pset border 0 \pset format unaligned execute q;
\pset expanded on \pset columns 20 \pset border 0 \pset format unaligned execute q;
\pset expanded on \pset columns 20 \pset border 0 \pset format unaligned execute q;
\pset expanded on \pset columns 30 \pset border 0 \pset format unaligned execute q;
\pset expanded on execute q;
\pset format a \pset format l drop table psql_serial_tab;
\pset format aligned \pset expanded off \pset border 1 \echo this is a test \echo -n without newline \echo with -n newline \echo '-n' with newline \set foo bar \echo foo = :foo \qecho this is a test \qecho foo = :foo \warn this is a test \warn foo = :foo \if true   select 'okay';
\pset format aligned \pset expanded off \pset numericlocale true select n, -n as m, n * 111 as x, '1e90'::float8 as f from generate_series(0,3) n;
\pset format aligned \pset expanded off \pset tuples_only true \pset tuples_only false \pset expanded on \pset tuples_only true \pset tuples_only false select 1 where false;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format aligned execute q;
\pset format csv \pset border 1 \pset expanded off \pset tuples_only true \pset tuples_only false \pset expanded on \pset tuples_only true \pset tuples_only false prepare q as   select 'some"text' as "a""title", E'  <foo>\n<bar>' as "junk",          '   ' as "empty", n as int   from generate_series(1,2) as n;
\pset format latex \pset border 1 \pset expanded off \pset tuples_only true \pset tuples_only false \pset expanded on \pset tuples_only true \pset tuples_only false prepare q as   select 'some\more_text' as "a$title", E'  #<foo>%&^~|\n{bar}' as "junk",          '   ' as "empty", n as int   from generate_series(1,2) as n;
\pset format latex-longtable \pset border 1 \pset expanded off \pset tuples_only true \pset tuples_only false \pset expanded on \pset tuples_only true \pset tuples_only false prepare q as   select 'some\more_text' as "a$title", E'  #<foo>%&^~|\n{bar}' as "junk",          '   ' as "empty", n as int   from generate_series(1,2) as n;
\pset format troff-ms \pset border 1 \pset expanded off \pset tuples_only true \pset tuples_only false \pset expanded on \pset tuples_only true \pset tuples_only false prepare q as   select 'some\text' as "a\title", E'  <foo>\n<bar>' as "junk",          '   ' as "empty", n as int   from generate_series(1,2) as n;
\pset format unaligned \pset expanded off \pset tuples_only true \pset tuples_only false \pset expanded on \pset tuples_only true \pset tuples_only false \pset format wrapped \pset expanded off \pset tuples_only true \pset tuples_only false \pset expanded on \pset tuples_only true \pset tuples_only false \pset expanded off CREATE SCHEMA tableam_display;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset format wrapped execute q;
\pset linestyle ascii \pset border 1 create table psql_serial_tab (id serial);
\pset linestyle ascii \pset expanded off \pset columns 40 \pset border 0 \pset format unaligned execute q;
\pset linestyle ascii \pset expanded off \pset columns 40 \pset border 0 \pset format unaligned execute q;
\pset linestyle old-ascii \pset expanded off \pset columns 40 \pset border 0 \pset format unaligned execute q;
\pset linestyle old-ascii \pset expanded off \pset columns 40 \pset border 0 \pset format unaligned execute q;
\pset null '' SELECT POSITION('4' IN '1234567890') = '4' AS "4";
\pset null '' create table check_con_tbl (f1 int);
\pset null '' select jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"');
\pset null '(null)' SELECT istrue AND isnul AND istrue FROM booltbl4;
\pset null 'NULL' \a\t WITH objects (classid, objid, objsubid) AS (VALUES     ('pg_class'::regclass, 0, 0), -- no relation     ('pg_class'::regclass, 'pg_class'::regclass, 100), -- no column for relation     ('pg_proc'::regclass, 0, 0), -- no function     ('pg_type'::regclass, 0, 0), -- no type     ('pg_cast'::regclass, 0, 0), -- no cast     ('pg_collation'::regclass, 0, 0), -- no collation     ('pg_constraint'::regclass, 0, 0), -- no constraint     ('pg_conversion'::regclass, 0, 0), -- no conversion     ('pg_attrdef'::regclass, 0, 0), -- no default attribute     ('pg_language'::regclass, 0, 0), -- no language     ('pg_largeobject'::regclass, 0, 0), -- no large object, no error     ('pg_operator'::regclass, 0, 0), -- no operator     ('pg_opclass'::regclass, 0, 0), -- no opclass, no need to check for no access method     ('pg_opfamily'::regclass, 0, 0), -- no opfamily     ('pg_am'::regclass, 0, 0), -- no access method     ('pg_amop'::regclass, 0, 0), -- no AM operator     ('pg_amproc'::regclass, 0, 0), -- no AM proc     ('pg_rewrite'::regclass, 0, 0), -- no rewrite     ('pg_trigger'::regclass, 0, 0), -- no trigger     ('pg_namespace'::regclass, 0, 0), -- no schema     ('pg_statistic_ext'::regclass, 0, 0), -- no statistics     ('pg_ts_parser'::regclass, 0, 0), -- no TS parser     ('pg_ts_dict'::regclass, 0, 0), -- no TS dictionnary     ('pg_ts_template'::regclass, 0, 0), -- no TS template     ('pg_ts_config'::regclass, 0, 0), -- no TS configuration     ('pg_authid'::regclass, 0, 0), -- no role     ('pg_database'::regclass, 0, 0), -- no database     ('pg_tablespace'::regclass, 0, 0), -- no tablespace     ('pg_foreign_data_wrapper'::regclass, 0, 0), -- no FDW     ('pg_foreign_server'::regclass, 0, 0), -- no server     ('pg_user_mapping'::regclass, 0, 0), -- no user mapping     ('pg_default_acl'::regclass, 0, 0), -- no default ACL     ('pg_extension'::regclass, 0, 0), -- no extension     ('pg_event_trigger'::regclass, 0, 0), -- no event trigger     ('pg_policy'::regclass, 0, 0), -- no policy     ('pg_publication'::regclass, 0, 0), -- no publication     ('pg_publication_rel'::regclass, 0, 0), -- no publication relation     ('pg_subscription'::regclass, 0, 0), -- no subscription     ('pg_transform'::regclass, 0, 0) -- no transformation   ) SELECT ROW(pg_identify_object(objects.classid, objects.objid, objects.objsubid))          AS ident,        ROW(pg_identify_object_as_address(objects.classid, objects.objid, objects.objsubid))          AS addr,        pg_describe_object(objects.classid, objects.objid, objects.objsubid)          AS descr FROM objects ORDER BY objects.classid, objects.objid, objects.objsubid;
\pset null '\\N' SELECT regexp_matches('foobarbequebaz', $re$(bar)(beque)$re$);
\pset null NULL BEGIN;
\pset null NULL select jsonb_set_lax('{"a":1,"b":2}','{b}','5') ;
\pset numericlocale false \pset format asciidoc \pset border 1 \pset expanded off \pset tuples_only true \pset tuples_only false \pset expanded on \pset tuples_only true \pset tuples_only false prepare q as   select 'some|text' as "a|title", '        ' as "empty ", n as int   from generate_series(1,2) as n;
\pset tableattr \pset expanded on \pset border 0 execute q;
\pset tableattr \pset expanded on \pset border 0 execute q;
\pset tableattr deallocate q;
\pset tableattr deallocate q;
\pset tableattr foobar execute q;
\pset tableattr foobar execute q;
\pset tableattr lr execute q;
\pset tableattr lr execute q;
\r \p SELECT 1 AS stuff UNION SELECT 2;
\set AUTOCOMMIT off INSERT INTO ac_test VALUES (1);
\set AUTOCOMMIT on DROP TABLE ac_test;
\set ECHO none SELECT 'CREATE TABLE extra_wide_table(firstc text, '|| array_to_string(array_agg('c'||i||' bool'),',')||', lastc text);' FROM generate_series(1, 1100) g(i) \gexec \set ECHO all INSERT INTO extra_wide_table(firstc, lastc) VALUES('first col', 'last col');
\set ECHO none \copy test_tsquery from stdin 'New York'	new <-> york | big <-> apple | nyc Moscow	moskva | moscow 'Sanct Peter'	Peterburg | peter | 'Sanct Peterburg' foo & bar & qq	foo & (bar | qq) & city 1 & (2 <-> 3)	2 <-> 4 5 <-> 6	5 <-> 7 \. \set ECHO all ALTER TABLE test_tsquery ADD COLUMN keyword tsquery;
\set HIDE_TABLEAM off \set HIDE_TABLEAM on RESET ROLE;
\set HIDE_TOAST_COMPRESSION false SET default_toast_compression = 'pglz';
\set ON_ERROR_ROLLBACK off \set ECHO errors SELECT * FROM notexists;
\set QUIET false INSERT INTO city_view(city_name) VALUES('Tokyo') RETURNING *;
\set QUIET false INSERT INTO european_city_view VALUES (0, 'x', 10000, 'y', 'z');
\set QUIET false INSERT INTO european_city_view(city_name, country_name)     VALUES ('Cambridge', 'USA') RETURNING *;
\set QUIET false INSERT INTO main_view VALUES (20, 30);
\set QUIET false UPDATE min_updates_test SET f1 = f1;
\set QUIET true CREATE RULE european_city_insert_rule AS ON INSERT TO european_city_view DO INSTEAD INSERT INTO city_view VALUES (NEW.city_id, NEW.city_name, NEW.population, NEW.country_name, NEW.continent) RETURNING *;
\set QUIET true CREATE VIEW european_city_view AS     SELECT * FROM city_view WHERE continent = 'Europe';
\set QUIET true DROP TRIGGER instead_of_insert_trig ON main_view;
\set QUIET true SELECT * FROM city_view;
\set QUIET true SELECT * FROM min_updates_test;
\set SHOW_CONTEXT alwaysdo $$ begin   raise notice 'foo';   raise exception 'bar'; end $$;
\set SHOW_CONTEXT errorsdo $$ begin   raise notice 'foo';   raise exception 'bar'; end $$;
\set SHOW_CONTEXT neverdo $$ begin   raise notice 'foo';   raise exception 'bar'; end $$;
\set VERBOSITY default DROP TABLE deptest;
\set VERBOSITY default DROP TABLE reindex_verbose;
\set VERBOSITY default SELECT xpath('/*', '<nosuchprefix:tag/>');
\set VERBOSITY terse ALTER TABLE deptest OWNER TO regress_dep_user3;
\set VERBOSITY terse SELECT xpath('/*', '<invalidns xmlns=''&lt;''/>');
\set VERBOSITY terse \\ -- suppress machine-dependent details REINDEX (VERBOSE) TABLE reindex_verbose;
\set init_range_parted 'truncate range_parted; insert into range_parted VALUES (''a'', 1, 1, 1), (''a'', 10, 200, 1), (''b'', 12, 96, 1), (''b'', 13, 97, 2), (''b'', 15, 105, 16), (''b'', 17, 105, 19)' \set show_data 'select tableoid::regclass::text COLLATE "C" partname, * from range_parted ORDER BY 1, 2, 3, 4, 5, 6' :init_range_parted;
\set invalid/name foo \set AUTOCOMMIT foo \set FETCH_COUNT foo \echo :ON_ERROR_ROLLBACK \set ON_ERROR_ROLLBACK \echo :ON_ERROR_ROLLBACK \set ON_ERROR_ROLLBACK foo \echo :ON_ERROR_ROLLBACK \set ON_ERROR_ROLLBACK on \echo :ON_ERROR_ROLLBACK \unset ON_ERROR_ROLLBACK \echo :ON_ERROR_ROLLBACK SELECT 1 as one, 2 as two \g \gx SELECT 3 as three, 4 as four \gx \g \set FETCH_COUNT 1 SELECT 1 as one, 2 as two \g \gx SELECT 3 as three, 4 as four \gx \g \unset FETCH_COUNT SELECT 1 as one, 2 as two \g (format=csv csv_fieldsep='\t') \g SELECT 1 as one, 2 as two \gx (title='foo bar') \g select 10 as test01, 20 as test02, 'Hello' as test03 \gset pref01_ \echo :pref01_test01 :pref01_test02 :pref01_test03 select 10 as "bad name" \gset select 97 as "EOF", 'ok' as _foo \gset IGNORE \echo :IGNORE_foo :IGNOREEOF select 1 as x, 2 as y \gset pref01_ \\ \echo :pref01_x select 3 as x, 4 as y \gset pref01_ \echo :pref01_x \echo :pref01_y select 5 as x, 6 as y \gset pref01_ \\ \g \echo :pref01_x :pref01_y select 7 as x, 8 as y \g \gset pref01_ \echo :pref01_x :pref01_y \set var2 xyz select 1 as var1, NULL as var2, 3 as var3 \gset \echo :var1 :var2 :var3 select 10 as test01, 20 as test02 from generate_series(1,3) \gset select 10 as test01, 20 as test02 from generate_series(1,0) \gset \set FETCH_COUNT 1 select 1 as x, 2 as y \gset pref01_ \\ \echo :pref01_x select 3 as x, 4 as y \gset pref01_ \echo :pref01_x \echo :pref01_y select 10 as test01, 20 as test02 from generate_series(1,3) \gset select 10 as test01, 20 as test02 from generate_series(1,0) \gset \unset FETCH_COUNT SELECT     NULL AS zero,     1 AS one,     2.0 AS two,     'three' AS three,     $1 AS four,     sin($2) as five,     'foo'::varchar(4) as six,     CURRENT_DATE AS now \gdesc PREPARE test AS SELECT 1 AS first, 2 AS second;
\sv xmltableview1 EXPLAIN (COSTS OFF) SELECT * FROM xmltableview1;
\x SELECT * FROM XMLTABLE('*' PASSING '<e>pre<!--c1--><?pi arg?><![CDATA[&ent1]]><n2>&amp;deep</n2>post</e>' COLUMNS x xml PATH 'node()', y xml PATH '/');
\x SELECT * FROM XMLTABLE('.' PASSING XMLELEMENT(NAME a) columns a varchar(20) PATH '"<foo/>"', b xml PATH '"<foo/>"');
\z deptest1 DROP OWNED BY regress_dep_user1;
\z deptest1 GRANT ALL ON deptest1 TO regress_dep_user1;
a	b	c	\N	c a	b	c	\N	d a	b	c	\N	a \. select * from nulltest;
a0 b \. COMMIT;
a1 b \. SELECT * FROM vistest;
a2 b \. SELECT * FROM vistest;
a\. \.b c\.d "\." \. COPY testeoc TO stdout CSV;
alter aggregate my_percentile_disc(float8 ORDER BY anyelement)   rename to test_percentile_disc;
alter aggregate my_rank(VARIADIC "any" ORDER BY VARIADIC "any")   rename to test_rank;
alter default privileges for role regress_evt_user  revoke delete on tables from regress_evt_user;
alter domain alter1.posint set schema alter2;
alter domain con add check (VALUE > 0);
alter domain con add constraint t check (VALUE < 1); -- fails alter domain con add constraint t check (VALUE < 34);
alter domain con drop constraint if exists nonexistent;
alter domain con drop constraint nonexistent;
alter domain con drop constraint t;
alter domain dcomptype add constraint c1 check ((value).r <= (value).i);
alter domain dcomptype add constraint c1 check ((value).r > 0);
alter domain dcomptype add constraint c2 check ((value).r > (value).i);  -- fail select row(2,1)::dcomptype;  -- fail insert into dcomptable values (row(1,2)::comptype);
alter domain dcomptypea add constraint c1 check (value[1].r <= value[1].i);
alter domain dcomptypea add constraint c2 check (value[1].r > value[1].i);  -- fail select array[row(2,1)]::dcomptypea;  -- fail insert into dcomptable values (array[row(1,2)]::comptype[]);
alter domain ddef1 drop default;
alter domain ddef1 set default '42';
alter domain di add constraint pos check (value > 0);
alter domain di add constraint pos check (value > 0);
alter domain dnotnulltest set not null;
alter domain dnotnulltest set not null; -- fails update domnotnull set col1 = 5;
alter domain dnotnulltest set not null; -- fails update domnotnull set col2 = 6;
alter domain dom add constraint domchkgt6 check(value > 6);
alter domain dom set not null;
alter domain posint add constraint c1 check(value >= 0);
alter domain posint add constraint c1 check(value >= 0);
alter domain posint add constraint c1 check(value >= 0);
alter domain posint add constraint c1 check(value >= 0);
alter domain posint add constraint c1 check(value >= 0);
alter domain posint add constraint c1 check(value >= 0);
alter domain posint add constraint c2 check(value >= 10); -- fail alter domain posint add constraint c2 check(value > 0); -- OK drop table ddtest2;
alter domain testdomain1 drop constraint unsigned_foo;
alter domain testdomain1 rename constraint unsigned to unsigned_foo;
alter domain testdomain1 rename to testdomain2;
alter event trigger regress_event_trigger disable;
alter event trigger regress_event_trigger disable;
alter event trigger regress_event_trigger enable always;
alter event trigger regress_event_trigger enable replica;
alter event trigger regress_event_trigger enable;
alter event trigger regress_event_trigger owner to regress_evt_user;
alter event trigger regress_event_trigger owner to regress_evt_user;
alter event trigger regress_event_trigger rename to regress_event_trigger2;
alter event trigger regress_event_trigger rename to regress_event_trigger3;
alter operator alter1.=(alter1.ctype, alter1.ctype) set schema alter2;
alter operator class alter1.ctype_hash_ops using hash set schema alter2;
alter operator family alter1.ctype_hash_ops using hash set schema alter2;
alter operator family integer_ops using btree add   function 1 int8alias1cmp (int8, int8alias1);
alter operator family integer_ops using btree add   operator 1 < (int8alias1, int8alias1);
alter operator family integer_ops using btree add   operator 3 = (int8, int8alias1);
alter operator family integer_ops using btree add   operator 3 = (int8alias1, int8alias1);
alter operator family integer_ops using btree add   operator 3 = (int8alias1, int8alias2);
alter operator family integer_ops using btree add   operator 3 = (int8alias2, int8alias2);
alter schema testpart owner to regress_partitioning_role;
alter table check_con_tbl add check (check_con_function(check_con_tbl.*));
alter table rename;
alter text search configuration alter1.cfg set schema alter2;
alter text search parser alter1.prs set schema alter2;
alter text search template alter1.tmpl set schema alter2;
alter trigger a on grandparent rename to b;
alter trigger a on only grandparent rename to b;	-- ONLY not supported alter trigger b on middle rename to c;	-- can't rename trigger on partition create trigger c after insert on middle for each row execute procedure f();
alter trigger b on grandparent rename to c;
alter trigger p on grandparent rename to q;
alter trigger parenttrig on parent rename to anothertrig;
alter type alter1.ctype set schema alter1; -- no-op, same schema alter type alter1.ctype set schema alter2;
alter type comptype drop attribute r;  -- fail alter type comptype drop attribute i;
alter type insenum add value 'i1' before 'L2';
alter type insenum add value 'i10' before 'L2';
alter type insenum add value 'i11' before 'L2';
alter type insenum add value 'i12' before 'L2';
alter type insenum add value 'i13' before 'L2';
alter type insenum add value 'i14' before 'L2';
alter type insenum add value 'i15' before 'L2';
alter type insenum add value 'i16' before 'L2';
alter type insenum add value 'i17' before 'L2';
alter type insenum add value 'i18' before 'L2';
alter type insenum add value 'i19' before 'L2';
alter type insenum add value 'i2' before 'L2';
alter type insenum add value 'i20' before 'L2';
alter type insenum add value 'i21' before 'L2';
alter type insenum add value 'i22' before 'L2';
alter type insenum add value 'i23' before 'L2';
alter type insenum add value 'i24' before 'L2';
alter type insenum add value 'i25' before 'L2';
alter type insenum add value 'i26' before 'L2';
alter type insenum add value 'i27' before 'L2';
alter type insenum add value 'i28' before 'L2';
alter type insenum add value 'i29' before 'L2';
alter type insenum add value 'i3' before 'L2';
alter type insenum add value 'i30' before 'L2';
alter type insenum add value 'i4' before 'L2';
alter type insenum add value 'i5' before 'L2';
alter type insenum add value 'i6' before 'L2';
alter type insenum add value 'i7' before 'L2';
alter type insenum add value 'i8' before 'L2';
alter type insenum add value 'i9' before 'L2';
alter type rewritetype alter attribute a type text cascade;
alter type rewritetype alter attribute a type varchar cascade;
alter type testdomain2 rename to testdomain3;  -- alter type also works drop domain testdomain3;
alter type two_ints add attribute c two_ints_range;
alter view base_tab_def_view alter b set default 'View default';
alter view base_tab_def_view alter d set default 'View default';
alter view base_tab_view alter column c set default 'View default';
alter view my_locks reset (autovacuum_enabled);
alter view my_locks reset (security_barrier);
alter view my_locks set (autovacuum_enabled = false);
alter view my_locks set (security_barrier=off);
alter view uv_iocu_view alter column bb set default 'view default';
alter view v1 rename column a to x;
blname	alias for $2;
blname	alias for $2;
blname	alias for $2;
bltype	char(2);
bltype := substr(rec.backlink, 1, 2);
blue purple \. SELECT * FROM enumtest;
cluster clstr_4 using cluster_sort;
cluster clstr_temp using clstr_temp_pkey;
cmd := 'SELECT ctid';
cmd := cmd || ' = fk.' || quote_ident(fk.fkcols[i]);
cmd := cmd || ' FROM ' || fk.fktable::text || ') fk WHERE ';
cmd := cmd || ') as ' || quote_ident(fk.fkcols[nkeys]);
cmd := cmd || ')';
cmd := cmd || ', unnest(' || quote_ident(fk.fkcols[nkeys]);
cmd := cmd || 'NOT EXISTS(SELECT 1 FROM ' || fk.pktable::text || ' pk WHERE ';
cmd := cmd || 'pk.' || quote_ident(fk.pkcols[i]);
cmd text;
comment on column atacc1."........pg.dropped.1........" is 'testing';
comment on column atacc1.a is 'testing';
comment on constraint at_partitioned_0_id_name_key on at_partitioned_0 is 'child 0 constraint';
comment on constraint at_partitioned_1_id_name_key on at_partitioned_1 is 'child 1 constraint';
comment on constraint at_partitioned_id_name_key on at_partitioned is 'parent constraint';
comment on constraint c1 on domain dcomptype is 'random commentary';
comment on domain domaindroptest is 'About to drop this..';
comment on event trigger regress_event_trigger is 'test comment';
comment on index at_partitioned_0_id_name_key is 'child 0 index';
comment on index at_partitioned_1_id_name_key is 'child 1 index';
comment on index at_partitioned_id_name_key is 'parent index';
comment on table event_trigger_fire1 is 'here is a comment';
copy (select * from test1) (t,id) to stdout;
copy (select * from test1) from stdin;
copy (select 1) to stdout\; select 1/0;	-- row, then error select 1/0\; copy (select 1) to stdout; -- error only copy (select 1) to stdout\; copy (select 2) to stdout\; select 0\; select 3; -- 1 2 3 create table test3 (c int);
create aggregate aggfns(integer,integer,text) (    sfunc = aggfns_trans, stype = aggtype[], sspace = 10000,    initcond = '{}' );
create aggregate aggfstr(integer,integer,text) (    sfunc = aggf_trans, stype = aggtype[],    initcond = '{}' );
create aggregate build_group(anyelement, integer) (   SFUNC = add_group,   STYPE = anyarray );
create aggregate build_group(int8, integer) (   SFUNC = add_group,   STYPE = int2[] );
create aggregate build_group(int8, integer) (   SFUNC = add_group,   STYPE = int8[] );
create aggregate cleast_agg(variadic items anycompatiblearray) (   stype = anycompatible, sfunc = cleast_accum );
create aggregate first_el_agg_any(anyelement) (   SFUNC = first_el_transfn,   STYPE = anyarray,   FINALFUNC = first_el );
create aggregate first_el_agg_f8(float8) (   SFUNC = array_append,   STYPE = float8[],   FINALFUNC = first_el );
create aggregate least_agg(int4) (   stype = int8, sfunc = least_accum );  -- fails create aggregate least_agg(int8) (   stype = int8, sfunc = least_accum );
create aggregate least_agg(int4) (   stype = int8, sfunc = least_accum );  -- fails drop function least_accum(int8, int8);
create aggregate least_agg(variadic items anyarray) (   stype = anyelement, sfunc = least_accum );
create aggregate my_avg(int4) (    stype = avg_state,    sfunc = avg_transfn,    finalfunc = avg_finalfn );
create aggregate my_avg_init(int4) (    stype = avg_state,    sfunc = avg_transfn,    finalfunc = avg_finalfn,    initcond = '(10,0)' );
create aggregate my_avg_init2(int4) (    stype = avg_state,    sfunc = avg_transfn,    finalfunc = avg_finalfn,    initcond = '(4,0)' );
create aggregate my_half_sum(int4) (    stype = int4,    sfunc = sum_transfn,    finalfunc = halfsum_finalfn );
create aggregate my_percentile_disc(float8 ORDER BY anyelement) (   stype = internal,   sfunc = ordered_set_transition,   finalfunc = percentile_disc_final,   finalfunc_extra = true,   finalfunc_modify = read_write );
create aggregate my_rank(VARIADIC "any" ORDER BY VARIADIC "any") (   stype = internal,   sfunc = ordered_set_transition_multi,   finalfunc = rank_final,   finalfunc_extra = true,   hypothetical );
create aggregate my_sum(int4) (    stype = avg_state,    sfunc = avg_transfn,    finalfunc = sum_finalfn );
create aggregate my_sum(int4) (    stype = int4,    sfunc = sum_transfn );
create aggregate my_sum_init(int4) (    stype = avg_state,    sfunc = avg_transfn,    finalfunc = sum_finalfn,    initcond = '(10,0)' );
create aggregate newavg2 (sfunc = int4pl, 			  basetype = int4, 			  stype = int4, 			  finalfunc = int2um, 			  initcond = '0');
create aggregate newcnt1 (sfunc = int4inc, 			  stype = int4, 			  initcond = '0');
create aggregate sum2(int8,int8) (    sfunc = sum3, stype = int8,    initcond = '0' );
create cast (bigint as xfloat8) without function;
create cast (float4 as xfloat4) without function;
create cast (float8 as xfloat8) without function;
create cast (int4 as myint) without function;
create cast (int8 as int8alias1) without function;
create cast (int8 as int8alias2) without function;
create cast (int8alias1 as int8) without function;
create cast (int8alias2 as int8) without function;
create cast (integer as date) with function sql_to_date(integer) as assignment;
create cast (integer as xfloat4) without function;
create cast (myint as int4) without function;
create cast (xfloat4 as float4) without function;
create cast (xfloat4 as integer) without function;
create cast (xfloat8 as bigint) without function;
create cast (xfloat8 as float8) without function;
create constraint trigger parted_trig after insert on parted_constr_ancestor   deferrable   for each row execute procedure trigger_notice_ab();
create constraint trigger parted_trig_two after insert on parted_constr   deferrable initially deferred   for each row when (bark(new.b) AND new.a % 2 = 1)   execute procedure trigger_notice_ab();
create constraint trigger parted_trigger after update on parted_trigger   from parted_referenced   for each row execute procedure trigger_notice_ab();
create constraint trigger parted_trigger after update on unparted_trigger   from parted_referenced   for each row execute procedure trigger_notice_ab();
create domain restrictedrange as int4range check (upper(value) < 10);
create event trigger no_rewrite_allowed on table_rewrite   execute procedure test_evtrig_no_rewrite();
create event trigger regress_event_trigger    on ddl_command_start    execute procedure pg_backend_pid();
create event trigger regress_event_trigger on ddl_command_start    execute procedure test_event_trigger();
create event trigger regress_event_trigger on elephant_bootstrap    execute procedure test_event_trigger();
create event trigger regress_event_trigger2 on ddl_command_start    execute procedure test_event_trigger('argument not allowed');
create event trigger regress_event_trigger2 on ddl_command_start    when food in ('sandwich')    execute procedure test_event_trigger();
create event trigger regress_event_trigger2 on ddl_command_start    when tag in ('CREATE DATABASE')    execute procedure test_event_trigger();
create event trigger regress_event_trigger2 on ddl_command_start    when tag in ('CREATE ROLE')    execute procedure test_event_trigger();
create event trigger regress_event_trigger2 on ddl_command_start    when tag in ('CREATE TABLESPACE')    execute procedure test_event_trigger();
create event trigger regress_event_trigger2 on ddl_command_start    when tag in ('DROP EVENT TRIGGER')    execute procedure test_event_trigger();
create event trigger regress_event_trigger2 on ddl_command_start    when tag in ('create table') and tag in ('CREATE FUNCTION')    execute procedure test_event_trigger();
create event trigger regress_event_trigger2 on ddl_command_start    when tag in ('create table', 'CREATE FUNCTION')    execute procedure test_event_trigger();
create event trigger regress_event_trigger2 on ddl_command_start    when tag in ('create table', 'create skunkcabbage')    execute procedure test_event_trigger();
create event trigger regress_event_trigger2 on ddl_command_start    when tag in ('sandwich')    execute procedure test_event_trigger();
create event trigger regress_event_trigger_end on ddl_command_end    execute function test_event_trigger();
create event trigger regress_event_trigger_noperms on ddl_command_start    execute procedure test_event_trigger();
create foreign data wrapper useless;
create function add_group(grp anyarray, ad anyelement, size integer)   returns anyarray  as $$ begin   if grp is null then     return array[ad];   end if;   if array_upper(grp, 1) < size then     return grp || ad;   end if;   return grp; end; $$   language plpgsql immutable;
create function anyctest(a anyelement, b anyarray,                          c anycompatible, d anycompatible)returns anycompatiblearray as $$   select array[c, d] $$ language sql;
create function anyctest(anycompatible)returns anycompatiblemultirange as $$   select $1 $$ language sql;
create function anyctest(anycompatible)returns anycompatiblerange as $$   select $1 $$ language sql;
create function anyctest(anycompatible, anycompatible)returns anycompatible as $$   select greatest($1, $2) $$ language sql;
create function anyctest(anycompatible, anycompatible)returns anycompatiblearray as $$   select array[$1, $2] $$ language sql;
create function anyctest(anycompatible, anycompatiblearray)returns anycompatiblearray as $$   select array[$1] || $2 $$ language sql;
create function anyctest(anycompatible, anycompatiblemultirange)returns anycompatiblemultirange as $$   select $2 $$ language sql;
create function anyctest(anycompatible, anycompatiblerange)returns anycompatiblerange as $$   select $2 $$ language sql;
create function anyctest(anycompatiblemultirange, anycompatiblemultirange)returns anycompatible as $$   select lower($1) + upper($2) $$ language sql;
create function anyctest(anycompatiblenonarray, anycompatiblenonarray)returns anycompatiblearray as $$   select array[$1, $2] $$ language sql;
create function anyctest(anycompatiblerange, anycompatiblerange)returns anycompatible as $$   select lower($1) + upper($2) $$ language sql;
create function anyctest(variadic anycompatiblearray)returns anycompatiblearray as $$   select $1 $$ language sql;
create function array_to_set(anyarray) returns setof record as $$   select i AS "index", $1[i] AS "value" from generate_subscripts($1, 1) i $$ language sql strict immutable;
create function arrayassign1() returns text[] language plpgsql as $$ declare  r record; begin   r := row(12, '{foo,bar,baz}')::rtype;   r.ar[2] := 'replace';   return r.ar; end$$;
create function at_test_sql_partop (int4, int4) returns int language sql as $$ select case when $1 = $2 then 0 when $1 > $2 then 1 else -1 end; $$;
create function avg_finalfn(state avg_state) returns int4 as$$ begin 	if state is null then 		return NULL; 	else 		return state.total / state.count; 	end if; end $$ language plpgsql;
create function bad_sql1() returns int as $$ declare a int; begin     a := 5;     Johnny Yuma;     a := 10;     return a; end$$ language plpgsql;
create function bad_sql2() returns int as $$ declare r record; begin     for r in select I fought the law, the law won LOOP         raise notice 'in loop';     end loop;     return 5; end;$$ language plpgsql;
create function bark(text) returns bool language plpgsql immutable   as $$ begin raise notice '% <- woof!', $1; return true; end; $$;
create function base_tab_def_view_instrig_func() returns trigger as$$ begin   insert into base_tab_def values (new.a, new.b, new.c, new.d, new.e);   return new; end; $$ language plpgsql;
create function bleat(int) returns int as $$ begin   raise notice 'bleat %', $1;   return $1; end$$ language plpgsql;
create function cache_test(int) returns int as $$ declare total int; begin 	create temp table t1(f1 int); 	insert into t1 values($1); 	insert into t1 values(11); 	insert into t1 values(12); 	insert into t1 values(13); 	select sum(f1) into total from t1; 	drop table t1; 	return total; end $$ language plpgsql;
create function cache_test_2() returns int as $$ begin 	return f1 from v1; end$$ language plpgsql;
create function cachebug() returns void as $$ declare r int; begin   drop table if exists temptable cascade;   create temp table temptable as select * from generate_series(1,3) as f1;   create temp view vv as select * from temptable;   for r in select * from vv loop     raise notice '%', r;   end loop; end$$ language plpgsql;
create function cast_invoker(integer) returns date as $$ begin   return $1; end$$ language plpgsql;
create function check_con_function(check_con_tbl) returns bool as $$ begin   raise notice 'input = %', row_to_json($1);   return $1.f1 > 0; end $$ language plpgsql immutable;
create function concat(text, variadic anyarray) returns text as $$   select array_to_string($2, $1); $$ language sql immutable strict;
create function conflict_test() returns setof int8_tbl as $$ declare r record;   q1 bigint := 42; begin   for r in select q1,q2 from int8_tbl loop     return next r;   end loop; end; $$ language plpgsql;
create function consumes_rw_array(int[]) returns intlanguage plpgsql as $$   begin return $1[1]; end; $$ stable;
create function depth_a_tf() returns trigger  language plpgsql as $$ begin   raise notice '%: depth = %', tg_name, pg_trigger_depth();   insert into depth_b values (new.id);   raise notice '%: depth = %', tg_name, pg_trigger_depth();   return new; end; $$;
create function depth_b_tf() returns trigger  language plpgsql as $$ begin   raise notice '%: depth = %', tg_name, pg_trigger_depth();   begin     execute 'insert into depth_c values (' || new.id::text || ')';   exception     when sqlstate 'U9999' then       raise notice 'SQLSTATE = U9999: depth = %', pg_trigger_depth();   end;   raise notice '%: depth = %', tg_name, pg_trigger_depth();   if new.id = 1 then     execute 'insert into depth_c values (' || new.id::text || ')';   end if;   return new; end; $$;
create function depth_c_tf() returns trigger  language plpgsql as $$ begin   raise notice '%: depth = %', tg_name, pg_trigger_depth();   if new.id = 1 then     raise exception sqlstate 'U9999';   end if;   raise notice '%: depth = %', tg_name, pg_trigger_depth();   return new; end; $$;
create function dfunc(a anyelement, b anyelement = null, flag bool = true)returns anyelement as $$   select case when $3 then $1 else $2 end; $$ language sql;
create function dfunc(a int = 1, out sum int, b int = 2) as $$   select $1 + $2; $$ language sql;
create function dfunc(a int DEFAULT 1.0, int DEFAULT '-1') returns int as $$   select $1 + $2; $$ language sql;
create function dfunc(a int, b int, c int = 0, d int = 0)  returns table (a int, b int, c int, d int) as $$   select $1, $2, $3, $4; $$ language sql;
create function dfunc(a text DEFAULT 'Hello', b text DEFAULT 'World') returns text as $$   select $1 || ', ' || $2; $$ language sql;
create function dfunc(a varchar = 'def a', out _a varchar, c numeric = NULL, out _c numeric)returns record as $$   select $1, $2; $$ language sql;
create function dfunc(a varchar, b numeric, c date = current_date)  returns table (a varchar, b numeric, c date) as $$   select $1, $2, $3; $$ language sql;
create function dfunc(a variadic int[]) returns int as $$ select array_upper($1, 1) $$ language sql;
create function dfunc(anyelement = 'World'::text) returns text as $$   select 'Hello, ' || $1::text; $$ language sql;
create function dfunc(int = 1, int = 2) returns int as $$   select 2; $$ language sql;
create function dfunc(int = 1, int = 2) returns int as $$   select 2; $$ language sql;
create function dfunc(int = 1, int = 2, int = 3) returns int as $$   select 3; $$ language sql;
create function dfunc(int = 1, int = 2, int = 3, int = 4) returns int as $$   select 4; $$ language sql;
create function dfunc(out int = 20) returns int as $$   select 1; $$ language sql;
create function dfunc(text) returns text as $$   select $1; $$ language sql;
create function dom_check(int) returns di as $$ declare d di; begin   d := $1::di;   return d; end $$ language plpgsql immutable;
create function duplic(in i anycompatiblerange, out j anycompatible, out k anycompatiblearray) as $$ begin   j := lower(i);   k := array[lower(i),upper(i)];   return; end$$ language plpgsql;
create function duplic(in i anyelement, out j anyelement, out k anyarray) as $$ begin   j := i;   k := array[j,j];   return; end$$ language plpgsql;
create function error1(text) returns text language sql as $$ SELECT relname::text FROM pg_class c WHERE c.oid = $1::regclass $$;
create function error2(p_name_table text) returns text language plpgsql as $$ begin   return error1(p_name_table); end$$;
create function exc_using(int, text) returns int as $$ declare i int; begin   for i in execute 'select * from generate_series(1,$1)' using $1+1 loop     raise notice '%', i;   end loop;   execute 'select $2 + $2*3 + length($1)' into i using $2,$1;   return i; end $$ language plpgsql;
create function excpt_test1() returns void as $$ begin     raise notice '% %', sqlstate, sqlerrm; end; $$ language plpgsql;
create function excpt_test2() returns void as $$ begin     begin         begin             raise notice '% %', sqlstate, sqlerrm;         end;     end; end; $$ language plpgsql;
create function excpt_test3() returns void as $$ begin     begin         raise exception 'user exception';     exception when others then 	    raise notice 'caught exception % %', sqlstate, sqlerrm; 	    begin 	        raise notice '% %', sqlstate, sqlerrm; 	        perform 10/0;         exception             when substring_error then                 raise notice 'unexpected exception: % %', sqlstate, sqlerrm; 	        when division_by_zero then 	            raise notice 'caught exception % %', sqlstate, sqlerrm; 	    end; 	    raise notice '% %', sqlstate, sqlerrm;     end; end; $$ language plpgsql;
create function excpt_test4() returns text as $$ begin 	begin perform 1/0; 	exception when others then return sqlerrm; end; end; $$ language plpgsql;
create function expensivefunc(int) returns int language plpgsql immutable strict cost 10000 as $$begin return $1; end$$;
create function extractq2(t int8_tbl) returns int8 as $$   select t.q2 $$ language sql immutable;
create function extractq2_2(t int8_tbl) returns table(ret1 int8) as $$   select extractq2(t) offset 0 $$ language sql immutable;
create function extractq2_2_opt(t int8_tbl) returns table(ret1 int8) as $$   select extractq2(t) $$ language sql immutable;
create function f () returns trigger as $$ begin return new; end; $$ language plpgsql;
create function f1(a anyelement, b anyarray,                    c anycompatible, d anycompatible,                    OUT x anyarray, OUT y anycompatiblearray)as $$ begin   x := a || b;   y := array[c, d]; end$$ language plpgsql;
create function f1(in i int, out j int) as $$ begin   j := i+1;   return; end$$ language plpgsql;
create function f1(in i int, out j int) returns int as $$ begin   return i+1; end$$ language plpgsql;
create function f1(in i int, out j int) returns setof int as $$ begin   j := i+1;   return next;   j := i+2;   return next;   return; end$$ language plpgsql;
create function f1(in i int, out j int, out k text) as $$ begin   j := i;   j := j+1;   k := 'foo'; end$$ language plpgsql;
create function f1(in i int, out j int, out k text) returns setof record as $$ begin   j := i+1;   k := 'foo';   return next;   j := j+1;   k := 'foot';   return next; end$$ language plpgsql;
create function f1(x anyarray) returns anyarray as $$ begin   return x; end$$ language plpgsql;
create function f1(x anyarray) returns anyelement as $$ begin   return x[1]; end$$ language plpgsql;
create function f1(x anycompatible) returns anycompatiblerange as $$ begin   return array[x + 1, x + 2]; end$$ language plpgsql;
create function f1(x anycompatible, y anycompatible) returns anycompatiblearray as $$ begin   return array[x, y]; end$$ language plpgsql;
create function f1(x anycompatiblerange, y anycompatible, z anycompatible) returns anycompatiblearray as $$ begin   return array[lower(x), upper(x), y, z]; end$$ language plpgsql;
create function f1(x anycompatiblerange, y anycompatiblearray) returns anycompatiblerange as $$ begin   return x; end$$ language plpgsql;
create function f1(x anyelement) returns anyarray as $$ begin   return array[x + 1, x + 2]; end$$ language plpgsql;
create function f1(x anyelement) returns anyelement as $$ begin   return x + 1; end$$ language plpgsql;
create function f1(x anyelement) returns anyrange as $$ begin   return array[x + 1, x + 2]; end$$ language plpgsql;
create function f1(x anyrange) returns anyarray as $$ begin   return array[lower(x), upper(x)]; end$$ language plpgsql;
create function f1_times_10() returns trigger as $$ begin new.f1 := new.f1 * 10; return new; end $$ language plpgsql;
create function f_immutable_int4(i integer) returns integer as $$ begin return i; end; $$ language plpgsql immutable;
create function fail() returns int language plpgsql as $$ begin   return 1/0; end $$;
create function fcompos1(v compos) returns void as $$ insert into compos values (v);  -- fail $$ language sql;
create function fcompos1(v compos) returns void as $$ insert into compos values (v.*); $$ language sql;
create function fcompos2(v compos) returns void as $$ select fcompos1(v); $$ language sql;
create function fcompos3(v compos) returns void as $$ select fcompos1(fcompos3.v.*); $$ language sql;
create function foreach_test(anyarray)returns void as $$ declare x int; begin   foreach x in array $1   loop     raise notice '%', x;   end loop;   end; $$ language plpgsql;
create function formarray(anyelement, variadic anyarray) returns anyarray as $$   select array_prepend($1, $2); $$ language sql immutable strict;
create function funcA() returns trigger as $$ begin   raise notice 'hello from funcA';   return null; end; $$ language plpgsql;
create function funcB() returns trigger as $$ begin   raise notice 'hello from funcB';   return null; end; $$ language plpgsql;
create function func_with_bad_set() returns int as $$ select 1 $$ language sql set default_text_search_config = no_such_config;
create function func_with_bad_set() returns int as $$ select 1 $$ language sql set default_text_search_config = no_such_config;
create function gstest_data(v integer, out a integer, out b integer)   returns setof record   as $f$     begin       return query select v, i from generate_series(1,3) i;
create function halfsum_finalfn(state int4) returns int4 as$$ begin 	if state is null then 		return NULL; 	else 		return state / 2; 	end if; end $$ language plpgsql;
create function inner_func(int)returns int as $$ declare   _context text;   sx int := 5; begin   begin     perform sx / 0;   exception     when division_by_zero then       get diagnostics _context = pg_context;       raise notice '***%***', _context;   end;   get diagnostics _context = pg_context;   raise notice '***%***', _context;   raise notice 'lets make sure we didnt break anything';   return 2 * $1; end; $$ language plpgsql;
create function inner_func(int)returns int as $$ declare _context text; begin   get diagnostics _context = pg_context;   raise notice '***%***', _context;   get diagnostics _context = pg_context;   raise notice '***%***', _context;   raise notice 'lets make sure we didnt break anything';   return 2 * $1; end; $$ language plpgsql;
create function inoutparam_fail(inout i anyelement, out r anyrange)   as $$ select $1, '[1,10]' $$ language sql;
create function inoutparam_succeed(out i anyelement, inout r anyrange)   as $$ select upper($1), $1 $$ language sql;
create function insert_tt(text) returns int as $$ insert into tt(data) values($1) returning f1 $$ language sql;
create function inverse(int) returns float8 as$$ begin   analyze revalidate_bug;   return 1::float8/$1; exception   when division_by_zero then return 0; end$$ language plpgsql volatile;
create function list_part_fn(int) returns int as $$ begin return $1; end;$$ language plpgsql stable;
create function longname(fullname) returns text language sql as $$select $1.first || ' ' || $1.last$$;
create function missing_return_expr() returns int as $$ begin     perform 2+2; end;$$ language plpgsql;
create function missing_return_expr() returns int as $$ begin     return ; end;$$ language plpgsql;
create function mki4(int) returns int4_tbl as $$select row($1)::int4_tbl$$ language sql;
create function mki8(bigint, bigint) returns int8_tbl as $$select row($1,$2)::int8_tbl$$ language sql;
create function mlparted11_trig_fn() returns trigger AS$$ begin   NEW.b := 4;   return NEW; end; $$ language plpgsql;
create function mlparted5abrtrig_func() returns trigger as $$ begin new.c = 'b'; return new; end; $$ language plpgsql;
create function mr_inoutparam_fail(inout i anyelement, out r anymultirange)   as $$ select $1, '[1,10]' $$ language sql;
create function mr_inoutparam_succeed(out i anyelement, inout r anymultirange)   as $$ select upper($1), $1 $$ language sql;
create function mr_outparam_fail(i anyelement, out r anymultirange, out t text)   as $$ select '[1,10]', 'foo' $$ language sql;
create function mr_outparam_succeed(i anymultirange, out r anymultirange, out t text)   as $$ select $1, 'foo'::text $$ language sql;
create function mr_outparam_succeed2(i anymultirange, out r anyarray, out t text)   as $$ select ARRAY[upper($1)], 'foo'::text $$ language sql;
create function mr_outparam_succeed3(i anymultirange, out r anyrange, out t text)   as $$ select range_merge($1), 'foo'::text $$ language sql;
create function mr_outparam_succeed4(i anyrange, out r anymultirange, out t text)   as $$ select multirange($1), 'foo'::text $$ language sql;
create function mr_polymorphic(i anyrange) returns anymultirange   as $$ begin return multirange($1); end; $$ language plpgsql;
create function mr_table_fail(i anyelement) returns table(i anyelement, r anymultirange)   as $$ select $1, '[1,10]' $$ language sql;
create function mr_table_succeed(i anyelement, r anymultirange) returns table(i anyelement, r anymultirange)   as $$ select $1, $2 $$ language sql;
create function multi_datum_use(p1 int) returns bool as $$ declare   x int;   y int; begin   select into x,y unique1/p1, unique1/$1 from tenk1 group by unique1/p1;   return x = y; end$$ language plpgsql;
create function multirangetypes_sql(q anymultirange, b anyarray, out c anyelement)   as $$ select upper($1) + $2[1] $$   language sql;
create function my_trigger_function() returns trigger as $$ begin end; $$ language plpgsql;
create function myinteq(myint, myint) returns bool as $$ begin   if $1 is null and $2 is null then     return true;   else     return $1::int = $2::int;   end if; end; $$ language plpgsql immutable;
create function myintne(myint, myint) returns bool as $$ begin   return not myinteq($1, $2); end; $$ language plpgsql immutable;
create function myleast(variadic anyarray) returns anyelement as $$   select min($1[i]) from generate_subscripts($1,1) g(i) $$ language sql immutable strict;
create function namedparmcursor_test1(int, int) returns boolean as $$ declare     c1 cursor (param1 int, param12 int) for select * from rc_test where a > param1 and b > param12;     nonsense record; begin     open c1(param12 := $2, param1 := $1);     fetch c1 into nonsense;     close c1;     if found then         return true;     else         return false;     end if; end $$ language plpgsql;
create function namedparmcursor_test2(int, int) returns boolean as $$ declare     c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;     nonsense record; begin     open c1(param1 := $1, $2);     fetch c1 into nonsense;     close c1;     if found then         return true;     else         return false;     end if; end $$ language plpgsql;
create function namedparmcursor_test3() returns void as $$ declare     c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2; begin     open c1(param2 := 20, 21); end $$ language plpgsql;
create function namedparmcursor_test4() returns void as $$ declare     c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2; begin     open c1(20, param1 := 21); end $$ language plpgsql;
create function namedparmcursor_test5() returns void as $$ declare   c1 cursor (p1 int, p2 int) for     select * from tenk1 where thousand = p1 and tenthous = p2; begin   open c1 (p2 := 77, p2 := 42); end $$ language plpgsql;
create function namedparmcursor_test6() returns void as $$ declare   c1 cursor (p1 int, p2 int) for     select * from tenk1 where thousand = p1 and tenthous = p2; begin   open c1 (p2 := 77); end $$ language plpgsql;
create function namedparmcursor_test7() returns void as $$ declare   c1 cursor (p1 int, p2 int) for     select * from tenk1 where thousand = p1 and tenthous = p2; begin   open c1 (p2 := 77, p1 := 42/0); end $$ language plpgsql;
create function namedparmcursor_test8() returns int4 as $$ declare   c1 cursor (p1 int, p2 int) for     select count(*) from tenk1 where thousand = p1 and tenthous = p2;   n int4; begin   open c1 (77 -- test   , 42);   fetch c1 into n;   return n; end $$ language plpgsql;
create function namedparmcursor_test9(p1 int) returns int4 as $$ declare   c1 cursor (p1 int, p2 int, debug int) for     select count(*) from tenk1 where thousand = p1 and tenthous = p2       and four = debug;   p2 int4 := 1006;   n int4; begin   open c1 (p1 := p1, p2 := p2, debug := 2);   fetch c1 into n;   return n; end $$ language plpgsql;
create function noticetrigger() returns trigger as $$ begin   raise notice 'noticetrigger % %', new.f1, new.data;   return null; end $$ language plpgsql;
create function outparam2_succeed(r anyrange, out lu anyarray, out ul anyarray)   as $$ select array[lower($1), upper($1)], array[upper($1), lower($1)] $$   language sql;
create function outparam_fail(i anyelement, out r anyrange, out t text)   as $$ select '[1,10]', 'foo' $$ language sql;
create function outparam_succeed(i anyrange, out r anyrange, out t text)   as $$ select $1, 'foo'::text $$ language sql;
create function outparam_succeed2(i anyrange, out r anyarray, out t text)   as $$ select ARRAY[upper($1)], 'foo'::text $$ language sql;
create function parted_trigfunc() returns trigger language plpgsql as $$ begin   new.a = new.a + 1;   return new; end; $$;
create function perform_simple_func(int) returns boolean as ' BEGIN 	IF $1 < 20 THEN 		INSERT INTO perform_test VALUES ($1, $1 + 10);
create function perform_test_func() returns void as ' BEGIN 	IF FOUND then 		INSERT INTO perform_test VALUES (100, 100);
create function pg_temp.twophase_func() returns void as   $$ select '2pc_func'::text $$ language sql;
create function pg_temp.twophase_func() returns void as   $$ select '2pc_func'::text $$ language sql;
create function pg_temp.whoami() returns text   as $$select 'temp'::text$$ language sql;
create function pl_qual_names (param1 int) returns void as $$ <<outerblock>> declare   param1 int := 1; begin   <<innerblock>>   declare     param1 int := 2;   begin     raise notice 'param1 = %', param1;     raise notice 'pl_qual_names.param1 = %', pl_qual_names.param1;     raise notice 'outerblock.param1 = %', outerblock.param1;     raise notice 'innerblock.param1 = %', innerblock.param1;   end; end; $$ language plpgsql;
create function plpgsql_arr_domain_check(val int[]) returns boolean as $$ begin return val[1] > 0; end $$ language plpgsql immutable;
create function plpgsql_domain_check(val int) returns boolean as $$ begin return val > 0; end $$ language plpgsql immutable;
create function polyf(a anyelement, b anyarray,                       c anycompatible, d anycompatible,                       OUT x anyarray, OUT y anycompatiblearray)as $$   select a || b, array[c, d] $$ language sql;
create function polyf(x anyarray) returns anyarray as $$   select x $$ language sql;
create function polyf(x anyarray) returns anyelement as $$   select x[1] $$ language sql;
create function polyf(x anycompatible) returns anycompatiblemultirange as $$   select array[x + 1, x + 2] $$ language sql;
create function polyf(x anycompatible) returns anycompatiblerange as $$   select array[x + 1, x + 2] $$ language sql;
create function polyf(x anycompatible, y anycompatible) returns anycompatiblearray as $$   select array[x, y] $$ language sql;
create function polyf(x anycompatiblemultirange, y anycompatible, z anycompatible) returns anycompatiblearray as $$   select array[lower(x), upper(x), y, z] $$ language sql;
create function polyf(x anycompatiblemultirange, y anycompatiblearray) returns anycompatiblemultirange as $$   select x $$ language sql;
create function polyf(x anycompatiblerange, y anycompatible, z anycompatible) returns anycompatiblearray as $$   select array[lower(x), upper(x), y, z] $$ language sql;
create function polyf(x anycompatiblerange, y anycompatiblearray) returns anycompatiblerange as $$   select x $$ language sql;
create function polyf(x anyelement) returns anyarray as $$   select array[x + 1, x + 2] $$ language sql;
create function polyf(x anyelement) returns anyelement as $$   select x + 1 $$ language sql;
create function polyf(x anyelement) returns anyrange as $$   select array[x + 1, x + 2] $$ language sql;
create function polyf(x anyrange) returns anyarray as $$   select array[lower(x), upper(x)] $$ language sql;
create function pslot_backlink_view(bpchar) returns text as ' <<outer>> declare     rec		record;
create function pslot_slotlink_view(bpchar) returns text as ' declare     psrec	record;
create function public.whoami() returns text   as $$select 'public'::text$$ language sql;
create function qqq_trig() returns trigger as $$ begin if tg_op in ('INSERT', 'UPDATE') then     raise notice '% % %', tg_when, tg_op, new.id;     return new; else     raise notice '% % %', tg_when, tg_op, old.id;     return old; end if; end $$ language plpgsql;
create function raise_exprs() returns void as $$ declare     a integer[] = '{10,20,30}';     c varchar = 'xyz';     i integer; begin     i := 2;     raise notice '%; %; %; %; %; %', a, a[i], c, (select c || 'abc'), row(10,'aaa',NULL,30), NULL; end;$$ language plpgsql;
create function raise_test1(int) returns int as $$ begin     raise notice 'This message has too many parameters!', $1;     return $1; end; $$ language plpgsql;
create function raise_test2(int) returns int as $$ begin     raise notice 'This message has too few parameters: %, %, %', $1, $1;     return $1; end; $$ language plpgsql;
create function raise_test3(int) returns int as $$ begin     raise notice 'This message has no parameters (despite having %% signs in it)!';     return $1; end; $$ language plpgsql;
create function rangetypes_sql(q anyrange, b anyarray, out c anyelement)   as $$ select upper($1) + $2[1] $$   language sql;
create function recurse(float8) returns float8 as$$ begin   if ($1 > 0) then     return sql_recurse($1 - 1);   else     return $1;   end if; end; $$ language plpgsql;
create function refcursor_test1(refcursor) returns refcursor as $$ begin     perform return_refcursor($1);     return $1; end $$ language plpgsql;
create function refcursor_test2(int, int) returns boolean as $$ declare     c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;     nonsense record; begin     open c1($1, $2);     fetch c1 into nonsense;     close c1;     if found then         return true;     else         return false;     end if; end $$ language plpgsql;
create function report_guc(text) returns text as $$ select current_setting($1) $$ language sql set work_mem = '1MB';
create function ret_query1(out int, out int) returns setof record as $$ begin     $1 := -1;     $2 := -2;     return next;     return query select x + 1, x * 10 from generate_series(0, 10) s (x);     return next; end; $$ language plpgsql;
create function return_int_input(int) returns int as $$ begin 	return $1; end; $$ language plpgsql stable;
create function return_refcursor(rc refcursor) returns refcursor as $$ begin     open rc for select a from rc_test;     return rc; end $$ language plpgsql;
create function return_text_input(text) returns text as $$ begin 	return $1; end; $$ language plpgsql stable;
create function returns_rw_array(int) returns int[]language plpgsql as $$   declare r int[];   begin r := array[$1, $1]; return r; end; $$ stable;
create function rngfunc1(n integer, out a text, out b text)   returns setof record   language sql   as $$ select 'foo ' || i, 'bar ' || i from generate_series(1,$1) i $$;
create function rttest()returns setof int as $$ declare rc int; begin   return query values(10),(20);   get diagnostics rc = row_count;   raise notice '% %', found, rc;   return query select * from (values(10),(20)) f(a) where false;   get diagnostics rc = row_count;   raise notice '% %', found, rc;   return query execute 'values(10),(20)';   get diagnostics rc = row_count;   raise notice '% %', found, rc;   return query execute 'select * from (values(10),(20)) f(a) where false';   get diagnostics rc = row_count;   raise notice '% %', found, rc; end; $$ language plpgsql;
create function sc_test() returns setof integer as $$ declare   c scroll cursor for select f1 from int4_tbl;   x integer; begin   open c;   fetch last from c into x;   while found loop     return next x;     fetch prior from c into x;   end loop;   close c; end; $$ language plpgsql;
create function sp_add_user(a_login text) returns int as $$ declare my_id_user int; begin   my_id_user = sp_id_user( a_login );   IF  my_id_user > 0 THEN     RETURN -1;  -- error code for existing user   END IF;   INSERT INTO users ( login ) VALUES ( a_login );   my_id_user = sp_id_user( a_login );   IF  my_id_user = 0 THEN     RETURN -2;  -- error code for insertion failure   END IF;   RETURN my_id_user; end$$ language plpgsql;
create function sp_id_user(a_login text) returns int as $$ declare x int; begin   select into x id from users where login = a_login;   if found then return x; end if;   return 0; end$$ language plpgsql stable;
create function sp_parallel_restricted(int) returns int as   $$begin return $1; end$$ language plpgsql parallel restricted;
create function sp_simple_func(var1 integer) returns integeras $$ begin         return var1 + 10; end; $$ language plpgsql PARALLEL SAFE;
create function sp_test_func() returns setof text as $$ select 'foo'::varchar union all select 'bar'::varchar $$ language sql stable;
create function sql_if(bool, anyelement, anyelement) returns anyelement as $$ select case when $1 then $2 else $3 end $$ language sql;
create function sql_recurse(float8) returns float8 as $$ select recurse($1) limit 1; $$ language sql;
create function sql_to_date(integer) returns date as $$ select $1::text::date $$ language sql immutable strict;
create function stacked_diagnostics_test() returns void as $$ declare _sqlstate text;         _message text;         _context text; begin   perform zero_divide(); exception when others then   get stacked diagnostics         _sqlstate = returned_sqlstate,         _message = message_text,         _context = pg_exception_context;   raise notice 'sqlstate: %, message: %, context: [%]',     _sqlstate, _message, replace(_context, E'\n', ' <- '); end; $$ language plpgsql;
create function sum_finalfn(state avg_state) returns int4 as$$ begin 	if state is null then 		return NULL; 	else 		return state.total; 	end if; end $$ language plpgsql;
create function table_fail(i anyelement) returns table(i anyelement, r anyrange)   as $$ select $1, '[1,10]' $$ language sql;
create function table_succeed(r anyrange)   returns table(l anyelement, u anyelement)   as $$ select lower($1), upper($1) $$   language sql;
create function tattle(x int, y int) returns boolvolatile language plpgsql as $$ begin   raise notice 'x = %, y = %', x, y;   return x > y; end$$;
create function test_event_trigger() returns event_trigger as $$ BEGIN     RAISE NOTICE 'test_event_trigger: % %', tg_event, tg_tag; END $$ language plpgsql;
create function test_event_trigger_arg(name text) returns event_trigger as $$ BEGIN RETURN 1; END $$ language plpgsql;
create function test_event_trigger_sql() returns event_trigger as $$ SELECT 1 $$ language sql;
create function test_found()   returns boolean as '   declare   begin   insert into found_test_tbl values (1);
create function test_ret_rec_dyn(int) returns record as ' DECLARE 	retval RECORD;
create function test_ret_set_rec_dyn(int) returns setof record as ' DECLARE 	retval RECORD;
create function test_ret_set_scalar(int,int) returns setof int as ' DECLARE 	i int;
create function test_table_func_rec() returns setof found_test_tbl as ' DECLARE 	rec RECORD;
create function test_table_func_row() returns setof found_test_tbl as ' DECLARE 	row found_test_tbl%ROWTYPE;
create function testpolym(a int) returns table(a int) as $$ select $1;$$ language sql;
create function testpolym(a int, a int) returns int as $$ select 1;$$ language sql;
create function testpolym(a int, inout a int) returns int as $$ select 1;$$ language sql;
create function testpolym(a int, out a int) returns int as $$ select $1;$$ language sql;
create function testpolym(int, out a int, out a int) returns int as $$ select 1;$$ language sql;
create function testpolym(out a int, inout a int) returns int as $$ select 1;$$ language sql;
create function testrngfunc() returns record as $$   insert into rngfunc values (1,2) returning *; $$ language sql;
create function testrngfunc() returns rngfunc_type as $$   select 7.136178319899999964, 7.136178319899999964; $$ language sql immutable;
create function testrngfunc() returns setof record as $$   insert into rngfunc values (1,2), (3,4) returning *; $$ language sql;
create function testrngfunc() returns setof rngfunc_type as $$   select 7.136178319899999964, 7.136178319899999964; $$ language sql immutable;
create function tftest(int) returns table(a int, b int) as $$ begin   return query select $1, $1+i from generate_series(1,5) g(i); end; $$ language plpgsql immutable strict;
create function tg_backlink_a() returns trigger as ' declare     dummy	integer;
create function tg_backlink_set(myname bpchar, blname bpchar) returns integer as ' declare     mytype	char(2);
create function tg_backlink_unset(bpchar, bpchar) returns integer as ' declare     myname	alias for $1;
create function tg_hslot_bd() returns trigger as ' declare     hubrec	record;
create function tg_hslot_biu() returns trigger as ' declare     sname	text;
create function tg_hslot_bu() returns trigger as ' begin     if new.slotname != old.slotname or new.hubname != old.hubname then         delete from HSlot where slotname = old.slotname;
create function tg_hub_a() returns trigger as ' declare     hname	text;
create function tg_hub_adjustslots(hname bpchar,                                    oldnslots integer,                                    newnslots integer) returns integer as ' begin     if newnslots = oldnslots then         return 0;
create function tg_iface_biu() returns trigger as $$ declare     sname	text;     sysrec	record; begin     select into sysrec * from system where name = new.sysname;     if not found then         raise exception $q$system "%" does not exist$q$, new.sysname;     end if;     sname := 'IF.' || new.sysname;     sname := sname || '.';     sname := sname || new.ifname;     if length(sname) > 20 then         raise exception 'IFace slotname "%" too long (20 char max)', sname;     end if;     new.slotname := sname;     return new; end; $$ language plpgsql;
create function tg_iface_bu() returns trigger as ' begin     if new.slotname != old.slotname then         delete from IFace where slotname = old.slotname;
create function tg_pfield_ad() returns trigger as ' begin     delete from PSlot where pfname = old.name;
create function tg_pfield_au() returns trigger as ' begin     if new.name != old.name then         update PSlot set pfname = new.name where pfname = old.name;
create function tg_phone_bu() returns trigger as ' begin     if new.slotname != old.slotname then         delete from PHone where slotname = old.slotname;
create function tg_pline_bu() returns trigger as ' begin     if new.slotname != old.slotname then         delete from PLine where slotname = old.slotname;
create function tg_pslot_biu() returns trigger as $proc$ declare     pfrec	record;
create function tg_pslot_bu() returns trigger as ' begin     if new.slotname != old.slotname then         delete from PSlot where slotname = old.slotname;
create function tg_room_ad() returns trigger as ' begin     delete from WSlot where roomno = old.roomno;
create function tg_room_au() returns trigger as ' begin     if new.roomno != old.roomno then         update WSlot set roomno = new.roomno where roomno = old.roomno;
create function tg_slotlink_a() returns trigger as ' declare     dummy	integer;
create function tg_slotlink_set(bpchar, bpchar) returns integer as ' declare     myname	alias for $1;
create function tg_slotlink_unset(bpchar, bpchar) returns integer as ' declare     myname	alias for $1;
create function tg_system_au() returns trigger as ' begin     if new.name != old.name then         update IFace set sysname = new.name where sysname = old.name;
create function tg_wslot_biu() returns trigger as $$ begin     if count(*) = 0 from Room where roomno = new.roomno then         raise exception 'Room % does not exist', new.roomno;     end if;     return new; end; $$ language plpgsql;
create function tg_wslot_bu() returns trigger as ' begin     if new.slotname != old.slotname then         delete from WSlot where slotname = old.slotname;
create function trig_nothing() returns trigger language plpgsql   as $$ begin return null; end $$;
create function trigger_ddl_func() returns trigger as $$ begin   alter table trigger_ddl_table add primary key (col1);   return new; end$$ language plpgsql;
create function trigger_nothing() returns trigger   language plpgsql as $$ begin end; $$;
create function trigger_parted_trigfunc() returns trigger language plpgsql as   $$ begin end; $$;
create function trigtest() returns trigger as $$ begin 	raise notice '% % % %', TG_TABLE_NAME, TG_OP, TG_WHEN, TG_LEVEL; 	return new; end;$$ language plpgsql;
create function tt14f() returns setof tt14t as$$ declare     rec1 record; begin     for rec1 in select * from tt14t     loop         return next rec1;     end loop; end; $$ language plpgsql;
create function unreserved_test() returns int as $$ declare   forward int := 21; begin   forward := forward * 2;   return forward; end $$ language plpgsql;
create function update_stmt_notice() returns trigger as $$ begin 	raise notice 'updating %', TG_TABLE_NAME; 	return null; end; $$ language plpgsql;
create function use_refcursor(rc refcursor) returns int as $$ declare     rc refcursor;     x record; begin     rc := return_unnamed_refcursor();     fetch next from rc into x;     return x.a; end $$ language plpgsql;
create function void_return_expr() returns void as $$ begin     perform 2+2; end;$$ language plpgsql;
create function void_return_expr() returns void as $$ begin     return 5; end;$$ language plpgsql;
create function wait_for_stats() returns void as $$ declare   start_time timestamptz := clock_timestamp();   updated1 bool;   updated2 bool;   updated3 bool;   updated4 bool; begin   for i in 1 .. 300 loop     SELECT (st.seq_scan >= pr.seq_scan + 1) INTO updated1       FROM pg_stat_user_tables AS st, pg_class AS cl, prevstats AS pr      WHERE st.relname='tenk2' AND cl.relname='tenk2';     SELECT (st.idx_scan >= pr.idx_scan + 1) INTO updated2       FROM pg_stat_user_tables AS st, pg_class AS cl, prevstats AS pr      WHERE st.relname='tenk2' AND cl.relname='tenk2';     SELECT (n_tup_ins > 0) INTO updated3       FROM pg_stat_user_tables WHERE relname='trunc_stats_test4';     SELECT (pr.snap_ts < pg_stat_get_snapshot_timestamp()) INTO updated4       FROM prevstats AS pr;     exit when updated1 and updated2 and updated3 and updated4;     perform pg_sleep_for('100 milliseconds');     perform pg_stat_clear_snapshot();   end loop;   raise log 'wait_for_stats delayed % seconds',     extract(epoch from clock_timestamp() - start_time); end $$ language plpgsql;
create function wslot_slotlink_view(bpchar) returns text as ' declare     rec		record;
create function zero_divide() returns int as $$ declare v int := 0; begin   return 10 / v; end; $$ language plpgsql;
create index on test_range_elem using spgist(int4range(i,i+10));
create materialized view mvtest_error as select 1/0 as x;  -- fail create materialized view mvtest_error as select 1/0 as x with no data;
create materialized view parallel_mat_view as     select length(stringu1) from tenk1 group by length(stringu1);
create operator < (     procedure = int8alias1lt,     leftarg = int8alias1, rightarg = int8alias1 );
create operator <> (   leftarg    = myint,   rightarg   = myint,   commutator = <>,   negator    = =,   procedure  = myintne,   restrict   = eqsel,   join       = eqjoinsel,   merges );
create operator = (     procedure = int8alias1eq,     leftarg = int8, rightarg = int8alias1,     restrict = eqsel, join = eqjoinsel,     merges );
create operator = (     procedure = int8alias1eq,     leftarg = int8alias1, rightarg = int8alias1,     commutator = =,     restrict = eqsel, join = eqjoinsel,     merges );
create operator = (     procedure = int8alias1eq,     leftarg = int8alias1, rightarg = int8alias2,     restrict = eqsel, join = eqjoinsel,     merges );
create operator = (     procedure = int8alias2eq,     leftarg = int8alias2, rightarg = int8alias2,     commutator = =,     restrict = eqsel, join = eqjoinsel,     merges );
create operator = (   leftarg    = myint,   rightarg   = myint,   commutator = =,   negator    = <>,   procedure  = myinteq,   restrict   = eqsel,   join       = eqjoinsel,   merges );
create operator = (procedure=bogus_int8_text_eq, leftarg=int8, rightarg=text);
create operator === (    leftarg = int4,    rightarg = int4,    procedure = int4eq,    commutator = ===,    hashes );
create operator alter1.=(procedure = alter1.same, leftarg  = alter1.ctype, rightarg = alter1.ctype);
create operator class alter1.ctype_hash_ops default for type alter1.ctype using hash as   operator 1 alter1.=(alter1.ctype, alter1.ctype);
create operator class at_test_sql_partop for type int4 using btree as     operator 1 < (int4, int4), operator 2 <= (int4, int4),     operator 3 = (int4, int4), operator 4 >= (int4, int4),     operator 5 > (int4, int4), function 1 at_test_sql_partop(int4, int4);
create operator class custom_opclass for type int4 using hash as operator 1 = , function 2 dummy_hashint4(int4, int8);
create operator class myint_ops default for type myint using hash as   operator    1   =  (myint, myint),   function    1   myinthash(myint);
create operator class part_test_int4_ops for type int4 using hash as operator 1 =, function 2 part_hashint4_noop(int4, int8);
create operator class part_test_int4_ops2 for type int4 using hash as operator 1 ===, function 2 part_hashint4_noop(int4, int8);
create operator class part_test_text_ops for type text using hash as operator 1 =, function 2 part_hashtext_length(text, int8);
create operator pg_temp.@@ (leftarg = int4, rightarg = int4, procedure = int4mi);
create or replace function array_elem_check(int) returns int as $$ declare   x orderedpair := '{1,2}'; begin   x[2] := $1;   return x[2]; end$$ language plpgsql;
create or replace function array_elem_check(numeric) returns numeric as $$ declare   x mynums2; begin   x[1] := $1;   return x[1]; end$$ language plpgsql;
create or replace function array_elem_check(numeric) returns numeric as $$ declare   x mynums; begin   x[1] := $1;   return x[1]; end$$ language plpgsql;
create or replace function array_elem_check(numeric) returns numeric as $$ declare   x numeric(4,2)[1]; begin   x[1] := $1;   return x[1]; end$$ language plpgsql;
create or replace function array_to_set(anyarray) returns setof record as $$   select i AS "index", $1[i] AS "value" from generate_subscripts($1, 1) i $$ language sql immutable;
create or replace function avg_transfn(state avg_state, n int) returns avg_state as$$ declare new_state avg_state; begin 	raise notice 'avg_transfn called with %', n; 	if state is null then 		if n is not null then 			new_state.total := n; 			new_state.count := 1; 			return new_state; 		end if; 		return null; 	elsif n is not null then 		state.total := state.total + n; 		state.count := state.count + 1; 		return state; 	end if; 	return null; end $$ language plpgsql;
create or replace function brtrigpartcon1trigf() returns trigger as $$begin new.a := 2; return new; end$$ language plpgsql;
create or replace function compos() returns compostype as $$ begin   return (1, 'hello')::compostype; end; $$ language plpgsql;
create or replace function compos() returns compostype as $$ begin   return (1, 'hello'); end; $$ language plpgsql;
create or replace function compos() returns compostype as $$ begin   return (1, 'hello'::varchar); end; $$ language plpgsql;
create or replace function compos() returns compostype as $$ begin   return 1 + 1; end; $$ language plpgsql;
create or replace function compos() returns compostype as $$ declare   v compostype; begin   v := (1, 'hello');   return v; end; $$ language plpgsql;
create or replace function compos() returns compostype as $$ declare   v record; begin   v := (1, 'hello'::varchar);   return v; end; $$ language plpgsql;
create or replace function compos() returns compostype as $$ declare x int := 42; begin   return x; end; $$ language plpgsql;
create or replace function compos() returns int as $$ begin   return (1, 'hello')::compostype; end; $$ language plpgsql;
create or replace function compos() returns int as $$ declare   v compostype; begin   v := (1, 'hello');   return v; end; $$ language plpgsql;
create or replace function compos() returns setof compostype as $$ begin   for i in 1..3   loop     return next (1, 'hello'::varchar);   end loop;   return next null::compostype;   return next (2, 'goodbye')::compostype; end; $$ language plpgsql;
create or replace function composrec() returns record as $$ begin   return (1, 'hello'); end; $$ language plpgsql;
create or replace function composrec() returns record as $$ declare   v record; begin   v := (1, 'hello');   return v; end; $$ language plpgsql;
create or replace function conflict_test() returns setof int8_tbl as $$ declare r record;   q1 bigint := 42; begin   for r in select q1,q2 from int8_tbl loop     return next r;   end loop; end; $$ language plpgsql;
create or replace function conflict_test() returns setof int8_tbl as $$ declare r record;   q1 bigint := 42; begin   for r in select q1,q2 from int8_tbl loop     return next r;   end loop; end; $$ language plpgsql;
create or replace function dfunc(a varchar = 'def a', out _a varchar, numeric = NULL, out _c numeric)returns record as $$   select $1, $2; $$ language sql;
create or replace function dfunc(a varchar = 'def a', out _a varchar, x numeric = NULL, out _c numeric)returns record as $$   select $1, $2; $$ language sql;
create or replace function dfunc(a variadic int[] default array[]::int[]) returns int as $$ select array_upper($1, 1) $$ language sql;
create or replace function dfunc(a variadic int[]) returns int as $$ select array_upper($1, 1) $$ language sql;
create or replace function dom_check(int) returns di as $$ declare d di; begin   d := $1;   return d; end $$ language plpgsql immutable;
create or replace function donothingbrtrig_func() returns trigger as $$begin raise notice 'b: %', new.b; return NULL; end$$ language plpgsql;
create or replace function dummy_hashint4(a int4, seed int8) returns int8 as $$ begin return (a + seed); end; $$ language 'plpgsql' immutable;
create or replace function exc_using(int) returns void as $$ declare   c refcursor;   i int; begin   open c for execute 'select * from generate_series(1,$1)' using $1+1;   loop     fetch c into i;     exit when not found;     raise notice '%', i;   end loop;   close c;   return; end; $$ language plpgsql;
create or replace function execute_into_test(varchar) returns record as $$ declare     _r record;     _rt eifoo%rowtype;     _v eitype;     i int;     j int;     k int; begin     execute 'insert into '||$1||' values(10,15)';     execute 'select (row).* from (select row(10,1)::eifoo) s' into _r;     raise notice '% %', _r.i, _r.y;     execute 'select * from '||$1||' limit 1' into _rt;     raise notice '% %', _rt.i, _rt.y;     execute 'select *, 20 from '||$1||' limit 1' into i, j, k;     raise notice '% % %', i, j, k;     execute 'select 1,2' into _v;     return _v; end; $$ language plpgsql;
create or replace function f1(inout i int) as $$ begin   i := i+1; end$$ language plpgsql;
create or replace function forc01() returns void as $$ declare   c cursor for select * from forc_test; begin   for r in c loop     raise notice '%, %', r.i, r.j;     update forc_test set i = i * 100, j = r.j * 2 where current of c;   end loop; end; $$ language plpgsql;
create or replace function forc01() returns void as $$ declare   c cursor(r1 integer, r2 integer)        for select * from generate_series(r1,r2) i;   c2 cursor        for select * from generate_series(41,43) i; begin   for r in c(5,7) loop     raise notice '% from %', r.i, c;   end loop;   for r in c(9,10) loop     raise notice '% from %', r.i, c;   end loop;   for r in c2 loop     raise notice '% from %', r.i, c2;   end loop;   raise notice 'after loop, c2 = %', c2;   c2 := 'special_name';   for r in c2 loop     raise notice '% from %', r.i, c2;   end loop;   raise notice 'after loop, c2 = %', c2;   c2 := null;   for r in c2 loop     raise notice '%', r.i;   end loop;   raise notice 'after loop, c2 = %', c2;   return; end; $$ language plpgsql;
create or replace function forc01() returns void as $$ declare   c refcursor := 'fooled_ya';   r record; begin   open c for select * from forc_test;   loop     fetch c into r;     exit when not found;     raise notice '%, %', r.i, r.j;     update forc_test set i = i * 100, j = r.j * 2 where current of c;   end loop; end; $$ language plpgsql;
create or replace function forc_bad() returns void as $$ declare   c refcursor; begin   for r in c loop     raise notice '%', r.i;   end loop; end; $$ language plpgsql;
create or replace function foreach_test(anyarray)returns void as $$ declare r record; begin   foreach r in array $1   loop     raise notice '%', r;   end loop;   end; $$ language plpgsql;
create or replace function foreach_test(anyarray)returns void as $$ declare x int; begin   foreach x slice 1 in array $1   loop     raise notice '%', x;   end loop;   end; $$ language plpgsql;
create or replace function foreach_test(anyarray)returns void as $$ declare x int; y int; begin   foreach x, y in array $1   loop     raise notice 'x = %, y = %', x, y;   end loop;   end; $$ language plpgsql;
create or replace function foreach_test(anyarray)returns void as $$ declare x int[]; begin   foreach x slice 1 in array $1   loop     raise notice '%', x;   end loop;   end; $$ language plpgsql;
create or replace function foreach_test(anyarray)returns void as $$ declare x int[]; begin   foreach x slice 2 in array $1   loop     raise notice '%', x;   end loop;   end; $$ language plpgsql;
create or replace function foreach_test(anyarray)returns void as $$ declare x xy_tuple[]; begin   foreach x slice 1 in array $1   loop     raise notice '%', x;   end loop;   end; $$ language plpgsql;
create or replace function func_part_attach() returns trigger  language plpgsql as $$   begin     execute 'create table tab_part_attach_1 (a int)';     execute 'alter table tab_part_attach attach partition tab_part_attach_1 for values in (1)';     return null;   end $$;
create or replace function func_part_create() returns trigger  language plpgsql as $$   begin     execute 'create table tab_part_create_1 partition of tab_part_create for values in (1)';     return null;   end $$;
create or replace function get_first_user() returns users as $$ SELECT * FROM users ORDER BY userid LIMIT 1; $$ language sql stable;
create or replace function get_users() returns setof users as $$ SELECT * FROM users ORDER BY userid; $$ language sql stable;
create or replace function insert_tt(text) returns int as $$ insert into tt(data) values($1),($1||$1) returning f1 $$ language sql;
create or replace function insert_tt2(text,text) returns setof int as $$ insert into tt(data) values($1),($2) returning f1 $$ language sql;
create or replace function myfunc(int) returns text as $$ begin   set local work_mem = '2MB';   return current_setting('work_mem'); end $$ language plpgsql set work_mem = '1MB';
create or replace function myfunc(int) returns text as $$ begin   set work_mem = '2MB';   perform 1/$1;   return current_setting('work_mem'); end $$ language plpgsql set work_mem = '1MB';
create or replace function myfunc(int) returns text as $$ begin   set work_mem = '2MB';   return current_setting('work_mem'); end $$ language plpgsql set work_mem = '1MB';
create or replace function outer_func(int)returns int as $$ declare   myresult int; begin   raise notice 'calling down into inner_func()';   myresult := inner_func($1);   raise notice 'inner_func() done';   return myresult; end; $$ language plpgsql;
create or replace function outer_func(int)returns int as $$ declare   myresult int; begin   raise notice 'calling down into inner_func()';   myresult := inner_func($1);   raise notice 'inner_func() done';   return myresult; end; $$ language plpgsql;
create or replace function outer_outer_func(int)returns int as $$ declare   myresult int; begin   raise notice 'calling down into outer_func()';   myresult := outer_func($1);   raise notice 'outer_func() done';   return myresult; end; $$ language plpgsql;
create or replace function outer_outer_func(int)returns int as $$ declare   myresult int; begin   raise notice 'calling down into outer_func()';   myresult := outer_func($1);   raise notice 'outer_func() done';   return myresult; end; $$ language plpgsql;
create or replace function part_hashint4_noop(value int4, seed int8)returns int8 as $$ select value + seed; $$ language sql immutable;
create or replace function part_hashtext_length(value text, seed int8)RETURNS int8 AS $$ select length(coalesce(value, ''))::int8 $$ language sql immutable;
create or replace function parted_conflict_update_func() returns trigger as $$ declare     r record; begin  for r in select * from inserted loop 	raise notice 'a = %, b = %, c = %', r.a, r.b, r.c;  end loop;  return new; end; $$ language plpgsql;
create or replace function parted_trigfunc() returns trigger language plpgsql as $$ begin   new.a = new.a + new.b;   return new; end; $$;
create or replace function parted_trigfunc2() returns trigger language plpgsql as $$ begin   new.a = new.a + 1;   return new; end; $$;
create or replace function pleast(numeric)returns numeric as $$ begin   raise notice 'non-variadic function called';   return $1; end; $$ language plpgsql immutable strict;
create or replace function pleast(variadic numeric[])returns numeric as $$ declare aux numeric = $1[array_lower($1,1)]; begin   for i in array_lower($1,1)+1..array_upper($1,1) loop     if $1[i] < aux then aux := $1[i]; end if;   end loop;   return aux; end; $$ language plpgsql immutable strict;
create or replace function raise_test() returns void as $$ begin   perform 1/0; exception   when sqlstate '22012' then     raise notice using message = sqlstate;     raise sqlstate '22012' using message = 'substitute message'; end; $$ language plpgsql;
create or replace function raise_test() returns void as $$ begin   raise 'check me'      using errcode = '1234F', detail = 'some detail info';   exception     when others then       raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;       raise; end; $$ language plpgsql;
create or replace function raise_test() returns void as $$ begin   raise 'check me'      using errcode = '1234F', detail = 'some detail info';   exception     when sqlstate '1234F' then       raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;       raise; end; $$ language plpgsql;
create or replace function raise_test() returns void as $$ begin   raise 'check me'      using errcode = 'division_by_zero', detail = 'some detail info';   exception     when others then       raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;       raise; end; $$ language plpgsql;
create or replace function raise_test() returns void as $$ begin   raise division_by_zero using detail = 'some detail info';   exception     when others then       raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;       raise; end; $$ language plpgsql;
create or replace function raise_test() returns void as $$ begin   raise division_by_zero using message = 'custom' || ' message', errcode = '22012'; end; $$ language plpgsql;
create or replace function raise_test() returns void as $$ begin   raise division_by_zero using message = 'custom' || ' message'; end; $$ language plpgsql;
create or replace function raise_test() returns void as $$ begin   raise division_by_zero; end; $$ language plpgsql;
create or replace function raise_test() returns void as $$ begin   raise exception 'custom exception'      using detail = 'some detail of custom exception',            hint = 'some hint related to custom exception'; end; $$ language plpgsql;
create or replace function raise_test() returns void as $$ begin   raise notice '% % %', 1, 2, 3      using errcode = '55001', detail = 'some detail info', hint = 'some hint';   raise '% % %', 1, 2, 3      using errcode = 'division_by_zero', detail = 'some detail info'; end; $$ language plpgsql;
create or replace function raise_test() returns void as $$ begin   raise notice 'some message' using message = 'custom' || ' message', errcode = '22012'; end; $$ language plpgsql;
create or replace function raise_test() returns void as $$ begin   raise sqlstate '1234F'; end; $$ language plpgsql;
create or replace function raise_test() returns void as $$ begin   raise using message = 'custom' || ' message', errcode = '22012'; end; $$ language plpgsql;
create or replace function raise_test() returns void as $$ begin   raise; end; $$ language plpgsql;
create or replace function ret_query2(lim int) returns setof record_type as $$ begin     return query select md5(s.x::text), s.x, s.x > 0                  from generate_series(-8, lim) s (x) where s.x % 2 = 0; end; $$ language plpgsql;
create or replace function return_dquery()returns setof int as $$ begin   return query execute 'select * from (values(10),(20)) f';   return query execute 'select * from (values($1),($2)) f' using 40,50; end; $$ language plpgsql;
create or replace function returnqueryf()returns setof tabwithcols as $$ begin   return query select * from tabwithcols;   return query execute 'select * from tabwithcols'; end; $$ language plpgsql;
create or replace function rngfuncbar() returns setof text as $$ select 'foo'::varchar union all select 'bar'::varchar ; $$ language sql stable;
create or replace function rngfuncbar(out integer, out numeric) as $$ select (1, 2) $$ language sql;
create or replace function rngfuncbar(out integer, out numeric) as $$ select (1, 2.1) $$ language sql;
create or replace function rttest()returns setof int as $$ begin   return query execute 'select 10 into no_such_table'; end; $$ language plpgsql;
create or replace function rttest()returns setof int as $$ begin   return query select 10 into no_such_table; end; $$ language plpgsql;
create or replace function sc_test() returns setof integer as $$ declare   c cursor for select * from generate_series(1, 10);   x integer; begin   open c;   loop       move relative 2 in c;       if not found then           exit;       end if;       fetch next from c into x;       if found then           return next x;       end if;   end loop;   close c; end; $$ language plpgsql;
create or replace function sc_test() returns setof integer as $$ declare   c cursor for select * from generate_series(1, 10);   x integer; begin   open c;   move forward all in c;   fetch backward from c into x;   if found then     return next x;   end if;   close c; end; $$ language plpgsql;
create or replace function sc_test() returns setof integer as $$ declare   c no scroll cursor for select f1 from int4_tbl;   x integer; begin   open c;   fetch last from c into x;   while found loop     return next x;     fetch prior from c into x;   end loop;   close c; end; $$ language plpgsql;
create or replace function sc_test() returns setof integer as $$ declare   c refcursor;   x integer; begin   open c scroll for execute 'select f1 from int4_tbl';   fetch last from c into x;   while found loop     return next x;     fetch relative -2 from c into x;   end loop;   close c; end; $$ language plpgsql;
create or replace function sc_test() returns setof integer as $$ declare   c refcursor;   x integer; begin   open c scroll for execute 'select f1 from int4_tbl';   fetch last from c into x;   while found loop     return next x;     move backward 2 from c;     fetch relative -1 from c into x;   end loop;   close c; end; $$ language plpgsql;
create or replace function shadowtest()	returns void as $$ declare f1 int; begin 	declare 	f1 int; 	begin 	end; end$$ language plpgsql;
create or replace function shadowtest()	returns void as $$ declare f1 int; c1 cursor (f1 int) for select 1; begin end$$ language plpgsql;
create or replace function shadowtest(f1 int)	returns boolean as $$ declare f1 int; begin return 1; end $$ language plpgsql;
create or replace function shadowtest(f1 int)	returns boolean as $$ declare f1 int; begin return 1; end $$ language plpgsql;
create or replace function shadowtest(in1 int)	returns table (out1 int) as $$ declare in1 int; out1 int; begin end $$ language plpgsql;
create or replace function shadowtest(in1 int)	returns table (out1 int) as $$ declare in1 int; out1 int; begin end $$ language plpgsql;
create or replace function shadowtest(in1 int)	returns void as $$ declare in1 int; begin 	declare 	in1 int; 	begin 	end; end$$ language plpgsql;
create or replace function stacked_diagnostics_test() returns void as $$ declare _column_name text;         _constraint_name text;         _datatype_name text;         _table_name text;         _schema_name text; begin   raise exception using     column = '>>some column name<<',     constraint = '>>some constraint name<<',     datatype = '>>some datatype name<<',     table = '>>some table name<<',     schema = '>>some schema name<<'; exception when others then   get stacked diagnostics         _column_name = column_name,         _constraint_name = constraint_name,         _datatype_name = pg_datatype_name,         _table_name = table_name,         _schema_name = schema_name;   raise notice 'column %, constraint %, type %, table %, schema %',     _column_name, _constraint_name, _datatype_name, _table_name, _schema_name; end; $$ language plpgsql;
create or replace function stacked_diagnostics_test() returns void as $$ declare _detail text;         _hint text;         _message text; begin   get stacked diagnostics         _message = message_text,         _detail = pg_exception_detail,         _hint = pg_exception_hint;   raise notice 'message: %, detail: %, hint: %', _message, _detail, _hint; end; $$ language plpgsql;
create or replace function stacked_diagnostics_test() returns void as $$ declare _detail text;         _hint text;         _message text; begin   perform raise_test(); exception when others then   get stacked diagnostics         _message = message_text,         _detail = pg_exception_detail,         _hint = pg_exception_hint;   raise notice 'message: %, detail: %, hint: %', _message, _detail, _hint; end; $$ language plpgsql;
create or replace function stricttest() returns void as $$ declare x record; begin   execute 'insert into foo values(5,6) returning *' into x;   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2; end$$ language plpgsql;
create or replace function stricttest() returns void as $$ declare x record; begin   execute 'insert into foo values(7,8),(9,10) returning *' into x;   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2; end$$ language plpgsql;
create or replace function stricttest() returns void as $$ declare x record; begin   execute 'select * from foo where f1 = $1 or f1::text = $2' using 0, 'foo' into strict x;   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2; end$$ language plpgsql;
create or replace function stricttest() returns void as $$ declare x record; begin   execute 'select * from foo where f1 = 0' into strict x;   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2; end$$ language plpgsql;
create or replace function stricttest() returns void as $$ declare x record; begin   execute 'select * from foo where f1 = 3' into strict x;   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2; end$$ language plpgsql;
create or replace function stricttest() returns void as $$ declare x record; begin   execute 'select * from foo where f1 > $1' using 1 into strict x;   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2; end$$ language plpgsql;
create or replace function stricttest() returns void as $$ declare x record; begin   execute 'select * from foo where f1 > 3' into strict x;   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2; end$$ language plpgsql;
create or replace function stricttest() returns void as $$ declare x record; begin   execute 'select * from foo where f1 > 3' into strict x;   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2; end$$ language plpgsql;
create or replace function stricttest() returns void as $$ declare x record; begin   insert into foo values(5,6) returning * into x;   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2; end$$ language plpgsql;
create or replace function stricttest() returns void as $$ declare x record; begin   insert into foo values(7,8),(9,10) returning * into x;   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2; end$$ language plpgsql;
create or replace function stricttest() returns void as $$ declare x record; begin   select * from foo where f1 = 0 into strict x;   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2; end$$ language plpgsql;
create or replace function stricttest() returns void as $$ declare x record; begin   select * from foo where f1 = 3 into strict x;   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2; end$$ language plpgsql;
create or replace function stricttest() returns void as $$ declare x record; begin   select * from foo where f1 > 3 into strict x;   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2; end$$ language plpgsql;
create or replace function stricttest() returns void as $$ declare x record; begin   select * from foo where f1 > 3 into strict x;   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2; end$$ language plpgsql;
create or replace function stricttest() returns void as $$ declare x record; p1 int := 2; p3 text := $a$'Valame Dios!' dijo Sancho; 'no le dije yo a vuestra merced que mirase bien lo que hacia?'$a$; begin   select * from foo where f1 = p1 and f1::text = p3 into strict x;   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2; end$$ language plpgsql;
create or replace function stricttest() returns void as $$ declare x record; p1 int := 2; p3 text := 'foo'; begin   select * from foo where f1 = p1 and f1::text = p3 into strict x;   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2; end$$ language plpgsql;
create or replace function stricttest() returns void as $$ declare x record; p1 int := 2; p3 text := 'foo'; begin   select * from foo where f1 > p1 or f1::text = p3  into strict x;   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2; end$$ language plpgsql;
create or replace function stricttest() returns void as $$ declare x record; p1 int := 2; p3 text := 'foo'; begin   select * from foo where f1 > p1 or f1::text = p3  into strict x;   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2; end$$ language plpgsql;
create or replace function stricttest() returns void as $$ declare x record; p1 int := 2; p3 text := 'foo'; begin   select * from foo where f1 > p1 or f1::text = p3  into strict x;   raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2; end$$ language plpgsql;
create or replace function strtest() returns text as $$ begin   raise notice 'foo\\bar\041baz';   return 'foo\\bar\041baz'; end $$ language plpgsql;
create or replace function strtest() returns text as $$ begin   raise notice 'foo\\bar\041baz\';   return 'foo\\bar\041baz\'; end $$ language plpgsql;
create or replace function strtest() returns text as $$ begin   raise notice E'foo\\bar\041baz';   return E'foo\\bar\041baz'; end $$ language plpgsql;
create or replace function strtest() returns text as $$ begin   raise notice E'foo\\bar\041baz';   return E'foo\\bar\041baz'; end $$ language plpgsql;
create or replace function sum_transfn(state int4, n int4) returns int4 as$$ declare new_state int4; begin 	raise notice 'sum_transfn called with %', n; 	if state is null then 		if n is not null then 			new_state := n; 			return new_state; 		end if; 		return null; 	elsif n is not null then 		state := state + n; 		return state; 	end if; 	return null; end $$ language plpgsql;
create or replace function test_conv(   input IN bytea,   src_encoding IN text,   dst_encoding IN text,   result OUT bytea,   errorat OUT bytea,   error OUT text) language plpgsql as$$ declare   validlen int; begin   begin     select * into validlen, result from test_enc_conversion(input, src_encoding, dst_encoding, false);     errorat = NULL;     error := NULL;   exception when others then     error := sqlerrm;     select * into validlen, result from test_enc_conversion(input, src_encoding, dst_encoding, true);     errorat = substr(input, validlen + 1);   end;   return; end; $$;
create or replace function testrngfunc() returns rngfunc_type as $$   select 7.136178319899999964, 7.136178319899999964; $$ language sql volatile;
create or replace function testrngfunc() returns setof rngfunc_type as $$   select 1, 2 union select 3, 4 order by 1; $$ language sql immutable;
create or replace function testrngfunc() returns setof rngfunc_type as $$   select 7.136178319899999964, 7.136178319899999964; $$ language sql volatile;
create or replace function tftest(a1 int) returns table(a int, b int) as $$ begin   a := a1; b := a1 + 1;   return next;   a := a1 * 10; b := a1 * 10 + 1;   return next; end; $$ language plpgsql immutable strict;
create or replace function trigger_notice() returns trigger as $$   begin     raise notice 'trigger % on % % % for %', TG_NAME, TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL;     if TG_LEVEL = 'ROW' then        return NEW;     end if;     return null;   end;   $$ language plpgsql;
create or replace function trigger_notice() returns trigger as $$   declare     arg1 text = TG_ARGV[0];     arg2 integer = TG_ARGV[1];   begin     raise notice 'trigger % on % % % for % args % %', 		TG_NAME, TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL, arg1, arg2;     return null;   end;   $$ language plpgsql;
create or replace function trigger_notice_ab() returns trigger as $$   begin     raise notice 'trigger % on % % % for %: (a,b)=(%,%)', 		TG_NAME, TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL, 		NEW.a, NEW.b;     if TG_LEVEL = 'ROW' then        return NEW;     end if;     return null;   end;   $$ language plpgsql;
create or replace function unnest1(anyarray)returns setof anyelement as $$ select $1[s] from generate_subscripts($1,1) g(s); $$ language sql immutable;
create or replace function unnest2(anyarray)returns setof anyelement as $$ select $1[s1][s2] from generate_subscripts($1,1) g1(s1),                    generate_subscripts($1,2) g2(s2); $$ language sql immutable;
create or replace function unreserved_test() returns int as $$ declare   comment int := 21; begin   comment := comment * 2;   comment on function unreserved_test() is 'this is a test';   return comment; end $$ language plpgsql;
create or replace function unreserved_test() returns int as $$ declare   return int := 42; begin   return := return + 1;   return return; end $$ language plpgsql;
create or replace function vari(variadic int[])returns void as $$ begin   for i in array_lower($1,1)..array_upper($1,1) loop     raise notice '%', $1[i];   end loop; end; $$ language plpgsql;
create or replace trigger my_trig   after insert on parted_trig   for each row execute procedure funcA();
create or replace trigger my_trig   after insert on parted_trig   for each row execute procedure funcA();
create or replace trigger my_trig   after insert on parted_trig   for each row execute procedure funcB();
create or replace trigger my_trig   after insert on parted_trig   for each row execute procedure funcB();
create or replace trigger my_trig   after insert on parted_trig_1   for each row execute procedure funcB();  -- should fail insert into parted_trig (a) values (50);
create or replace trigger my_trig   before insert on my_table   for each row execute procedure funcB();  -- OK insert into my_table values (2);  -- this insert should become a no-op table my_table;
create policy p1 on ec1 using (f1 < '5'::int8alias1);
create publication pub1 for table alter1.t1, all tables in schema alter2;
create rule insert_tt_rule as on insert to tt do also   insert into tt_log values(new.*);
create rule r1 as on update to rules_src do also   insert into rules_log values(old.*, 'old'), (new.*, 'new');
create rule r2 as on update to rules_src do also   values(old.*, 'old'), (new.*, 'new');
create rule rr as on update to rule_t1 do instead UPDATE rule_dest trgt   SET (f2[1], f1, tag) = (SELECT new.f2, new.f1, 'updated'::varchar)   WHERE trgt.f1 = new.f1 RETURNING new.*;
create rule rrule as   on update to vview do instead (   insert into cchild (pid, descrip)     select old.pid, new.descrip where old.descrip isnull;
create rule rtest_sys_del as on delete to rtest_system do also ( 	delete from rtest_interface where sysname = old.sysname;
create rule rtest_sys_upd as on update to rtest_system do also ( 	update rtest_interface set sysname = new.sysname 		where sysname = old.sysname;
create rule silly as on delete to dcomptable do instead   update dcomptable set d1.r = (d1).r - 1, d1.i = (d1).i + 1 where (d1).i > 0;
create rule silly as on delete to dcomptable do instead   update dcomptable set d1[1].r = d1[1].r - 1, d1[1].i = d1[1].i + 1     where d1[1].i > 0;
create server useless_server foreign data wrapper useless;
create statistics stts_1 (ndistinct) on a, b from stts_t1;
create statistics stts_2 (ndistinct, dependencies) on a, b from stts_t1;
create statistics stts_3 (ndistinct, dependencies, mcv) on a, b from stts_t1;
create statistics stts_4 on b, c from stts_t2;
create statistics stts_hoge on col1, col2, col3 from stts_t3;
create statistics stts_s1.stts_foo on col1, col2 from stts_t3;
create statistics stts_s2.stts_yama (dependencies, mcv) on col1, col3 from stts_t3;
create table agg_data_20k as select g from generate_series(0, 19999) g;
create table agg_data_2k as select g from generate_series(0, 1999) g;
create table agg_group_1 as select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3   from agg_data_20k group by g%10000;
create table agg_group_2 as select * from   (values (100), (300), (500)) as r(a),   lateral (     select (g/2)::numeric as c1,            array_agg(g::numeric) as c2, 	   count(*) as c3     from agg_data_2k     where g < r.a     group by g/2) as s;
create table agg_group_3 as select (g/2)::numeric as c1, sum(7::int4) as c2, count(*) as c3   from agg_data_2k group by g/2;
create table agg_group_4 as select (g/2)::numeric as c1, array_agg(g::numeric) as c2, count(*) as c3   from agg_data_2k group by g/2;
create table agg_hash_1 as select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3   from agg_data_20k group by g%10000;
create table agg_hash_2 as select * from   (values (100), (300), (500)) as r(a),   lateral (     select (g/2)::numeric as c1,            array_agg(g::numeric) as c2, 	   count(*) as c3     from agg_data_2k     where g < r.a     group by g/2) as s;
create table agg_hash_3 as select (g/2)::numeric as c1, sum(7::int4) as c2, count(*) as c3   from agg_data_2k group by g/2;
create table agg_hash_4 as select (g/2)::numeric as c1, array_agg(g::numeric) as c2, count(*) as c3   from agg_data_2k group by g/2;
create table attest1 as select * from atacc1;
create table bigger_than_it_looks as   select generate_series(1, 20000) as id, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
create table cities ( 	name		text, 	population	float8, 	altitude	int		-- (in ft) );
create table clstr_4 as select * from tenk1;
create table failpart partition of idxpart (b primary key) for values from (0) to (100);
create table foo (with baz);  -- fail, WITH is a reserved word create table foo (with ordinality);  -- fail, WITH is a reserved word with ordinality as (select 1 as x) select * from ordinality;
create table gs_data_1 as select g%1000 as g1000, g%100 as g100, g%10 as g10, g    from generate_series(0,1999) g;
create table gs_group_1 as select g100, g10, sum(g::numeric), count(*), max(g::text) from gs_data_1 group by cube (g1000, g100,g10);
create table gs_hash_1 as select g100, g10, sum(g::numeric), count(*), max(g::text) from gs_data_1 group by cube (g1000, g100,g10);
create table i8r_array (f1 int, f2 int8range[]);
create table idxpart1pk partition of idxpart (a primary key) for values from (0) to (100);
create table j3 as select unique1, tenthous from onek;
create table join_bar as select generate_series(1, 10000) as id, 'xxxxx'::text as t;
create table join_foo as select generate_series(1, 3) as id, 'xxxxx'::text as t;
create table nulltest            ( col1 dnotnull            , col2 dnotnull NULL  -- NOT NULL in the domain cannot be overridden            , col3 dnull    NOT NULL            , col4 dnull            , col5 dcheck CHECK (col5 IN ('c', 'd'))            );
create table nv_parent (d date, check (false) no inherit not valid);
create table parallel_write as     select length(stringu1) from tenk1 group by length(stringu1);
create table parallel_write as execute prep_stmt;
create table parted_conflict_test_1 partition of parted_conflict_test (b unique) for values in (1, 2);
create table pktable(ptest1 inet, ptest2 inet[], primary key(base1, ptest1), foreign key(base2, ptest2) references                                              pktable(base1, ptest1)) inherits (pktable_base);
create table simple as   select generate_series(1, 20000) AS id, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
create table wide as select generate_series(1, 2) as id, rpad('', 320000, 'x') as t;
create temp table forc_test as   select n as i, n as j from generate_series(1,10) n;
create temp table old_oids as   select relname, oid as oldoid, relfilenode as oldfilenode   from pg_class where relname like 'at_partitioned%';
create temp table patest0 (id, x) as   select x, x from generate_series(0,1000) x;
create temp table q1 as select 1 as q1;
create temp table q2 as select 0 as q2;
create temp table t3 as select generate_series(-1000,1000) as x;
create temp table tt1 as select * from int8_tbl limit 2;
create temp table xx1 as select f1 as x1, -f1 as x2 from int4_tbl;
create temp view usersview as SELECT * FROM ROWS FROM(get_users(), generate_series(10,11)) WITH ORDINALITY;
create temp view v_cycle1 as with recursive search_graph(f, t, label) as ( 	select * from graph g 	union all 	select g.* 	from graph g, search_graph sg 	where g.f = sg.t ) cycle f, t set is_cycle using path select f, t, label from search_graph;
create temp view v_cycle2 as with recursive search_graph(f, t, label) as ( 	select * from graph g 	union all 	select g.* 	from graph g, search_graph sg 	where g.f = sg.t ) cycle f, t set is_cycle to 'Y' default 'N' using path select f, t, label from search_graph;
create temp view v_search as with recursive search_graph(f, t, label) as ( 	select * from graph0 g 	union all 	select g.* 	from graph0 g, search_graph sg 	where g.f = sg.t ) search depth first by f, t set seq select f, t, label from search_graph;
create temporary view vw_ord as select * from (values (1)) v(n) join rows from(rngfunct(1),rngfunct(2)) with ordinality as z(a,b,c,d,ord) on (n=ord);
create temporary view vw_ord as select * from rows from(unnest(array[10,20],array['foo','bar']), generate_series(1,2)) as z(a,b,c);
create temporary view vw_ord as select * from rows from(unnest(array[10,20],array['foo','bar'],array[1.0])) as z(a,b,c);
create temporary view vw_rngfunc as   select * from rows from(getrngfunc9(1),                       getrngfunc7(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text),                       getrngfunc1(1))                 with ordinality as t1(a,b,c,d,e,f,g,n);
create type cantcompare as (p point, r float8);
create type cashrange as range (subtype = money);
create type ct1 as (f1 money);
create type testtype4 as (a int, b point);  -- by ref, fixed length select row(1, '(1,2)')::testtype4 *< row(1, '(1,3)')::testtype4;
create type testtype6 as (a int, b point);
create type testtype6 as (a int, b point);
create unique index plain on insertconflicttest(key);
create view insertconflictv as   select * from insertconflict with cascaded check option;
create view tt201v as select   extract(day from now()) as extr,   (now(), '1 day'::interval) overlaps     (current_timestamp(2), '1 day'::interval) as o,   'foo' is normalized isn,   'foo' is nfkc normalized isnn,   normalize('foo') as n,   normalize('foo', nfkd) as nfkd,   overlay('foo' placing 'bar' from 2) as ovl,   overlay('foo' placing 'bar' from 2 for 3) as ovl2,   position('foo' in 'foobar') as p,   substring('foo' from 2 for 3) as s,   substring('foo' similar 'f' escape '#') as ss,   substring('foo' from 'oo') as ssf,  -- historically-permitted abuse   trim(' ' from ' foo ') as bt,   trim(leading ' ' from ' foo ') as lt,   trim(trailing ' foo ') as rt,   trim(E'\\000'::bytea from E'\\000Tom\\000'::bytea) as btb,   trim(leading E'\\000'::bytea from E'\\000Tom\\000'::bytea) as ltb,   trim(trailing E'\\000'::bytea from E'\\000Tom\\000'::bytea) as rtb;
create view tt26v as select x + y + z as c1,        (x * y) + z as c2,        x + (y * z) as c3,        (x + y) * z as c4,        x * (y + z) as c5,        x + (y + z) as c6,        x + (y # z) as c7,        (x > y) AND (y > z OR x > z) as c8,        (x > y) OR (y > z AND NOT (x > z)) as c9,        (x,y) <> ALL (values(1,2),(3,4)) as c10,        (x,y) <= ANY (values(1,2),(3,4)) as c11 from (values(1,2,3)) v(x,y,z);
create view view_of_joins_2d as select * from (tbl1 join tbl1a using (a) as x) as y;
d1 e \. SELECT * FROM vistest;
d2 e \. SELECT * FROM vistest;
d3 e \. COMMIT;
d4 e \. SELECT * FROM vistest;
declare c cursor for select * from int8_tbl limit nochange(3);
declare c1 cursor for select * from int8_tbl limit 10;
declare c1 cursor for select count_tt1_v(), count_tt1_s();
declare c1 scroll cursor for  select * from generate_series(1,4) i   where i <> all (values (2),(3));
declare c1 scroll cursor for select (select 42) as x;
declare c2 cursor for select * from int8_tbl limit 3;
declare c2 cursor with hold for select count_tt1_v(), count_tt1_s();
declare c2 scroll cursor for select generate_series(1,3) as g;
declare c3 cursor for select * from int8_tbl offset 3;
declare c4 cursor for select * from int8_tbl offset 10;
declare c5 cursor for select * from int8_tbl order by q1 fetch first 2 rows with ties;
declare cur SCROLL CURSOR for select 1 from list_part where a > (select 1) and a < (select 4);
declare foo cursor for select * from abc;
declare foo cursor for select * from abc;
declare rf_cur scroll cursor for select * from rows from(generate_series(1,5),generate_series(1,2)) with ordinality as g(i,j,o);
delete from;
discard all;
discard all;
discard temp;
do $$   declare r integer;   begin     select dfunc(a=>-- comment       1) into r;     raise info 'r = %', r;   end; $$;
do $$ BEGIN   EXECUTE 'CREATE COLLATION test0 (locale = ' ||           quote_literal(current_setting('lc_collate')) || ');'; END $$;
do $$ BEGIN   EXECUTE 'CREATE COLLATION test0 (provider = icu, locale = ' ||           quote_literal(current_setting('lc_collate')) || ');'; END $$;
do $$ begin   assert 1=0, 'unhandled assertion'; exception when others then   null; -- do nothing end; $$;
do $$ begin   assert 1=0;  -- should fail end; $$;
do $$ begin   assert 1=0;  -- won't be tested end; $$;
do $$ begin   assert 1=1;  -- should succeed end; $$;
do $$ begin   assert NULL;  -- should fail end; $$;
do $$ declare   t test_01; begin   select 1 into t; -- should fail; end; $$;
do $$ declare   t test_01; begin   select 1, 2 into t;  -- should be ok   raise notice 'ok';   select 1, 2, 3 into t; -- should fail; end; $$;
do $$ declare   x int;   y int; begin   select * from test_01 into x, y; -- should be ok   raise notice 'ok';   select * from test_01 into x;    -- should to fail end; $$;
do $$ declare   x int;   y int; begin   select 1 into x, y;   select 1,2 into x, y;   select 1,2,3 into x, y; end $$;
do $$ declare   x int;   y int; begin   select 1 into x, y;   select 1,2 into x, y;   select 1,2,3 into x, y; end $$;
do $$ declare a int[] := array[1,2]; begin   a := a || 3;   raise notice 'a = %', a; end$$;
do $$ declare v_test plpgsql_arr_domain := array[1]; begin   v_test := 0 || v_test;  -- fail end; $$;
do $$ declare v_test plpgsql_arr_domain; begin   v_test := array[1];   v_test := v_test || 2; end; $$;
do $$ declare v_test plpgsql_domain := 1; begin   v_test := 0;  -- fail end; $$;
do $$ declare v_test plpgsql_domain; begin   v_test := 1; end; $$;
do $$ declare var text := 'some value'; begin   assert 1=0, format('assertion failed, var = "%s"', var); end; $$;
do $$ declare x int := 42;         y int := x + 1; begin   raise notice 'x = %, y = %', x, y; end; $$;
do $$ declare x int := 42; begin   declare y int := x + 1;           x int := x + 2;           z int := x * 10;   begin     raise notice 'x = %, y = %, z = %', x, y, z;   end; end; $$;
do $$ declare x int := x + 1;  -- error begin   raise notice 'x = %', x; end; $$;
do $$ declare x int; begin   select v from generate_series(1,2) g(v) into x; end; $$;
do $$ declare x int; begin   select v from generate_series(1,2) g(v) into x; end; $$;
do $$ declare x text[]; begin x := '{1.23, 4.56}'::numeric[]; end $$;
do $$ declare x text[]; begin x := '{1.23, 4.56}'::numeric[]; end $$;
do $$ declare y int := x + 1;  -- error         x int := 42; begin   raise notice 'x = %, y = %', x, y; end; $$;
do $outer$ begin   for i in 1..10 loop    begin     execute $ex$      do $$       declare x int = 0;       begin         x := 1 / x;       end;       $$;
drop aggregate 314159 (int);
drop aggregate newcnt (float4);
drop aggregate newcnt (nonesuch);
drop aggregate newcnt1;
drop aggregate nonesuch (int4);
drop aggregate;
drop event trigger if exists regress_event_trigger2;
drop event trigger if exists regress_event_trigger2;
drop event trigger no_rewrite_allowed;
drop event trigger regress_event_trigger3;
drop event trigger regress_event_trigger;
drop event trigger regress_event_trigger_end;
drop function ();
drop function 314159();
drop index 314159;
drop index plain;
drop index;
drop instance rule nonesuch on noplace;
drop materialized view parallel_mat_view;
drop operator (int4, int4);
drop operator = ( , int4);
drop operator = (int4, );
drop operator = (int4, nonesuch);
drop operator = (nonesuch);
drop operator = (nonesuch, int4);
drop operator === ();
drop operator === (int4);
drop operator === (int4, int4);
drop operator ===(int4, int4);
drop operator ===;
drop operator class at_test_sql_partop using btree;
drop operator class custom_opclass using hash;
drop operator class part_test_int4_ops2 using hash;
drop operator equals;
drop operator int4, int4;
drop operator;
drop rewrite rule nonesuch;
drop routine f1(), p1();
drop rule "_RETURN" on rules_fooview;
drop rule 314159;
drop rule base_tab_def_view_ins_rule on base_tab_def_view;
drop rule def_view_test_ins on def_view_test;
drop rule nonesuch on noplace;
drop rule qqq on copydml_test;
drop rule qqq on copydml_test;
drop rule qqq on copydml_test;
drop rule qqq on copydml_test;
drop rule qqq on copydml_test;
drop rule qqq on copydml_test;
drop rule qqq on copydml_test;
drop rule qqq on copydml_test;
drop rule qqq on copydml_test;
drop rule qqq on copydml_test;
drop rule qqq on copydml_test;
drop rule qqq on copydml_test;
drop rule rrule on vview;
drop rule rules_foorule on rules_foo;
drop rule rules_foorule on rules_foo;
drop rule;
drop table;
drop trigger base_tab_def_view_instrig on base_tab_def_view;
drop trigger child1_delete_trig on child1;
drop trigger child1_delete_trig on child1;
drop trigger child1_update_trig on child1;
drop trigger child1_update_trig on child1;
drop trigger child2_delete_trig on child2;
drop trigger child2_delete_trig on child2;
drop trigger child2_insert_trig on child2;
drop trigger child2_insert_trig on child2;
drop trigger child2_update_trig on child2;
drop trigger child2_update_trig on child2;
drop trigger child3_delete_trig on child3;
drop trigger child3_delete_trig on child3;
drop trigger child3_insert_trig on child3;
drop trigger child3_insert_trig on child3;
drop trigger child3_update_trig on child3;
drop trigger child3_update_trig on child3;
drop trigger child_row_trig on child;
drop trigger child_row_trig on child;
drop trigger mlparted11_trig on mlparted11;
drop trigger my_trig on parted_trig;
drop trigger self_ref_r_trig on self_ref;
drop trigger trg1 on trigpart1;	-- fail drop trigger trg1 on trigpart2;	-- fail drop trigger trg1 on trigpart3;	-- fail drop table trigpart2;			-- ok, trigger should be gone in that partition select tgrelid::regclass, tgname, tgfoid::regproc from pg_trigger   where tgrelid::regclass::text like 'trigpart%' order by tgrelid::regclass::text;
drop trigger trg1 on trigpart3; -- fail due to "does not exist" alter table trigpart detach partition trigpart4;
drop trigger trg1 on trigpart41; -- fail due to "does not exist" drop table trigpart4;
drop trigger trg1 on trigpart;		-- ok, all gone select tgrelid::regclass, tgname, tgfoid::regproc from pg_trigger   where tgrelid::regclass::text like 'trigpart%' order by tgrelid::regclass::text;
drop trigger trigger_alpha on trigtest;
drop tuple rule nonesuch;
drop type 314159;
drop type _comptype;
drop type compostype;
drop type comptype cascade;
drop type comptype cascade;
drop type comptype cascade;
drop type comptype;
drop type ct1;
drop type ddtest1;
drop type eitype cascade;
drop type insert_test_type;
drop type intr;
drop type lockmodes;
drop type lockmodes;
drop type nonesuch;
drop type pp_colors;
drop type pp_rectype;
drop type rngfunc2;
drop type rposint;
drop type testtype1, testtype2, testtype3, testtype4, testtype5, testtype6;
drop type testtype1, testtype3, testtype5, testtype6;
drop type textandtext;
drop type textrange1;
drop type textrange1;
drop type textrange2;
drop type textrange2;
drop type textrange_c;
drop type textrange_c;
drop type textrange_en_us;
drop type textrange_en_us;
drop type two_ints cascade;
drop type two_ints cascade;
drop type vc4;
drop type xfloat4 cascade;
drop type xfloat8 cascade;
drop type xy_tuple;
drop type;
dummy	integer;
dummy := tg_hub_adjustslots(new.name, old.nslots, new.nslots);
else 	    if new.slotname != old.slotname and new.backlink != '''' then 	        dummy := tg_slotlink_set(new.backlink, new.slotname);
else 	    if new.slotname != old.slotname and new.slotlink != '''' then 	        dummy := tg_slotlink_set(new.slotlink, new.slotname);
else       cmd := cmd || ' FROM ' || fk.fktable::text || ' fk WHERE ';
err record;
exception when division_by_zero then     raise notice 'caught division by zero';
execute p1;
execute p1;
execute p2;
execute p2;
explain (costs off)  -- this should not require a sort   select * from overview where sqli = 'foo' order by sqli;
explain (costs off) create materialized view parallel_mat_view as     select length(stringu1) from tenk1 group by length(stringu1);
explain (costs off) create table parallel_write as     select length(stringu1) from tenk1 group by length(stringu1);
explain (costs off) create table parallel_write as execute prep_stmt;
explain (costs off) select * from hp_contradict_test where a === 1 and b === 1 and a is null;
explain (costs off) select * from hp_contradict_test where a is null and a === 1 and b === 1;
explain (costs off) select * from int4_tbl o where exists   (select 1 from int4_tbl i where i.f1=o.f1 limit null);
explain (costs off) select * from pp_intrangepart where a = '(1,2)'::int4range;
explain (costs off) select * from pp_intrangepart where a = '[1,2]'::int4range;
explain (costs off) select count(*) from test_range_elem where int4range(i,i+10) <@ int4range(10,30);
explain (costs off) select ir from test_range_spgist where ir -|- int4range(10,20) order by ir;
explain (costs off) select p from   (values (box(point(0,0), point(0.5,0.5))),           (box(point(0.5,0.5), point(0.75,0.75))),           (box(point(0.8,0.8), point(1.0,1.0)))) as v(bb) cross join lateral   (select p from gist_tbl where p <@ bb order by p <-> bb[0] limit 2) ss;
explain (costs off) select x from (values (100::money), (200::money)) _(x) union select x from (values (100::money), (300::money)) _(x);
explain (costs off) select x from (values (100::money), (200::money)) _(x) union select x from (values (100::money), (300::money)) _(x);
explain (costs off) select x from (values (array[100::money]), (array[200::money])) _(x) union select x from (values (array[100::money]), (array[300::money])) _(x);
explain (costs off) select x from (values (row(100::money)), (row(200::money))) _(x) union select x from (values (row(100::money)), (row(300::money))) _(x);
explain (costs off) select x from (values (row(100::money)::ct1), (row(200::money)::ct1)) _(x) union select x from (values (row(100::money)::ct1), (row(300::money)::ct1)) _(x);
explain (verbose, costs off)   update dcomptable set d1.r = (d1).r - 1, d1.i = (d1).i + 1 where (d1).i > 0;
explain (verbose, costs off)   update dcomptable set d1[1].r = d1[1].r - 1, d1[1].i = d1[1].i + 1     where d1[1].i > 0;
explain (verbose, costs off) select r, r is null as isnull, r is not null as isnotnull from (values (1,row(1,2)), (1,row(null,null)), (1,null),              (null,row(1,2)), (null,row(null,null)), (null,null) ) r(a,b);
explain (verbose, costs off) with r(a,b) as materialized   (values (1,row(1,2)), (1,row(null,null)), (1,null),           (null,row(1,2)), (null,row(null,null)), (null,null) ) select r, r is null as isnull, r is not null as isnotnull from r;
explain (verbose, costs off) with recursive search_graph(f, t, label) as ( 	select * from graph g 	union all 	select g.* 	from graph g, search_graph sg 	where g.f = sg.t ) cycle f, t set is_cycle using path select * from search_graph;
explain (verbose, costs off) with recursive search_graph(f, t, label) as ( 	select * from graph0 g 	union all 	select g.* 	from graph0 g, search_graph sg 	where g.f = sg.t ) search breadth first by f, t set seq select * from search_graph order by seq;
explain (verbose, costs off) with recursive search_graph(f, t, label) as ( 	select * from graph0 g 	union all 	select g.* 	from graph0 g, search_graph sg 	where g.f = sg.t ) search depth first by f, t set seq select * from search_graph order by seq;
fetch 1 from hsc;
fetch 1 in c1;
fetch 1 in c2;
fetch 1 in c3;
fetch 1 in c4;
fetch 1 in c5;
fetch absolute 1 from rf_cur;
fetch all from c1;
fetch all from c2;
fetch all from c;
fetch all from c;
fetch all from rf_cur;
fetch all from rf_cur;
fetch all from test2;
fetch all in c1;
fetch all in c1;
fetch all in c1;
fetch all in c2;
fetch all in c2;
fetch all in c2;
fetch all in c3;
fetch all in c3;
fetch all in c4;
fetch all in c4;
fetch all in c5;
fetch all in c5;
fetch all in c5;
fetch backward 1 in c1;
fetch backward 1 in c1;
fetch backward 1 in c2;
fetch backward 1 in c2;
fetch backward 1 in c3;
fetch backward 1 in c3;
fetch backward 1 in c4;
fetch backward 1 in c4;
fetch backward 1 in c5;
fetch backward 1 in c5;
fetch backward all from cur;
fetch backward all from rf_cur;
fetch backward all in c1;
fetch backward all in c1;
fetch backward all in c1;
fetch backward all in c2;
fetch backward all in c2;
fetch backward all in c3;
fetch backward all in c4;
fetch backward all in c5;
fetch backward all in c5;
fetch first from hsc;
fetch from foo;
fetch from foo;
fetch from foo;
fetch from foo;
fetch from foo;
fetch last from hsc;
fetch next from rf_cur;
fetch next from rf_cur;
fetch next from rf_cur;
fetch next from rf_cur;
fetch next from rf_cur;
fetch next from test1;
fetch next in test1;
fetch prior from rf_cur;
fetch prior from rf_cur;
fetch prior from rf_cur;
fetch prior from rf_cur;
foo2	202 bar2	203 \. SELECT * FROM itest9 ORDER BY c;
for err in execute cmd loop       raise warning 'FK VIOLATION IN %(%): %', fk.fktable, fk.fkcols, err;
for i in 1 .. 10 loop   end loop;
for i in 1 .. nkeys loop       cmd := cmd || ', ' || quote_ident(fk.fkcols[i]);
for i in 1 .. nkeys loop       if i > 1 then cmd := cmd || ' AND '; end if;
for i in 1 .. nkeys-1 loop         cmd := cmd || ', ' || quote_ident(fk.fkcols[i]);
for i in 2 .. 1 loop   end loop;
for i in oldnslots + 1 .. newnslots loop         insert into HSlot (slotname, hubname, slotno, slotlink) 		values (''HS.dummy'', hname, i, '''');
hubrec	record;
if FOUND then      insert into found_test_tbl values (2);
if FOUND then     insert into found_test_tbl values (3);
if FOUND then     insert into found_test_tbl values (5);
if bltype = ''PL'' then         declare 	    rec		record;
if bltype = ''WS'' then         select into rec * from WSlot where slotname = rec.backlink;
if fk.is_array then       cmd := cmd || ' FROM (SELECT ctid';
if fk.is_opt then       for i in 1 .. nkeys loop         cmd := cmd || quote_ident(fk.fkcols[i]) || ' != 0 AND ';
if length(sname) > 20 then         raise exception ''HSlot slotname "%" too long (20 char max)'', sname;
if link = ''PHPH'' then         raise exception 		''slotlink between two phones does not make sense'';
if link = ''PLPL'' then         raise exception 		''backlink between two phone lines does not make sense'';
if link in (''PHHS'', ''HSPH'') then         raise exception 		''link of phone to hub does not make sense'';
if link in (''PHIF'', ''IFPH'') then         raise exception 		''link of phone to hub does not make sense'';
if link in (''PLWS'', ''WSPL'') then         raise exception 		''direct link of phone line to wall slot not permitted'';
if link in (''PSWS'', ''WSPS'') then         raise exception 		''slotlink from patchslot to wallslot not permitted'';
if mytype = ''HS'' then         select into rec * from HSlot where slotname = myname;
if mytype = ''HS'' then         select into rec * from HSlot where slotname = myname;
if mytype = ''IF'' then         select into rec * from IFace where slotname = myname;
if mytype = ''IF'' then         select into rec * from IFace where slotname = myname;
if mytype = ''PH'' then         select into rec * from PHone where slotname = myname;
if mytype = ''PH'' then         select into rec * from PHone where slotname = myname;
if mytype = ''PL'' then         select into rec * from PLine where slotname = myname;
if mytype = ''PL'' then         select into rec * from PLine where slotname = myname;
if mytype = ''PS'' then         select into rec * from PSlot where slotname = myname;
if mytype = ''PS'' then         select into rec * from PSlot where slotname = myname;
if mytype = ''PS'' then         select into rec * from PSlot where slotname = myname;
if mytype = ''PS'' then         select into rec * from PSlot where slotname = myname;
if mytype = ''WS'' then         select into rec * from WSlot where slotname = myname;
if mytype = ''WS'' then         select into rec * from WSlot where slotname = myname;
if mytype = ''WS'' then         select into rec * from WSlot where slotname = myname;
if mytype = ''WS'' then         select into rec * from WSlot where slotname = myname;
if new.backlink != '''' then 	        dummy := tg_backlink_set(new.backlink, new.slotname);
if new.slotlink != '''' then 	        dummy := tg_slotlink_set(new.slotlink, new.slotname);
if new.slotno < 1 or new.slotno > hubrec.nslots then         raise exception ''no manual manipulation of HSlot'';
if newnslots < oldnslots then         delete from HSlot where hubname = hname and slotno > newnslots;
if not FOUND then     insert into found_test_tbl values (6);
if not found then 	    raise exception ''% does not exist'', myname;
if not found then 	    raise exception ''% does not exist'', myname;
if not found then 	    raise exception ''% does not exist'', myname;
if not found then 	    raise exception ''% does not exist'', myname;
if not found then 	    raise exception ''% does not exist'', myname;
if not found then 	    raise exception ''% does not exist'', myname;
if not found then 	    raise exception ''% does not exist'', myname;
if not found then 	    raise exception ''% does not exist'', myname;
if not found then 	    return 0;
if not found then 	    return 0;
if not found then 	    return 0;
if not found then 	    return 0;
if not found then 	    return 0;
if not found then 	    return 0;
if not found then 	    return 0;
if not found then 	    return 0;
if not found then         raise exception $$Patchfield "%" does not exist$$, ps.pfname;
if not found then         raise exception ''no manual manipulation of HSlot'';
if not found then         return '''';
if not found then         return '''';
if not found then         return '''';
if not found then         return old;
if old.slotno > hubrec.nslots then         return old;
if psrec.slotlink = '''' then         return ''-'';
if rec.backlink != blname then 	    update PLine set backlink = blname where slotname = myname;
if rec.backlink != blname then 	    update PSlot set backlink = blname where slotname = myname;
if rec.backlink != blname then 	    update WSlot set backlink = blname where slotname = myname;
if rec.backlink = '''' then         return ''-'';
if rec.backlink = blname then 	    update PLine set backlink = '''' where slotname = myname;
if rec.backlink = blname then 	    update PSlot set backlink = '''' where slotname = myname;
if rec.backlink = blname then 	    update WSlot set backlink = '''' where slotname = myname;
if rec.comment != '''' then 	        retval := retval || '' ('';
if rec.comment != '''' then 	    retval := retval || '' ('';
if rec.slotlink != blname then 	    update HSlot set slotlink = blname where slotname = myname;
if rec.slotlink != blname then 	    update IFace set slotlink = blname where slotname = myname;
if rec.slotlink != blname then 	    update PHone set slotlink = blname where slotname = myname;
if rec.slotlink != blname then 	    update PSlot set slotlink = blname where slotname = myname;
if rec.slotlink != blname then 	    update WSlot set slotlink = blname where slotname = myname;
if rec.slotlink = '''' then         return ''-'';
if rec.slotlink = blname then 	    update HSlot set slotlink = '''' where slotname = myname;
if rec.slotlink = blname then 	    update IFace set slotlink = '''' where slotname = myname;
if rec.slotlink = blname then 	    update PHone set slotlink = '''' where slotname = myname;
if rec.slotlink = blname then 	    update PSlot set slotlink = '''' where slotname = myname;
if rec.slotlink = blname then 	    update WSlot set slotlink = '''' where slotname = myname;
if sltype = ''HS'' then         retval := comment from Hub H, HSlot HS 			where HS.slotname = psrec.slotlink 			  and H.name = HS.hubname;
if sltype = ''IF'' then 	declare 	    syrow	System%RowType;
if sltype = ''PH'' then         select into rec * from PHone where slotname = rec.slotlink;
if sltype = ''PS'' then 	retval := trim(psrec.slotlink) || '' -> '';
if syrow.comment != '''' then 	        retval := retval || '' ('';
if tg_op = ''DELETE'' then 	dummy := tg_hub_adjustslots(old.name, old.nslots, 0);
if tg_op = ''DELETE'' then         if old.backlink != '''' then 	    dummy := tg_backlink_unset(old.backlink, old.slotname);
if tg_op = ''DELETE'' then         if old.slotlink != '''' then 	    dummy := tg_slotlink_unset(old.slotlink, old.slotname);
if tg_op = ''UPDATE'' and new.hubname != old.hubname then 	if count(*) > 0 from Hub where name = old.hubname then 	    raise exception ''no manual manipulation of HSlot'';
if tg_op = ''UPDATE'' then 	if new.name != old.name then 	    update HSlot set hubname = new.name where hubname = old.name;
if tg_op = ''UPDATE'' then         if new.backlink != old.backlink then 	    if old.backlink != '''' then 	        dummy := tg_backlink_unset(old.backlink, old.slotname);
if tg_op = ''UPDATE'' then         if new.slotlink != old.slotlink then 	    if old.slotlink != '''' then 	        dummy := tg_slotlink_unset(old.slotlink, old.slotname);
if this_schema = 'fast_default'     then         RAISE NOTICE 'rewriting table % for reason %',           pg_event_trigger_table_rewrite_oid()::regclass,           pg_event_trigger_table_rewrite_reason();
ifrow	IFace%ROWTYPE;
insert into arr_pk_tbl values (1, '{3,4,5}') on conflict (pk)   do update set f1[1] = excluded.f1[1], f1[3] = excluded.f1[3]   returning pk, f1;
insert into arr_pk_tbl(pk, f1[1:2]) values (1, '{6,7,8}') on conflict (pk)   do update set f1[1] = excluded.f1[1],     f1[2] = excluded.f1[2],     f1[3] = excluded.f1[3]   returning pk, f1;
insert into base_tab_view (b[1], b[2], c, b[5], b[4], a, b[3]) values (1, 2, default, 5, 4, default, 3), (10, 11, 'C value', 14, 13, 100, 12);
insert into bmscantest select r, 'fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo' FROM generate_series(1,100000) r;
insert into btree_bpchar select 'foo' from generate_series(1,1500);
insert into btree_tall_tbl select g, repeat('x', 250) from generate_series(1, 130) g;
insert into bug_16784 select g/10, g from generate_series(1,40) g;
insert into capitals values ('Sacramento', 4664.E+5, 30, 'CA') on conflict (name) do update set population = excluded.population;
insert into def_test default values;
insert into def_test default values;
insert into def_test default values;
insert into def_test default values;
insert into def_view_test default values;
insert into def_view_test default values;
insert into def_view_test default values;
insert into defaulttest default values;
insert into defaulttest default values;
insert into defaulttest default values; -- succeeds, inserts domain default alter table defaulttest alter column col5 set default null;
insert into dest select array[row(f1,f1)::textandtext] from src;
insert into domdeftest default values;
insert into domdeftest default values;
insert into domdeftest default values;
insert into domnotnull default values;
insert into exists_tbl select x, x/2, x+1 from generate_series(0,10) x;
insert into extremely_skewed   select 42 as id, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'   from generate_series(1, 20000);
insert into fk_notpartitioned_pk (a, b)   select 2048, x from generate_series(1,10) x;
insert into fkest select x, x/10, x/10, x/100 from generate_series(1,1000) x;
insert into fkest select x/10, x%10, x from generate_series(1,1000) x;
insert into fkest1 select x/10, x%10 from generate_series(1,1000) x;
insert into gin_test_tbl select array[1, 2, g] from generate_series(1, 1000) g;
insert into gin_test_tbl select array[1, 2, g] from generate_series(1, 20000) g;
insert into gin_test_tbl select array[1, 3, g] from generate_series(1, 1000) g;
insert into gin_test_tbl select array[1, 3, g] from generate_series(1, 1000) g;
insert into gist_point_tbl (id, p) select g+100000, point(g*10+1, g*10+1) from generate_series(1, 10000) g;
insert into gist_point_tbl (id, p) select g,        point(g*10, g*10) from generate_series(1, 10000) g;
insert into gist_tbl select box(point(0.05*i, 0.05*i), point(0.05*i, 0.05*i)),        point(0.05*i, 0.05*i),        circle(point(0.05*i, 0.05*i), 1.0) from generate_series(0,10000) as i;
insert into gstest4 values (1,1,b'0000','1'), (2,2,b'0001','1'),        (3,4,b'0010','2'), (4,8,b'0011','2'),        (5,16,b'0000','2'), (6,32,b'0001','2'),        (7,64,b'0010','1'), (8,128,b'0011','1');
insert into i8mr_array values (42, array[int8multirange(int8range(1,10)), int8multirange(int8range(2,20))]);
insert into i8r_array values (42, array[int8range(1,10), int8range(2,20)]);
insert into i_table values(1)\; select * from i_table;
insert into i_table values(2)\; select * from i_table\; select 1/0;
insert into i_table values(7)\; commit\; insert into i_table values(8)\; select 1/0;
insert into i_table values(9)\; rollback\; select 2;
insert into idxpart select 2^g, format('two to power of %s', g) from generate_series(15, 17) g;
insert into idxpart select a * 2, b || b from idxpart where a between 2^16 and 2^19;
insert into inserttest (f2[1], f2[2]) select 7,8;
insert into inserttest (f2[1], f2[2]) values (1,2);
insert into inserttest (f2[1], f2[2]) values (1,default);  -- not supported insert into inserttest (f3.if1, f3.if2) values (1,array['foo']);
insert into inserttest (f2[1], f2[2]) values (3,4), (5,6);
insert into inserttest (f3.if1, f3.if2) select 3, '{baz,quux}';
insert into inserttest (f3.if2[1], f3.if2[2]) select 'bear', 'beer';
insert into inserttest (f3.if2[1], f3.if2[2]) values ('foo', 'bar'), ('baz', 'quux');
insert into inserttest (f4[1].if2[1], f4[1].if2[2]) select 'bear', 'beer';
insert into inserttest (f4[1].if2[1], f4[1].if2[2]) values ('foo', 'bar'), ('baz', 'quux');
insert into inserttest (f4[1].if2[1], f4[1].if2[2]) values ('foo', 'bar');
insert into list_part select generate_series(1,4);
insert into list_parted select 'Ff', s.a from generate_series(1, 29) s(a);
insert into list_parted select 'gg', s.a from generate_series(1, 9) s(a);
insert into lprt_a select 0 from generate_series(1,100);
insert into ma_test select x,x from generate_series(0,29) t(x);
insert into onerow default values;
insert into other_partitioned_fk   select 2048, x from generate_series(1,10) x;
insert into parted_conflict values (50, 'cincuenta', 2)   on conflict (a, b) do update set (a, b, c) = row(excluded.*)   where parted_conflict = (50, text 'cincuenta', 1) and         excluded = (50, text 'cincuenta', 2);
insert into patest1   select x, x from generate_series(0,1000) x;
insert into patest2   select x, x from generate_series(0,1000) x;
insert into people select ('Jim', f1, null)::fullname, current_date from pp;
insert into permtest_parent   select 1, 'a', left(md5(i::text), 5) from generate_series(0, 100) i;
insert into prtx1 select 1 + i%30, i, i   from generate_series(1,1000) i;
insert into prtx2 select 1 + i%30, i, i   from generate_series(1,500) i, generate_series(1,10) j;
insert into public.brintest_multi (float8col) values (real 'nan');
insert into reservations values (1, daterange('2018-07-01', '2018-07-07')), (1, daterange('2018-07-07', '2018-07-14')), (1, daterange('2018-07-20', '2018-07-22')), (2, daterange('2018-07-01', '2018-07-03')), (3, NULL), (4, NULL), (4, NULL), (5, NULL), (5, daterange('2018-07-01', '2018-07-03')), (6, daterange('2018-07-01', '2018-07-07')), (6, daterange('2018-07-05', '2018-07-10')), (7, daterange('2018-07-01', '2018-07-07')), (7, daterange('2018-07-07', '2018-07-14')), (8, 'empty'::daterange) ;
insert into rewriteme      select x * 1.001 from generate_series(1, 500) as t(x);
insert into rtest_emp select * from rtest_empmass;
insert into rtest_nothn1 select * from rtest_nothn4;
insert into rtest_nothn2 select * from rtest_nothn4;
insert into rtest_t4 select * from rtest_t9 where a < 20;
insert into rtest_t4 select * from rtest_t9 where b ~ 'and t8';
insert into rtest_t4 select a + 1, b from rtest_t9 where a in (20, 30, 40);
insert into rtest_v1 (a) select a from rtest_t3;
insert into rtest_v1 (b, a) select b, a from rtest_t2;
insert into rtest_v1 select * from rtest_t2;
insert into rtest_v1 select * from rtest_t3;
insert into rtest_v1 select rtest_t2.a, rtest_t3.b     from rtest_t2, rtest_t3     where rtest_t2.a = rtest_t3.a;
insert into rtest_view3 select * from rtest_vview1 where a < 7;
insert into rtest_view3 select * from rtest_vview2 where a != 5 and b !~ '2';
insert into rtest_view3 select * from rtest_vview3;
insert into rtest_view4 select * from rtest_vview4 where 3 > refcount;
insert into rtest_view4 select * from rtest_vview5 where a > 2 and refcount = 0;
insert into shoelace_ok select * from shoelace_arrive;
insert into spgist_box_tbl(b) select box(point(i,j),point(i+s,j+s))   from generate_series(1,100,5) i,        generate_series(1,100,5) j,        generate_series(1,10) s;
insert into spgist_point_tbl (id, p) select g+100000, point(g*10+1, g*10+1) from generate_series(1, 10000) g;
insert into spgist_point_tbl (id, p) select g,      point(g*10, g*10) from generate_series(1, 10000) g;
insert into spgist_point_tbl (id, p) select g, point(g*10, g*10) from generate_series(1, 10) g;
insert into spgist_text_tbl (id, t) select -g, 'f' || repeat('o', 100-g) || 'surprise' from generate_series(1, 100) g;
insert into spgist_text_tbl (id, t) select g, 'f' || repeat('o', 100) || g from generate_series(1, 10000) g union all select g, 'baaaaaaaaaaaaaar' || g from generate_series(1, 1000) g;
insert into src   select string_agg(random()::text,'') from generate_series(1,10000);
insert into stts_t1 select i,i from generate_series(1,100) i;
insert into t select mod(i,10),mod(i,10),i from generate_series(1,10000) s(i);
insert into t(a, b) select (case when i < 5 then i else 9 end), i from generate_series(1, 1000) n(i);
insert into t(a, b) select i / 10, i from generate_series(1, 1000) n(i);
insert into t(a, b) select i, i from generate_series(1, 1000) n(i);
insert into t(a, b) select i/100 + 1, i + 1 from generate_series(0, 999) n(i);
insert into t(a, b) select i/50 + 1, i + 1 from generate_series(0, 999) n(i);
insert into t1 select * from generate_series(5,19,1) g;
insert into t_gin_test_tbl select array[1, g, g/10], array[2, g, g/10]   from generate_series(1, 20000) g;
insert into test_jsonb_subscript values (1, '{}'), -- empty jsonb (2, '{"key": "value"}'); -- jsonb with data update test_jsonb_subscript set test_json['a'] = '1' where id = 1;
insert into test_mode select 1 from generate_series(1,1000) union all select 2;
insert into test_multirange_gist select '{}'::int4multirange from generate_series(1,500) g;
insert into test_multirange_gist select int4multirange(int4range(NULL, g*10, '(]'), int4range(g*10, g*20, '(]')) from generate_series(1,100) g;
insert into test_multirange_gist select int4multirange(int4range(g*10, g*20, '(]'), int4range(g*20, NULL, '(]')) from generate_series(1,100) g;
insert into test_multirange_gist select int4multirange(int4range(g, g+10),int4range(g+20, g+30),int4range(g+40, g+50)) from generate_series(1,2000) g;
insert into test_multirange_gist select int4multirange(int4range(g, g+10000)) from generate_series(1,1000) g;
insert into test_range_elem select i from generate_series(1,100) i;
insert into test_range_excl   values(int4range(123, 123, '[]'), int4range(1, 1, '[]'), '[2010-01-02 10:00, 2010-01-02 11:00)');
insert into test_range_excl   values(int4range(123, 123, '[]'), int4range(2, 2, '[]'), '[2010-01-02 11:00, 2010-01-02 12:00)');
insert into test_range_excl   values(int4range(123, 123, '[]'), int4range(3, 3, '[]'), '[2010-01-02 10:10, 2010-01-02 11:00)');
insert into test_range_excl   values(int4range(124, 124, '[]'), int4range(3, 3, '[]'), '[2010-01-02 10:10, 2010-01-02 11:10)');
insert into test_range_excl   values(int4range(125, 125, '[]'), int4range(1, 1, '[]'), '[2010-01-02 10:10, 2010-01-02 11:00)');
insert into test_range_gist select 'empty'::int4range from generate_series(1,500) g;
insert into test_range_gist select 'empty'::int4range from generate_series(1,500) g;
insert into test_range_gist select int4range(NULL,g*10,'(]') from generate_series(1,100) g;
insert into test_range_gist select int4range(g*10,NULL,'(]') from generate_series(1,100) g;
insert into test_range_gist select int4range(g, g+10) from generate_series(1,2000) g;
insert into test_range_gist select int4range(g, g+10) from generate_series(1,2000) g;
insert into test_range_gist select int4range(g, g+10000) from generate_series(1,1000) g;
insert into test_range_spgist select 'empty'::int4range from generate_series(1,500) g;
insert into test_range_spgist select 'empty'::int4range from generate_series(1,500) g;
insert into test_range_spgist select int4range(NULL,g*10,'(]') from generate_series(1,100) g;
insert into test_range_spgist select int4range(g*10,NULL,'(]') from generate_series(1,100) g;
insert into test_range_spgist select int4range(g, g+10) from generate_series(1,2000) g;
insert into test_range_spgist select int4range(g, g+10) from generate_series(1,2000) g;
insert into test_range_spgist select int4range(g, g+10000) from generate_series(1,1000) g;
insert into test_table select 'a', null from generate_series(1,1000);
insert into trigtest default values;
insert into trigtest default values;
insert into trigtest default values;
insert into trigtest default values;
insert into trigtest default values;
insert into trigtest default values;  -- does not trigger alter table trigtest enable always trigger trigtest_a_stmt_tg;
insert into trigtest default values;  -- now it does reset session_replication_role;
insert into tt3 select x, repeat('xyzzy', 100) from generate_series(1,10000) x;
link	char(4);
link	char(4);
link := mytype || substr(blname, 1, 2);
link := mytype || substr(blname, 1, 2);
listen a;
lock table pxtest3 in access share mode nowait;
lock table pxtest3 in access share mode nowait;
lock twophase_tab in access exclusive mode;
m k \. COMMIT;
move 3 from cur;
move backward all in c;
move forward all in c1;
mytype	char(2);
mytype	char(2);
mytype	char(2);
new.slotname := sname;
nkeys := array_length(fk.fkcols, 1);
nkeys integer;
notify a;
p g \. BEGIN;
prepare transaction 'twophase_func';
prepare transaction 'twophase_func';
prepare transaction 'twophase_operator';
prepare transaction 'twophase_sequence';
prepare transaction 'twophase_tab';
prepare transaction 'twophase_tab';
prepare transaction 'twophase_tab';
prepare transaction 'twophase_tab';
prepare transaction 'twophase_type';
prepare transaction 'twophase_view';
ps          alias for new;
raise exception ''illegal backlink beginning with %'', mytype;
raise exception ''illegal slotlink beginning with %'', mytype;
raise exception ''no manual manipulation of HSlot'';
rec		record;
rec		record;
rec		record;
rec		record;
refresh materialized view concurrently parallel_mat_view;
refresh materialized view mvtest_error;  -- fail here drop materialized view mvtest_error;
refresh materialized view parallel_mat_view;
reindex index gist_pointidx;
reindex index spgist_point_idx;
return 0;
return 0;
return 0;
return 0;
return 0;
return 0;
return 0;
return 0;
return 0;
return 0;
return 0;
return 0;
return 0;
return 0;
return 0;
return 0;
return 0;
return 0;
return NEW;
return NULL;
return new;
return new;
return new;
return new;
return new;
return new;
return new;
return new;
return new;
return new;
return new;
return new;
return new;
return new;
return new;
return new;
return new;
return new;
return new;
return null;
return null;
return null;
return null;
return null;
return null;
return old;
return old;
return old;
return old;
return old;
return ps;
return psrec.slotlink;
return rec.backlink;
return rec.slotlink;
return retval || pslot_backlink_view(psrec.slotlink);
return retval || wslot_slotlink_view(rec.slotname);
return retval;
return retval;
return retval;
return retval;
return true;
return x;
retval	text;
retval	text;
retval	text;
retval := ''Phone '' || trim(rec.slotname);
retval := ''Phone line '' || trim(rec.phonenumber);
retval := retval || '' -> '';
retval := retval || '' slot '';
retval := retval || '')'';
retval := retval || '')'';
retval := retval || '')'';
retval := retval || ifrow.ifname;
retval := retval || rec.comment;
retval := retval || rec.comment;
retval := retval || slotno::text from HSlot 			where slotname = psrec.slotlink;
retval := retval || syrow.comment;
retval := retval || trim(rec.roomno);
retval := syrow.name || '' IF '';
retval := trim(rec.slotname) || '' in room '';
select   query,   js->0->'Plan'->'Plans'->0->'Actual Rows' as "return by index",   js->0->'Plan'->'Rows Removed by Index Recheck' as "removed by recheck",   (res_index = res_heap) as "match" from   (values     ($$ i @> '{}' $$),     ($$ j @> '{}' $$),     ($$ i @> '{}' and j @> '{}' $$),     ($$ i @> '{1}' $$),     ($$ i @> '{1}' and j @> '{}' $$),     ($$ i @> '{1}' and i @> '{}' and j @> '{}' $$),     ($$ j @> '{10}' $$),     ($$ j @> '{10}' and i @> '{}' $$),     ($$ j @> '{10}' and j @> '{}' and i @> '{}' $$),     ($$ i @> '{1}' and j @> '{10}' $$)   ) q(query),   lateral explain_query_json($$select * from t_gin_test_tbl where $$ || query) js,   lateral execute_text_query_index($$select string_agg((i, j)::text, ' ') from t_gin_test_tbl where $$ || query) res_index,   lateral execute_text_query_heap($$select string_agg((i, j)::text, ' ') from t_gin_test_tbl where $$ || query) res_heap;
select '"\b\f\r\n\t\v\"\''\\"'::jsonpath;
select '[2010-01-01 01:00:00 -05, 2010-01-01 02:00:00 -08)'::tstzrange;
select '[2010-01-01 01:00:00 -08, 2010-01-01 02:00:00 -05)'::tstzrange;
select 'empty'::int4range::int4multirange;
select 'empty'::numrange << nummultirange();
select 'empty'::numrange >> nummultirange();
select '{(10,20),(30,40),(50,60)}'::nummultirange && '(42,92)'::numrange;
select '{(10,20),(30,40),(50,60)}'::nummultirange @> '(52,56)'::numrange;
select '{nan, 1, nan}'::line = '{nan, 1, nan}'::line as true, 	   '{nan, 1, nan}'::line = '{nan, 2, nan}'::line as false;
select (d1).r, (d1).i, (d1).* from dcomptable;
select (dfunc('Hello World', 20, '2009-07-25'::date)).*;
select (dfunc()).*;
select (dfunc(10,20,30)).*;
select (dfunc(a := 10, b := 20, c := 30)).*;
select (select (a.*)::text) from view_a a;
select (w).size = :segsize as ok from (select pg_ls_waldir() w) ss where length((w).name) = 24 limit 1;
select * from array_to_set(array['one', 'two']) as t(f1 point,f2 text);
select * from array_to_set(array['one', 'two']) as t(f1 point,f2 text);
select * from duplic(int4range(42,49));
select * from hash_join_batches($$   select count(*) from simple r join extremely_skewed s using (id); $$);
select * from hash_join_batches($$   select count(*) from simple r join extremely_skewed s using (id); $$);
select * from hash_join_batches($$   select count(*) from simple r join extremely_skewed s using (id); $$);
select * from hash_join_batches($$   select count(*) from simple r join simple s using (id); $$);
select * from inoutparam_succeed(int4range(1,2));
select * from int8_tbl i where i.* in (values(i.*::int8_tbl));
select * from int8_tbl i, lateral(values(i.*::int8_tbl)) ss;
select * from int8_tbl limit (case when random() < 0.5 then null::bigint end);
select * from int8_tbl offset (case when random() < 0.5 then null::bigint end);
select * from json_to_record('{"out": "{\"key\": 1}"}') as x(out json);
select * from json_to_record('{"out": "{\"key\": 1}"}') as x(out jsonb);
select * from json_to_record('{"out": [{"key": 1}]}') as x(out json);
select * from json_to_record('{"out": [{"key": 1}]}') as x(out jsonb);
select * from json_to_record('{"out": {"key": 1}}') as x(out json);
select * from json_to_record('{"out": {"key": 1}}') as x(out jsonb);
select * from jsonb_to_record('{"out": "{\"key\": 1}"}') as x(out json);
select * from jsonb_to_record('{"out": "{\"key\": 1}"}') as x(out jsonb);
select * from jsonb_to_record('{"out": [{"key": 1}]}') as x(out json);
select * from jsonb_to_record('{"out": [{"key": 1}]}') as x(out jsonb);
select * from jsonb_to_record('{"out": {"key": 1}}') as x(out json);
select * from jsonb_to_record('{"out": {"key": 1}}') as x(out jsonb);
select * from mr_inoutparam_succeed(int4multirange(int4range(1,2)));
select * from mr_outparam_succeed(int4multirange(int4range(1,2)));
select * from mr_outparam_succeed2(int4multirange(int4range(1,2)));
select * from mr_outparam_succeed3(int4multirange(int4range(1,2)));
select * from mr_outparam_succeed4(int4range(1,2));
select * from mr_table_succeed(123, int4multirange(int4range(1,11)));
select * from nummultirange_test2 where nmr = nummultirange(numrange(1.1, 2.2));
select * from nummultirange_test2 where nmr = nummultirange(numrange(1.1, 2.3));
select * from numrange_test where nr < numrange(-1000.0, -1000.0,'[]');
select * from numrange_test where nr < numrange(0.0, 1.0,'[]');
select * from numrange_test where nr < numrange(1000.0, 1001.0,'[]');
select * from numrange_test where nr > numrange(-1001.0, -1000.0,'[]');
select * from numrange_test where nr > numrange(0.0, 1.0,'[]');
select * from numrange_test where nr > numrange(1000.0, 1000.0,'[]');
select * from numrange_test2 where nr = 'empty'::numrange;
select * from numrange_test2 where nr = numrange(1.1, 2.2);
select * from numrange_test2 where nr = numrange(1.1, 2.3);
select * from outparam2_succeed(int4range(1,11));
select * from outparam_succeed(int4range(1,2));
select * from outparam_succeed2(int4range(int4range(1,2)));
select * from pendtest where 'ipi:*'::tsquery @@ ts;
select * from pendtest where 'ips:*'::tsquery @@ ts;
select * from pendtest where 'ipsa:*'::tsquery @@ ts;
select * from pendtest where 'ipsu:*'::tsquery @@ ts;
select * from pendtest where 'ipt:*'::tsquery @@ ts;
select * from rows from(getrngfunc1(1),getrngfunc2(1),getrngfunc3(1),getrngfunc4(1),getrngfunc5(1),                     getrngfunc6(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text),                     getrngfunc7(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text),                     getrngfunc8(1),getrngfunc9(1))               with ordinality as t1(a,b,c,d,e,f,g,h,i,j,k,l,m,o,p,q,r,s,t,u);
select * from rows from(getrngfunc9(1),getrngfunc8(1),                     getrngfunc7(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text),                     getrngfunc6(1) AS (rngfuncid int, rngfuncsubid int, rngfuncname text),                     getrngfunc5(1),getrngfunc4(1),getrngfunc3(1),getrngfunc2(1),getrngfunc1(1))               with ordinality as t1(a,b,c,d,e,f,g,h,i,j,k,l,m,o,p,q,r,s,t,u);
select * from rows from(rngfunct(1),rngfunct(2)) with ordinality as z(a,b,c,d,ord);
select * from rows from(unnest(array[10,20],array['foo','bar']), generate_series(101,102)) with ordinality as z(a,b,c,ord);
select * from rows from(unnest(array[10,20],array['foo','bar'],array[1.0])) with ordinality as z(a,b,c,ord);
select * from table_succeed(int4range(1,11));
select * from test_jsonb_subscript where test_json['key'] = '"value"';
select * from test_jsonb_subscript where test_json['key'] = '"wrong_value"';
select * from test_jsonb_subscript where test_json['key_doesnt_exists'] = '"value"';
select 0\; copy test3 from stdin\; copy test3 from stdin\; select 1; -- 1 1 \. 2 \. select * from test3;
select 1\; begin\; insert into i_table values(6);
select ARRAY[nummultirange(numrange(1.1, 1.2)), nummultirange(numrange(12.3, 155.5))];
select ARRAY[numrange(1.1, 1.2), numrange(12.3, 155.5)];
select ROW('ABC','DEF') ~<=~ ROW('DEF','ABC') as true;
select ROW('ABC','DEF') ~>=~ ROW('DEF','ABC') as false;
select ROW(1,2) < ROW(1,1) as false;
select ROW(1,2) < ROW(1,3) as true;
select ROW(1,2) < ROW(1,NULL) as null;
select ROW(1,2,3) < ROW(1,3,NULL) as true; -- the NULL is not examined select ROW(11,'ABC') < ROW(11,'DEF') as true;
select ROW(1,2,3) < ROW(1,NULL,4) as null;
select ROW(1,2,3) <> ROW(1,NULL,4) as true;
select ROW(1,2,3) = ROW(1,NULL,4) as false;
select ROW(11,'ABC') > ROW(11,'DEF') as false;
select ROW(12,'ABC') > ROW(11,'DEF') as true;
select a, b, c from (values (1, 2, 3), (4, null, 6), (7, 8, 9)) as t (a, b, c) group by all rollup(a, b), rollup(a, c) order by a, b, c;
select a, b, c from (values (1, 2, 3), (4, null, 6), (7, 8, 9)) as t (a, b, c) group by distinct rollup(a, b), rollup(a, c) order by a, b, c;
select anyarray_anymultirange_func(ARRAY[1,2], int4multirange(int4range(10,20)));
select anyarray_anymultirange_func(ARRAY[1,2], nummultirange(numrange(10,20)));
select anyarray_anyrange_func(ARRAY[1,2], int4range(10,20));
select anyarray_anyrange_func(ARRAY[1,2], numrange(10,20));
select anycompatiblearray_anycompatiblemultirange_func(ARRAY[1,2], multirange(int4range(10,20)));
select anycompatiblearray_anycompatiblemultirange_func(ARRAY[1,2], multirange(numrange(10,20)));
select anycompatiblearray_anycompatiblemultirange_func(ARRAY[1.1,2], multirange(int4range(10,20)));
select anycompatiblearray_anycompatiblerange_func(ARRAY[1,2], int4range(10,20));
select anycompatiblearray_anycompatiblerange_func(ARRAY[1,2], numrange(10,20));
select anycompatiblearray_anycompatiblerange_func(ARRAY[1.1,2], int4range(10,20));
select anycompatiblerange_anycompatiblemultirange_func(int4range(1,2), multirange(int4range(10,20)));
select anycompatiblerange_anycompatiblemultirange_func(numrange(1,2), multirange(int4range(10,20)));
select array(select row(v.a,s1.*) from (select two,four, count(*) from onek group by cube(two,four) order by two,four) s1) from (values (1),(2)) v(a);
select array(select row(v.a,s1.*) from (select two,four, count(*) from onek group by cube(two,four) order by two,four) s1) from (values (1),(2)) v(a);
select array(select row(v.a,s1.*) from (select two,four, count(*) from onek group by grouping sets(two,four) order by two,four) s1) from (values (1),(2)) v(a);
select conname, obj_description(oid, 'pg_constraint') as desc   from pg_constraint where conname like 'at_partitioned%'   order by conname;
select conname, obj_description(oid, 'pg_constraint') as desc   from pg_constraint where conname like 'at_partitioned%'   order by conname;
select count(*)   from (values (point(5,5)),(point(8,8)),(point(12,12))) v(p)  where exists(select * from spgist_box_tbl b where b.b && box(v.p,v.p));
select count(*) from test_multirange_gist where mr && 'empty'::int4range;
select count(*) from test_multirange_gist where mr && 'empty'::int4range;
select count(*) from test_multirange_gist where mr && int4range(10,20);
select count(*) from test_multirange_gist where mr && int4range(10,20);
select count(*) from test_multirange_gist where mr &< 'empty'::int4range;
select count(*) from test_multirange_gist where mr &< 'empty'::int4range;
select count(*) from test_multirange_gist where mr &< '{}'::int4multirange;
select count(*) from test_multirange_gist where mr &< '{}'::int4multirange;
select count(*) from test_multirange_gist where mr &< int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_multirange_gist where mr &< int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_multirange_gist where mr &< int4range(100,500);
select count(*) from test_multirange_gist where mr &< int4range(100,500);
select count(*) from test_multirange_gist where mr &> 'empty'::int4range;
select count(*) from test_multirange_gist where mr &> 'empty'::int4range;
select count(*) from test_multirange_gist where mr &> '{}'::int4multirange;
select count(*) from test_multirange_gist where mr &> '{}'::int4multirange;
select count(*) from test_multirange_gist where mr &> int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_multirange_gist where mr &> int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_multirange_gist where mr &> int4range(100,500);
select count(*) from test_multirange_gist where mr &> int4range(100,500);
select count(*) from test_multirange_gist where mr -|- 'empty'::int4range;
select count(*) from test_multirange_gist where mr -|- 'empty'::int4range;
select count(*) from test_multirange_gist where mr -|- int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_multirange_gist where mr -|- int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_multirange_gist where mr -|- int4range(100,500);
select count(*) from test_multirange_gist where mr -|- int4range(100,500);
select count(*) from test_multirange_gist where mr << 'empty'::int4range;
select count(*) from test_multirange_gist where mr << 'empty'::int4range;
select count(*) from test_multirange_gist where mr << '{}'::int4multirange;
select count(*) from test_multirange_gist where mr << '{}'::int4multirange;
select count(*) from test_multirange_gist where mr << int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_multirange_gist where mr << int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_multirange_gist where mr << int4range(100,500);
select count(*) from test_multirange_gist where mr << int4range(100,500);
select count(*) from test_multirange_gist where mr <@ 'empty'::int4range;
select count(*) from test_multirange_gist where mr <@ 'empty'::int4range;
select count(*) from test_multirange_gist where mr = int4multirange(int4range(10,20), int4range(30,40), int4range(50,60));
select count(*) from test_multirange_gist where mr = int4multirange(int4range(10,20), int4range(30,40), int4range(50,60));
select count(*) from test_multirange_gist where mr >> 'empty'::int4range;
select count(*) from test_multirange_gist where mr >> 'empty'::int4range;
select count(*) from test_multirange_gist where mr >> '{}'::int4multirange;
select count(*) from test_multirange_gist where mr >> '{}'::int4multirange;
select count(*) from test_multirange_gist where mr >> int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_multirange_gist where mr >> int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_multirange_gist where mr >> int4range(100,500);
select count(*) from test_multirange_gist where mr >> int4range(100,500);
select count(*) from test_multirange_gist where mr @> 'empty'::int4range;
select count(*) from test_multirange_gist where mr @> 'empty'::int4range;
select count(*) from test_multirange_gist where mr @> 'empty'::int4range;
select count(*) from test_multirange_gist where mr @> int4multirange(int4range(10,20), int4range(30,40));
select count(*) from test_multirange_gist where mr @> int4multirange(int4range(10,20), int4range(30,40));
select count(*) from test_range_elem where int4range(i,i+10) <@ int4range(10,30);
select count(*) from test_range_gist where ir && int4range(10,20);
select count(*) from test_range_gist where ir && int4range(10,20);
select count(*) from test_range_gist where ir && int4range(10,20);
select count(*) from test_range_gist where ir &< int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_range_gist where ir &< int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_range_gist where ir &< int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_range_gist where ir &< int4range(100,500);
select count(*) from test_range_gist where ir &< int4range(100,500);
select count(*) from test_range_gist where ir &< int4range(100,500);
select count(*) from test_range_gist where ir &> int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_range_gist where ir &> int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_range_gist where ir &> int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_range_gist where ir &> int4range(100,500);
select count(*) from test_range_gist where ir &> int4range(100,500);
select count(*) from test_range_gist where ir &> int4range(100,500);
select count(*) from test_range_gist where ir -|- int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_range_gist where ir -|- int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_range_gist where ir -|- int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_range_gist where ir -|- int4range(100,500);
select count(*) from test_range_gist where ir -|- int4range(100,500);
select count(*) from test_range_gist where ir -|- int4range(100,500);
select count(*) from test_range_gist where ir << int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_range_gist where ir << int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_range_gist where ir << int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_range_gist where ir << int4range(100,500);
select count(*) from test_range_gist where ir << int4range(100,500);
select count(*) from test_range_gist where ir << int4range(100,500);
select count(*) from test_range_gist where ir = int4range(10,20);
select count(*) from test_range_gist where ir = int4range(10,20);
select count(*) from test_range_gist where ir = int4range(10,20);
select count(*) from test_range_gist where ir >> int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_range_gist where ir >> int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_range_gist where ir >> int4multirange(int4range(100,200), int4range(400,500));
select count(*) from test_range_gist where ir >> int4range(100,500);
select count(*) from test_range_gist where ir >> int4range(100,500);
select count(*) from test_range_gist where ir >> int4range(100,500);
select count(*) from test_range_gist where ir @> 'empty'::int4range;
select count(*) from test_range_gist where ir @> 'empty'::int4range;
select count(*) from test_range_gist where ir @> 'empty'::int4range;
select count(*) from test_range_gist where ir @> int4multirange(int4range(10,20), int4range(30,40));
select count(*) from test_range_gist where ir @> int4multirange(int4range(10,20), int4range(30,40));
select count(*) from test_range_gist where ir @> int4multirange(int4range(10,20), int4range(30,40));
select count(*) from test_range_spgist where ir && int4range(10,20);
select count(*) from test_range_spgist where ir && int4range(10,20);
select count(*) from test_range_spgist where ir && int4range(10,20);
select count(*) from test_range_spgist where ir &< int4range(100,500);
select count(*) from test_range_spgist where ir &< int4range(100,500);
select count(*) from test_range_spgist where ir &< int4range(100,500);
select count(*) from test_range_spgist where ir &> int4range(100,500);
select count(*) from test_range_spgist where ir &> int4range(100,500);
select count(*) from test_range_spgist where ir &> int4range(100,500);
select count(*) from test_range_spgist where ir -|- int4range(100,500);
select count(*) from test_range_spgist where ir -|- int4range(100,500);
select count(*) from test_range_spgist where ir -|- int4range(100,500);
select count(*) from test_range_spgist where ir << int4range(100,500);
select count(*) from test_range_spgist where ir << int4range(100,500);
select count(*) from test_range_spgist where ir << int4range(100,500);
select count(*) from test_range_spgist where ir = int4range(10,20);
select count(*) from test_range_spgist where ir = int4range(10,20);
select count(*) from test_range_spgist where ir = int4range(10,20);
select count(*) from test_range_spgist where ir >> int4range(100,500);
select count(*) from test_range_spgist where ir >> int4range(100,500);
select count(*) from test_range_spgist where ir >> int4range(100,500);
select count(*) from test_range_spgist where ir @> 'empty'::int4range;
select count(*) from test_range_spgist where ir @> 'empty'::int4range;
select count(*) from test_range_spgist where ir @> 'empty'::int4range;
select d1[2], d1[1].r, d1[1].i from dcomptable;
select description, (test_conv(inbytes, 'utf8', 'utf8')).* from utf8_inputs;
select description, inbytes, (test_conv(inbytes, 'big5', 'big5')).* from big5_inputs;
select description, inbytes, (test_conv(inbytes, 'big5', 'mule_internal')).* from big5_inputs;
select description, inbytes, (test_conv(inbytes, 'big5', 'utf8')).* from big5_inputs;
select description, inbytes, (test_conv(inbytes, 'euc_jis_2004', 'euc_jis_2004')).* from euc_jis_2004_inputs;
select description, inbytes, (test_conv(inbytes, 'euc_jis_2004', 'utf8')).* from euc_jis_2004_inputs;
select description, inbytes, (test_conv(inbytes, 'gb18030', 'gb18030')).* from gb18030_inputs;
select description, inbytes, (test_conv(inbytes, 'gb18030', 'utf8')).* from gb18030_inputs;
select description, inbytes, (test_conv(inbytes, 'iso8859-5', 'iso8859-5')).* from iso8859_5_inputs;
select description, inbytes, (test_conv(inbytes, 'iso8859-5', 'koi8r')).* from iso8859_5_inputs;
select description, inbytes, (test_conv(inbytes, 'iso8859-5', 'utf8')).* from iso8859_5_inputs;
select description, inbytes, (test_conv(inbytes, 'iso8859_5', 'mule_internal')).* from iso8859_5_inputs;
select description, inbytes, (test_conv(inbytes, 'mule_internal', 'big5')).* from mic_inputs;
select description, inbytes, (test_conv(inbytes, 'mule_internal', 'euc_jp')).* from mic_inputs;
select description, inbytes, (test_conv(inbytes, 'mule_internal', 'iso8859-5')).* from mic_inputs;
select description, inbytes, (test_conv(inbytes, 'mule_internal', 'koi8r')).* from mic_inputs;
select description, inbytes, (test_conv(inbytes, 'mule_internal', 'mule_internal')).* from mic_inputs;
select description, inbytes, (test_conv(inbytes, 'mule_internal', 'sjis')).* from mic_inputs;
select description, inbytes, (test_conv(inbytes, 'shiftjis2004', 'euc_jis_2004')).* from shiftjis2004_inputs;
select description, inbytes, (test_conv(inbytes, 'shiftjis2004', 'shiftjis2004')).* from shiftjis2004_inputs;
select description, inbytes, (test_conv(inbytes, 'shiftjis2004', 'utf8')).* from shiftjis2004_inputs;
select description, inbytes, (test_conv(inbytes, 'utf8', 'euc_jis_2004')).* from utf8_inputs;
select description, inbytes, (test_conv(inbytes, 'utf8', 'gb18030')).* from utf8_inputs;
select description, inbytes, (test_conv(inbytes, 'utf8', 'koi8r')).* from utf8_inputs;
select description, inbytes, (test_conv(inbytes, 'utf8', 'latin1')).* from utf8_inputs;
select description, inbytes, (test_conv(inbytes, 'utf8', 'latin2')).* from utf8_inputs;
select description, inbytes, (test_conv(inbytes, 'utf8', 'latin5')).* from utf8_inputs;
select dfunc(a => 'a'::text, b => 'b');
select dfunc(a => 'a'::text, b => 'b', flag => false); -- named notation select dfunc(b => 'b'::text, a => 'a'); -- named notation with default select dfunc(a => 'a'::text, flag => true); -- named notation with default select dfunc(a => 'a'::text, flag => false); -- named notation with default select dfunc(b => 'b'::text, a => 'a', flag => true); -- named notation select dfunc('a'::text, 'b', false); -- full positional notation select dfunc('a'::text, 'b', flag => false); -- mixed notation select dfunc('a'::text, 'b', true); -- full positional notation select dfunc('a'::text, 'b', flag => true); -- mixed notation select dfunc(a =>-1);
select dfunc(a =>+1);
select dfunc(a =>--comment to be removed by psql   1);
select dfunc(a =>/**/1);
select distinct from pg_database;
select div(-9999999999999999999999::numeric,1000000000000000000000)*1000000000000000000000 + mod(-9999999999999999999999::numeric,1000000000000000000000);
select f1(2, 4) as int, f1(2, 4.5) as num;
select f1(42) as int, f1(4.5) as num;
select f1(42) as int, f1(4.5) as num;
select f1(array[2,4]) as int, f1(array[4.5, 7.7]) as num;
select f1(array[2,4]) as int, f1(array[4.5, 7.7]) as num;
select f1(int4range(42, 49)) as int, f1(float8range(4.5, 7.8)) as num;
select f1(int4range(42, 49), 11, 2::smallint) as int, f1(float8range(4.5, 7.8), 7.8, 11::real) as num;
select f1(int4range(42, 49), 11, 4.5) as fail;  -- range type doesn't fit drop function f1(x anycompatiblerange, y anycompatible, z anycompatible);
select f1(int4range(42, 49), array[11]) as int, f1(float8range(4.5, 7.8), array[7]) as num;
select f1(point(3,4));  -- fail for lack of + operator drop function f1(x anyelement);
select f1, f1[1], (f1[2])[1] from dposintatable;
select final > 1 as multibatch   from hash_join_batches($$   select count(*) from join_foo     left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss     on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1; $$);
select final > 1 as multibatch   from hash_join_batches($$   select count(*) from join_foo     left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss     on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1; $$);
select final > 1 as multibatch   from hash_join_batches($$   select count(*) from join_foo     left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss     on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1; $$);
select final > 1 as multibatch   from hash_join_batches($$   select count(*) from join_foo     left join (select b1.id, b1.t from join_bar b1 join join_bar b2 using (id)) ss     on join_foo.id < ss.id + 1 and join_foo.id > ss.id - 1; $$);
select final > 1 as multibatch   from hash_join_batches($$   select length(max(s.t))   from wide left join (select id, coalesce(t, '') || '' as t from wide) s using (id); $$);
select format('create index on gexec_test(%I)', attname) from pg_attribute where attrelid = 'gexec_test'::regclass and attnum > 0 order by attnum \gexec \set FETCH_COUNT 1 select 'select 1 as ones', 'select x.y, x.y*2 as double from generate_series(1,4) as x(y)' union all select 'drop table gexec_test', NULL union all select 'drop table gexec_test', 'select ''2000-01-01''::date as party_over' \gexec \unset FETCH_COUNT \pset prepare q as select array_to_string(array_agg(repeat('x',2*n)),E'\n') as "ab c", array_to_string(array_agg(repeat('y',20-2*n)),E'\n') as "a bc" from generate_series(1,10) as n(n) group by n>1 order by n>1;
select ir from test_range_spgist where ir -|- int4range(10,20) order by ir;
select jsonb_path_exists('[{"a": 1}, {"a": 2}, 3]', 'lax $[*].a', silent => false);
select jsonb_path_exists('[{"a": 1}, {"a": 2}, 3]', 'lax $[*].a', silent => true);
select jsonb_path_exists('[{"a": 1}, {"a": 2}, 3]', 'strict $[*].a', silent => false);
select jsonb_path_exists('[{"a": 1}, {"a": 2}, 3]', 'strict $[*].a', silent => true);
select jsonb_path_match('[{"a": 1}, {"a": 2}, 3]', 'lax exists($[*].a)', silent => false);
select jsonb_path_match('[{"a": 1}, {"a": 2}, 3]', 'lax exists($[*].a)', silent => true);
select jsonb_path_match('[{"a": 1}, {"a": 2}, 3]', 'strict exists($[*].a)', silent => false);
select jsonb_path_match('[{"a": 1}, {"a": 2}, 3]', 'strict exists($[*].a)', silent => true);
select jsonb_path_query('"-inf"', '$.double()', silent => true);
select jsonb_path_query('"1.2"', '$.ceiling()', silent => true);
select jsonb_path_query('"a"', '-$', silent => true);
select jsonb_path_query('"inf"', '$.double()', silent => true);
select jsonb_path_query('1', '$ + "2"', silent => true);
select jsonb_path_query('1', 'strict $.*', silent => true);
select jsonb_path_query('1', 'strict $.a', silent => true);
select jsonb_path_query('1', 'strict $[*]', silent => true);
select jsonb_path_query('1', 'strict $[1]', silent => true);
select jsonb_path_query('[1, 2]', '3 * $', silent => true);
select jsonb_path_query('[1,"2",3]', '+$', silent => true);
select jsonb_path_query('[1,2,3]', '$[last ? (@.type() == "string")]', silent => true);
select jsonb_path_query('[1,2,3]', 'strict $[*].a', silent => true);
select jsonb_path_query('[1,null,true,"11",[],[1],[1,2,3],{},{"a":1,"b":2}]', 'strict $[*].size()', silent => true);
select jsonb_path_query('[1]', 'strict $[1]', silent => true);
select jsonb_path_query('[]', 'strict $.a', silent => true);
select jsonb_path_query('[]', 'strict $.double()', silent => true);
select jsonb_path_query('[]', 'strict $["a"]', silent => true);
select jsonb_path_query('[]', 'strict $[1]', silent => true);
select jsonb_path_query('[]', 'strict $[last]', silent => true);
select jsonb_path_query('[{},1]', '$[*].keyvalue()', silent => true);
select jsonb_path_query('null', '$.double()', silent => true);
select jsonb_path_query('true', '$.double()', silent => true);
select jsonb_path_query('true', '$.floor()', silent => true);
select jsonb_path_query('{"a": [1, 2]}', 'lax $.a * 3', silent => true);
select jsonb_path_query('{}', '$.abs()', silent => true);
select jsonb_path_query('{}', '$.double()', silent => true);
select jsonb_path_query('{}', 'strict $.a', silent => true);
select jsonb_set_lax('{"a":1,"b":2}', '{b}', null, null_value_treatment => 'delete_key') as delete_key;
select jsonb_set_lax('{"a":1,"b":2}', '{b}', null, null_value_treatment => 'raise_exception') as raise_exception;
select jsonb_set_lax('{"a":1,"b":2}', '{b}', null, null_value_treatment => 'return_target') as return_target;
select jsonb_set_lax('{"a":1,"b":2}', '{b}', null, null_value_treatment => 'use_json_null') as use_json_null;
select length(md5((f1[1]).c2)) from dest;
select length(md5((f1[1]).c2)) from dest;
select length(md5((f1[1]).c2)) from dest;
select md5(''::bytea) = 'd41d8cd98f00b204e9800998ecf8427e' AS "TRUE";
select md5('12345678901234567890123456789012345678901234567890123456789012345678901234567890'::bytea) = '57edf4a22be3c955ac49da2e2107b67a' AS "TRUE";
select md5('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'::bytea) = 'd174ab98d277d9f5a5611c2c9f419d9f' AS "TRUE";
select md5('a'::bytea) = '0cc175b9c0f1b6a831c399e269772661' AS "TRUE";
select md5('abc'::bytea) = '900150983cd24fb0d6963f7d28e17f72' AS "TRUE";
select md5('abcdefghijklmnopqrstuvwxyz'::bytea) = 'c3fcd3d76192e4007dfb496cca67e13b' AS "TRUE";
select md5('message digest'::bytea) = 'f96b697d7cb7938d525a2f31aaf161d0' AS "TRUE";
select min_scale(numeric 'NaN') is NULL; -- should be true select min_scale(numeric 'inf') is NULL; -- should be true select min_scale(0);                     -- no digits select min_scale(0.00);                  -- no digits again select min_scale(1.0);                   -- no scale select min_scale(1.1);                   -- scale 1 select min_scale(1.12);                  -- scale 2 select min_scale(1.123);                 -- scale 3 select min_scale(1.1234);                -- scale 4, filled digit select min_scale(1.12345);               -- scale 5, 2 NDIGITS select min_scale(1.1000);                -- 1 pos in NDIGITS select min_scale(1e100);                 -- very big number select trim_scale(numeric 'NaN');
select mr_polymorphic(int4range(1, 4));
select multirangetypes_sql(int4multirange(int4range(1,10)), ARRAY[2,20]);
select multirangetypes_sql(nummultirange(numrange(1,10)), ARRAY[2,20]);  -- match failure create function anycompatiblearray_anycompatiblemultirange_func(a anycompatiblearray, mr anycompatiblemultirange)   returns anycompatible as 'select $1[1] + lower($2);' language sql;
select nummultirange() << 'empty'::numrange;
select nummultirange() << nummultirange();
select nummultirange() << nummultirange(numrange(1,2));
select nummultirange() << numrange(1,2);
select nummultirange() >> 'empty'::numrange;
select nummultirange() >> nummultirange();
select nummultirange() >> nummultirange(numrange(1,2));
select nummultirange() >> numrange(1,2);
select nummultirange(numrange(-4,-2), numrange(0,2)) << numrange(3,6);
select nummultirange(numrange(0,2)) << numrange(3,6);
select nummultirange(numrange(0,2), numrange(7,8)) << numrange(3,6);
select nummultirange(numrange(0,4)) >> numrange(1,2);
select nummultirange(numrange(0,4), numrange(7,8)) >> numrange(1,2);
select nummultirange(numrange(1,2)) << nummultirange();
select nummultirange(numrange(1,2)) << nummultirange(numrange(1,2));
select nummultirange(numrange(1,2)) << nummultirange(numrange(3,4));
select nummultirange(numrange(1,2)) << nummultirange(numrange(3,4), numrange(7,8));
select nummultirange(numrange(1,2)) >> nummultirange();
select nummultirange(numrange(1,2)) >> nummultirange(numrange(1,2));
select nummultirange(numrange(1,2), numrange(4,5)) << nummultirange(numrange(3,4), numrange(7,8));
select nummultirange(numrange(2.0, 1.0));
select nummultirange(numrange(3,4)) << numrange(3,6);
select nummultirange(numrange(3,4)) >> nummultirange(numrange(1,2));
select nummultirange(numrange(3,4)) >> numrange(1,2);
select nummultirange(numrange(3,4), numrange(7,8)) >> nummultirange(numrange(1,2));
select nummultirange(numrange(3,4), numrange(7,8)) >> nummultirange(numrange(1,2), numrange(4,5));
select nummultirange(numrange(5.0, 6.0), numrange(1.0, 2.0));
select original > 1 as initially_multibatch, final > original as increased_batches   from hash_join_batches($$   select count(*) FROM simple r JOIN bigger_than_it_looks s USING (id); $$);
select original > 1 as initially_multibatch, final > original as increased_batches   from hash_join_batches($$   select count(*) from simple r join bigger_than_it_looks s using (id); $$);
select original > 1 as initially_multibatch, final > original as increased_batches   from hash_join_batches($$   select count(*) from simple r join bigger_than_it_looks s using (id); $$);
select original > 1 as initially_multibatch, final > original as increased_batches   from hash_join_batches($$   select count(*) from simple r join simple s using (id); $$);
select original > 1 as initially_multibatch, final > original as increased_batches   from hash_join_batches($$   select count(*) from simple r join simple s using (id); $$);
select original > 1 as initially_multibatch, final > original as increased_batches   from hash_join_batches($$   select count(*) from simple r join simple s using (id); $$);
select original > 1 as initially_multibatch, final > original as increased_batches   from hash_join_batches($$   select count(*) from simple r join simple s using (id); $$);
select original > 1 as initially_multibatch, final > original as increased_batches   from hash_join_batches($$   select count(*) from simple r join simple s using (id); $$);
select original > 1 as initially_multibatch, final > original as increased_batches   from hash_join_batches($$   select count(*) from simple r join simple s using (id); $$);
select p from   (values (box(point(0,0), point(0.5,0.5))),           (box(point(0.5,0.5), point(0.75,0.75))),           (box(point(0.8,0.8), point(1.0,1.0)))) as v(bb) cross join lateral   (select p from gist_tbl where p <@ bb order by p <-> bb[0] limit 2) ss;
select p2text(c1.*) from c1;
select pg_typeof((f1[1])[1]) from dposintatable;
select pg_typeof(f1[1]) from dposintatable;
select pg_typeof(f1[1][1]) from dposintatable;
select polyf(2, 4) as int, polyf(2, 4.5) as num;
select polyf(42) as int, polyf(4.5) as num;
select polyf(42) as int, polyf(4.5) as num;
select polyf(array[2,4]) as int, polyf(array[4.5, 7.7]) as num;
select polyf(array[2,4]) as int, polyf(array[4.5, 7.7]) as num;
select polyf(int4multirange(int4range(1,10), int4range(20,30)));
select polyf(int4multirange(int4range(1,10), int4range(20,30)));
select polyf(int4multirange(int4range(1,10), int4range(20,30)));
select polyf(int4multirange(int4range(1,10), int4range(20,30)));
select polyf(int4range(1,10));
select polyf(int4range(1,10));
select polyf(int4range(42, 49)) as int, polyf(float8range(4.5, 7.8)) as num;
select polyf(int4range(42, 49), 11, 2::smallint) as int, polyf(float8range(4.5, 7.8), 7.8, 11::real) as num;
select polyf(int4range(42, 49), 11, 4.5) as fail;  -- range type doesn't fit drop function polyf(x anycompatiblerange, y anycompatible, z anycompatible);
select polyf(int4range(42, 49), array[11]) as int, polyf(float8range(4.5, 7.8), array[7]) as num;
select polyf(multirange(int4range(42, 49)), 11, 2::smallint) as int, polyf(multirange(float8range(4.5, 7.8)), 7.8, 11::real) as num;
select polyf(multirange(int4range(42, 49)), 11, 4.5) as fail;  -- range type doesn't fit drop function polyf(x anycompatiblemultirange, y anycompatible, z anycompatible);
select polyf(multirange(int4range(42, 49)), array[11]) as int, polyf(multirange(float8range(4.5, 7.8)), array[7]) as num;
select polyf(point(3,4));  -- fail for lack of + operator drop function polyf(x anyelement);
select q1, float8(count(*)) / (select count(*) from int8_tbl) from int8_tbl group by q1 order by q1;
select r, r is null as isnull, r is not null as isnotnull from (values (1,row(1,2)), (1,row(null,null)), (1,null),              (null,row(1,2)), (null,row(null,null)), (null,null) ) r(a,b);
select range_add_bounds(int4multirange(int4range(1, 17)));
select range_add_bounds(int4range(1, 17));
select range_add_bounds(nummultirange(numrange(1.0001, 123.123)));
select range_add_bounds(numrange(1.0001, 123.123));
select range_adjacent(numrange(2.0, 3.0), numrange(3.1, 4.0));
select range_adjacent(numrange(2.0, 3.0), numrange(3.1, null));
select range_adjacent(numrange(2.0, 3.0, '(]'), numrange(1.0, 2.0, '(]'));
select range_merge(numrange(1.0, 2.0), numrange(1.5, 3.0));
select range_merge(numrange(1.0, 2.0), numrange(2.5, 3.0)); -- shouldn't fail select numrange(1.0, 2.0) * numrange(2.0, 3.0);
select range_minus(numrange(10.1,12.2,'[]'), numrange(0.0,120.2,'(]'));
select range_minus(numrange(10.1,12.2,'[]'), numrange(110.0,120.2,'(]'));
select rangetypes_sql(int4range(1,10), ARRAY[2,20]);
select rangetypes_sql(numrange(1,10), ARRAY[2,20]);  -- match failure create function anycompatiblearray_anycompatiblerange_func(a anycompatiblearray, r anycompatiblerange)   returns anycompatible as 'select $1[1] + lower($2);' language sql;
select relname,   c.oid = oldoid as orig_oid,   case relfilenode     when 0 then 'none'     when c.oid then 'own'     when oldfilenode then 'orig'     else 'OTHER'     end as storage,   obj_description(c.oid, 'pg_class') as desc   from pg_class c left join old_oids using (relname)   where relname like 'at_partitioned%'   order by relname;
select relname,   c.oid = oldoid as orig_oid,   case relfilenode     when 0 then 'none'     when c.oid then 'own'     when oldfilenode then 'orig'     else 'OTHER'     end as storage,   obj_description(c.oid, 'pg_class') as desc   from pg_class c left join old_oids using (relname)   where relname like 'at_partitioned%'   order by relname;
select row(-2, true)::testtype2 *< row(-1, true)::testtype2;
select row(0, false)::testtype2 *< row(0, true)::testtype2;
select row(0, false)::testtype2 *<> row(0, true)::testtype2;
select row(1, '(1,2)')::testtype4 *<> row(1, '(1,3)')::testtype4;
select row(1, '(1,2)')::testtype6 *< row(1, '(1,3)')::testtype6;
select row(1, '(1,2)')::testtype6 *<> row(1, '(1,3)')::testtype6;
select row(1, '(1,2)')::testtype6 *>= row(1, '(1,3)')::testtype6;
select row(1, 'abc')::testtype3 *< row(1, 'abcd')::testtype3;
select row(1, 'abc')::testtype3 *<> row(1, 'abd')::testtype3;
select row(1, 'abc')::testtype3 *> row(1, 'abd')::testtype3;
select row(1, -2)::testtype1 *< row(1, -3)::testtype1;
select row(1, -2)::testtype1 *< row(1, 3)::testtype1;
select row(1, -2)::testtype1 *<= row(1, -3)::testtype1;
select row(1, -2)::testtype1 *<> row(1, -2)::testtype1;
select row(1, -2)::testtype1 *= row(1, -3)::testtype1;
select row(1, -3)::testtype1 *> row(1, -2)::testtype1;
select row(1, -3)::testtype1 *>= row(1, -2)::testtype1;
select row(1, 2)::testtype1 *< row(1)::testtype5;
select row(1, 2)::testtype1 *< row(1, 'abc')::testtype3;
select row(1, 2)::testtype1 *< row(1, 3)::testtype1;
select row(1, 2)::testtype1 *<= row(1, 3)::testtype1;
select row(1, 2)::testtype1 *<> row(1)::testtype5;
select row(1, 2)::testtype1 *<> row(1, 'abc')::testtype3;
select row(1, 2)::testtype1 *<> row(1, 3)::testtype1;
select row(1, 2)::testtype1 *= row(1, 2)::testtype1;
select row(1, 3)::testtype1 *> row(1, 2)::testtype1;
select row(1, 3)::testtype1 *>= row(1, 2)::testtype1;
select row(i.*::int8_tbl)::nestedcomposite from int8_tbl i;
select row_to_json(s.*) from generate_series(11,14) with ordinality s;
select scale(numeric 'NaN');
select scale(numeric 'inf');
select setting as segsize from pg_settings where name = 'wal_segment_size' \gset select count(*) > 0 as ok from pg_ls_waldir();
select t1.q2, count(t2.*) from int8_tbl t1 left join   (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2   on (t1.q2 = t2.q1) group by t1.q2 order by 1;
select t1.q2, count(t2.*) from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1) group by t1.q2 order by 1;
select t1.q2, count(t2.*) from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1) group by t1.q2 order by 1;
select t1.q2, count(t2.*) from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1) group by t1.q2 order by 1;
select testint4arr[1], testchar4arr[2:2] from domarrtest;
select to_json(date '-Infinity');
select to_json(date '2014-05-28');
select to_json(date 'Infinity');
select to_json(timestamp '-Infinity');
select to_json(timestamp '2014-05-28 12:22:35.614298');
select to_json(timestamp 'Infinity');
select to_jsonb(date '-Infinity');
select to_jsonb(date '2014-05-28');
select to_jsonb(date 'Infinity');
select to_jsonb(timestamp '-Infinity');
select to_jsonb(timestamp '2014-05-28 12:22:35.614298');
select to_jsonb(timestamp 'Infinity');
select trim_scale(numeric 'inf');
select ts_headline('[]'::json, tsquery('aaa & bbb'));
select ts_headline('[]'::jsonb, tsquery('aaa & bbb'));
select ts_headline('english', '{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::json, tsquery('bbb & ddd & hhh'), 'StartSel = <, StopSel = >');
select ts_headline('english', '{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'), 'StartSel = <, StopSel = >');
select ts_headline('english', '{"a": "aaa bbb", "b": {"c": "ccc ddd fff"}, "d": ["ggg hhh", "iii jjj"]}'::json, tsquery('bbb & ddd & hhh'));
select ts_headline('english', '{"a": "aaa bbb", "b": {"c": "ccc ddd fff"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'));
select ts_headline('null'::json, tsquery('aaa & bbb'));
select ts_headline('null'::jsonb, tsquery('aaa & bbb'));
select ts_headline('{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::json, tsquery('bbb & ddd & hhh'));
select ts_headline('{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::json, tsquery('bbb & ddd & hhh'), 'StartSel = <, StopSel = >');
select ts_headline('{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'));
select ts_headline('{"a": "aaa bbb", "b": {"c": "ccc ddd fff", "c1": "ccc1 ddd1"}, "d": ["ggg hhh", "iii jjj"]}'::jsonb, tsquery('bbb & ddd & hhh'), 'StartSel = <, StopSel = >');
select ts_headline('{}'::json, tsquery('aaa & bbb'));
select ts_headline('{}'::jsonb, tsquery('aaa & bbb'));
select unnest(int4multirange(int4range('5', '6'), int4range('1', '2')));
select websearch_to_tsquery('\');
select x from (values (array[100::money]), (array[200::money])) _(x) union select x from (values (array[100::money]), (array[300::money])) _(x);
select x from (values (row(100::money)), (row(200::money))) _(x) union select x from (values (row(100::money)), (row(300::money))) _(x);
select x from (values (row(100::money)::ct1), (row(200::money)::ct1)) _(x) union select x from (values (row(100::money)::ct1), (row(300::money)::ct1)) _(x);
select x, pg_typeof(x) from anyctest(11, '{1,2}', point(1,2), '(3,4)') x;
select x, pg_typeof(x) from anyctest(11, array[1, 2], point(1,2), point(3,4)) x;
select x, pg_typeof(x) from anyctest(11, array[point(1,2)]) x;  -- fail select x, pg_typeof(x) from anyctest(11, 12) x;  -- fail drop function anyctest(anycompatible, anycompatiblearray);
select x, pg_typeof(x) from anyctest(11, int4range(4,7)) x;
select x, pg_typeof(x) from anyctest(11, multirange(int4range(4,7))) x;
select x, pg_typeof(x) from anyctest(11, multirange(numrange(4,7))) x;
select x, pg_typeof(x) from anyctest(11, numrange(4,7)) x;
select x, pg_typeof(x) from anyctest(11, point(1,2)) x;  -- fail select x, pg_typeof(x) from anyctest('11', '12.3') x;  -- defaults to text drop function anyctest(anycompatible, anycompatible);
select x, pg_typeof(x) from anyctest(int4range(11,12), int4range(4,7)) x;
select x, pg_typeof(x) from anyctest(int4range(11,12), numrange(4,7)) x; -- fail drop function anyctest(anycompatiblerange, anycompatiblerange);
select x, pg_typeof(x) from anyctest(multirange(int4range(11,12)), multirange(int4range(4,7))) x;
select x, pg_typeof(x) from anyctest(multirange(int4range(11,12)), multirange(numrange(4,7))) x; -- fail drop function anyctest(anycompatiblemultirange, anycompatiblemultirange);
select x, pg_typeof(x), y, pg_typeof(y)   from f1(11, '{1,2}', point(1,2), '(3,4)');
select x, pg_typeof(x), y, pg_typeof(y)   from f1(11, array[1, 2], point(1,2), point(3,4));
select x, pg_typeof(x), y, pg_typeof(y)   from polyf(11, '{1,2}', point(1,2), '(3,4)');
select x, pg_typeof(x), y, pg_typeof(y)   from polyf(11, array[1, 2], point(1,2), point(3,4));
short \. select * from basictest;
show escape_string_warning;
show escape_string_warning;
show standard_conforming_strings;
show standard_conforming_strings;
show synchronous_commit;
sltype	char(2);
sltype	char(2);
sltype := substr(psrec.slotlink, 1, 2);
sltype := substr(rec.slotlink, 1, 2);
sname := ''HS.'' || trim(new.hubname);
sname := sname || ''.'';
sname := sname || new.slotno::text;
still not okay \endif \g select   \if true     42   \else     (bogus   \endif   forty_two;
test1 \. SELECT * FROM instead_of_insert_tbl;
test1 \. SELECT * FROM instead_of_insert_tbl;
update arrtest1 set i[-12:-10] = array[-22,null,-20], t[-12:-10] = array['m22',null,'m20'];
update arrtest1 set i[-3] = -3, t[-3] = 'minus-three';
update arrtest1 set i[-5:-3] = array[-15,-14,-13], t[-5:-3] = array['m15','m14','m13'];
update arrtest1 set i[-7:-6] = array[-17,null], t[-7:-6] = array['m17',null];
update arrtest1 set i[0:2] = array[10,11,12], t[0:2] = array['ten','eleven','twelve'];
update arrtest1 set i[0:5] = array[0,1,2,null,4,5], t[0:5] = array['z','p1','p2',null,'p4','p5'];
update arrtest1 set i[0] = 0, t[0] = 'zero';
update arrtest1 set i[11:12] = array[null,22], t[11:12] = array[null,'p22'];
update arrtest1 set i[15:16] = array[null,26], t[15:16] = array[null,'p26'];
update arrtest1 set i[2] = 22, t[2] = 'twenty-two';
update arrtest1 set i[5] = 5, t[5] = 'five';
update arrtest1 set i[8:10] = array[18,null,20], t[8:10] = array['p18',null,'p20'];
update arrtest1 set i[8] = 8, t[8] = 'eight';
update dcomptable set d1.r = (d1).r + 1 where (d1).i > 0;
update dcomptable set d1[1].r = d1[1].r + 1 where d1[1].i > 0;
update dcomptable set d1[2] = row(d1[2].i, d1[2].r);
update dcomptable set f1[1].cf1 = -1;  -- fail update dcomptable set f1[1].cf1 = 1;
update dcomptable set f1[1].cf2 = 5;
update domarrtest set   testint4arr[1] = testint4arr[1] + 1,   testint4arr[3] = testint4arr[3] - 1 where testchar4arr is null;
update dposintatable set (f1[2])[1] = array[98];
update dposintatable set f1[2] = array[99];
update dposintatable set f1[2][1] = array[97];
update op set f1[2] = 0;  -- fail select * from op;
update people set fn.suffix = 'Jr';
update pitable set f1[1] = 0;  -- fail select * from pitable;
update quadtable set q.c1 = 12;  -- error, type mismatch select * from quadtable;
update quadtable set q.c1.r = 12 where f1 = 2;
update t1 set f1[5].q2 = 43;
update test_jsonb_subscript set test_json['a'] = '"test"';
update test_jsonb_subscript set test_json['a'] = '1' where id = 2;
update test_jsonb_subscript set test_json['a'] = '1' where id = 3;
update test_jsonb_subscript set test_json['a'] = '[1, 2, 3]'::jsonb;
update test_jsonb_subscript set test_json['a'] = '{"b": 1}'::jsonb;
update test_jsonb_subscript set test_json['a']['b'] = '1';
update test_jsonb_subscript set test_json['a']['b']['c'] = '1';
update test_jsonb_subscript set test_json['a']['b']['c'][2] = '1';
update test_jsonb_subscript set test_json['a']['b'][10] = '1';
update test_jsonb_subscript set test_json['a']['b'][10] = '1';
update test_jsonb_subscript set test_json['a']['b'][1] = '1';
update test_jsonb_subscript set test_json['a'][0] = '1';
update test_jsonb_subscript set test_json['a'][0] = '2';
update test_jsonb_subscript set test_json['a'][0]['b'][0]['c'] = '1';
update test_jsonb_subscript set test_json['a'][0]['c'] = '1';
update test_jsonb_subscript set test_json['a'][0][0] = '1';
update test_jsonb_subscript set test_json['a'][10][10] = '1';
update test_jsonb_subscript set test_json['a'][1]['c'][2] = '1';
update test_jsonb_subscript set test_json['a'][2]['b'][2]['c'][2] = '1';
update test_jsonb_subscript set test_json['another_key'] = NULL;
update test_jsonb_subscript set test_json[-4] = '1';
update test_jsonb_subscript set test_json[-8] = '1';
update test_jsonb_subscript set test_json[0] = '1';
update test_jsonb_subscript set test_json[0] = '1';
update test_jsonb_subscript set test_json[0]['a'] = '1';
update test_jsonb_subscript set test_json[0]['a'] = '1';
update test_jsonb_subscript set test_json[0][0] = '1';
update test_jsonb_subscript set test_json[0][0][0] = '1';
update test_jsonb_subscript set test_json[0][0][1] = '1';
update test_jsonb_subscript set test_json[2]['b'] = '2';
update test_jsonb_subscript set test_json[5] = '1';
update test_jsonb_subscript set test_json[5] = '1';
update test_jsonb_subscript set test_json[NULL] = '1';
with ins (a) as (   insert into parted2_stmt_trig values (1), (2) returning a ) insert into parted_stmt_trig select a from ins returning tableoid::regclass, a;
with r(a,b) as materialized   (values (1,row(1,2)), (1,row(null,null)), (1,null),           (null,row(1,2)), (null,row(null,null)), (null,null) ) select r, r is null as isnull, r is not null as isnotnull from r;
with recursive a as ( 	select 1 as b 	union all 	select * from a ) cycle b set c using p select * from a;
with recursive graph(f, t, label) as (   values (1, 2, 'arc 1 -> 2'),          (1, 3, 'arc 1 -> 3'),          (2, 3, 'arc 2 -> 3'),          (1, 4, 'arc 1 -> 4'),          (4, 5, 'arc 4 -> 5'),          (5, 1, 'arc 5 -> 1') ), search_graph(f, t, label) as (         select * from graph g         union all         select g.*         from graph g, search_graph sg         where g.f = sg.t ) cycle f, t set is_cycle to true default false using path select f, t, label from search_graph;
with recursive search_graph(f, t, label) as ( 	select * from graph g 	union all 	select g.* 	from graph g, search_graph sg 	where g.f = sg.t ) cycle f, t set foo to true default false using foo select * from search_graph;
with recursive search_graph(f, t, label) as ( 	select * from graph g 	union all 	select g.* 	from graph g, search_graph sg 	where g.f = sg.t ) cycle f, t set is_cycle to point '(1,1)' default point '(0,0)' using path select * from search_graph;
with recursive search_graph(f, t, label) as ( 	select * from graph g 	union all 	select g.* 	from graph g, search_graph sg 	where g.f = sg.t ) cycle f, t set is_cycle to true default 55 using path select * from search_graph;
with recursive search_graph(f, t, label) as ( 	select * from graph g 	union all 	select g.* 	from graph g, search_graph sg 	where g.f = sg.t ) cycle f, t set is_cycle to true default false using label select * from search_graph;
with recursive search_graph(f, t, label) as ( 	select * from graph g 	union all 	select g.* 	from graph g, search_graph sg 	where g.f = sg.t ) cycle f, t set is_cycle using path select * from search_graph;
with recursive search_graph(f, t, label) as ( 	select * from graph g 	union all 	select g.* 	from graph g, search_graph sg 	where g.f = sg.t ) cycle f, t set label to true default false using path select * from search_graph;
with recursive search_graph(f, t, label) as ( 	select * from graph g 	union all 	select g.* 	from graph g, search_graph sg 	where g.f = sg.t ) cycle f, t, f set is_cycle to true default false using path select * from search_graph;
with recursive search_graph(f, t, label) as ( 	select * from graph g 	union all 	select g.* 	from graph g, search_graph sg 	where g.f = sg.t ) cycle foo, tar set is_cycle using path select * from search_graph;
with recursive search_graph(f, t, label) as ( 	select * from graph g 	union all 	select g.* 	from graph g, search_graph sg 	where g.f = sg.t ) search breadth first by f, t set seq   cycle f, t set is_cycle using path select * from search_graph;
with recursive search_graph(f, t, label) as ( 	select * from graph g 	union all 	select g.* 	from graph g, search_graph sg 	where g.f = sg.t ) search depth first by f, t set foo   cycle f, t set foo to true default false using path select * from search_graph;
with recursive search_graph(f, t, label) as ( 	select * from graph g 	union all 	select g.* 	from graph g, search_graph sg 	where g.f = sg.t ) search depth first by f, t set foo   cycle f, t set is_cycle to true default false using foo select * from search_graph;
with recursive search_graph(f, t, label) as ( 	select * from graph g 	union all 	select g.* 	from graph g, search_graph sg 	where g.f = sg.t ) search depth first by f, t set seq   cycle f, t set is_cycle using path select * from search_graph;
with recursive search_graph(f, t, label) as ( 	select * from graph g 	union distinct 	select g.* 	from graph g, search_graph sg 	where g.f = sg.t ) cycle f, t set is_cycle to 'Y' default 'N' using path select * from search_graph;
with recursive search_graph(f, t, label) as ( 	select * from graph0 g 	union all 	(select * from graph0 g 	union all 	select g.* 	from graph0 g, search_graph sg 	where g.f = sg.t) ) search depth first by f, t set seq select * from search_graph order by seq;
with recursive search_graph(f, t, label) as ( 	select * from graph0 g 	union all 	select * from graph0 g 	union all 	select g.* 	from graph0 g, search_graph sg 	where g.f = sg.t ) search depth first by f, t set seq select * from search_graph order by seq;
with recursive search_graph(f, t, label) as ( 	select * from graph0 g 	union all 	select g.* 	from graph0 g, search_graph sg 	where g.f = sg.t ) search breadth first by f, t set seq select * from search_graph order by seq;
with recursive search_graph(f, t, label) as ( 	select * from graph0 g 	union all 	select g.* 	from graph0 g, search_graph sg 	where g.f = sg.t ) search depth first by f, t set label select * from search_graph;
with recursive search_graph(f, t, label) as ( 	select * from graph0 g 	union all 	select g.* 	from graph0 g, search_graph sg 	where g.f = sg.t ) search depth first by f, t set seq select * from search_graph order by seq;
with recursive search_graph(f, t, label) as ( 	select * from graph0 g 	union all 	select g.* 	from graph0 g, search_graph sg 	where g.f = sg.t ) search depth first by f, t, f set seq select * from search_graph;
with recursive search_graph(f, t, label) as ( 	select * from graph0 g 	union all 	select g.* 	from graph0 g, search_graph sg 	where g.f = sg.t ) search depth first by foo, tar set seq select * from search_graph;
with recursive search_graph(f, t, label) as ( 	select * from graph0 g 	union distinct 	select g.* 	from graph0 g, search_graph sg 	where g.f = sg.t ) search breadth first by f, t set seq select * from search_graph order by seq;
with recursive search_graph(f, t, label) as ( 	select * from graph0 g 	union distinct 	select g.* 	from graph0 g, search_graph sg 	where g.f = sg.t ) search depth first by f, t set seq select * from search_graph order by seq;
with recursive search_graph(f, t, label, is_cycle, path) as ( 	select *, false, array[row(g.f, g.t)] from graph g 	union all 	select g.*, row(g.f, g.t) = any(path), path || row(g.f, g.t) 	from graph g, search_graph sg 	where g.f = sg.t and not is_cycle ) select * from search_graph order by path;
with recursive search_graph(f, t, label, is_cycle, path) as ( 	select *, false, array[row(g.f, g.t)] from graph g 	union all 	select g.*, row(g.f, g.t) = any(path), path || row(g.f, g.t) 	from graph g, search_graph sg 	where g.f = sg.t and not is_cycle ) select * from search_graph;
with recursive search_graph(f, t, label, is_cycle, path) as ( 	select *, false, array[row(g.f, g.t)] from graph g 	union distinct 	select g.*, row(g.f, g.t) = any(path), path || row(g.f, g.t) 	from graph g, search_graph sg 	where g.f = sg.t and not is_cycle ) select * from search_graph;
with result as (insert into brtrigpartcon values (1, 'hi there') returning 1)   insert into inserttest3 (f3) select * from result;
with test as (select 42) insert into test select * from test;
with testdata(bits) as (values   (x'00000000'),   (x'00800000'), (x'00800001'), (x'00800004'), (x'00800005'),   (x'00800006'),   (x'008002f1'), (x'008002f2'), (x'008002f3'),   (x'00800e17'), (x'00800e18'), (x'00800e19'),   (x'01000001'), (x'01102843'), (x'01a52c98'),   (x'0219c229'), (x'02e4464d'), (x'037343c1'), (x'03a91b36'),   (x'047ada65'), (x'0496fe87'), (x'0550844f'), (x'05999da3'),   (x'060ea5e2'), (x'06e63c45'), (x'07f1e548'), (x'0fc5282b'),   (x'1f850283'), (x'2874a9d6'),   (x'3356bf94'), (x'3356bf95'), (x'3356bf96'),   (x'33d6bf94'), (x'33d6bf95'), (x'33d6bf96'),   (x'34a10faf'), (x'34a10fb0'), (x'34a10fb1'),   (x'350637bc'), (x'350637bd'), (x'350637be'),   (x'35719786'), (x'35719787'), (x'35719788'),   (x'358637bc'), (x'358637bd'), (x'358637be'),   (x'36a7c5ab'), (x'36a7c5ac'), (x'36a7c5ad'),   (x'3727c5ab'), (x'3727c5ac'), (x'3727c5ad'),   (x'38d1b714'), (x'38d1b715'), (x'38d1b716'),   (x'38d1b717'), (x'38d1b718'), (x'38d1b719'),   (x'38d1b71a'), (x'38d1b71b'), (x'38d1b71c'),   (x'38d1b71d'),   (x'38dffffe'), (x'38dfffff'), (x'38e00000'),   (x'38efffff'), (x'38f00000'), (x'38f00001'),   (x'3a83126e'), (x'3a83126f'), (x'3a831270'),   (x'3c23d709'), (x'3c23d70a'), (x'3c23d70b'),   (x'3dcccccc'), (x'3dcccccd'), (x'3dccccce'),   (x'3dcccd6f'), (x'3dcccd70'), (x'3dcccd71'),   (x'3effffff'), (x'3f000000'), (x'3f000001'),   (x'3f333332'), (x'3f333333'), (x'3f333334'),   (x'3f666665'), (x'3f666666'), (x'3f666667'),   (x'3f7d70a3'), (x'3f7d70a4'), (x'3f7d70a5'),   (x'3f7fbe76'), (x'3f7fbe77'), (x'3f7fbe78'),   (x'3f7ff971'), (x'3f7ff972'), (x'3f7ff973'),   (x'3f7fff57'), (x'3f7fff58'), (x'3f7fff59'),   (x'3f7fffee'), (x'3f7fffef'),   (x'3f7ffff0'), (x'3f7ffff1'), (x'3f7ffff2'),   (x'3f7ffff3'), (x'3f7ffff4'), (x'3f7ffff5'),   (x'3f7ffff6'), (x'3f7ffff7'), (x'3f7ffff8'),   (x'3f7ffff9'), (x'3f7ffffa'), (x'3f7ffffb'),   (x'3f7ffffc'), (x'3f7ffffd'), (x'3f7ffffe'),   (x'3f7fffff'),   (x'3f800000'),   (x'3f800001'), (x'3f800002'), (x'3f800003'),   (x'3f800004'), (x'3f800005'), (x'3f800006'),   (x'3f800007'), (x'3f800008'), (x'3f800009'),   (x'3f80000f'), (x'3f800010'), (x'3f800011'),   (x'3f800012'), (x'3f800013'), (x'3f800014'),   (x'3f800017'), (x'3f800018'), (x'3f800019'),   (x'3f80001a'), (x'3f80001b'), (x'3f80001c'),   (x'3f800029'), (x'3f80002a'), (x'3f80002b'),   (x'3f800053'), (x'3f800054'), (x'3f800055'),   (x'3f800346'), (x'3f800347'), (x'3f800348'),   (x'3f8020c4'), (x'3f8020c5'), (x'3f8020c6'),   (x'3f8147ad'), (x'3f8147ae'), (x'3f8147af'),   (x'3f8ccccc'), (x'3f8ccccd'), (x'3f8cccce'),   (x'3fc90fdb'), -- pi/2   (x'402df854'), -- e   (x'40490fdb'), -- pi   (x'409fffff'), (x'40a00000'), (x'40a00001'),   (x'40afffff'), (x'40b00000'), (x'40b00001'),   (x'411fffff'), (x'41200000'), (x'41200001'),   (x'42c7ffff'), (x'42c80000'), (x'42c80001'),   (x'4479ffff'), (x'447a0000'), (x'447a0001'),   (x'461c3fff'), (x'461c4000'), (x'461c4001'),   (x'47c34fff'), (x'47c35000'), (x'47c35001'),   (x'497423ff'), (x'49742400'), (x'49742401'),   (x'4b18967f'), (x'4b189680'), (x'4b189681'),   (x'4cbebc1f'), (x'4cbebc20'), (x'4cbebc21'),   (x'4e6e6b27'), (x'4e6e6b28'), (x'4e6e6b29'),   (x'501502f8'), (x'501502f9'), (x'501502fa'),   (x'51ba43b6'), (x'51ba43b7'), (x'51ba43b8'),   (x'1f6c1e4a'),  -- 5e-20   (x'59be6cea'),  -- 67e14   (x'5d5ab6c4'),  -- 985e15   (x'2cc4a9bd'),  -- 55895e-16   (x'15ae43fd'),  -- 7038531e-32   (x'2cf757ca'),  -- 702990899e-20   (x'665ba998'),  -- 25933168707e13   (x'743c3324'),  -- 596428896559e20   (x'47f1205a'),   (x'4640e6ae'),   (x'449a5225'),   (x'42f6e9d5'),   (x'414587dd'),   (x'3f9e064b'),   (x'4c000004'),   (x'50061c46'),   (x'510006a8'),   (x'48951f84'),   (x'45fd1840'),   (x'39800000'),   (x'3b200000'),   (x'3b900000'),   (x'3bd00000'),   (x'63800000'),   (x'4b000000'),   (x'4b800000'),   (x'4c000001'),   (x'4c800b0d'),   (x'00d24584'),   (x'00d90b88'),   (x'45803f34'),   (x'4f9f24f7'),   (x'3a8722c3'),   (x'5c800041'),   (x'15ae43fd'),   (x'5d4cccfb'),   (x'4c800001'),   (x'57800ed8'),   (x'5f000000'),   (x'700000f0'),   (x'5f23e9ac'),   (x'5e9502f9'),   (x'5e8012b1'),   (x'3c000028'),   (x'60cde861'),   (x'03aa2a50'),   (x'43480000'),   (x'4c000000'),   (x'5D1502F9'),   (x'5D9502F9'),   (x'5E1502F9'),   (x'3f99999a'),   (x'3f9d70a4'),   (x'3f9df3b6'),   (x'3f9e0419'),   (x'3f9e0610'),   (x'3f9e064b'),   (x'3f9e0651'),   (x'03d20cfe') ) select float4send(flt) as ibits,        flt,        flt::text::float4 as r_flt,        float4send(flt::text::float4) as obits,        float4send(flt::text::float4) = float4send(flt) as correct   from (select bits::integer::xfloat4::float4 as flt           from testdata 	offset 0) s;
with testdata(bits) as (values   (x'00000001'),   (x'00000002'), (x'00000003'),   (x'00000010'), (x'00000011'), (x'00000100'), (x'00000101'),   (x'00004000'), (x'00004001'), (x'00080000'), (x'00080001'),   (x'0053c4f4'),  -- 7693e-42   (x'006c85c4'),  -- 996622e-44   (x'0041ca76'),  -- 60419369e-46   (x'004b7678'),  -- 6930161142e-48   (x'00000007'),   (x'00424fe2'),   (x'007ffff0'), (x'007ffff1'), (x'007ffffe'), (x'007fffff')) select float4send(flt) as ibits,        flt   from (select bits::integer::xfloat4::float4 as flt           from testdata 	offset 0) s;
x y \. SELECT * FROM vistest;
x,45,80,90 x,\x,\\x,\\\x x,\,,\\\,,\\ \. COPY x from stdin WITH DELIMITER AS ';' NULL AS '';
xname	HSlot.slotname%TYPE;
xxx;
{3,4}	{q,w,e} \N	\N \. COPY domarrtest FROM stdin;	-- fail {3,4}	{qwerty,w,e} \. select * from domarrtest;
