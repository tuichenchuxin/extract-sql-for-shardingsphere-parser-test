CREATE  VIEW v1 AS SELECT GROUPING(`߸߸߸߸߸߸߸߸߸߸0123456789012345678901234567890123456789`.a), GROUPING(`߸߸߸߸߸߸߸߸߸߸0123456789012345678901234567890123456789`.a), GROUPING(`߸߸߸߸߸߸߸߸߸߸0123456789012345678901234567890123456789`.a) FROM t1 AS `߸߸߸߸߸߸߸߸߸߸0123456789012345678901234567890123456789` GROUP BY a WITH ROLLUP
CREATE DEFINER = u1@192.129.12.11 VIEW v3 as SELECT * FROM t1
CREATE DEFINER = u1@localhost FUNCTION f2() RETURNS int BEGIN DECLARE n int; DECLARE m int; SET n:= (SELECT min(a) FROM t1); SET m:= (SELECT max(a) FROM t1); RETURN n < m; END ;
CREATE DEFINER=CURRENT_USER() FUNCTION should_not_parse RETURNS STRING SONAME "should_not_parse.so"
CREATE DEFINER=baz@localhost PROCEDURE my_db.baz_proc() BEGIN set ROLE all; INSERT into my_db.t1 values(4) on duplicate key UPDATE id = values(id) + 400; END
CREATE DEFINER=event_u2@192.1.1.140 EVENT e3 ON SCHEDULE AT '2037-01-01 00:00:00' DISABLE DO SET @a = 5
CREATE DEFINER=event_u2@192.1.1.140 EVENT e4 ON SCHEDULE AT '2037-01-01 00:00:00' DISABLE DO SET @a = 5
CREATE DEFINER=mysqltest_u1@localhost FUNCTION f_evil () RETURNS INT SQL SECURITY INVOKER BEGIN SET @a:= CURRENT_USER(); SET @b:= (SELECT COUNT(*) FROM t1); RETURN @b; END
CREATE DEFINER=root@localhost PROCEDURE p1() BEGIN UPDATE t1, t2 SET a = 1 WHERE regexp_like(t1.subject, t2.pattern); END|
CREATE DEFINER=someone@somewhere FUNCTION should_not_parse RETURNS STRING SONAME "should_not_parse.so"
CREATE DEFINER=trig_u2@xyz.com TRIGGER trig3 BEFORE INSERT ON t1 FOR EACH ROW SET @sum = 1
CREATE DEFINER=trig_u2@xyz.com TRIGGER trig4 BEFORE INSERT ON t1 FOR EACH ROW SET @sum = 1
CREATE DEFINER=view_u2@my.oracle.com VIEW v3 AS SELECT * FROM t1
CREATE DEFINER=view_u2@my.oracle.com VIEW v4 AS SELECT * FROM t1
CREATE EVENT e1 ON SCHEDULE EVERY 1 SECOND DO DROP DATABASE BUG52792
CREATE EVENT e1 ON SCHEDULE EVERY 1 SECOND DO DROP DATABASE BUG52792
CREATE EVENT e2 ON SCHEDULE EVERY 1 SECOND DO DROP DATABASE BUG52792
CREATE EVENT e2 ON SCHEDULE EVERY 1 SECOND DO DROP DATABASE BUG52792
CREATE EVENT e_x1 ON SCHEDULE EVERY 1 SECOND DO DROP DATABASE db_x
CREATE FUNCTION BUG_12490() RETURNS INT HELP CONTENTS
CREATE FUNCTION MY_KILL(tid INT) RETURNS INT BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN END; KILL tid; RETURN (SELECT COUNT(*) = 0 FROM INFORMATION_SCHEMA.PROCESSLIST WHERE ID = tid); END
CREATE FUNCTION bug12953() RETURNS INT BEGIN OPTIMIZE TABLE t1; RETURN 1; END
CREATE FUNCTION bug12995() RETURNS INT BEGIN HANDLER t1 CLOSE; RETURN 1; END
CREATE FUNCTION bug12995() RETURNS INT BEGIN HANDLER t1 OPEN; RETURN 1; END
CREATE FUNCTION bug12995() RETURNS INT BEGIN HANDLER t1 READ FIRST; RETURN 1; END
CREATE FUNCTION bug13012() RETURNS INT BEGIN REPAIR TABLE t1; RETURN 1; END
CREATE FUNCTION bug13575 ( p1 integer ) returns varchar(3) BEGIN DECLARE v1 VARCHAR(10) DEFAULT null; SELECT f2 INTO v1 FROM t3 WHERE f1 = p1; RETURN v1; END
CREATE FUNCTION bug21493(paramMember VARCHAR(15)) RETURNS varchar(45) BEGIN DECLARE tracks VARCHAR(45); SELECT GROUP_CONCAT(Track SEPARATOR ', ') INTO tracks FROM t4 WHERE Member_ID=paramMember AND Action='Enrolled' AND (Track,Action_Date) IN (SELECT Track, MAX(Action_Date) FROM t4 WHERE Member_ID=paramMember GROUP BY Track); RETURN tracks; END
CREATE FUNCTION bug21975() returns int BEGIN grant select on t1 to 'mysqltest_1'; return 1; END
CREATE FUNCTION bug21975() returns int BEGIN revoke all privileges on *.* from 'mysqltest_1'; return 1; END
CREATE FUNCTION bug21975() returns int BEGIN revoke select on t1 from 'mysqltest_1'; return 1; END
CREATE FUNCTION bug27563() RETURNS INT(11) DETERMINISTIC BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '70100' SET @a:= 'killed'; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET @a:= 'exception'; SET DEBUG_SYNC= 'now SIGNAL in_sync WAIT_FOR kill'; RETURN 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN DROP TRIGGER test1; return 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN LOCK TABLE t1 READ; return 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN alter view v1 as select 1; return 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN create database mysqltest; return 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN create function f2 () returns int return 1; return 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN create index t1_i on t1 (a); return 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN create trigger tr2 before insert on t1 for each row do select 1; return 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN create user 'mysqltest_1'; return 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN create view v1 as select 1; return 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN drop database mysqltest; return 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN drop function bug_13627_f; return 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN drop index t1_i on t1; return 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN drop user 'mysqltest_1'; return 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN drop view v1; return 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN rename table t1 to t2; return 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN rename user 'mysqltest_2' to 'mysqltest_1'; return 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN unlock tables; return 1; END
CREATE FUNCTION crc(_text TEXT) RETURNS BIGINT(20) UNSIGNED DETERMINISTIC RETURN CONV(LEFT(MD5(_text),16),16,10)
CREATE FUNCTION crc32_func(inputvar CHAR) RETURNS BIGINT BEGIN DECLARE crcval BIGINT; SELECT CRC32(inputvar) INTO crcval; RETURN crcval; END
CREATE FUNCTION f(f1 VARCHAR(64) CHARACTER SET ucs2 COLLATE ucs2_unicode_ci) RETURNS VARCHAR(64) CHARACTER SET ucs2 COLLATE ucs2_danish_ci BEGIN DECLARE f2 VARCHAR(64) CHARACTER SET ucs2 COLLATE ucs2_swedish_ci; DECLARE f3 VARCHAR(64) CHARACTER SET ucs2 COLLATE ucs2_bin; SET f1= concat(collation(f1), ' ', collation(f2), ' ', collation(f3)); RETURN f1; END
CREATE FUNCTION f(f1 VARCHAR(64) CHARACTER SET ucs2) RETURNS VARCHAR(64) CHARACTER SET ucs2 BEGIN DECLARE f2 VARCHAR(64) COLLATE ucs2_unicode_ci; RETURN 'str'; END
CREATE FUNCTION f(f1 VARCHAR(64) CHARACTER SET ucs2) RETURNS VARCHAR(64) COLLATE ucs2_unicode_ci BEGIN RETURN 'str'; END
CREATE FUNCTION f(f1 VARCHAR(64) COLLATE ucs2_unicode_ci) RETURNS VARCHAR(64) CHARACTER SET ucs2 BEGIN RETURN 'str'; END
CREATE FUNCTION f1() RETURNS INT BEGIN CREATE TEMPORARY TABLE t2 (c1 INT); ALTER TEMPORARY TABLE tm1 UNION=(t1,t2); INSERT INTO t2 (c1) VALUES (2); RETURN (SELECT MAX(c1) FROM tm1); END
CREATE FUNCTION f1() RETURNS INT BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION               # handler 1 BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION             # handler 2 BEGIN INSERT INTO t1 VALUE('WRONG: Inside H2'); RETURN 2; END; INSERT INTO t1 VALUE('CORRECT: Inside H1'); RETURN 1; END; BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING               # handler 3 BEGIN INSERT INTO t1 VALUE('WRONG: Inside H3'); RETURN 3; END; INSERT INTO t1 VALUE('CORRECT: Calling f1()'); RETURN f1(); # -- exception here END; INSERT INTO t1 VALUE('WRONG: Returning 10'); RETURN 10; END
CREATE FUNCTION f1() RETURNS INT BEGIN SET PASSWORD FOR u1@h = '12345'; RETURN 0; END;
CREATE FUNCTION f1() RETURNS INT BEGIN SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE, READ ONLY; RETURN 1; END
CREATE FUNCTION f1() RETURNS INT BEGIN SET SESSION TRANSACTION READ ONLY; RETURN 1; END
CREATE FUNCTION f1() RETURNS INTEGER BEGIN CALL db1.p1(); RETURN 1; END
CREATE FUNCTION f1() RETURNS INTEGER BEGIN DECLARE foo INTEGER; DECLARE bar INTEGER; SET foo=1; SET bar=2; RETURN foo; END
CREATE FUNCTION f1() RETURNS INTEGER BEGIN DECLARE retn INTEGER; SELECT Meaning FROM v1 INTO retn; RETURN retn; END
CREATE FUNCTION f1() RETURNS INTEGER BEGIN DECLARE v VARCHAR(5) DEFAULT -1; SELECT b FROM t1 WHERE a = 2 INTO v; RETURN v; END
CREATE FUNCTION f1() RETURNS TEXT BEGIN DECLARE message TEXT; DECLARE warn CONDITION FOR SQLSTATE "01234"; DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN GET DIAGNOSTICS CONDITION 1 message = MESSAGE_TEXT; END; SIGNAL warn SET MESSAGE_TEXT = "message text"; return message; END
CREATE FUNCTION f1() RETURNS VARCHAR(2000) BEGIN DECLARE var VARCHAR(2000); SET var = ''; SET var = CONCAT(var, 'abc'); SET var = CONCAT(var, ''); RETURN var; END
CREATE FUNCTION f1() RETURNS VARCHAR(64) CHARACTER SET ucs2 BEGIN DECLARE f1 VARCHAR(64) CHARACTER SET ucs2; DECLARE f2 VARCHAR(64) CHARACTER SET ucs2; SET f1='str'; CALL p1(f1, f2); RETURN f2; END
CREATE FUNCTION f1() RETURNS char(255) BEGIN DECLARE ret char(255); SELECT  AVG(c2)  OVER ( ) AS res FROM  te2 INTO ret; RETURN ret; END
CREATE FUNCTION f1() RETURNS longblob BEGIN DECLARE ret longblob; SELECT statement_digest_text( "DROP TABLE t" ) INTO ret; RETURN ret; END;
CREATE FUNCTION f1(arg VARCHAR(255)) RETURNS VARCHAR(255) BEGIN DECLARE v1 VARCHAR(255); DECLARE v2 VARCHAR(255); SET v1 = CONCAT(LOWER(arg), UPPER(arg)); SET v2 = CONCAT(LOWER(v1), UPPER(v1)); INSERT INTO t1 VALUES(v1), (v2); RETURN CONCAT(LOWER(arg), UPPER(arg)); END
CREATE FUNCTION f1(comment CHAR(80)) RETURNS INT BEGIN DECLARE orig_tz CHAR(64); DECLARE unix_time INT; DECLARE local_now DATETIME; DECLARE utc_now DATETIME; DECLARE local_time INT; SET unix_time= UNIX_TIMESTAMP(); SET local_now= FROM_UNIXTIME(unix_time); SET orig_tz= @@TIME_ZONE; SET TIME_ZONE = '+00:00'; SET utc_now= FROM_UNIXTIME(unix_time); SET TIME_ZONE= orig_tz; SET local_time = unix_time + TIMESTAMPDIFF(SECOND, utc_now, local_now); SET unix_time= round_to_step(unix_time, 6); SET local_time= round_to_step(local_time, 6); INSERT INTO t1 VALUES ((SELECT count FROM t2), unix_time, local_time, comment); RETURN 0; END
CREATE FUNCTION f1(vlt_code_id CHAR(11)) RETURNS tinyint DETERMINISTIC BEGIN DECLARE not_installed TINYINT DEFAULT 0; select count(distinct x.id_aams) into not_installed from (select * from (select t1.id_aams, t2.* from t1 left join t2 on t2.code_id = vlt_code_id and t1.id_aams = t2.id_game where t1.id_aams = 1715000360 order by t2.id desc ) as g group by g.id_aams having g.id is null ) as x; RETURN TRUE; END
CREATE FUNCTION f2 () RETURNS INT BEGIN DECLARE v INT; SELECT s1 FROM t2 INTO v; RETURN v; END
CREATE FUNCTION f2() RETURNS INT BEGIN DECLARE v INT DEFAULT 1; IF v * (SELECT * FROM t1) THEN RETURN 1; ELSE RETURN 2; END IF; RETURN 3; END
CREATE FUNCTION f2() RETURNS INTEGER BEGIN DECLARE v INTEGER; DECLARE CONTINUE HANDLER FOR NOT FOUND SET @msg = 'Handler activated.'; SELECT f1() INTO v; RETURN v; END
CREATE FUNCTION f2() RETURNS VARCHAR(77) SQL SECURITY INVOKER BEGIN DECLARE cu VARCHAR(77); CALL p1(cu); RETURN cu; END
CREATE FUNCTION f2() RETURNS int BEGIN DECLARE a int; SET @a=20; CALL sp1(a); RETURN a; END
CREATE FUNCTION f3() RETURNS int BEGIN DECLARE a, b int; DROP TEMPORARY TABLE IF EXISTS t3; CREATE TEMPORARY TABLE t3 (id INT); INSERT INTO t3 VALUES (1), (2), (3); SET a:= (SELECT COUNT(*) FROM t3); SET b:= (SELECT COUNT(*) FROM t3 t3_alias); RETURN a + b; END
CREATE FUNCTION f4() RETURNS int BEGIN DECLARE x int; DECLARE c CURSOR FOR SELECT * FROM t1 limit 1; SET NAMES 'utf8'; SET @var1=20; OPEN c; FETCH c INTO x; CLOSE c; RETURN x; END
CREATE FUNCTION f4_show_warnings() RETURNS TEXT BEGIN SHOW WARNINGS; RETURN "yeah, not so much"; END
CREATE FUNCTION fn(a int) RETURNS int DETERMINISTIC BEGIN RETURN a; END |
CREATE FUNCTION fn2() RETURNS tinyint BEGIN DECLARE v1 TINYINT DEFAULT 450000; RETURN v1; END
CREATE FUNCTION func1() RETURNS INT DETERMINISTIC BEGIN DECLARE a int; SELECT COUNT(*) INTO a FROM information_schema.columns WHERE table_name='db'; RETURN a; END
CREATE FUNCTION get_value() RETURNS TEXT DETERMINISTIC BEGIN DECLARE col1, col2, col3, col4, col6 CHAR(255); DECLARE default_val VARCHAR(65532) CHARACTER SET latin1; DECLARE done INT DEFAULT 0; DECLARE cur1 CURSOR FOR SELECT COLUMN_NAME, COLUMN_TYPE, IS_NULLABLE, COLUMN_KEY, COLUMN_DEFAULT, EXTRA FROM INFORMATION_SCHEMA.COLUMNS where TABLE_NAME='bug23037'; DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1; OPEN cur1; FETCH cur1 INTO col1, col2, col3, col4, default_val, col6; CLOSE cur1; RETURN default_val; end
CREATE FUNCTION myfunc(dt VARCHAR(50)) RETURNS VARCHAR(32) DETERMINISTIC BEGIN DECLARE dt_local TIMESTAMP(0); SET dt_local = dt; RETURN CONCAT(UNIX_TIMESTAMP(dt_local)); END;
CREATE FUNCTION next_seq_value() RETURNS INT BEGIN DECLARE next_val INT; SELECT val INTO next_val FROM series; UPDATE series SET val=mod(val + 1, 2); UPDATE seq_calls SET c=c+1; RETURN next_val; END;
CREATE FUNCTION p() RETURNS INTEGER BEGIN DECLARE retn INTEGER; SELECT count(f1) FROM t1 INTO retn; RETURN retn; END
CREATE FUNCTION p() RETURNS INTEGER DETERMINISTIC BEGIN DECLARE retn INTEGER; SELECT count(f1) FROM t1 INTO retn; RETURN retn; END
CREATE FUNCTION round_to_step(i INT, n INT) RETURNS INT BEGIN DECLARE step INT; SELECT * INTO step FROM t_step; RETURN FLOOR((i % (step * n) + 0.1) / step); END
CREATE FUNCTION seq_1_to_2() RETURNS INT BEGIN DECLARE limit_value, return_value INT; SET limit_value = 2; SELECT c1 INTO return_value FROM tr; IF (return_value < limit_value) THEN UPDATE tr SET c1 = c1 + 1; ELSE UPDATE tr SET c1 = 1; END IF; RETURN (return_value); END
CREATE FUNCTION service_get_write_locks RETURNS INT SONAME "$LOCKING_SERVICE"
CREATE FUNCTION service_release_locks   RETURNS INT SONAME "$LOCKING_SERVICE"
CREATE FUNCTION sf_a_from_t1b(s varchar(128)) RETURNS INT BEGIN DECLARE i INT; SELECT a INTO i FROM t1 where b = s; RETURN i; END
CREATE FUNCTION sf_a_from_t1b_d(s varchar(128)) RETURNS INT DETERMINISTIC BEGIN DECLARE i INT; SELECT a INTO i FROM t1 where b = s; RETURN i; END
CREATE FUNCTION testQuestion() RETURNS INTEGER BEGIN DECLARE foo INTEGER; DECLARE bar INTEGER; SET foo=1; SET bar=2; RETURN foo; END
CREATE FUNCTION test_fn() RETURNS INTEGER BEGIN DECLARE rId bigint; RETURN rId; END
CREATE FUNCTION test_fn2() RETURNS INTEGER BEGIN DECLARE rId bigint; RETURN rId; END
CREATE FUNCTION test_func1 (s char(20) RETURNS CHAR(50) RETURN CONCAT('Hello', ,s,'!')
CREATE FUNCTION test_func1 (s char(20) RETURNS CHAR(50) RETURN CONCAT('Hello', ,s,'!')
CREATE FUNCTION test_function(var CHAR(50)) RETURNS CHAR(50) BEGIN DECLARE char_val CHAR(50); SELECT c1 INTO char_val FROM test_table WHERE c1=var; RETURN char_val; END
CREATE FUNCTION test_function(var CHAR(50)) RETURNS CHAR(50) BEGIN DECLARE char_val CHAR(50); SELECT c1 INTO char_val FROM test_table WHERE c1=var; RETURN char_val; END
CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_E() RETURNS INT return 15081947
CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_e() RETURNS INT return 15081947
CREATE FUNCTION очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é() RETURNS INT return 15081947
CREATE IF NOT EXISTS PROCEDURE bug14702() BEGIN END
CREATE PROCEDURE BUG_12490() HELP CONTENTS
CREATE PROCEDURE IF NOT EXISTS bug14702() BEGIN END
CREATE PROCEDURE SP001() P1: BEGIN DECLARE ENDTABLE INT DEFAULT 0; DECLARE TEMP_NUM INT; DECLARE TEMP_SUM INT; DECLARE C1 CURSOR FOR SELECT F1 FROM t1; DECLARE C2 CURSOR FOR SELECT F1 FROM t2; DECLARE CONTINUE HANDLER FOR NOT FOUND SET ENDTABLE = 1; SET ENDTABLE=0; SET TEMP_SUM=0; SET TEMP_NUM=0; OPEN C1; FETCH C1 INTO TEMP_NUM; WHILE ENDTABLE = 0 DO SET TEMP_SUM=TEMP_NUM+TEMP_SUM; FETCH C1 INTO TEMP_NUM; END WHILE; SELECT TEMP_SUM; CLOSE C1; CLOSE C1; SELECT 'end of proc'; END P1
CREATE PROCEDURE `XXX2`() begin declare testval varchar(10); set testval = 'hello'; select metaphon(testval); end
CREATE PROCEDURE `bug13549_1`() begin declare done int default 0; set done= not done; end
CREATE PROCEDURE `bug9056_proc1`(IN a INT, IN b INT, OUT c INT) BEGIN SELECT a+b INTO c; end
CREATE PROCEDURE a(x INT) BEGIN DECLARE rnd INT; DECLARE cnt INT; WHILE x > 0 DO SET rnd= x % 100; SET cnt = (SELECT COUNT(*) FROM t1 WHERE a = rnd); INSERT INTO t1(a,b) VALUES (rnd, CAST(cnt AS CHAR)); SET x= x - 1; END WHILE; END
CREATE PROCEDURE account.account(OUT ac CHAR(20)) BEGIN SELECT account.`account`.account INTO ac FROM account.account; END
CREATE PROCEDURE bug11758414() BEGIN SET @@GLOBAL.default_storage_engine="MyISAM"; SET @@SESSION.default_storage_engine="MyISAM"; SHOW GLOBAL VARIABLES LIKE 'default_storage_engine'; SHOW SESSION VARIABLES LIKE 'default_storage_engine'; CREATE TABLE t1 (id int); CREATE TABLE t2 (id int) ENGINE=InnoDB; SHOW CREATE TABLE t1; SHOW CREATE TABLE t2; END;
CREATE PROCEDURE bug13012_1() REPAIR TABLE t1
CREATE PROCEDURE bug13095(tbl_name varchar(32)) BEGIN SET @str = CONCAT("CREATE TABLE ", tbl_name, "(stuff char(15))"); SELECT @str; PREPARE stmt FROM @str; EXECUTE stmt; SET @str = CONCAT("INSERT INTO ", tbl_name, " VALUES('row1'),('row2'),('row3')" ); SELECT @str; PREPARE stmt FROM @str; EXECUTE stmt; SET @str = CONCAT("CREATE VIEW bug13095_v1(c1) AS SELECT stuff FROM ", tbl_name); SELECT @str; PREPARE stmt FROM @str; EXECUTE stmt; SELECT * FROM bug13095_v1; SET @str = "DROP VIEW bug13095_v1"; SELECT @str; PREPARE stmt FROM @str; EXECUTE stmt; END
CREATE PROCEDURE bug15231_1() BEGIN DECLARE xid INTEGER; DECLARE xdone INTEGER DEFAULT 0; DECLARE CONTINUE HANDLER FOR NOT FOUND SET xdone = 1; SET xid=NULL; CALL bug15231_2a(xid); SELECT "1,0", xid, xdone; SET xid=NULL; CALL bug15231_2b(xid); SELECT "NULL, 1", xid, xdone; END
CREATE PROCEDURE bug15231_2a(INOUT ioid INTEGER) BEGIN SELECT "Before NOT FOUND condition is triggered" AS '1'; SELECT id INTO ioid FROM t3 WHERE id=ioid; SELECT "After NOT FOUND condtition is triggered" AS '2'; IF ioid IS NULL THEN SET ioid=1; END IF; END
CREATE PROCEDURE bug15231_2b(INOUT ioid INTEGER) BEGIN SELECT id INTO ioid FROM t3 WHERE id=ioid; END
CREATE PROCEDURE bug15231_4() BEGIN DECLARE x DECIMAL(2,1); SET x = 'zap'; SHOW WARNINGS; END
CREATE PROCEDURE bug15231_6() BEGIN DECLARE x DECIMAL(2,1); SET x = 'zap'; SELECT id FROM t3; END
CREATE PROCEDURE bug18037_p1() BEGIN DECLARE v INT DEFAULT @@server_id; END
CREATE PROCEDURE bug18589_p2(arg TEXT) BEGIN DECLARE v TEXT; CALL bug18589_p1(arg, v); SELECT v; END
CREATE PROCEDURE bug20953() BEGIN DECLARE i INT; CREATE VIEW v AS SELECT i; END
CREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 FROM (SELECT 1) AS d1
CREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO @a
CREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO DUMPFILE "file"
CREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO OUTFILE "file"
CREATE PROCEDURE bug20953(i INT) CREATE VIEW v AS SELECT i
CREATE PROCEDURE bug21013(IN lim INT) BEGIN DECLARE i INT DEFAULT 0; WHILE (i < lim) DO SET @b = LOCATE(_latin1'b', @a, 1); SET i = i + 1; END WHILE; END
CREATE PROCEDURE bug22580_proc_1() BEGIN CALL bug22580_proc_2(); END|
CREATE PROCEDURE bug22580_proc_2() BEGIN DROP TABLE IF EXISTS bug22580_tmp; CREATE TEMPORARY TABLE bug22580_tmp (a INT); DROP TABLE bug22580_tmp; END|
CREATE PROCEDURE bug24117() BEGIN DECLARE t3c1 ENUM('abc'); DECLARE mycursor CURSOR FOR SELECT c1 FROM t3; OPEN mycursor; FLUSH TABLES; FETCH mycursor INTO t3c1; CLOSE mycursor; END
CREATE PROCEDURE bug27415_text_test(entity_id_str_in text) BEGIN DECLARE str_remainder text; SET str_remainder = entity_id_str_in; select 'before substr', str_remainder; SET str_remainder = SUBSTRING(str_remainder, 3); select 'after substr', str_remainder; END
CREATE PROCEDURE bug27415_text_test2(entity_id_str_in text) BEGIN DECLARE str_remainder text; DECLARE str_remainder2 text; SET str_remainder2 = entity_id_str_in; select 'before substr', str_remainder2; SET str_remainder = SUBSTRING(str_remainder2, 3); select 'after substr', str_remainder; END
CREATE PROCEDURE bug6866 (_a1 int) BEGIN SELECT * FROM tv WHERE a1 = _a1; END
CREATE PROCEDURE bug9056_proc2(OUT a INT) BEGIN select sum(id) from t1 into a; END
CREATE PROCEDURE check_const_len_sp (IN str_const VARCHAR(4000)) BEGIN DECLARE result VARCHAR(4000); SET result = check_const_len(str_const); insert into const_len_bug values(str_const, result, ""); END
CREATE PROCEDURE cr(IN start BIGINT) BEGIN SET @idx =start; WHILE (@idx > 0) DO CREATE TABLESPACE x; DROP TABLESPACE x; SET @idx = @idx - 1; END WHILE; END
CREATE PROCEDURE crc32_proc (IN a CHAR, OUT b BIGINT) SELECT CRC32(a) INTO b
CREATE PROCEDURE ctest() BEGIN DECLARE i CHAR(16); DECLARE j INT; SET i= 'string'; SET j= 1 + i; END
CREATE PROCEDURE cursor1() BEGIN DECLARE v1 int; DECLARE done INT DEFAULT FALSE; DECLARE cur1 CURSOR FOR SELECT * FROM t1; DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; SET @@session.transaction_isolation='READ-COMMITTED'; OPEN cur1; read_loop: LOOP FETCH cur1 INTO v1; IF done THEN LEAVE read_loop; END IF; END LOOP; SELECT v1; CLOSE cur1; END
CREATE PROCEDURE cursor2() BEGIN DECLARE x int; DECLARE y int; DECLARE c1 CURSOR FOR SELECT * FROM t1 limit 1; DECLARE c2 CURSOR FOR SELECT * FROM t2 limit 1; SET @@session.transaction_isolation='READ-COMMITTED'; OPEN c1; OPEN c2; FETCH c1 INTO x; FETCH c2 INTO y; SELECT (x+y); SELECT "session state sent as part of above SELECT" AS col_heading; CLOSE c1; CLOSE c2; END
CREATE PROCEDURE ddse_access() DROP TABLE mysql.innodb_index_stats(i INTEGER)
CREATE PROCEDURE f1(IN arg TINYINT UNSIGNED) BEGIN DECLARE arg1 TINYINT; select abs('1abcd') into arg; END
CREATE PROCEDURE information_schema.is() BEGIN END
CREATE PROCEDURE mysqltest1.p1() DROP DATABASE mysqltest2
CREATE PROCEDURE p() ANALYZE TABLE v UPDATE HISTOGRAM ON w
CREATE PROCEDURE p() BEGIN DECLARE val INTEGER; SET val = 2; EXPLAIN FORMAT=tree SELECT AVG(f1) FROM (SELECT * FROM t1) as dt WHERE f2 > val; SELECT AVG(f1) FROM (SELECT * FROM t1) as dt WHERE f2 > val; END
CREATE PROCEDURE p() BEGIN of: LOOP LEAVE of; END LOOP of; END
CREATE PROCEDURE p1 ( ) BEGIN DO (SELECT  @next := IFNULL(max(bug_table_seq),0) + 1 FROM v1); INSERT INTO t1 VALUES (1); END
CREATE PROCEDURE p1 () BEGIN DECLARE a DATETIME(6); SET a='2001-01-01 11:22:33.123'; SELECT a; END
CREATE PROCEDURE p1 () BEGIN DECLARE a TIME(6); SET a='11:22:33.123'; SELECT a; END
CREATE PROCEDURE p1 () BEGIN DECLARE a TIMESTAMP(6); SET a='2001-01-01 11:22:33.123'; SELECT a; END
CREATE PROCEDURE p1 () DROP TRIGGER tr1
CREATE PROCEDURE p1 () DROP TRIGGER tr1
CREATE PROCEDURE p1 (arg DECIMAL(64,2)) BEGIN DECLARE var DECIMAL(64,2); SET var = arg; SELECT var; END
CREATE PROCEDURE p1() BEGIN DECLARE CONTINUE HANDLER FOR 1051 BEGIN DROP DATABASE none;  # Error 1008 END; DROP TABLE none;  # Error 1051 END
CREATE PROCEDURE p1() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H2' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should be handled by H2. END
CREATE PROCEDURE p1() BEGIN DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN GET CURRENT DIAGNOSTICS CONDITION 1 @msg1 = MESSAGE_TEXT, @errno1 = MYSQL_ERRNO; GET STACKED DIAGNOSTICS CONDITION 1 @msg2 = MESSAGE_TEXT, @errno2 = MYSQL_ERRNO; SELECT @msg1, @errno1; SELECT @msg2, @errno2; SELECT * FROM t1;   # Clear first diagnostics area GET CURRENT DIAGNOSTICS @cno = NUMBER; SELECT @cno; GET STACKED DIAGNOSTICS CONDITION 1 @msg4 = MESSAGE_TEXT, @errno4 = MYSQL_ERRNO; SELECT @msg4, @errno4; END; DROP TABLE non_existent; END
CREATE PROCEDURE p1() BEGIN DECLARE `get` INT DEFAULT 1; SELECT `get`; END
CREATE PROCEDURE p1() BEGIN DECLARE a DATETIME(6); CREATE TABLE t1 AS SELECT a; SHOW CREATE TABLE t1; DROP TABLE t1; END
CREATE PROCEDURE p1() BEGIN DECLARE a TIME(6); CREATE TABLE t1 AS SELECT a; SHOW CREATE TABLE t1; DROP TABLE t1; END
CREATE PROCEDURE p1() BEGIN DECLARE a TIMESTAMP(6); CREATE TABLE t1 AS SELECT a; SHOW CREATE TABLE t1; DROP TABLE t1; END
CREATE PROCEDURE p1() BEGIN DECLARE c CURSOR FOR SELECT a FROM t1; OPEN c; BEGIN DECLARE v INT; DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN GET DIAGNOSTICS @n = NUMBER; GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT; SELECT "Warning found!"; SELECT @err_no, @err_txt; END; DECLARE EXIT HANDLER FOR NOT FOUND BEGIN GET DIAGNOSTICS @n = NUMBER; GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT; SELECT "End of Result Set found!"; SELECT @err_no, @err_txt; END; WHILE TRUE DO FETCH c INTO v; END WHILE; END; CLOSE c; SELECT a INTO @foo FROM t1 LIMIT 1; # Clear warning stack END
CREATE PROCEDURE p1() BEGIN DECLARE c CURSOR FOR SELECT a FROM t1; OPEN c; BEGIN DECLARE v1 INT; DECLARE v2 INT; DECLARE EXIT HANDLER FOR SQLEXCEPTION SELECT "Error caught (expected)"; DECLARE EXIT HANDLER FOR NOT FOUND SELECT "End of Result Set found!"; WHILE TRUE DO FETCH c INTO v1, v2; END WHILE; END; CLOSE c; SELECT a INTO @foo FROM t1 LIMIT 1; # Clear warning stack END
CREATE PROCEDURE p1() BEGIN DECLARE c INT DEFAULT 0; DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN SET c = c + 1; SELECT 'Warning caught!' AS Msg; END; CALL p2(); # 1 warning CALL p3(); # 1 warning CALL p4(); # No warnings CALL p5(); # 1 warning SELECT c; SELECT @@warning_count; SHOW WARNINGS; END
CREATE PROCEDURE p1() BEGIN DECLARE c char(100)
CREATE PROCEDURE p1() BEGIN DECLARE class_origin TEXT DEFAULT "a"; DECLARE subclass_origin TEXT DEFAULT "a"; DECLARE constraint_catalog TEXT DEFAULT "a"; DECLARE constraint_schema TEXT DEFAULT "a"; DECLARE constraint_name TEXT DEFAULT "a"; DECLARE catalog_name TEXT DEFAULT "a"; DECLARE schema_name TEXT DEFAULT "a"; DECLARE table_name TEXT DEFAULT "a"; DECLARE column_name TEXT DEFAULT "a"; DECLARE cursor_name TEXT DEFAULT "a"; DECLARE message_text TEXT DEFAULT "a"; DECLARE mysql_errno INT DEFAULT 1; DECLARE returned_sqlstate TEXT DEFAULT "a"; SELECT CAST(-19999999999999999999 AS SIGNED); GET DIAGNOSTICS CONDITION 1 class_origin = CLASS_ORIGIN, subclass_origin = SUBCLASS_ORIGIN, constraint_catalog = CONSTRAINT_CATALOG, constraint_schema = CONSTRAINT_SCHEMA, constraint_name = CONSTRAINT_NAME, catalog_name = CATALOG_NAME, schema_name = SCHEMA_NAME, table_name = TABLE_NAME, column_name = COLUMN_NAME, cursor_name = CURSOR_NAME, message_text = MESSAGE_TEXT, mysql_errno = MYSQL_ERRNO, returned_sqlstate = RETURNED_SQLSTATE; SELECT class_origin, subclass_origin, constraint_catalog, constraint_schema, constraint_name, catalog_name, schema_name, table_name, column_name, cursor_name, message_text, mysql_errno, returned_sqlstate; END
CREATE PROCEDURE p1() BEGIN DECLARE cond INT DEFAULT 1; DECLARE var INT; GET DIAGNOSTICS CONDITION cond var = CLASS_ORIGIN; END
CREATE PROCEDURE p1() BEGIN DECLARE cond TEXT; DECLARE var INT; GET DIAGNOSTICS CONDITION cond var = CLASS_ORIGIN; END
CREATE PROCEDURE p1() BEGIN DECLARE current INT DEFAULT 1; DECLARE diagnostics INT DEFAULT 2; DECLARE number INT DEFAULT 3; DECLARE returned_sqlstate INT DEFAULT 4; SELECT current, diagnostics, number, returned_sqlstate; END
CREATE PROCEDURE p1() BEGIN DECLARE dummy int default 0; CASE 12 WHEN 12 THEN SET dummy = 0; END CASE; END
CREATE PROCEDURE p1() BEGIN DECLARE errno INT DEFAULT 0; DECLARE msg TEXT DEFAULT "foo"; DECLARE cond CONDITION FOR SQLSTATE "01234"; DECLARE CONTINUE HANDLER for 1012 BEGIN GET DIAGNOSTICS CONDITION 1 errno = MYSQL_ERRNO, msg = MESSAGE_TEXT; END; SIGNAL cond SET MESSAGE_TEXT = "Signal message", MYSQL_ERRNO = 1012; SELECT errno, msg; END
CREATE PROCEDURE p1() BEGIN DECLARE errno1 INT; DECLARE errno2 INT; DECLARE msg1 TEXT; DECLARE msg2 TEXT; SELECT CAST(-19999999999999999999 AS SIGNED); GET DIAGNOSTICS CONDITION 99999 msg1 = MESSAGE_TEXT; GET DIAGNOSTICS CONDITION 1 errno1 = MYSQL_ERRNO, msg1 = MESSAGE_TEXT; GET DIAGNOSTICS CONDITION 2 errno2 = MYSQL_ERRNO, msg2 = MESSAGE_TEXT; SELECT errno1, msg1, errno2, msg2; END
CREATE PROCEDURE p1() BEGIN DECLARE export INT; END
CREATE PROCEDURE p1() BEGIN DECLARE f1 INT; DECLARE f2 INT; DECLARE f3 INT; DECLARE x INT DEFAULT 1; DECLARE y INT DEFAULT 2; DECLARE c CURSOR FOR SELECT x, y, t1.a FROM t1; ALTER TABLE t1 ADD COLUMN b INT; BEGIN DECLARE x INT DEFAULT 10; DECLARE y INT DEFAULT 20; OPEN c; FETCH c INTO f1, f2, f3; SELECT f1, f2, f3; CLOSE c; END; END
CREATE PROCEDURE p1() BEGIN DECLARE get INT DEFAULT 1; END
CREATE PROCEDURE p1() BEGIN DECLARE number INT; DECLARE row_count INT; SELECT CAST(-19999999999999999999 AS SIGNED), CAST(-19999999999999999999 AS SIGNED); GET DIAGNOSTICS number = NUMBER; CREATE TABLE t1 (a INT); INSERT INTO t1 VALUES (1),(2),(3); GET DIAGNOSTICS row_count = ROW_COUNT; DROP TABLE t1; SELECT number, row_count; END
CREATE PROCEDURE p1() BEGIN DECLARE only INT DEFAULT 1; END
CREATE PROCEDURE p1() BEGIN DECLARE slow INT; DECLARE general INT; DECLARE ignore_server_ids INT; DECLARE master_heartbeat_period INT; SELECT max(t1.slow) INTO slow FROM t1; SELECT max(t1.general) INTO general FROM t1; SELECT max(t1.ignore_server_ids) INTO ignore_server_ids FROM t1; SELECT max(t1.master_heartbeat_period) INTO master_heartbeat_period FROM t1; SELECT slow, general, ignore_server_ids, master_heartbeat_period; END
CREATE PROCEDURE p1() BEGIN DECLARE sp_var INTEGER; SELECT col INTO sp_var FROM t1 LIMIT 1; SHOW WARNINGS; SET @user_var = sp_var; SELECT sp_var; SELECT @user_var; END
CREATE PROCEDURE p1() BEGIN DECLARE stacked INT DEFAULT 1; SELECT stacked; END
CREATE PROCEDURE p1() BEGIN DECLARE v CHAR(1); CREATE TABLE IF NOT EXISTS t1 (a INT); GET DIAGNOSTICS CONDITION 1 v = MESSAGE_TEXT; SELECT v; END
CREATE PROCEDURE p1() BEGIN DECLARE v INT DEFAULT (SELECT * FROM t1); SELECT v; END
CREATE PROCEDURE p1() BEGIN DECLARE v INT; DECLARE c CURSOR FOR SELECT * FROM t1; ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2; ALTER TABLE t1 DROP COLUMN a; OPEN c; FETCH c INTO v; CLOSE c; SELECT v; END
CREATE PROCEDURE p1() BEGIN DECLARE v INT; DECLARE c CURSOR FOR SELECT * FROM t1; ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2; ALTER TABLE t1 DROP COLUMN a; OPEN c; FETCH c INTO v; CLOSE c; SELECT v; END
CREATE PROCEDURE p1() BEGIN DECLARE v INT; DECLARE c CURSOR FOR SELECT * FROM t1; OPEN c; ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2; ALTER TABLE t1 DROP COLUMN a; FETCH c INTO v; CLOSE c; SELECT v; END
CREATE PROCEDURE p1() BEGIN DECLARE v TINYINT DEFAULT 1e200; SELECT v; END
CREATE PROCEDURE p1() BEGIN DECLARE v VARCHAR(64); DECLARE CONTINUE HANDLER FOR SQLEXCEPTION GET DIAGNOSTICS CONDITION 1 v = TABLE_NAME; DROP TABLE no_such_table; SELECT v; END
CREATE PROCEDURE p1() BEGIN DECLARE v1 BIT; DECLARE v2 BIT(1); DECLARE v3 BIT(3) DEFAULT b'101'; DECLARE v4 BIT(64) DEFAULT 0x5555555555555555; DECLARE v5 BIT(3); DECLARE v6 BIT(64); DECLARE v7 BIT(8) DEFAULT 128; DECLARE v8 BIT(8) DEFAULT '128'; DECLARE v9 BIT(8) DEFAULT ' 128'; DECLARE v10 BIT(8) DEFAULT 'x 128'; SET v1 = v4; SET v2 = 0; SET v5 = v4; # check overflow SHOW WARNINGS; SET v6 = v3; # check padding SELECT HEX(v1); SELECT HEX(v2); SELECT HEX(v3); SELECT HEX(v4); SELECT HEX(v5); SELECT HEX(v6); SELECT HEX(v7); SELECT HEX(v8); SELECT HEX(v9); SELECT HEX(v10); END
CREATE PROCEDURE p1() BEGIN DECLARE v1 DOUBLE(10,3); SET v1= 100; SET @s = CONCAT('########################################', 40 , v1); SELECT @s; END;
CREATE PROCEDURE p1() BEGIN DECLARE v_char VARCHAR(255); DECLARE v_text TEXT DEFAULT ''; SET v_char = 'abc'; SET v_text = v_char; SET v_char = 'def'; SET v_text = concat(v_text, '|', v_char); SELECT v_text; END
CREATE PROCEDURE p1() BEGIN DECLARE var  INT; DECLARE var1 INT; DECLARE var2 INT; GET DIAGNOSTICS CONDITION 1 var = CLASS_ORIGIN; GET DIAGNOSTICS CONDITION 1 var = SUBCLASS_ORIGIN; GET DIAGNOSTICS CONDITION 1 var1 = CLASS_ORIGIN, var2 = SUBCLASS_ORIGIN; GET DIAGNOSTICS CONDITION 1 var1 = SUBCLASS_ORIGIN, var2 = CLASS_ORIGIN; END
CREATE PROCEDURE p1() BEGIN DECLARE var  INT; DECLARE var1 INT; DECLARE var2 INT; GET DIAGNOSTICS var = NUMBER; GET DIAGNOSTICS var = ROW_COUNT; GET DIAGNOSTICS var1 = NUMBER, var2 = ROW_COUNT; GET DIAGNOSTICS var1 = ROW_COUNT, var2 = NUMBER; END
CREATE PROCEDURE p1() BEGIN DECLARE var CONDITION FOR SQLSTATE '12345'; GET DIAGNOSTICS CONDITION 1 var = NUMBER; END
CREATE PROCEDURE p1() BEGIN DECLARE var CONDITION FOR SQLSTATE '12345'; GET DIAGNOSTICS var = NUMBER; END
CREATE PROCEDURE p1() BEGIN DECLARE var INT; GET DIAGNOSTICS CONDITION 1 var = CLASS_ORIGIN, var1 = SUBCLASS_ORIGIN; END
CREATE PROCEDURE p1() BEGIN DECLARE var INT; GET DIAGNOSTICS CONDITION 1 var = INVALID; END
CREATE PROCEDURE p1() BEGIN DECLARE var INT; GET DIAGNOSTICS CONDITION 1 var; END
CREATE PROCEDURE p1() BEGIN DECLARE var INT; GET DIAGNOSTICS var = INVALID; END
CREATE PROCEDURE p1() BEGIN DECLARE var INT; GET DIAGNOSTICS var = NUMBER, @var = NUMBER; SELECT var, @var; END
CREATE PROCEDURE p1() BEGIN DECLARE var INT; GET DIAGNOSTICS var = NUMBER, var1 = ROW_COUNT; END
CREATE PROCEDURE p1() BEGIN DECLARE var INT; GET DIAGNOSTICS var; END
CREATE PROCEDURE p1() BEGIN DECLARE var1 INTEGER DEFAULT 'string'; DECLARE EXIT HANDLER FOR SQLWARNING SELECT 'H1'; END
CREATE PROCEDURE p1() BEGIN DECLARE x INT; SET x = (SELECT * FROM t1); SELECT x; END
CREATE PROCEDURE p1() BEGIN DECLARE x1 INT DEFAULT (SELECT 1 + 2); DECLARE x2 INT DEFAULT (SELECT * FROM (SELECT 1 + 2) t1); DECLARE x3 INT DEFAULT (SELECT * FROM t1); DECLARE x4 INT DEFAULT (SELECT * FROM t2); DECLARE x5 INT DEFAULT (SELECT * FROM t3); DECLARE x6 INT DEFAULT (SELECT f()); DECLARE c1 CURSOR FOR SELECT (1 + 2) FROM dual; DECLARE c2 CURSOR FOR SELECT * FROM (SELECT 1 + 2) t1; DECLARE c3 CURSOR FOR SELECT * FROM t1; DECLARE c4 CURSOR FOR SELECT * FROM t2; DECLARE c5 CURSOR FOR SELECT * FROM t3; DECLARE c6 CURSOR FOR SELECT f(); IF (SELECT 1 + 2) THEN SET @dummy = 1; END IF; IF (SELECT * FROM (SELECT 1 + 2) t1) THEN SET @dummy = 1; END IF; IF (SELECT * FROM t1) THEN SET @dummy = 1; END IF; IF (SELECT * FROM t2) THEN SET @dummy = 1; END IF; IF (SELECT * FROM t3) THEN SET @dummy = 1; END IF; IF (SELECT f()) THEN SET @dummy = 1; END IF; SET x1 = (SELECT 1 + 2); SET x1 = (SELECT * FROM (SELECT 1 + 2) t1); SET x1 = (SELECT * FROM t1); SET x1 = (SELECT * FROM t2); SET x1 = (SELECT * FROM t3); SET x1 = (SELECT f()); CASE WHEN (SELECT 1 + 2) = 1                     THEN SET @dummy = 1; WHEN (SELECT * FROM (SELECT 1 + 2) t1) = 2  THEN SET @dummy = 1; WHEN (SELECT * FROM t1) = 3                 THEN SET @dummy = 1; WHEN (SELECT * FROM t2) = 3                 THEN SET @dummy = 1; WHEN (SELECT * FROM t3) = 3                 THEN SET @dummy = 1; WHEN (SELECT f()) = 3                       THEN SET @dummy = 1; END CASE; CASE (SELECT 1 + 2) WHEN 1 THEN SET @dummy = 1; ELSE SET @dummy = 1; END CASE; CASE (SELECT * FROM (SELECT 1 + 2) t1) WHEN 1 THEN SET @dummy = 1; ELSE SET @dummy = 1; END CASE; CASE (SELECT * FROM t1) WHEN 1 THEN SET @dummy = 1; ELSE SET @dummy = 1; END CASE; CASE (SELECT * FROM t2) WHEN 1 THEN SET @dummy = 1; ELSE SET @dummy = 1; END CASE; CASE (SELECT * FROM t3) WHEN 1 THEN SET @dummy = 1; ELSE SET @dummy = 1; END CASE; CASE (SELECT f()) WHEN 1 THEN SET @dummy = 1; ELSE SET @dummy = 1; END CASE; WHILE (SELECT 1 - 1) DO SET @dummy = 1; END WHILE; WHILE (SELECT * FROM (SELECT 1 - 1) t1) DO SET @dummy = 1; END WHILE; WHILE (SELECT * FROM t1) - 10 DO SET @dummy = 1; END WHILE; WHILE (SELECT * FROM t2) - 10 DO SET @dummy = 1; END WHILE; WHILE (SELECT * FROM t3) - 10 DO SET @dummy = 1; END WHILE; WHILE (SELECT f()) - 1 DO SET @dummy = 1; END WHILE; REPEAT SET @dummy = 1; UNTIL (SELECT 1 - 1) END REPEAT; REPEAT SET @dummy = 1; UNTIL (SELECT * FROM (SELECT 1 - 1) t1) END REPEAT; REPEAT SET @dummy = 1; UNTIL (SELECT * FROM t1) - 10 END REPEAT; REPEAT SET @dummy = 1; UNTIL (SELECT * FROM t2) - 10 END REPEAT; REPEAT SET @dummy = 1; UNTIL (SELECT * FROM t3) - 10 END REPEAT; REPEAT SET @dummy = 1; UNTIL (SELECT f()) - 1 END REPEAT; END
CREATE PROCEDURE p1() BEGIN DROP VIEW v1; CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b, 3 AS c; END
CREATE PROCEDURE p1() BEGIN DROP VIEW v1; CREATE VIEW v1 AS SELECT 2 AS b, 3 AS c; END
CREATE PROCEDURE p1() BEGIN GET DIAGNOSTICS CONDITION 1 var; END
CREATE PROCEDURE p1() BEGIN GET DIAGNOSTICS var; END
CREATE PROCEDURE p1() BEGIN SET @@SESSION.GTID_NEXT = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:2'; START TRANSACTION; COMMIT; SET @@SESSION.GTID_NEXT = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:3'; START TRANSACTION; COMMIT; END
CREATE PROCEDURE p1() BEGIN SHOW CREATE PROCEDURE p1; SELECT get_lock("test", 100000); SHOW CREATE PROCEDURE p1; END
CREATE PROCEDURE p1() BEGIN skip: LOOP LEAVE skip; END LOOP skip; END
CREATE PROCEDURE p1() CREATE INDEX idx ON t1 (c1)
CREATE PROCEDURE p1() CREATE VIEW v1 AS SELECT * FROM t1
CREATE PROCEDURE p1() LOAD DATA INFILE '../../std_data/loaddata_utf8.dat' INTO TABLE t1
CREATE PROCEDURE p1() RENAME TABLE t2 TO t3
CREATE PROCEDURE p1() SET @a :=1
CREATE PROCEDURE p1() SET PASSWORD FOR u1@h = '12345'
CREATE PROCEDURE p1() SET SESSION TRANSACTION READ ONLY
CREATE PROCEDURE p1() SET SESSION TRANSACTION READ ONLY, ISOLATION LEVEL SERIALIZABLE
CREATE PROCEDURE p1() SHOW ENGINE INNODB STATUS;
CREATE PROCEDURE p1(IN a FLOAT UNSIGNED, OUT b DOUBLE UNSIGNED) BEGIN SELECT 1 INTO b; END|
CREATE PROCEDURE p1(IN a FLOAT(255,0), OUT b DOUBLE(12,3)) BEGIN SELECT 1 INTO b; END|
CREATE PROCEDURE p1(IN number INT) BEGIN SELECT number; GET DIAGNOSTICS number = NUMBER; SELECT number; END
CREATE PROCEDURE p1(IN param INT) LANGUAGE SQL BEGIN DECLARE v INT DEFAULT 0; DECLARE rcount_each INT; DECLARE rcount_total INT DEFAULT 0; WHILE v < 5 DO UPDATE t1 SET a = a * 1.1  WHERE b = param; GET DIAGNOSTICS rcount_each = ROW_COUNT; SET rcount_total = rcount_total + rcount_each; SET v = v + 1; END WHILE; SELECT rcount_total; END
CREATE PROCEDURE p1(IN val BLOB) BEGIN SET @tval = val; SET @sql_cmd = CONCAT_WS(' ', 'insert into t1(f1) values(?)'); PREPARE stmt FROM @sql_cmd; EXECUTE stmt USING @tval; DEALLOCATE PREPARE stmt; END
CREATE PROCEDURE p1(OUT number INT, INOUT message TEXT) BEGIN DECLARE warn CONDITION FOR SQLSTATE "01234"; DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN GET DIAGNOSTICS number = NUMBER; GET DIAGNOSTICS CONDITION 1 message = MESSAGE_TEXT; END; SELECT message; SIGNAL warn SET MESSAGE_TEXT = "inout parameter"; END
CREATE PROCEDURE p1(arg VARCHAR(255)) BEGIN INSERT INTO t1 VALUES('p1: step1'); CASE arg * 10 WHEN 10 * 10 THEN INSERT INTO t1 VALUES('p1: case1: on 10'); WHEN 10 * 10 + 10 * 10 THEN BEGIN CASE arg / 10 WHEN 1 THEN INSERT INTO t1 VALUES('p1: case1: case2: on 1'); WHEN 2 THEN BEGIN DECLARE i TINYINT DEFAULT 10; WHILE i > 0 DO INSERT INTO t1 VALUES(CONCAT('p1: case1: case2: loop: i: ', i)); CASE MOD(i, 2) WHEN 0 THEN INSERT INTO t1 VALUES('p1: case1: case2: loop: i is even'); WHEN 1 THEN INSERT INTO t1 VALUES('p1: case1: case2: loop: i is odd'); ELSE INSERT INTO t1 VALUES('p1: case1: case2: loop: ERROR'); END CASE; SET i = i - 1; END WHILE; END; ELSE INSERT INTO t1 VALUES('p1: case1: case2: ERROR'); END CASE; CASE arg WHEN 10 THEN INSERT INTO t1 VALUES('p1: case1: case3: on 10'); WHEN 20 THEN INSERT INTO t1 VALUES('p1: case1: case3: on 20'); ELSE INSERT INTO t1 VALUES('p1: case1: case3: ERROR'); END CASE; END; ELSE INSERT INTO t1 VALUES('p1: case1: ERROR'); END CASE; CASE arg * 10 WHEN 10 * 10 THEN INSERT INTO t1 VALUES('p1: case4: on 10'); WHEN 10 * 10 + 10 * 10 THEN BEGIN CASE arg / 10 WHEN 1 THEN INSERT INTO t1 VALUES('p1: case4: case5: on 1'); WHEN 2 THEN BEGIN DECLARE i TINYINT DEFAULT 10; WHILE i > 0 DO INSERT INTO t1 VALUES(CONCAT('p1: case4: case5: loop: i: ', i)); CASE MOD(i, 2) WHEN 0 THEN INSERT INTO t1 VALUES('p1: case4: case5: loop: i is even'); WHEN 1 THEN INSERT INTO t1 VALUES('p1: case4: case5: loop: i is odd'); ELSE INSERT INTO t1 VALUES('p1: case4: case5: loop: ERROR'); END CASE; SET i = i - 1; END WHILE; END; ELSE INSERT INTO t1 VALUES('p1: case4: case5: ERROR'); END CASE; CASE arg WHEN 10 THEN INSERT INTO t1 VALUES('p1: case4: case6: on 10'); WHEN 20 THEN INSERT INTO t1 VALUES('p1: case4: case6: on 20'); ELSE INSERT INTO t1 VALUES('p1: case4: case6: ERROR'); END CASE; END; ELSE INSERT INTO t1 VALUES('p1: case4: ERROR'); END CASE; END
CREATE PROCEDURE p1(arg1 BINARY(2), arg2 VARBINARY(2)) BEGIN DECLARE var1 BINARY(2) DEFAULT 0x41; DECLARE var2 VARBINARY(2) DEFAULT 0x42; SELECT HEX(arg1), HEX(arg2); SELECT HEX(var1), HEX(var2); END
CREATE PROCEDURE p1(n INT) DO NTILE(n) OVER()
CREATE PROCEDURE p1(x DATETIME) BEGIN CREATE TABLE t1 SELECT x; SHOW CREATE TABLE t1; DROP TABLE t1; END
CREATE PROCEDURE p10() BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H2' AS HandlerId; BEGIN BEGIN BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H1:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H1:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H2:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H2:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H3:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H3:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H4:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H4:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H5:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H5:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H6:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H6:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN SELECT 'H2' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should be handled by H1. END; SELECT 'S6' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S5' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S4' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S3' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S2' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S1' AS SignalId; SIGNAL SQLSTATE 'HY000'; # Should be handled by H2. END; END; END; END
CREATE PROCEDURE p10_ps_with_warning () BEGIN DECLARE CONTINUE HANDLER FOR 1050 SELECT "a warn place"; EXECUTE stmt1; END
CREATE PROCEDURE p11() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H2' AS HandlerId; BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000', 1249 BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H3' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H4' AS HandlerId; BEGIN SELECT 'H5' AS HandlerId; SELECT 'S3' AS SignalId; SIGNAL SQLSTATE 'HY000'; # H3 SELECT 'S4' AS SignalId; SIGNAL SQLSTATE '22003'; # H3 SELECT 'S5' AS SignalId; SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1249; # H4 END; END; SELECT 'S6' AS SignalId; SIGNAL SQLSTATE 'HY000'; # H1 SELECT 'S7' AS SignalId; SIGNAL SQLSTATE '22003'; # H1 SELECT 'S8' AS SignalId; SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1249; # H5 END; SELECT 'S1' AS SignalId; SIGNAL SQLSTATE 'HY000'; # H1 SELECT 'S2' AS SignalId; SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1249; # H2 END
CREATE PROCEDURE p2 () BEGIN DECLARE p LONGTEXT CHARACTER SET UTF8 DEFAULT '<Ñ><r>A</r></Ñ>'; SELECT EXTRACTVALUE(p,'/Ñ/r'); END
CREATE PROCEDURE p2() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H2' AS HandlerId; BEGIN SELECT 'B1' AS BlockId; BEGIN SELECT 'B2' AS BlockId; BEGIN SELECT 'B3' AS BlockId; SIGNAL SQLSTATE '01000'; # Should be handled by H2. END; END; END; END
CREATE PROCEDURE p2() BEGIN DECLARE EXIT HANDLER FOR SQLSTATE '23000' # (ER_DUP_ENTRY) BEGIN SELECT 'Duplication handled!'; END; CALL p1(); END
CREATE PROCEDURE p2() BEGIN DECLARE i TINYINT DEFAULT 3; WHILE i > 0 DO IF MOD(i, 2) = 0 THEN SET @_test_session_var = 10; ELSE SET @_test_session_var = 'test'; END IF; CASE @_test_session_var WHEN 10 THEN INSERT INTO t1 VALUES('p2: case: numerical type'); WHEN 'test' THEN INSERT INTO t1 VALUES('p2: case: string type'); ELSE INSERT INTO t1 VALUES('p2: case: ERROR'); END CASE; SET i = i - 1; END WHILE; END
CREATE PROCEDURE p2() BEGIN DECLARE n INT DEFAULT 2; general: WHILE n > 0 DO SET n = n -1; END WHILE general; SET n = 2; slow: WHILE n > 0 DO SET n = n -1; END WHILE slow; SET n = 2; ignore_server_ids: WHILE n > 0 DO SET n = n -1; END WHILE ignore_server_ids; SET n = 2; master_heartbeat_period: WHILE n > 0 DO SET n = n -1; END WHILE master_heartbeat_period; END
CREATE PROCEDURE p2() BEGIN DECLARE v DECIMAL(5) DEFAULT 1e200; SELECT v; END
CREATE PROCEDURE p2() BEGIN DECLARE v INT DEFAULT 1; IF v * (SELECT * FROM t1) THEN SELECT 1; ELSE SELECT 2; END IF; END
CREATE PROCEDURE p2() BEGIN DECLARE vb BIT(1); SELECT b INTO vb FROM t1 WHERE b = 0; SELECT HEX(vb), vb = 0, vb = FALSE, vb IS FALSE, vb = 1, vb = TRUE, vb IS TRUE; SELECT b INTO vb FROM t1 WHERE b = 1; SELECT HEX(vb), vb = 0, vb = FALSE, vb IS FALSE, vb = 1, vb = TRUE, vb IS TRUE; END
CREATE PROCEDURE p2() BEGIN SELECT CAST('2x' as unsigned integer); END| # 1 warning is passed to the caller CREATE PROCEDURE p3() BEGIN SELECT CAST('3x' as unsigned integer); GET DIAGNOSTICS @n = NUMBER; # does not clear the warning END| # 1 warning is passed to the caller CREATE PROCEDURE p4() BEGIN SELECT CAST('4x' as unsigned integer); INSERT INTO t1 VALUES(1); # Clears the warning END| # No warnings to pass CREATE PROCEDURE p5() BEGIN SELECT CAST('5x' as unsigned integer); CALL p2(); END
CREATE PROCEDURE p2(arg ENUM('a', 'b')) BEGIN DECLARE var ENUM('c', 'd') DEFAULT arg; SHOW WARNINGS; SELECT arg, var; END
CREATE PROCEDURE p2(n INT) DO LEAD(1, n) OVER()
CREATE PROCEDURE p2_declare_variable_clears () BEGIN DECLARE CONTINUE HANDLER FOR NOT FOUND BEGIN /* DECLARE a variable. This will clear the diagnostics area, so the subsequent GET DIAGNOSTICS will fail. It in turn will flag a warning (not an exception), which will remain unseen, as it in turn gets cleared by the next statement (SELECT). */ DECLARE v1 INT; GET DIAGNOSTICS @n2 = NUMBER; GET DIAGNOSTICS CONDITION 1 @e2 = MYSQL_ERRNO, @t2 = MESSAGE_TEXT; END; SET @n2 = 0, @e2 = 0, @t2 = 'handler was not run or GET DIAGNOSTICS failed'; SIGNAL SQLSTATE '02000' SET MESSAGE_TEXT = 'signal message'; /* Show handler was called, and DA was NOT read intact because of DECLARE VARIABLE. */ SELECT @n2, @e2, @t2; END
CREATE PROCEDURE p3() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN SELECT 'SQLEXCEPTION caught' AS msg; CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b; END; SELECT * FROM v1; SELECT * FROM v1; DROP VIEW v1; END
CREATE PROCEDURE p3() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'H3' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should be handled by H3. END
CREATE PROCEDURE p3() BEGIN DECLARE v CHAR(5) DEFAULT 'abcdef'; SELECT v LIKE 'abc___'; END
CREATE PROCEDURE p3(n INT) DO LAG(1, n) OVER()
CREATE PROCEDURE p4() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'H2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H3' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should be handled by H2. END
CREATE PROCEDURE p4(arg VARCHAR(2)) BEGIN DECLARE var VARCHAR(1); SET var := arg; SELECT arg, var; END
CREATE PROCEDURE p5() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'H2' AS HandlerId; BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H3' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should be handled by H3. END; END
CREATE PROCEDURE p5() BEGIN DECLARE EXIT HANDLER FOR 1292 BEGIN SELECT 'Handler for 1292' AS Msg; SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1234; SHOW WARNINGS; END; INSERT INTO t2 SELECT CAST(999999 AS SIGNED INTEGER), CAST(CONCAT(CAST('2X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER), CAST(CONCAT(CAST('3X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER); END
CREATE PROCEDURE p5(arg CHAR(2)) BEGIN DECLARE var CHAR(1); SET var := arg; SELECT arg, var; END
CREATE PROCEDURE p5_declare_variable_clears () BEGIN DECLARE CONTINUE HANDLER FOR NOT FOUND BEGIN /* DECLARE a VARIABLE with a broken DEFAULT. This will throw a warning at runtime, which GET DIAGNOSTICS will see instead of the previous condition (the SIGNAL). */ DECLARE v1 INT DEFAULT 'meow'; GET DIAGNOSTICS @n5 = NUMBER; GET DIAGNOSTICS CONDITION 1 @e5= MYSQL_ERRNO, @t5 = MESSAGE_TEXT; END; SET @n5 = 0, @e5 = 0, @t5 = 'handler was not run or GET DIAGNOSTICS failed'; SIGNAL SQLSTATE '02000' SET MESSAGE_TEXT = 'signal message'; /* Show handler was called, and DA was NOT read intact because of DECLARE VARIABLE. */ SELECT @n5, @e5, @t5; SELECT "still here, we got a warning, not an exception!"; END
CREATE PROCEDURE p6() BEGIN DECLARE CONTINUE HANDLER FOR 1292 BEGIN SHOW WARNINGS; SELECT 'Handler for 1292' Msg; END; INSERT INTO t2 SELECT CAST(CONCAT(CAST('1X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER), CAST(CONCAT(CAST('2X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER), CAST(CONCAT(CAST('3X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER); END
CREATE PROCEDURE p6() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN SELECT 'H1' AS HandlerId; SIGNAL SQLSTATE 'HY000'; # Should *not* be handled by H1. END; SELECT 'S1' AS SignalId; SIGNAL SQLSTATE 'HY000'; # Should be handled by H1. END
CREATE PROCEDURE p6() BEGIN SELECT CAST('6x' as unsigned integer); SHOW WARNINGS; END
CREATE PROCEDURE p6(arg DECIMAL(2)) BEGIN DECLARE var DECIMAL(1); SET var := arg; SELECT arg, var; END
CREATE PROCEDURE p7() BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN SELECT 'H1' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should *not* be handled by H1. END; SELECT 'S1' AS SignalId; SIGNAL SQLSTATE '01000'; # Should be handled by H1. END
CREATE PROCEDURE p7() BEGIN DECLARE c INT DEFAULT 0; DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN SET c = c + 1; SELECT 'Warning caught!' AS Msg; END; CALL p6(); SELECT c; END
CREATE PROCEDURE p7_show_warnings () BEGIN SHOW VARIABLES LIKE 'foo'; SHOW WARNINGS; SELECT "(SHOW WARNINGS does not have to come last)"; END
CREATE PROCEDURE p8() BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN SELECT 'H2' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should *not* be handled by H1. END; SELECT 'S1' AS SignalId; SIGNAL SQLSTATE 'HY000'; # Should be handled by H2. END
CREATE PROCEDURE p8b_show_warnings () BEGIN SHOW WARNINGS; END
CREATE PROCEDURE p9() BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H1:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H1:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H2:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H2:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H3:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H3:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H4:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H4:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H5:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H5:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H6:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H6:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN SELECT 'H2' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should *not* be handled by H1. END; SELECT 'S6' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S5' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S4' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S3' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S2' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S1' AS SignalId; SIGNAL SQLSTATE 'HY000'; # Should be handled by H2. END
CREATE PROCEDURE p_install() BEGIN INSTALL PLUGIN no_such_plugin SONAME 'no_such_object'; END
CREATE PROCEDURE p_suid(IN i INT) SQL SECURITY DEFINER SET @c:= 0
CREATE PROCEDURE peter1 () BEGIN DECLARE v INTEGER DEFAULT 1234; DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN SHOW WARNINGS; SELECT "handler done: ",v; END; CREATE TABLE gg (smallint_column SMALLINT); CALL peter2(v); END
CREATE PROCEDURE peter2 (INOUT v INTEGER) BEGIN INSERT INTO gg (smallint_column) VALUES (32769); GET DIAGNOSTICS v = ROW_COUNT; END
CREATE PROCEDURE peter3(a DECIMAL(2,2)) BEGIN DECLARE b DECIMAL(2,2) DEFAULT @var; END
CREATE PROCEDURE peter_p1 () BEGIN DECLARE x CONDITION FOR SQLSTATE '42000'; DECLARE EXIT HANDLER FOR x BEGIN SHOW WARNINGS; RESIGNAL x SET MYSQL_ERRNO = 9999; END; BEGIN DECLARE EXIT HANDLER FOR x BEGIN SHOW WARNINGS; RESIGNAL x SET SCHEMA_NAME = 'test', MYSQL_ERRNO= 1232; END; /* Raises ER_WRONG_VALUE_FOR_VAR : 1231, SQLSTATE 42000 */ SET @@sql_mode=NULL; END; END
CREATE PROCEDURE peter_p2 () BEGIN DECLARE x CONDITION for SQLSTATE '42000'; DECLARE EXIT HANDLER FOR x BEGIN SHOW WARNINGS; RESIGNAL x SET MESSAGE_TEXT = 'Hi, I am a useless error message', MYSQL_ERRNO = 9999; END; CALL peter_p1(); END
CREATE PROCEDURE proc (ofs INT, count INT) BEGIN DECLARE i INT DEFAULT ofs; WHILE i < count DO SELECT i AS i; IF LOWER(CHAR(i USING utf8) COLLATE utf8_tolower_ci) != LOWER(CHAR(i USING utf8mb4) COLLATE utf8mb4_0900_as_ci) THEN SELECT i AS 'found funny character'; END IF; SET i = i + 1; END WHILE; END
CREATE PROCEDURE proc1() BEGIN CREATE TABLE t1 (f1 INT) START TRANSACTION; ROLLBACK; CREATE TABLE t1 (f1 INT) START TRANSACTION; COMMIT; END
CREATE PROCEDURE proc1() BEGIN DECLARE i INT; SELECT (func1() + COUNT(*)) INTO i FROM information_schema.tables m JOIN information_schema.columns n ON m.table_name = n.table_name WHERE m.table_name='db'; INSERT INTO t1 VALUES (i); END
CREATE PROCEDURE proc3() BEGIN DECLARE x CHAR(36); SET x=UUID(); END
CREATE PROCEDURE proc6369() EXPLAIN FOR CONNECTION 1
CREATE PROCEDURE proc_12976_a() BEGIN declare localvar bit(1); SELECT val INTO localvar FROM table_12976_a; SELECT coalesce(localvar, 1)+1, coalesce(val, 1)+1 FROM table_12976_a; END|
CREATE PROCEDURE proc_12976_b( name varchar(15), out ep bit, out msg varchar(10)) BEGIN SELECT emailperm into ep FROM table_12976_b where (appname = name); IF ep is true THEN SET msg = 'True'; ELSE SET msg = 'False'; END IF; END|
CREATE PROCEDURE proc_19194_codegen( IN proc_name VARCHAR(50), IN count INTEGER, IN simple INTEGER, OUT body MEDIUMTEXT) BEGIN DECLARE code MEDIUMTEXT; DECLARE i INT DEFAULT 1; SET code = concat("CREATE PROCEDURE ", proc_name, "(i INT)\n"); SET code = concat(code, "BEGIN\n"); SET code = concat(code, "  DECLARE str CHAR(10);\n"); IF (simple) THEN SET code = concat(code, "  CASE i\n"); ELSE SET code = concat(code, "  CASE\n"); END IF; WHILE (i <= count) DO IF (simple) THEN SET code = concat(code, "    WHEN ", i, " THEN SET str=\"", i, "\";\n"); ELSE SET code = concat(code, "    WHEN i=", i, " THEN SET str=\"", i, "\";\n"); END IF; SET i = i + 1; END WHILE; SET code = concat(code, "    ELSE SET str=\"unknown\";\n"); SET code = concat(code, "  END CASE;\n"); SET code = concat(code, "  SELECT str;\n"); SET code = concat(code, "END\n"); SET body = code; END
CREATE PROCEDURE proc_19194_nested_1(i int, j int) BEGIN DECLARE str_i CHAR(10); DECLARE str_j CHAR(10); CASE i WHEN 10 THEN SET str_i="10"; WHEN 20 THEN BEGIN set str_i="20"; CASE WHEN j=1 THEN SET str_j="1"; WHEN j=2 THEN SET str_j="2"; WHEN j=3 THEN SET str_j="3"; ELSE SET str_j="unknown"; END CASE; select "i was 20"; END; WHEN 30 THEN SET str_i="30"; WHEN 40 THEN SET str_i="40"; ELSE SET str_i="unknown"; END CASE; SELECT str_i, str_j; END
CREATE PROCEDURE proc_19194_nested_2(i int, j int) BEGIN DECLARE str_i CHAR(10); DECLARE str_j CHAR(10); CASE WHEN i=10 THEN SET str_i="10"; WHEN i=20 THEN BEGIN set str_i="20"; CASE j WHEN 1 THEN SET str_j="1"; WHEN 2 THEN SET str_j="2"; WHEN 3 THEN SET str_j="3"; ELSE SET str_j="unknown"; END CASE; select "i was 20"; END; WHEN i=30 THEN SET str_i="30"; WHEN i=40 THEN SET str_i="40"; ELSE SET str_i="unknown"; END CASE; SELECT str_i, str_j; END
CREATE PROCEDURE proc_19194_nested_3(i int, j int) BEGIN DECLARE str_i CHAR(10); DECLARE str_j CHAR(10); CASE i WHEN 10 THEN SET str_i="10"; WHEN 20 THEN BEGIN set str_i="20"; CASE j WHEN 1 THEN SET str_j="1"; WHEN 2 THEN SET str_j="2"; WHEN 3 THEN SET str_j="3"; ELSE SET str_j="unknown"; END CASE; select "i was 20"; END; WHEN 30 THEN SET str_i="30"; WHEN 40 THEN SET str_i="40"; ELSE SET str_i="unknown"; END CASE; SELECT str_i, str_j; END
CREATE PROCEDURE proc_19194_nested_4(i int, j int) BEGIN DECLARE str_i CHAR(10); DECLARE str_j CHAR(10); CASE WHEN i=10 THEN SET str_i="10"; WHEN i=20 THEN BEGIN set str_i="20"; CASE WHEN j=1 THEN SET str_j="1"; WHEN j=2 THEN SET str_j="2"; WHEN j=3 THEN SET str_j="3"; ELSE SET str_j="unknown"; END CASE; select "i was 20"; END; WHEN i=30 THEN SET str_i="30"; WHEN i=40 THEN SET str_i="40"; ELSE SET str_i="unknown"; END CASE; SELECT str_i, str_j; END
CREATE PROCEDURE proc_19194_searched(i int) BEGIN DECLARE str CHAR(10); CASE WHEN i=1 THEN SET str="1"; WHEN i=2 THEN SET str="2"; WHEN i=3 THEN SET str="3"; ELSE SET str="unknown"; END CASE; SELECT str; END
CREATE PROCEDURE proc_19194_simple(i int) BEGIN DECLARE str CHAR(10); CASE i WHEN 1 THEN SET str="1"; WHEN 2 THEN SET str="2"; WHEN 3 THEN SET str="3"; ELSE SET str="unknown"; END CASE; SELECT str; END
CREATE PROCEDURE proc_35577() BEGIN DECLARE z_done INT DEFAULT 0; DECLARE t_done VARCHAR(5000); outer_loop: LOOP IF t_done=1  THEN LEAVE outer_loop; END IF; inner_block:BEGIN DECLARE z_done INT DEFAULT  0; SET z_done = 0; inner_loop: LOOP IF z_done=1  THEN LEAVE inner_loop; END IF; IF (t_done = 'a') THEN IF (t_done <> 0) THEN IF ( t_done > 0) THEN IF (t_done = 'a') THEN SET t_done = 'a'; ELSEIF (t_done = 'a') THEN SET t_done = 'a'; ELSEIF(t_done = 'a') THEN SET t_done = 'a'; ELSEIF(t_done = 'a') THEN SET t_done = 'a'; ELSEIF(t_done = 'a') THEN SET t_done = 'a'; ELSEIF(t_done = 'a') THEN SET t_done = 'a'; ELSEIF(t_done = 'a') THEN SET t_done = 'a'; ELSEIF(t_done = 'a') THEN SET t_done = 'a'; END IF; END IF; END IF; END IF; END LOOP inner_loop; END inner_block; END LOOP outer_loop; END
CREATE PROCEDURE proc_c() BEGIN DECLARE div_zero INTEGER; SET SQL_MODE='TRADITIONAL'; SELECT 1/0; END
CREATE PROCEDURE run_n_times(x int) BEGIN DECLARE c int; WHILE x DO SET x = x-1; SELECT COUNT(expr_key) INTO c FROM ot WHERE expr_key IN (SELECT expr_nokey FROM it) AND ot.expr_key<100000000; END WHILE; END
CREATE PROCEDURE simpleproc1 (OUT param1 INT) BEGIN SELECT COUNT(*) INTO param1 FROM t1; END
CREATE PROCEDURE simpleproc1 (OUT param1 INT) BEGIN SELECT COUNT(*) INTO param1 FROM t1; END
CREATE PROCEDURE simpleproc2 (OUT param1 INT) BEGIN SELECT COUNT(*) INTO param1 FROM t2; END
CREATE PROCEDURE simpleproc2 (OUT param1 INT) BEGIN SELECT COUNT(*) INTO param1 FROM t2; END
CREATE PROCEDURE sp1() BEGIN DECLARE v1, v2, v3, v4 DECIMAL(28,12); DECLARE v3_2, v4_2 DECIMAL(28, 12); DECLARE counter INT; SET v1 = 1; SET v2 = 2; SET v3 = 1000000000000; SET v4 = 2000000000000; SET counter = 0; WHILE counter < 100000 DO SET v1 = v1 + 0.000000000001; SET v2 = v2 - 0.000000000001; SET v3 = v3 + 1; SET v4 = v4 - 1; SET counter = counter + 1; END WHILE; SET v3_2 = v3 * 0.000000000001; SET v4_2 = v4 * 0.000000000001; SELECT v1, v2, v3, v3_2, v4, v4_2; END
CREATE PROCEDURE sp1() BEGIN DECLARE x NUMERIC ZEROFILL; SELECT f1 INTO x FROM t1 LIMIT 1; END
CREATE PROCEDURE sp1() BEGIN declare x numeric unsigned zerofill; SELECT f1 into x from t2 limit 1; END
CREATE PROCEDURE sp1(OUT x INT) BEGIN SELECT MIN(a) INTO x FROM t1; END
CREATE PROCEDURE sp19857() DETERMINISTIC BEGIN DECLARE a INT; SET a=1; SELECT a; END
CREATE PROCEDURE sp2() BEGIN DECLARE v1 TINYINT DEFAULT 450000; END
CREATE PROCEDURE sp2() BEGIN DECLARE x NUMERIC ZEROFILL; SELECT f1 INTO x FROM t2 LIMIT 1; END
CREATE PROCEDURE sp3() BEGIN DECLARE x NUMERIC ZEROFILL; SELECT f1 INTO x FROM t3 LIMIT 1; END
CREATE PROCEDURE sp_insert_partition(p CHAR(16), a INT, b CHAR(16)) BEGIN SET @str = CONCAT("INSERT INTO test.t1 PARTITION(", p, ") VALUES (?, ?)"); SET @x = a, @y = b; PREPARE stmt FROM @str; EXECUTE stmt USING @x, @y; DEALLOCATE PREPARE stmt; END
CREATE PROCEDURE sp_select_partition(p CHAR(16)) BEGIN SET @str = CONCAT("SELECT * FROM test.t1 PARTITION(", p, ")"); PREPARE stmt FROM @str; EXECUTE stmt; DEALLOCATE PREPARE stmt; END
CREATE PROCEDURE spxml(xml VARCHAR(128)) BEGIN DECLARE c INT; DECLARE i INT DEFAULT 1; SET c= ExtractValue(xml,'count(/a/b)'); SET @i= c; WHILE i <= c DO BEGIN SELECT i, @i, ExtractValue(xml,'/a/b[$i]'), ExtractValue(xml,'/a/b[$@i]'); SET i= i + 1; SET @i= @i - 1; END; END WHILE; END
CREATE PROCEDURE sub1(id CHAR(10) CHARACTER SET utf8) BEGIN SELECT * FROM view1 WHERE table_name=id COLLATE utf8_tolower_ci; EXPLAIN SELECT * FROM view1 WHERE table_name=id COLLATE utf8_tolower_ci; SELECT * FROM view2 WHERE table_name=id; EXPLAIN SELECT * FROM view2 WHERE table_name=id; SELECT * FROM dd_table WHERE name COLLATE utf8_tolower_ci = id; EXPLAIN SELECT * FROM dd_table WHERE name COLLATE utf8_tolower_ci = id; SELECT * FROM view1 WHERE id COLLATE utf8_tolower_ci=table_name; EXPLAIN SELECT * FROM view1 WHERE id COLLATE utf8_tolower_ci=table_name; SELECT * FROM view2 WHERE id=table_name; EXPLAIN SELECT * FROM view2 WHERE id=table_name; SELECT * FROM dd_table WHERE id = name COLLATE utf8_tolower_ci; EXPLAIN SELECT * FROM dd_table WHERE id = name COLLATE utf8_tolower_ci; SELECT * FROM view1 WHERE table_name COLLATE utf8_tolower_ci = id; EXPLAIN SELECT * FROM view1 WHERE table_name COLLATE utf8_tolower_ci = id; END
CREATE PROCEDURE t_cache() BEGIN SET @A= 20; SELECT * FROM t1; SELECT * FROM t1; PREPARE x FROM 'SELECT 1'; SELECT * FROM t1; SELECT * FROM t1; END
CREATE PROCEDURE t_cache() BEGIN SET @A= 20; SELECT * FROM t1; SELECT * FROM t1; PREPARE x FROM 'SELECT 1'; SELECT * FROM t1; SELECT * FROM t1; END ;
CREATE PROCEDURE test27759() BEGIN declare v_a date default '2007-4-10'; declare v_b date default '2007-4-11'; declare v_c datetime default '2004-4-9 0:0:0'; select v_a as a,v_b as b, least( v_a, v_b ) as a_then_b, least( v_b, v_a ) as b_then_a, least( v_c, v_a ) as c_then_a; END;
CREATE PROCEDURE test_hint (hint_str VARCHAR(255), var_str VARCHAR(64)) BEGIN SET @orig_q= CONCAT("SELECT VARIABLE_VALUE FROM performance_schema.session_variables where VARIABLE_NAME = '",  var_str, "'"); SET @hint_q= CONCAT("SELECT /*+ ", hint_str, "*/ VARIABLE_VALUE" , " FROM performance_schema.session_variables where VARIABLE_NAME = '",  var_str, "'"); PREPARE orig_stmt FROM @orig_q; PREPARE hint_stmt FROM @hint_q; EXECUTE orig_stmt; EXECUTE hint_stmt; EXECUTE orig_stmt; DEALLOCATE PREPARE orig_stmt; DEALLOCATE PREPARE hint_stmt; END
CREATE PROCEDURE test_if_commit() BEGIN ROLLBACK; SELECT IF (COUNT(*) > 0, "YES", "NO") AS "IMPLICIT COMMIT" FROM trans; DELETE FROM trans; COMMIT; END
CREATE PROCEDURE test_round(in arg bigint) BEGIN DECLARE i int; SET i = 0; WHILE (i >= -20) DO BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '22003' SHOW ERRORS; SELECT arg, i, round(arg, i); END; SET i = i - 1; END WHILE; END
CREATE PROCEDURE test_round_fn() BEGIN DECLARE num_digits int; SET num_digits := 3; CREATE TEMPORARY TABLE tmp_test ( number double ); INSERT INTO tmp_test VALUES (1),(0); SELECT number, Round(number, num_digits) > 0, Round(number, 3) > 0 FROM tmp_test; SELECT number, Round(number, num_digits) > 0, Round(number, 3) > 0 FROM tmp_test WHERE Round(number, 3) >= 0; SELECT number, Round(number, num_digits) > 0, Round(number, 3) > 0 FROM tmp_test WHERE Round(number, num_digits) >= 0; END
CREATE PROCEDURE test_round_unsigned(in arg bigint unsigned) BEGIN DECLARE i int; SET i = 0; WHILE (i >= -20) DO BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '22003' SHOW ERRORS; SELECT arg, i, round(arg, i); END; SET i = i - 1; END WHILE; END
CREATE PROCEDURE vctest() BEGIN DECLARE i VARCHAR(16); DECLARE j INT; SET i= 'string'; SET j= 1 + i; END
CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_E() BEGIN END
CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_e() BEGIN END
CREATE PROCEDURE очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é() BEGIN END
CREATE ROLE of
CREATE ROLE r1 IDENTIFIED BY 'test'
CREATE ROLE skip
CREATE SPATIAL INDEX USING BTREE ON t2(col)
CREATE TABLE C ( col_int int(11) DEFAULT NULL, col_varchar_10_utf8 varchar(10) CHARACTER SET utf8 DEFAULT NULL, pk int(11) NOT NULL AUTO_INCREMENT, col_varchar_10_latin1 varchar(10) DEFAULT NULL, col_varchar_255_utf8 varchar(255) CHARACTER SET utf8 DEFAULT NULL, col_varchar_255_latin1 varchar(255) DEFAULT NULL, col_int_key int(11) GENERATED ALWAYS AS ((col_int + col_int)) VIRTUAL, col_varchar_255_utf8_key varchar(255) CHARACTER SET utf8 GENERATED ALWAYS AS (concat(repeat(col_varchar_10_utf8,3),repeat(col_varchar_10_utf8,3))) VIRTUAL, col_varchar_255_latin1_key varchar(255) GENERATED ALWAYS AS (concat(repeat(col_varchar_10_latin1,3),repeat(col_varchar_10_latin1,3))) VIRTUAL, col_varchar_10_utf8_key varchar(10) CHARACTER SET utf8 GENERATED ALWAYS AS (repeat(substr(col_varchar_10_utf8,-(1)),5)) VIRTUAL, col_varchar_10_latin1_key varchar(10) GENERATED ALWAYS AS (repeat(substr(col_varchar_10_latin1,-(1)),7)) VIRTUAL, PRIMARY KEY (pk DESC), UNIQUE KEY ucover_key1 (pk DESC, col_int_key DESC, col_varchar_255_utf8_key DESC, col_varchar_255_latin1_key DESC, col_varchar_10_utf8_key DESC, col_varchar_10_latin1_key DESC), UNIQUE KEY ucover_key2 (pk, col_int_key, col_varchar_255_utf8_key, col_varchar_255_latin1_key, col_varchar_10_utf8_key, col_varchar_10_latin1_key), KEY col_int_key (col_int_key DESC), KEY col_varchar_255_utf8_key (col_varchar_255_utf8_key DESC), KEY col_varchar_255_latin1_key (col_varchar_255_latin1_key DESC), KEY col_varchar_10_utf8_key (col_varchar_10_utf8_key DESC), KEY col_varchar_10_latin1_key (col_varchar_10_latin1_key), KEY multi_key1 (col_int_key DESC, col_varchar_10_latin1_key), KEY multi_key1a (col_int_key DESC, col_varchar_10_latin1_key DESC), KEY multi_key2 (col_int_key, col_int DESC), KEY multi_key3 (col_varchar_255_utf8_key DESC, col_varchar_255_utf8), KEY multi_key4 (col_varchar_255_latin1_key, col_varchar_255_latin1), KEY multi_key5 (pk DESC, col_int_key DESC, col_varchar_10_latin1_key), KEY cover_key1 (pk DESC, col_int_key DESC, col_varchar_255_utf8_key, col_varchar_255_latin1_key DESC, col_varchar_10_utf8_key DESC, col_varchar_10_latin1_key) )
CREATE TABLE E ( col_int int(11) DEFAULT NULL, col_varchar_10_utf8 varchar(10) CHARACTER SET utf8 DEFAULT NULL, pk int(11) NOT NULL AUTO_INCREMENT, col_varchar_10_latin1 varchar(10) DEFAULT NULL, col_varchar_255_utf8 varchar(255) CHARACTER SET utf8 DEFAULT NULL, col_varchar_255_latin1 varchar(255) DEFAULT NULL, col_int_key int(11) GENERATED ALWAYS AS ((col_int + col_int)) VIRTUAL, col_varchar_255_utf8_key varchar(255) CHARACTER SET utf8 GENERATED ALWAYS AS (concat(repeat(col_varchar_10_utf8,3),repeat(col_varchar_10_utf8,3))) VIRTUAL, col_varchar_255_latin1_key varchar(255) GENERATED ALWAYS AS (concat(repeat(col_varchar_10_latin1,3),repeat(col_varchar_10_latin1,3))) VIRTUAL, col_varchar_10_utf8_key varchar(10) CHARACTER SET utf8 GENERATED ALWAYS AS (repeat(substr(col_varchar_10_utf8,-(1)),5)) VIRTUAL, col_varchar_10_latin1_key varchar(10) GENERATED ALWAYS AS (repeat(substr(col_varchar_10_latin1,-(1)),7)) VIRTUAL, PRIMARY KEY (pk DESC), UNIQUE KEY ucover_key1 (pk DESC, col_int_key DESC, col_varchar_255_utf8_key DESC, col_varchar_255_latin1_key DESC, col_varchar_10_utf8_key DESC, col_varchar_10_latin1_key DESC), UNIQUE KEY ucover_key2 (pk, col_int_key, col_varchar_255_utf8_key, col_varchar_255_latin1_key, col_varchar_10_utf8_key, col_varchar_10_latin1_key), KEY col_int_key (col_int_key DESC), KEY col_varchar_255_utf8_key (col_varchar_255_utf8_key DESC), KEY col_varchar_255_latin1_key (col_varchar_255_latin1_key DESC), KEY col_varchar_10_utf8_key (col_varchar_10_utf8_key DESC), KEY col_varchar_10_latin1_key (col_varchar_10_latin1_key), KEY multi_key1 (col_int_key DESC, col_varchar_10_latin1_key), KEY multi_key1a (col_int_key DESC, col_varchar_10_latin1_key DESC), KEY multi_key2 (col_int_key,col_int DESC), KEY multi_key3 (col_varchar_255_utf8_key DESC, col_varchar_255_utf8), KEY multi_key4 (col_varchar_255_latin1_key, col_varchar_255_latin1), KEY multi_key5 (pk DESC,col_int_key DESC, col_varchar_10_latin1_key), KEY cover_key1 (pk DESC,col_int_key DESC, col_varchar_255_utf8_key, col_varchar_255_latin1_key DESC, col_varchar_10_utf8_key DESC, col_varchar_10_latin1_key) )
CREATE TABLE IF NOT EXISTS t1 ( f1 bit(2) NOT NULL default b'' ) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci
CREATE TABLE ```a` (i INT)
CREATE TABLE ```ab````cd``` (i INT)
CREATE TABLE ```ab``cd``` (i INT)
CREATE TABLE `t1` ( `a b` INT, `c"d` INT, `e``f` INT, PRIMARY KEY (`a b`, `c"d`, `e``f`) ) ENGINE=MyISAM DEFAULT CHARSET=latin1
CREATE TABLE `t1` ( `a b` INT, `c"d` INT, `e``f` INT, PRIMARY KEY (`a b`, `c"d`, `e``f`) ) ENGINE=MyISAM DEFAULT CHARSET=latin1
CREATE TABLE `t``\""e` (a INT, PRIMARY KEY (a)) ENGINE=InnoDB PARTITION BY RANGE (a) SUBPARTITION BY HASH (a) (PARTITION `p0``\""e` VALUES LESS THAN (100) (SUBPARTITION `sp0``\""e`, SUBPARTITION `sp1``\""e`), PARTITION `p1``\""e` VALUES LESS THAN (MAXVALUE) (SUBPARTITION `sp2``\""e`, SUBPARTITION `sp3``\""e`))
CREATE TABLE at(_bin binary(16), _vbn varbinary(16), _tbl tinyblob, _ttx tinytext, _blb blob)
CREATE TABLE at(_bit bit(64), _tin tinyint(8), _boo bool, _sms smallint signed, _smu smallint unsigned, _mes mediumint signed, _meu mediumint unsigned, _ins int signed, _inu int unsigned, _bis bigint signed, _biu bigint unsigned, _dec decimal (5,2), _flo float, _dou double, _yea year, _jsn json, _chr char(12), _vch varchar(12), _bin binary(255), _vbn varbinary(255), _tbl tinyblob, _ttx tinytext, _blb blob, _txt text, _mbb mediumblob, _mtx mediumtext, _lbb longblob, _ltx longtext, _pnt point, _dat date default '1988-12-15', _dtt datetime default '2015-10-24 12:00:00', _smp timestamp default '2015-10-24 14:00:00', _tim time default' 07:08:09', _enu enum('a', 'b', 'c'), _set set('a', 'b', 'c') )
CREATE TABLE b15776 (a blob(2147483647), b blob(2147483648), c blob(4294967295), a1 text(2147483647), b1 text(2147483648), c1 text(4294967295) )
CREATE TABLE b15776 (a blob(4294967296))
CREATE TABLE b15776 (a blob(999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999))
CREATE TABLE b15776 (a char(2147483648))
CREATE TABLE b15776 (a char(4294967295))
CREATE TABLE b15776 (a char(4294967296))
CREATE TABLE b15776 (a char(999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999))
CREATE TABLE b15776 (a int(-1))
CREATE TABLE b15776 (a int(999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999))
CREATE TABLE b15776 (a text(4294967296))
CREATE TABLE b15776 (a text(999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999))
CREATE TABLE b15776 (a year(-2))
CREATE TABLE b15776 (a year(4294967295))
CREATE TABLE b15776 (a year(4294967296))
CREATE TABLE b15776 (a year(999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999))
CREATE TABLE b15776 (data blob(-1))
CREATE TABLE bridges ( fid INTEGER NOT NULL PRIMARY KEY, name CHARACTER VARYING(64), position POINT)
CREATE TABLE buildings ( fid INTEGER NOT NULL PRIMARY KEY, address CHARACTER VARYING(64), position POINT, footprint POLYGON)
CREATE TABLE divided_routes ( fid INTEGER NOT NULL PRIMARY KEY, name CHARACTER VARYING(64), num_lanes INTEGER, centerlines MULTILINESTRING)
CREATE TABLE forests ( fid INTEGER NOT NULL PRIMARY KEY, name CHARACTER VARYING(64), boundary MULTIPOLYGON)
CREATE TABLE innodb_table1 (m INT, n INT, FOREIGN KEY (n) REFERENCES t0(f1)) START TRANSACTION
CREATE TABLE lakes ( fid INTEGER NOT NULL PRIMARY KEY, name CHARACTER VARYING(64), shore POLYGON)
CREATE TABLE m1(a INT) ENGINE=MERGE UNION=()
CREATE TABLE named_places ( fid INTEGER NOT NULL PRIMARY KEY, name CHARACTER VARYING(64), boundary POLYGON)
CREATE TABLE ponds ( fid INTEGER NOT NULL PRIMARY KEY, name CHARACTER VARYING(64), type CHARACTER VARYING(64), shores MULTIPOLYGON)
CREATE TABLE road_segments ( fid INTEGER NOT NULL PRIMARY KEY, name CHARACTER VARYING(64), aliases CHARACTER VARYING(64), num_lanes INTEGER, centerline LINESTRING)
CREATE TABLE streams ( fid INTEGER NOT NULL PRIMARY KEY, name CHARACTER VARYING(64), centerline LINESTRING)
CREATE TABLE t ( of INT )
CREATE TABLE t(i BIGINT, b LONGBLOB  DEFAULT (repeat('b', i)))
CREATE TABLE t(i BIGINT, b MEDIUMBLOB  DEFAULT (repeat('b', i)))
CREATE TABLE t(i INT, b BLOB DEFAULT (repeat('b', i)))
CREATE TABLE t(i INT, b BLOB DEFAULT (repeat('b', i)))
CREATE TABLE t(i INT, b TINYBLOB  DEFAULT (repeat('b', i)))
CREATE TABLE t(i INT, b VARCHAR(20) DEFAULT (repeat('b', i)))
CREATE TABLE t0 ( skip INT, locked INT, nowait INT )
CREATE TABLE t1 ( a int ) PARTITION BY RANGE (a) ( PARTITION p0 VALUES LESS THAN (1), PARTITION p1 VALU ES LESS THAN (2) )
CREATE TABLE t1 ( a int not null default 0, b int not null default 0,  key  using BTREE (a,b),  key  using BTREE (b)  ) ENGINE=HEAP
CREATE TABLE t1 ( a int not null default 0, b int not null default 0,  key  using HASH (a),  key  using HASH (b)  ) ENGINE=HEAP
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by key (a) subpartition by list (a+b) ( partition x1 ( subpartition x11 values in (0), subpartition x12 values in (1)), partition x2 ( subpartition x21 values in (0), subpartition x22 values in (1)) )
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by key (a) subpartition by list (a+b) ( partition x1 ( subpartition x11, subpartition x12), partition x2 ( subpartition x21, subpartition x22) )
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by list (a) subpartition by hash (a+b) ( partition x1 values in (1) ( subpartition x11 nodegroup 0, subpartition xextra, subpartition x12 nodegroup 1), partition x2 values in (2) ( subpartition x21 nodegroup 0, subpartition x22 nodegroup 1) )
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by list (a) subpartition by hash (a+b) ( partition x1 values in (1,2,3) ( subpartition x11 nodegroup 0, subpartition x12 nodegroup 1), partition x2 values in (4,5,6) ( subpartition x21 nodegroup 0, subpartition x22 nodegroup 1) )
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by list (a) subpartition by hash (a+b) subpartitions 3 ( partition x1 values in (1,2,4) ( subpartition x11 nodegroup 0, subpartition x12 nodegroup 1), partition x2 values in (3,5,6) ( subpartition x21 nodegroup 0, subpartition x22 nodegroup 1) )
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by range (a) subpartition by hash (a+b) ( partition x1 values less than (1) ( subpartition x11 engine innodb nodegroup 0, subpartition x12 engine innodb nodegroup 1), partition x2 values less than (5) ( subpartition x21 engine innodb nodegroup 0, subpartition x22 engine innodb nodegroup 1) )
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by range (a) subpartition by hash (a+b) ( partition x1 values less than (1) ( subpartition x11 engine innodb nodegroup 0, subpartition x12 engine innodb nodegroup 1), partition x2 values less than (5) ( subpartition x21 engine innodb nodegroup 0, subpartition x22 engine innodb nodegroup 1) )
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by range (a) subpartition by hash (a+b) ( partition x1 values less than (1) ( subpartition x11 nodegroup 0, subpartition x12 nodegroup 1), partition x2 values less than (5) ( subpartition x21 nodegroup 0, subpartition x22 nodegroup 1) )
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by range (a) subpartition by key (a+b) (partition x1 values less than (1) (subpartition x11, subpartition x12), partition x2 values less than (2) (subpartition x21, subpartition x22))
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by key (a) partitions 3 (partition tablespace ts1, partition x2 tablespace ts2, partition x3 tablespace ts3)
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by key (a) partitions 3 (partition x1 nodegroup 0, partition x2 nodegroup 1, partition x3 nodegroup 2)
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by key (a+2) partitions 3 (partition x1 tablespace ts1, partition x2 tablespace ts2, partition x3 tablespace ts3)
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by list (a) partitions 2 (partition x1 values in 4, partition x2 values in (5))
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by list (a) partitions 2 (partition x1 values less than 4, partition x2 values less than (5))
CREATE TABLE t1 ( c1 CHAR(3), c2 INTEGER, KEY USING BTREE(c1), KEY USING BTREE(c2) ) ENGINE= MEMORY
CREATE TABLE t1 ( c1 ENUM('1', '2'), UNIQUE USING BTREE(c1) ) ENGINE= MEMORY DEFAULT CHARSET= utf8
CREATE TABLE t1 ( c1 SET('1', '2'), UNIQUE USING BTREE(c1) ) ENGINE= MEMORY DEFAULT CHARSET= utf8
CREATE TABLE t1 ( col_int_key INTEGER, col_json JSON, KEY mv_idx ((CAST(col_json->'$[*]' AS CHAR(40) ARRAY))) )
CREATE TABLE t1 ( col_int_key INTEGER, col_json JSON, KEY mv_idx ((CAST(col_json->'$[*]' AS CHAR(40) ARRAY))) )
CREATE TABLE t1 ( f1 CHAR(20) COLLATE utf8mb4_0900_ai_ci  # A NO PAD collation. )
CREATE TABLE t1 ( json_col JSON , KEY json_col ((CAST(json_col -> '$' AS UNSIGNED ARRAY))) )
CREATE TABLE t1 ( pk INT PRIMARY KEY, val INT, UNIQUE KEY USING HASH(val) ) ENGINE=MEMORY
CREATE TABLE t1 ( Ñ INTEGER, N INTEGER, a INTEGER, b INTEGER, c INTEGER, d INTEGER, e INTEGER, f INTEGER, g INTEGER, h INTEGER, i INTEGER, j INTEGER, k INTEGER, l INTEGER, m INTEGER, na INTEGER, o INTEGER, p INTEGER, q INTEGER, r INTEGER, s INTEGER, t INTEGER, u INTEGER, v INTEGER, w INTEGER, x INTEGER, y INTEGER, z INTEGER, aa INTEGER, ab INTEGER, ac INTEGER, ad INTEGER )
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(DAY_HOUR FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(DAY_MICROSECOND FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(DAY_MINUTE FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(DAY_SECOND FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(HOUR_MICROSECOND FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(HOUR_MINUTE FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(HOUR_SECOND FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(MINUTE_MICROSECOND FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(MINUTE_SECOND FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(SECOND_MICROSECOND FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(YEAR_MONTH FROM a))
CREATE TABLE t1 (a DATETIME(-1))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(DAY_HOUR FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(DAY_MICROSECOND FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(DAY_MINUTE FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(DAY_SECOND FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(HOUR_MICROSECOND FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(HOUR_MINUTE FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(HOUR_SECOND FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(MINUTE_MICROSECOND FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(MINUTE_SECOND FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(SECOND_MICROSECOND FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(YEAR_MONTH FROM a))
CREATE TABLE t1 (a INT NOT NULL,b INT NOT NULL, PRIMARY KEY USING BTREE (a)) ENGINE=MYISAM COMMENT="TESTING" PACK_KEYS=1 DELAY_KEY_WRITE=1 STATS_PERSISTENT=1 CHECKSUM=1 MIN_ROWS=1 MAX_ROWS=100
CREATE TABLE t1 (a INT) /*!50100 PARTITION BY HASH (a) /* Test of multi-line comment */ PARTITIONS 5 */
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(DAY_HOUR FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(DAY_MICROSECOND FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(DAY_MINUTE FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(DAY_SECOND FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(HOUR_MICROSECOND FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(HOUR_MINUTE FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(HOUR_SECOND FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(MINUTE_MICROSECOND FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(MINUTE_SECOND FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(SECOND_MICROSECOND FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(YEAR_MONTH FROM a))
CREATE TABLE t1 (a INT, KEY USING BTREE(a)) ENGINE=MEMORY
CREATE TABLE t1 (a INT, UNIQUE USING BTREE(a)) ENGINE=MEMORY
CREATE TABLE t1 (a INT, b TIMESTAMP DEFAULT (TIMESTAMPADD(MINUTE, 1,'2003-01-02')) ON UPDATE NOW())
CREATE TABLE t1 (a TIME(-1))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(DAY_HOUR FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(DAY_MICROSECOND FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(DAY_MINUTE FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(DAY_SECOND FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(HOUR_MICROSECOND FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(HOUR_MINUTE FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(HOUR_SECOND FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(MINUTE_MICROSECOND FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(MINUTE_SECOND FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(SECOND_MICROSECOND FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(YEAR_MONTH FROM a))
CREATE TABLE t1 (a TIMESTAMP(-1))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(DAY_HOUR FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(DAY_MICROSECOND FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(DAY_MINUTE FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(DAY_SECOND FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(HOUR_MICROSECOND FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(HOUR_MINUTE FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(HOUR_SECOND FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(MINUTE_MICROSECOND FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(MINUTE_SECOND FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(SECOND_MICROSECOND FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(YEAR_MONTH FROM a))
CREATE TABLE t1 (a datetime, b datetime DEFAULT (utc_date()))
CREATE TABLE t1 (a datetime, b datetime DEFAULT (utc_time()))
CREATE TABLE t1 (a int not null, primary key using BTREE (a)) engine=heap
CREATE TABLE t1 (a int not null, primary key using HASH (a)) engine=heap
CREATE TABLE t1 (a int, b int, c int, key using BTREE (a, b, c)) engine=heap
CREATE TABLE t1 (c TIMESTAMP) PARTITION BY RANGE (TO_DAYS(c)) (PARTITION p0 VALUES LESS THAN (10000), PARTITION p1 VALUES LESS THAN (MAXVALUE))
CREATE TABLE t1 (c TIMESTAMP) PARTITION BY RANGE (UNIX_TIMESTAMP(c)) (PARTITION p0 VALUES LESS THAN ('2000-01-01 00:00:00'), PARTITION p1 VALUES LESS THAN (MAXVALUE))
CREATE TABLE t1 (c TIMESTAMP) PARTITION BY RANGE (UNIX_TIMESTAMP(c)) (PARTITION p0 VALUES LESS THAN (UNIX_TIMESTAMP('2000-01-01 00:00:00')), PARTITION p1 VALUES LESS THAN (MAXVALUE))
CREATE TABLE t1 (c TIMESTAMP) PARTITION BY RANGE (c) (PARTITION p0 VALUES LESS THAN ('2000-01-01 00:00:00'), PARTITION p1 VALUES LESS THAN (MAXVALUE))
CREATE TABLE t1 (c TIMESTAMP) PARTITION BY RANGE COLUMNS(c) (PARTITION p0 VALUES LESS THAN ('2000-01-01 00:00:00'), PARTITION p1 VALUES LESS THAN (MAXVALUE))
CREATE TABLE t1 (c1 INT, c2 INT, PRIMARY KEY USING BTREE (c1,c2)) PARTITION BY KEY(c2,c1) PARTITIONS 4
CREATE TABLE t1 (c1 YEAR(4294967295))
CREATE TABLE t1 (c1 YEAR(4294967296))
CREATE TABLE t1 (created DATETIME NOT NULL DEFAULT (UTC_DATE()))
CREATE TABLE t1 (created DATETIME NOT NULL DEFAULT (UTC_TIME()))
CREATE TABLE t1 (d ENUM("YES","NO")) PARTITION BY RANGE COLUMNS(d) (PARTITION p0 VALUES LESS THAN ("NO"), PARTITION p1 VALUES LESS THAN (MAXVALUE))
CREATE TABLE t1 (d SET("Car","MC")) PARTITION BY RANGE COLUMNS(d) (PARTITION p0 VALUES LESS THAN ("MC"), PARTITION p1 VALUES LESS THAN (MAXVALUE))
CREATE TABLE t1 (f1 DATETIME CHECK (f1 + UTC_DATE() > '2011-11-21'))
CREATE TABLE t1 (f1 DATETIME CHECK (f1 + UTC_TIME() > '23:11:21'))
CREATE TABLE t1 (f1 INT CHECK (f1 = default(f1)))
CREATE TABLE t1 (f1 INT NOT NULL AUTO_INCREMENT, f2 INT NOT NULL, PRIMARY KEY (f1,f2)) ENGINE=InnoDB PARTITION BY RANGE (f2) (PARTITION p0 VALUES LESS THAN (100), PARTITION p1 VALUES LESS THAN (200), PARTITION p2 VALUES LESS THAN (300), PARTITION p3 VALUES LESS THAN (MAXVALUE))
CREATE TABLE t1 (f1 INT) ENGINE=MyiSAM START TRANSACTION
CREATE TABLE t1 (f1 INT) START TRANSACTION
CREATE TABLE t1 (f1 INT) START TRANSACTION
CREATE TABLE t1 (f1 INT) START TRANSACTION
CREATE TABLE t1 (f1 INT, f2 INT PRIMARY KEY INVISIBLE)
CREATE TABLE t1 (f1 INT, f2 INT PRIMARY KEY INVISIBLE)
CREATE TABLE t1 (f1 INT, f2 INT PRIMARY KEY INVISIBLE)
CREATE TABLE t1 (g GEOMCOLLECTION)
CREATE TABLE t1 (get INT)
CREATE TABLE t1 (i int, KEY USING BTREE (i)) ENGINE=MEMORY
CREATE TABLE t1 (i int, KEY USING BTREE (i)) ENGINE=MyISAM
CREATE TABLE t1 (i int, KEY USING BTREE (i)) ENGINE=MyISAM
CREATE TABLE t1 (i int, KEY USING HASH (i)) ENGINE=MEMORY
CREATE TABLE t1 (user_num BIGINT, hours SMALLINT, KEY user_num (user_num)) ENGINE = InnoDB PARTITION BY RANGE COLUMNS (hours) (PARTITION hour_003 VALUES LESS THAN (3), PARTITION hour_004 VALUES LESS THAN (4), PARTITION hour_005 VALUES LESS THAN (5), PARTITION hour_last VALUES LESS THAN (MAXVALUE))
CREATE TABLE t1 AS SELECT CONCAT(CURRENT_TIME()), CONCAT(CURRENT_TIME(6)), CONCAT(UTC_TIME()), CONCAT(UTC_TIME(6)), CONCAT(CURRENT_TIMESTAMP()), CONCAT(CURRENT_TIMESTAMP(6)), CONCAT(UTC_TIMESTAMP()), CONCAT(UTC_TIMESTAMP(6)), CONCAT(LOCALTIME()), CONCAT(LOCALTIME(6)), CONCAT(LOCALTIMESTAMP()), CONCAT(LOCALTIMESTAMP(6)), CONCAT(SYSDATE()), CONCAT(SYSDATE(6))
CREATE TABLE t1 AS SELECT REPEAT (' ', 10) AS a LIMIT 0
CREATE TABLE t1 AS SELECT REPEAT (' ', 10) AS a LIMIT 0
CREATE TABLE t1 AS SELECT REPEAT(' ', 10) AS a LIMIT 0
CREATE TABLE t1 AS SELECT REPEAT(' ', 10) AS a LIMIT 0
CREATE TABLE t1 AS SELECT REPEAT(' ', 10) as c LIMIT 0
CREATE TABLE t1 AS SELECT REPEAT(' ', 16) AS a LIMIT 0
CREATE TABLE t1 AS SELECT REPEAT('a',2) as s1 LIMIT 0
CREATE TABLE t1 AS SELECT REPEAT('abcd', 128) AS a
CREATE TABLE t1 AS SELECT REPEAT('abcd', 128) AS a LIMIT 0
CREATE TABLE t1 AS SELECT regexp_instr( 'a', 'a' ) AS a, regexp_like( 'a', 'a' ) AS b, regexp_replace( 'abc', 'b', 'x' ) AS c, regexp_substr( 'a', 'a' ) AS d, regexp_substr( repeat('a', 512), 'a' ) AS e, regexp_substr( repeat('a', 513), 'a' ) AS f
CREATE TABLE t1 AS SELECT repeat('a',2) as s1 LIMIT 0
CREATE TABLE t1 AS SELECT repeat('a',2) as s1 LIMIT 0
CREATE TABLE t1 ENGINE=FALCON AS SELECT repeat('a', 5) AS s1 LIMIT 0
CREATE TABLE t1 ENGINE=INNODB AS SELECT repeat('a', 5) AS s1 LIMIT 0
CREATE TABLE t1 ENGINE=MARIA AS SELECT repeat('a', 5) AS s1 LIMIT 0
CREATE TABLE t1 ENGINE=MYISAM AS SELECT repeat('a', 5) AS s1 LIMIT 0
CREATE TABLE t1 SELECT /* 81 */ 100000000000000000000000000000000000000000000000000000000000000000000000000000001. AS c1
CREATE TABLE t1 SELECT 5.0 + 96 DIV 1,                     # Dividend is integer 5.0 + 96.1234 DIV 1,                # Dividend is decimal 5.0 + '96' DIV 1,                   # Dividend is string 5.0 + CAST('96' AS SIGNED) DIV 1,   # Dividend is function 5.0 + CAST('96' AS UNSIGNED) DIV 1
CREATE TABLE t1 SELECT @decimal AS c1
CREATE TABLE t1 START TRANSACTION as SELECT * FROM t0
CREATE TABLE t1 charset utf8mb4 SELECT SUBSTRING('1', DAY(FROM_UNIXTIME(-1))) AS f1, LEFT('1', DAY(FROM_UNIXTIME(-1))) AS f2, RIGHT('1', DAY(FROM_UNIXTIME(-1))) AS f3, REPEAT('1', DAY(FROM_UNIXTIME(-1))) AS f4, RPAD('hi', DAY(FROM_UNIXTIME(-1)),'?') AS f5, LPAD('hi', DAY(FROM_UNIXTIME(-1)),'?') AS f6
CREATE TABLE t1( a TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE NOW(), b INT DEFAULT 1 )
CREATE TABLE t1( a TIMESTAMP NOT NULL DEFAULT NOW(), b INT )
CREATE TABLE t1( id INT AUTO_INCREMENT PRIMARY KEY, c1 INT NOT NULL, c2 INT NOT NULL, UNIQUE KEY USING BTREE (c2,c1)) ENGINE = MEMORY
CREATE TABLE t1( id INT AUTO_INCREMENT PRIMARY KEY, c1 INT NOT NULL, c2 INT NOT NULL, UNIQUE KEY USING HASH (c2,c1)) ENGINE = MEMORY
CREATE TABLE t1(a DATETIME NOT NULL DEFAULT NOW(), b INT)
CREATE TABLE t1(a DATETIME NOT NULL DEFAULT NOW(), b INT)
CREATE TABLE t1(a DATETIME) PARTITION BY HASH (EXTRACT(HOUR_MICROSECOND FROM a))
CREATE TABLE t1(a INT, KEY USING BTREE (a)) ENGINE=MEMORY
CREATE TABLE t1(a INT, b DATE NOT NULL INVISIBLE) PARTITION BY RANGE( YEAR(b) ) ( PARTITION p0 VALUES LESS THAN (1960), PARTITION p1 VALUES LESS THAN (1970), PARTITION p2 VALUES LESS THAN (1980), PARTITION p3 VALUES LESS THAN (1990))
CREATE TABLE t1(c1 INT, c2 INT, CONSTRAINT FLOAT CHECK (c2 < 10))
CREATE TABLE t1(c1 VARCHAR(33), KEY USING BTREE (c1) USING HASH) ENGINE=MEMORY
CREATE TABLE t1(c1 VARCHAR(33), KEY USING BTREE (c1))
CREATE TABLE t1(c1 VARCHAR(33), KEY USING HASH (c1) USING BTREE) ENGINE=MEMORY
CREATE TABLE t1(col1 MULTIPOLYGON NOT NULL, SPATIAL INDEX USING BTREE (col1))
CREATE TABLE t1(f1 INT INVISIBLE, f2 INT)
CREATE TABLE t1(f1 INT INVISIBLE, f2 INT, f3 INT AS (f1 + 10), f4 INT AS (f2 + 10) INVISIBLE)
CREATE TABLE t1(f1 INT INVISIBLE, f2 INT, f3 INT AS (f1 + 10), f4 INT AS (f2 + 10) INVISIBLE, f5 INT AS (f2 + 10) STORED INVISIBLE)
CREATE TABLE t1(f1 INT, f2 VARCHAR(64) NOT NULL, PRIMARY KEY (f1)) PARTITION BY RANGE(f1) ( PARTITION p1 VALUES LESS THAN (3), PARTITION p2 VALUES LESS THAN (maxvalue) )
CREATE TABLE t1(f1 int CHECK())
CREATE TABLE t1(f1 int CHECK(f1 < 10), f2 int CHECK())
CREATE TABLE t1(f1 int CHECK(f1 < 10), f2 int CHECK(f2 < 10) NOT)
CREATE TABLE t1(f1 int CHECK(f1 < 10), f2 int CHECK)
CREATE TABLE t1(f1 int CHECK(f1 < 10), f2 int CONSTRAINT CHECK())
CREATE TABLE t1(f1 int CHECK(f1 < 10), f2 int CONSTRAINT t1_f2_ck CHECK(f2 < 10) NOT)
CREATE TABLE t1(f1 int CHECK(f1 < 10), f2 int t1_f2_ck CHECK(f2 < 10))
CREATE TABLE t1(f1 int CHECK)
CREATE TABLE t1(f1 int CONSTRAINT CHECK())
CREATE TABLE t1(f1 int CONSTRAINT t1_ck CHECK( f1 < 10) NOT)
CREATE TABLE t1(f1 int CONSTRAINT t1_ck CHECK())
CREATE TABLE t1(f1 int t1_ck CHECK())
CREATE TABLE t1(f1 int, CONSTRAINT t1_ck CHECK()
CREATE TABLE t1(f1 int, CONSTRAINT t1_ck CHECK())
CREATE TABLE t1(f1 int, CONSTRAINT t1_ck CHECK(f1<10), CONSTRAINT t2_ck CHECK()
CREATE TABLE t1(f1 int, CONSTRAINT t1_ck CHECK(f1<10), CONSTRAINT t2_ck CHECK(f2 > 0) NOT)
CREATE TABLE t1(f1 int, CONSTRAINT t1_ck CHECK(f1<10), CONSTRAINT t2_ck CHECK)
CREATE TABLE t1(f1 int, CONSTRAINT t1_ck CHECK)
CREATE TABLE t1(i INT PRIMARY KEY) KEY_BLOCK_SIZE = -2147483647
CREATE TABLE t1(i INT PRIMARY KEY) KEY_BLOCK_SIZE = -2147483648
CREATE TABLE t1(id INT NOT NULL INVISIBLE, name VARCHAR(10)) PARTITION BY LIST(id) ( PARTITION p0 VALUES IN (10,19), PARTITION p1 VALUES IN (20,29), PARTITION p2 VALUES IN (30,39), PARTITION p3 VALUES IN (40,49))
CREATE TABLE t1(id INT NOT NULL INVISIBLE, name VARCHAR(40)) PARTITION BY HASH(id) PARTITIONS 4
CREATE TABLE t1(id INT PRIMARY KEY NOT NULL INVISIBLE, name VARCHAR(40)) PARTITION BY KEY() PARTITIONS 4
CREATE TABLE t1(id INT) PARTITION BY RANGE (id) (PARTITION p0 VALUES LESS THAN (100), PARTITION pmax VALUES LESS THAN (MAXVALUE))
CREATE TABLE t1(j json, INDEX mv_idx((CAST(j AS UNSIGNED ARRAY))))
CREATE TABLE t1(val INT, KEY USING BTREE(val)) ENGINE=memory
CREATE TABLE t1(x INT, KEY `` ((x + 1)))
CREATE TABLE t1(🐬 INT)
CREATE TABLE t1(🐬 INT)
CREATE TABLE t2 (a INT NOT NULL,b INT NOT NULL, PRIMARY KEY USING BTREE (a)) ENGINE=MYISAM COMMENT="TESTING" PACK_KEYS=0 DELAY_KEY_WRITE=1 STATS_PERSISTENT=1 CHECKSUM=1 MIN_ROWS=1 MAX_ROWS=100
CREATE TABLE t2 (a INT, b INT DEFAULT (select * from t1))
CREATE TABLE t2 (a INT, b INT DEFAULT (select 1))
CREATE TABLE t2 (a INT, b INT DEFAULT (select count(*) from t1))
CREATE TABLE t2 (f1 INT PRIMARY KEY INVISIBLE, f2 INT, CONSTRAINT FOREIGN KEY (f1) REFERENCES t1(f2))
CREATE TABLE t2 (i INT, j DOUBLE DEFAULT (SQRT(i)), k DOUBLE DEFAULT (DEFAULT(j)))
CREATE TABLE t2 (pk INTEGER PRIMARY KEY) TABLESPACE ``
CREATE TABLE t2 AS SELECT COALESCE(5, -5) AS c1, COALESCE(5, 5.5) AS c2, COALESCE(5, 5.5e5) AS c3, COALESCE(5, '5') AS c4, COALESCE(20010101, date '2005-05-05') AS c5, COALESCE(010101, time '05:05:05.555555') AS c6, COALESCE(010101, timestamp '2005-05-05 05:05:05.555555') AS c7, COALESCE(20010101, NOW(0)) AS c8, COALESCE(5.55, 88.8) AS c11, COALESCE(5.5, 5.5e5) AS c12, COALESCE(5.5, '5') AS c13, COALESCE(010101.5, date '2005-05-05') AS c14, COALESCE(5.5, time '05:05:05.555555') AS c15, COALESCE(010101.5, timestamp '2005-05-05 05:05:05.555555') AS c16, COALESCE(5.5e5, '5') AS c21, COALESCE(2004041e1, date '2005-05-05') AS c22, COALESCE(150505.0e5, time '05:05:05.555555') AS c23, COALESCE(2004041e1, timestamp '2005-05-05 05:05:05.555555') AS c24, COALESCE('010101', date '2005-05-05') AS c31, COALESCE('5', time '05:05:05.555555') AS c32, COALESCE('010101', timestamp '2005-05-05 05:05:05.555555') AS c33, COALESCE(date '2005-05-05', time '05:05:05.555555') AS c41, COALESCE(date '2005-05-05', timestamp '2005-05-05 05:05:05.555555') AS c42, COALESCE(time '05:05:05.555555', timestamp '2005-05-05 05:05:05.555555') AS c51, COALESCE(x'c3a5', '1') AS c61, COALESCE(x'c3a5', _binary '1') AS c62, COALESCE(_utf8mb4 x'c3a5', '1') AS c63, COALESCE(_utf8mb4 x'c3a5', _binary '1') AS c64, COALESCE(JSON_OBJECT('a', 1), NULL) AS c71
CREATE TABLE t2 AS SELECT INSERT(1133,3,0,22) FROM t1
CREATE TABLE t2 AS SELECT INSERT(1133,3,0,22) FROM t1
CREATE TABLE t2 AS SELECT INSERT(1133,3,0,22) FROM t1
CREATE TABLE t2 AS SELECT REPEAT(1,2) FROM t1
CREATE TABLE t2 AS SELECT REPEAT(1,2) FROM t1
CREATE TABLE t2 AS SELECT REPEAT(1,2) FROM t1
CREATE TABLE t2 LIKE t1 PARTITION (p0, p2)
CREATE TABLE t2(f1 INT, f2 INT INVISIBLE)
CREATE TABLE t3 (a INT PRIMARY KEY, d INT DEFAULT (-a + 1), c INT DEFAULT (DEFAULT(d)) )
CREATE TABLE t3 (a int DEFAULT 10, b varchar(64) DEFAULT "Default", c varchar(64) DEFAULT "Default", d int unsigned DEFAULT 9, e varchar(255) DEFAULT "Default-filler.filler.filler.", PRIMARY KEY (a,b,c,d)) charset latin1 PARTITION BY RANGE COLUMNS (a, b) SUBPARTITION BY LINEAR KEY (d, c) SUBPARTITIONS 4 (PARTITION pNeg VALUES LESS THAN (0, ""), PARTITION `p0-9` VALUES LESS THAN (9, MAXVALUE), PARTITION p10 VALUES LESS THAN (10, MAXVALUE), PARTITION `p11-100` VALUES LESS THAN (99, MAXVALUE))
CREATE TABLE t3 AS SELECT GREATEST(5, -5) AS c1, GREATEST(5, 5.5) AS c2, GREATEST(5, 5.5e5) AS c3, GREATEST(5, '5') AS c4, GREATEST(20010101, date '2005-05-05') AS c5, GREATEST(010101, time '05:05:05.555555') AS c6, GREATEST(010101, timestamp '2005-05-05 05:05:05.555555') AS c7, GREATEST(20010101, NOW(0)) AS c8, GREATEST(5.55, 88.8) AS c11, GREATEST(5.5, 5.5e5) AS c12, GREATEST(5.5, '5') AS c13, GREATEST(010101.5, date '2005-05-05') AS c14, GREATEST(5.5, time '05:05:05.555555') AS c15, GREATEST(010101.5, timestamp '2005-05-05 05:05:05.555555') AS c16, GREATEST(5.5e5, '5') AS c21, GREATEST(2004041e1, date '2005-05-05') AS c22, GREATEST(150505.0e5, time '05:05:05.555555') AS c23, GREATEST(2004041e1, timestamp '2005-05-05 05:05:05.555555') AS c24, GREATEST('010101', date '2005-05-05') AS c31, GREATEST('5', time '05:05:05.555555') AS c32, GREATEST('010101', timestamp '2005-05-05 05:05:05.555555') AS c33, GREATEST(date '2005-05-05', time '05:05:05.555555') AS c41, GREATEST(date '2005-05-05', timestamp '2005-05-05 05:05:05.555555') AS c42, GREATEST(time '05:05:05.555555', timestamp '2005-05-05 05:05:05.555555') AS c51, GREATEST(x'c3a5', '1') AS c61, GREATEST(x'c3a5', _binary '1') AS c62, GREATEST(_utf8mb4 x'c3a5', '1') AS c63, GREATEST(_utf8mb4 x'c3a5', _binary '1') AS c64
CREATE TABLE t3 AS SELECT hex('c8eb4b15cb0948bb'),hex(_bin),hex(_blb) FROM at
CREATE TABLE t3 AS SELECT unhex(_bin) FROM at
CREATE TABLE t4 (s1 CHAR(50) CHARACTER SET latin1, s2 CHAR(50) CHARACTER SET cp932, d DECIMAL(10,2))| CREATE PROCEDURE bug18293 (IN ins1 CHAR(50), IN ins2 CHAR(50) CHARACTER SET cp932, IN ind DECIMAL(10,2)) BEGIN INSERT INTO t4 VALUES (ins1, ins2, ind)
CREATE TABLE t5 ( f1 INT, f2 INT ) ENGINE=InnoDB PARTITION BY RANGE COLUMNS(f1,f2) ( PARTITION p0 VALUES LESS THAN (10000,12), PARTITION p1 VALUES LESS THAN (MAXVALUE, MAXVALUE) )
CREATE TABLE t6 ( a INT, b INT ) ENGINE=InnoDB PARTITION BY RANGE COLUMNS(a,b) SUBPARTITION BY KEY(a,b) SUBPARTITIONS 2 ( PARTITION p0 VALUES LESS THAN (10000,12), PARTITION p1 VALUES LESS THAN (MAXVALUE, MAXVALUE) )
CREATE TABLE t_illegal (col_1 INT CHECK something (whatever))
CREATE TABLE t_illegal (col_1 INT CHECK something)
CREATE TABLE tp (a VARCHAR(24), b DATETIME, PRIMARY KEY (a,b)) PARTITION BY RANGE COLUMNS (a, b) (PARTITION p0 VALUES LESS THAN ("Middle", '0000-00-00'), PARTITION p1 VALUES LESS THAN (MAXVALUE, '9999-12-31 23:59:59'))
CREATE TABLE v0(v1 DEC, v2 INT)
CREATE TABLE 🐬(a INT)
CREATE TABLE 🐬(a INT)
CREATE TABLESPACE `` ADD DATAFILE 'x.ibd'
CREATE TABLESPACE `a𐍈` ADD DATAFILE 'x.ibd'
CREATE TABLESPACE `innodb_file_per_table.2` ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE `mytbsp` ADD DATAFILE 'mytbsp.ibd' ENGINE INNODB
CREATE TABLESPACE `ts6` ADD DATAFILE 'ts6.ibd' ENGINE=INNODB
CREATE TABLESPACE `¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥` ADD DATAFILE 'x.ibd'
CREATE TABLESPACE `¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥` ADD DATAFILE 'x.ibd'
CREATE TABLESPACE `€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€` ADD DATAFILE 'x.ibd'
CREATE TABLESPACE `€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€` ADD DATAFILE 'x.ibd'
CREATE TABLESPACE altering ADD DATAFILE 'altering.ibd' ENGINE InnoDB
CREATE TABLESPACE innodb_file_per_table ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE innodb_file_per_table ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE innodb_file_per_table_whatever ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE innodb_system ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE innodb_temporary ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE mysql ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE mysql ADD DATAFILE 'new_file.ibd'
CREATE TABLESPACE s1 ADD DATAFILE 's1.ibd'
CREATE TABLESPACE t1 ADD DATAFILE 't1.ibd' ENGINE=HEAP
CREATE TABLESPACE t1 ADD DATAFILE 't1.ibd' ENGINE=INNODB
CREATE TABLESPACE tb1 ADD DATAFILE 't1.ibd' ENGINE=INNODB
CREATE TABLESPACE testtablespace ADD DATAFILE 'ts.ibd' ENGINE=InnoDB
CREATE TABLESPACE testtablespace ADD DATAFILE 'ts.ibd' ENGINE=InnoDB
CREATE TABLESPACE testtablespace ADD DATAFILE 'ts.ibd' ENGINE=InnoDB
CREATE TABLESPACE testtablespace ADD DATAFILE 'ts.ibd' ENGINE=InnoDB
CREATE TABLESPACE ts ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE ts ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE ts ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE ts ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE ts ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE ts ADD DATAFILE 'ts.ibd' ENGINE=InnoDB
CREATE TABLESPACE ts Engine=InnoDB
CREATE TABLESPACE ts1
CREATE TABLESPACE ts1
CREATE TABLESPACE ts1 ADD DATAFILE './ts1.ibd' ENGINE=INNODB
CREATE TABLESPACE ts1 ADD DATAFILE 'df1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'df1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'df1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'df1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'df1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'df1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'df1.ibd' ENGINE=InnoDB
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1.ibd' ENGINE=INNODB
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1.ibd' Engine=InnoDB
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
CREATE TABLESPACE ts1 ENGINE_ATTRIBUTE=''
CREATE TABLESPACE ts1 Engine=InnoDB
CREATE TABLESPACE ts1 Engine=InnoDB
CREATE TABLESPACE ts2 ADD DATAFILE 'ts2.ibd'
CREATE TABLESPACE ts2 ADD DATAFILE 'ts2.ibd'
CREATE TABLESPACE ts2 ADD DATAFILE 'ts2.ibd' Engine=InnoDB
CREATE TABLESPACE ts2 ADD DATAFILE 'ts2_1.ibd'
CREATE TABLESPACE ts2 ADD DATAFILE 'ts2_1.ibd'
CREATE TABLESPACE ts2 ADD DATAFILE 'ts2_1.ibd'
CREATE TABLESPACE ts2 ENGINE_ATTRIBUTE='{"c": "v"}'
CREATE TABLESPACE ts2 Engine=InnoDB
CREATE TABLESPACE ts2 Engine=InnoDB
CREATE TABLESPACE ts3 ADD DATAFILE 'ts3.ibd'
CREATE TABLESPACE ts3 ADD DATAFILE 'ts3_1.ibd'
CREATE TABLESPACE ts3 ADD DATAFILE 'ts3_1.ibd'
CREATE TABLESPACE ts3 ENGINE_ATTRIBUTE='{"c": v}'
CREATE TABLESPACE xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ADD DATAFILE 'x.ibd'
CREATE TABLESPACE xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ADD DATAFILE 'x.ibd'
CREATE TEMPORARY TABLE issue_functional_key_part ( sold_on DATETIME NOT NULL DEFAULT NOW(), INDEX sold_on_date ((DATE(sold_on))) ) SELECT NOW() `sold_on`
CREATE TEMPORARY TABLE t1 (f1 INT) START TRANSACTION
CREATE TEMPORARY TABLE t6(a INT) ENGINE = MERGE UNION = ()
CREATE TRIGGER BUG_12490 BEFORE UPDATE ON t_bug_12490 FOR EACH ROW HELP CONTENTS
CREATE TRIGGER ai AFTER INSERT ON t1 FOR EACH ROW SET @a:= NEW.at
CREATE TRIGGER bi_t5 BEFORE INSERT ON t5 FOR EACH ROW SET @a:= (SELECT COUNT(*) FROM t1)
CREATE TRIGGER bi_t6 BEFORE INSERT ON t6 FOR EACH ROW SET @a:= (SELECT COUNT(*) FROM t2)
CREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN grant select on t1 to 'mysqltest_1'; END
CREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN revoke all privileges on *.* from 'mysqltest_1'; END
CREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN revoke select on t1 from 'mysqltest_1'; END
CREATE TRIGGER f BEFORE INSERT ON t1 FOR EACH ROW BEGIN INSERT INTO t1 ( `int` ) VALUES (4 ),( 8 ),( 2 )
CREATE TRIGGER f BEFORE INSERT ON t1 FOR EACH ROW BEGIN UPDATE A SET `pk`=1 WHERE `pk`=0
CREATE TRIGGER t1_BI BEFORE INSERT ON t1 FOR EACH ROW SET NEW.id := -1
CREATE TRIGGER t1_au AFTER UPDATE ON t1 FOR EACH ROW CREATE SERVER s FOREIGN DATA WRAPPER mysql OPTIONS (USER 'Remote', HOST '192.168.1.106', DATABASE 'test')
CREATE TRIGGER t1_au AFTER UPDATE ON t1 FOR EACH ROW START SLAVE
CREATE TRIGGER t1_au AFTER UPDATE ON t1 FOR EACH ROW STOP SLAVE
CREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW BEGIN DECLARE v TEXT; SET v = 'aaa'; SET NEW.c = v; END
CREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:= (SELECT COUNT(*) FROM t1)
CREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=0
CREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROW ALTER SERVER s OPTIONS (password '1')
CREATE TRIGGER t1_trg_after_del AFTER DELETE ON t1 FOR EACH ROW SET @a := 1
CREATE TRIGGER t1bu BEFORE UPDATE ON bug22580_t1 FOR EACH ROW BEGIN CALL bug22580_proc_1(); END|
CREATE TRIGGER testtrigger_1 BEFORE INSERT ON testtable_1 FOR EACH ROW SET @a:=1
CREATE TRIGGER testtrigger_1 BEFORE INSERT ON testtable_1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr0_bi BEFORE INSERT ON t1 FOR EACH ROW PRECEDES tr1_bi SET @a:=0
CREATE TRIGGER tr1 AFTER DELETE ON t1 FOR EACH ROW BEGIN INSERT INTO t1 SELECT * FROM t1 AS A
CREATE TRIGGER tr1 AFTER UPDATE ON t1 FOR EACH ROW ALTER DATABASE db1 CHARACTER SET latin1
CREATE TRIGGER tr1 AFTER UPDATE ON t1 FOR EACH ROW ALTER USER 'u1'@'localhost' PASSWORD EXPIRE
CREATE TRIGGER tr1 AFTER UPDATE ON t1 FOR EACH ROW CHANGE REPLICATION SOURCE TO SOURCE_SSL = 0
CREATE TRIGGER tr1 AFTER UPDATE ON t1 FOR EACH ROW DROP SERVER IF EXISTS s
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN DROP TRIGGER test1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN LOCK TABLE t1 READ; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN alter view v1 as select 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create database mysqltest; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create function f2 () returns int return 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create index t1_i on t1 (a); END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create trigger tr2 before insert on t1 for each row do select 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create user 'mysqltest_1'; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create view v1 as select 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop database mysqltest; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop function bug_13627_f; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop index t1_i on t1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop user 'mysqltest_1'; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop view v1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN rename table t1 to t2; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN rename user 'mysqltest_2' to 'mysqltest_1'; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN unlock tables; END
CREATE TRIGGER tr1_1_bi BEFORE INSERT ON t1 FOR EACH ROW FOLLOWS tr1_bi SET @a:=0
CREATE TRIGGER tr1_ai AFTER INSERT ON t1 FOR EACH ROW FOLLOWS tr1_bi SET @a:=3
CREATE TRIGGER tr1_au AFTER UPDATE ON t1 FOR EACH ROW FOLLOWS tr1_bu SET @a:=3
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=2
CREATE TRIGGER tr1_bu BEFORE UPDATE ON t1 FOR EACH ROW SET @a:=3
CREATE TRIGGER tr1_bu BEFORE UPDATE ON t1 FOR EACH ROW SET @a:=3
CREATE TRIGGER tr1_bu BEFORE UPDATE ON t1 FOR EACH ROW SET @a:=3
CREATE TRIGGER tr1_bu BEFORE UPDATE ON t1 FOR EACH ROW SET @a:=3
CREATE TRIGGER tr2_au AFTER UPDATE ON t1 FOR EACH ROW FOLLOWS tr1_bi SET @a:=3
CREATE TRIGGER tr2_bi BEFORE INSERT ON t1 FOR EACH ROW FOLLOWS tr0_bi SET @a:=2
CREATE TRIGGER tr2_bi BEFORE INSERT ON t1 FOR EACH ROW PRECEDES tr0_bi SET @a:=2
CREATE TRIGGER tr2_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=2
CREATE TRIGGER tr2_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=2
CREATE TRIGGER tr2_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=2
CREATE TRIGGER tr2_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=2
CREATE TRIGGER tr2_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=2
CREATE TRIGGER tr2_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=2
CREATE TRIGGER tr2_bu BEFORE UPDATE ON t1 FOR EACH ROW FOLLOWS tr1_bi SET @a:=3
CREATE TRIGGER tr2_bu BEFORE UPDATE ON t1 FOR EACH ROW FOLLOWS tr1_bu SET @a:=3
CREATE TRIGGER tr3_bi BEFORE INSERT ON t1 FOR EACH ROW FOLLOWS tr2_bi SET @a:=3
CREATE TRIGGER tr3_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=3
CREATE TRIGGER tr3_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=3
CREATE TRIGGER trg1 AFTER INSERT ON table1 FOR EACH ROW INSERT INTO table2 SELECT t.notable.*
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN DECLARE a CHAR; SELECT 'ab' INTO a; SELECT 'ab' INTO a; SELECT 'a' INTO a; END
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN DECLARE trg1 CHAR; SELECT 'ab' INTO trg1; END
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN DECLARE var INT DEFAULT row_count(); GET DIAGNOSTICS @var1 = ROW_COUNT; SET @var2 = var; END
CREATE TRIGGER trg2 AFTER INSERT ON t1 FOR EACH ROW BEGIN DECLARE trg2 CHAR; SELECT 'ab' INTO trg2; END
CREATE TRIGGER trg27563 BEFORE INSERT ON t1 FOR EACH ROW BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '70100' SET @a:= 'killed'; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET @a:= 'exception'; INSERT INTO t2 VALUES(0); SET DEBUG_SYNC= 'now SIGNAL in_sync WAIT_FOR kill'; INSERT INTO t2 VALUES(1); END
CREATE TRIGGER trig_t1_ins BEFORE INSERT ON t1 FOR EACH ROW BEGIN SET @aux = GET_LOCK(2,1)
CREATE TRIGGER trigger_before_update BEFORE UPDATE ON t1 FOR EACH ROW SET @x:= NEW.a
CREATE TRIGGER trigger_before_update BEFORE UPDATE ON t1 FOR EACH ROW SET @x:= NEW.a
CREATE TRIGGER trigger_before_update_with_join BEFORE UPDATE ON t1 FOR EACH ROW SET @x:= NEW.a
CREATE TRIGGER trigger_for_insert_select BEFORE INSERT ON t1 FOR EACH ROW SET @x:= NEW.a
CREATE TRIGGER trigger_for_load_infile BEFORE INSERT ON t1 FOR EACH ROW SET @x:= NEW.a
CREATE TRIGGER trigger_for_normal_insert BEFORE INSERT ON t1 FOR EACH ROW SET @x:= NEW.a
CREATE TRIGGER trigger_for_normal_replace BEFORE INSERT ON t1 FOR EACH ROW SET @x:= NEW.a
CREATE TRIGGER trigger_for_replace_select BEFORE INSERT ON t1 FOR EACH ROW SET @x:= NEW.a
CREATE TRIGGER очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_E BEFORE INSERT ON t1 FOR EACH ROW SET @sum= @sum + NEW.f1
CREATE TRIGGER очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_e BEFORE INSERT ON t1 FOR EACH ROW SET @sum= @sum + NEW.f1
CREATE TRIGGER очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_é BEFORE INSERT ON t1 FOR EACH ROW SET @sum= @sum + NEW.f1
CREATE UNDO TABLESPACE undo_003 ADD DATAFILE 'undo_003.ibu' ENGINE InnoDB
CREATE UNDO TABLESPACE undo_003 ADD DATAFILE 'undo_003.ibu' ENGINE MyISAM
CREATE USER ACCOUNT LOCK user6@localhost
CREATE USER ACCOUNT UNLOCK user5@localhost
CREATE USER IF NOT EXISTS event_u2@192.1.1.140
CREATE USER IF NOT EXISTS trig_u2@xyz.com
CREATE USER IF NOT EXISTS view_u2@my.oracle.com
CREATE USER foo2@localhost IDENTIFIED BY 'foo' COMMENT 'xxx'
CREATE USER foo3 PASSWORD EXPIRE DEFAULT COMMENT 'abc'
CREATE USER foo4 ACCOUNT LOCK ATTRIBUTE '{"stuff":"ffuts"}'
CREATE USER foo@localhost FAILED_LOGIN_ATTEMPTS -1
CREATE USER foo@localhost PASSWORD_LOCK_TIME -1
CREATE USER plug IDENTIFIED AS ''
CREATE USER plug IDENTIFIED WITH
CREATE USER plug IDENTIFIED WITH 'test_plugin_server' AS
CREATE USER plug IDENTIFIED WITH 'test_plugin_server' AS '' AS 'plug_dest'
CREATE USER plug IDENTIFIED WITH 'test_plugin_server' AS '' IDENTIFIED WITH test_plugin_server   AS 'plug_dest'
CREATE USER plug IDENTIFIED WITH 'test_plugin_server' AS 'plug_dest' IDENTIFIED by 'plug_dest_pwd'
CREATE USER plug IDENTIFIED WITH 'test_plugin_server' AS 'plug_dest' USER plug_dest IDENTIFIED by 'plug_dest_pwd'
CREATE USER plug IDENTIFIED WITH 'test_plugin_server' AS 'plug_dest' plug_dest IDENTIFIED by 'plug_dest_pwd'
CREATE USER plug IDENTIFIED WITH 'test_plugin_server' IDENTIFIED WITH 'test_plugin_server'
CREATE USER plug IDENTIFIED WITH @auth_name AS 'plug_dest'
CREATE USER plug IDENTIFIED WITH AS plug_dest
CREATE USER plug IDENTIFIED WITH hh''s_test_plugin_server AS 'plug_dest'
CREATE USER plug IDENTIFIED WITH test_plugin_server AS @auth_string
CREATE USER plug IDENTIFIED WITH test_plugin_server AS plug_dest
CREATE USER plug_dest IDENTIFIED BY 'plug_dest_passwd' IDENTIFIED WITH 'test_plugin_server' AS 'plug_dest'
CREATE USER plüg IDENTIFIED WITH 'test_pluggggin_server' AS 'plüg_dest'
CREATE USER plüg IDENTIFIED WITH 'test_plugin_server' AS 'plüg_dest'
CREATE USER plüg IDENTIFIED WITH test_plugin_server AS 'plüg_dest'
CREATE USER plüg_dest IDENTIFIED BY 'plug_dest_passwd'
CREATE USER plüg_dest IDENTIFIED BY 'plug_dest_passwd'
CREATE USER u1 COMMENT 'Hello "Smith"'
CREATE USER u1 COMMENT 'Hello "Smith"'
CREATE USER u1@120.0.0.1
CREATE USER u1@120.0.0.1
CREATE USER u1@192.129.12.11
CREATE USER u1@localhost ATTRIBUTE "this is a string"
CREATE USER u1@localhost IDENTIFIED BY 'foo' COMMENT 'Not permitted to change this'
CREATE USER u1@localhost IDENTIFIED BY 'foo',u2@localhost IDENTIFIED BY 'foo' COMMENT "Works with partial restrictions"
CREATE USER u1@localhost REQUIRE NONE ACCOUNT LOCK WITH MAX_QUERIES_PER_HOUR 100
CREATE USER u3@120.0.0.1
CREATE USER u3@120.0.0.1
CREATE USER user1@
CREATE USER user1@47.9.9.9 IDENTIFIED BY 'pass1'
CREATE USER user3@%
CREATE USER user3@localhost BY 'auth_string' WITH 'sha_256_password'
CREATE USER user5@localhost IDENTIFIED  AS 'auth_string'
CREATE USER очень_очень_очень_длинный_дест__ IDENTIFIED BY 'plug_dest_passwd'
CREATE USER очень_очень_очень_длинный_юзер__ IDENTIFIED WITH 'test_plugin_server' AS 'очень_очень_очень_длинный_дест__'
CREATE USER очень_очень_очень_длинный_юзер__@localhost
CREATE USER очень_очень_очень_длинный_юзер__@localhost IDENTIFIED WITH 'cleartext_plugin_server' AS 'auth_string'
CREATE USER очень_очень_очень_длинный_юзер__@localhost IDENTIFIED WITH 'cleartext_plugin_server' AS 'auth_string' REQUIRE SSL
CREATE USER очень_очень_очень_длинный_юзер__@localhost IDENTIFIED WITH 'mysql_native_password' BY 'auth_string'
CREATE USER очень_очень_очень_длинный_юзер__@localhost IDENTIFIED WITH 'mysql_native_password' BY 'auth_string' REQUIRE SSL
CREATE USER очень_очень_очень_длинный_юзер__@localhost IDENTIFIED WITH 'sha256_password' BY 'auth_string'
CREATE USER очень_очень_очень_длинный_юзер__@localhost IDENTIFIED WITH 'sha256_password' BY 'auth_string' REQUIRE SSL
CREATE VIEW V_T1_C AS SELECT DB29023216.TESTFUNC()
CREATE VIEW v AS SELECT * FROM (VALUES ROW(1)) AS t1
CREATE VIEW v AS SELECT * FROM (VALUES ROW(1)) AS t1(x)
CREATE VIEW v AS SELECT INSERT('a', 1, 1, YEAR(UNHEX('w'))) AS c
CREATE VIEW v AS SELECT REPEAT('x', 1 NOT IN (0)) AS c
CREATE VIEW v AS SELECT i, j, JSON_ARRAYAGG(j) OVER (ORDER BY i DESC ROWS UNBOUNDED PRECEDING) jarray_j FROM t1
CREATE VIEW v AS SELECT i, j, JSON_OBJECTAGG(i,j) OVER (ORDER BY i DESC ROWS UNBOUNDED PRECEDING) jobject_j FROM t1
CREATE VIEW v AS VALUES
CREATE VIEW v AS VALUES ROW(1)
CREATE VIEW v(x) AS SELECT * FROM (VALUES ROW(1)) AS t1(z)
CREATE VIEW v(x) AS VALUES ROW(1)
CREATE VIEW v(x, y) AS VALUES ROW(1,2), ROW(2,4), ROW(3,6)
CREATE VIEW v1 (a) AS SELECT f1 IN (SELECT f1 FROM t1) FROM t1
CREATE VIEW v1 AS SELECT * FROM t1 FORCE KEY (PRIMARY,b) ORDER BY a
CREATE VIEW v1 AS SELECT 1 FROM t1 GROUP BY SUBSTRING(1 FROM (SELECT 3 FROM t1 WHERE a >= ANY(SELECT 1)))
CREATE VIEW v1 AS SELECT 1 IN (1 LIKE 2,0) AS f
CREATE VIEW v1 AS SELECT GROUPING(a2345678901234567890123456789012345678901234.a), GROUPING(a2345678901234567890123456789012345678901234.a), GROUPING(a2345678901234567890123456789012345678901234.a) FROM t1 AS a2345678901234567890123456789012345678901234 GROUP BY a WITH ROLLUP
CREATE VIEW v1 AS SELECT NOW(6), CURTIME(4), LOCALTIME(3), CURRENT_TIME(2), CURRENT_TIMESTAMP(0), LOCALTIMESTAMP(1), UTC_TIME(4), UTC_TIMESTAMP(4)
CREATE VIEW v1 AS SELECT STDDEV_SAMP(a) OVER ( ORDER BY a ROWS CURRENT ROW) AS std_dev_samp FROM t
CREATE VIEW v1 AS SELECT TRIM(BOTH 'y' FROM s) FROM t1
CREATE VIEW v1 AS SELECT TRIM(LEADING 'y' FROM s) FROM t1
CREATE VIEW v1 AS SELECT TRIM(TRAILING 'y' FROM s) FROM t1
CREATE VIEW v1 AS SELECT id, 'a' AS name, a AS val FROM t1 UNION SELECT id, 'mn', HEX(LIKE_RANGE_MIN(a, 16)) AS min FROM t1 UNION SELECT id, 'mx', HEX(LIKE_RANGE_MAX(a, 16)) AS max FROM t1 UNION SELECT id, 'sp', REPEAT('-', 32) AS sep FROM t1 ORDER BY id, name
CREATE VIEW v1 AS SELECT test.bug12812()
CREATE VIEW v2 AS SELECT * FROM t1 USE KEY () ORDER BY a
CREATE VIEW v2 AS SELECT GROUPING(a2345678901234567890123456789012345678901234xxxxxxxxxxxxxxxx.a), GROUPING(a2345678901234567890123456789012345678901234xxxxxxxxxxxxxxxx.a), GROUPING(a2345678901234567890123456789012345678901234xxxxxxxxxxxxxxxx.a) FROM t1 AS a2345678901234567890123456789012345678901234xxxxxxxxxxxxxxxx GROUP BY a WITH ROLLUP
CREATE VIEW v_mysqluser1_f1 AS SELECT mysqltest1.f1() AS a
create aggregate function bug16896() returns int return 1
create database имя_базы_в_кодировке_утф8_длиной_больше_чем_45
create definer=some_user@`` sql security invoker view v1 as select 1
create event задачка on schedule every 123 minute starts now() ends now() + interval 1 month do select 1
create event закачка on schedule every 10 hour do select get_lock("test_lock1", 20)
create event закачка on schedule every 10 hour do select get_lock("test_lock2", 20)
create event закачка21 on schedule every 10 hour do select get_lock("test_lock2_1", 20)
create event имя_события_в_кодировке_утф8_длиной_больше_чем_48 on schedule every 2 year do select 1
create event очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_66 on schedule every 2 year do select 1
create function `f``1` () returns int return 5
create function bug10015_2() returns int begin declare i, s int; set i:= (select min(id) from t1); set s:= (select max(id) from t1); return (s - i); end
create function bug10015_4(i int) returns int begin declare m int; set m:= (select max(id) from t2); insert into t2 values (i, m); return m; end
create function bug10015_6(i int) returns int begin declare continue handler for sqlexception set @error_in_func:= 1; if (i = 5) then insert into t2 values (4, 0), (1, 0); end if; return i; end
create function bug10015_7() returns int begin commit; return 1; end
create function bug10015_7() returns int begin start transaction; return 1; end
create function bug131333() returns int begin begin declare a int; set a = 1; end; begin declare b int; return b; end; end
create function bug13825_0() returns int begin rollback to savepoint x; return 1; end
create function bug13825_1() returns int begin release savepoint x; return 1; end
create function bug13825_2() returns int begin insert into t1 values (2); savepoint x; insert into t1 values (3); rollback to savepoint x; insert into t1 values (4); return 1; end
create function bug13825_3(rb int) returns int begin insert into t1 values(1); savepoint x; insert into t1 values(2); if rb then rollback to savepoint x; end if; insert into t1 values(3); return rb; end
create function bug13825_4() returns int begin savepoint x; insert into t1 values(2); rollback to savepoint x; return 0; end
create function bug13825_5(p int) returns int begin savepoint x; insert into t2 values(p); rollback to savepoint x; insert into t2 values(p+1); return p; end
create function bug13941(p_input_str text) returns text begin declare p_output_str text; set p_output_str = p_input_str; set p_output_str = replace(p_output_str, 'xyzzy', 'plugh'); set p_output_str = replace(p_output_str, 'test', 'prova'); set p_output_str = replace(p_output_str, 'this', 'questo'); set p_output_str = replace(p_output_str, ' a ', 'una '); set p_output_str = replace(p_output_str, 'is', ''); return p_output_str; end
create function bug14270() returns int begin cache index t1 key (`primary`) in keycache1; return 1; end
create function bug14270() returns int begin load index into cache t1; return 1; end
create function bug17615() returns varchar(256) unicode begin declare tmp_res varchar(256) unicode; set tmp_res= 'foo string'; return tmp_res; end
create function bug23333() RETURNS int(11) DETERMINISTIC begin insert into t1 values (null)
create function bug3287() returns int begin declare v int default null; case when v is not null then return 1; end case; return 2; end
create function bug4487() returns char begin declare v char; return v; end
create function bug5240 () returns int begin declare x int; declare c cursor for select data from t1 limit 1; open c; fetch c into x; close c; return x; end
create function bug7047() returns int begin alter function bug7047; return 0; end
create function bug7049_2() returns int begin declare x int default 0; declare continue handler for sqlexception set x = 1; set x = bug7049_1(); return x; end
create function bug8408() returns int begin declare n int default 0; select count(*) into n from t1; return n; end
create function bug8408() returns int begin show warnings; return 0; end
create function bug8408(a int) returns int begin declare b int; select b; return b; end
create function bug8409() returns int begin flush hosts; return 1; end
create function bug8409() returns int begin flush logs; return 1; end
create function bug8409() returns int begin flush privileges; return 1; end
create function bug8409() returns int begin flush status; return 1; end
create function bug8409() returns int begin flush tables with read lock; return 1; end
create function bug8409() returns int begin flush tables; return 1; end
create function bug8409() returns int begin flush tables; return 5; end
create function bug8409() returns int begin flush user_resources; return 1; end
create function bug8409() returns int begin reset master; return 1; end
create function bug8409() returns int begin reset slave; return 1; end
create function bug_9503 () returns int sql security invoker begin declare v int; select min(s1) into v from t1; return v; end
create function db() returns varchar(64) begin declare v varchar(64); select u into v from t1 limit 1; return v; end
create function f(val int) returns int begin declare x int; set x = val+3; end
create function f(val int) returns int begin declare x int; set x = val+3; if x < 4 then return x; end if; end
create function f1 (x INTEGER) returns integer begin declare ret integer; set ret = x * 10; return ret; end
create function f1() returns int begin alter event e1 rename to e2; return 1; end
create function f1() returns int begin deallocate prepare stmt; return 1; end
create function f1() returns int begin declare j int; select i from t1 where i = 1 into j; return j; end
create function f1() returns int begin declare j int; select i from t1 where i = 1 into j; return j; end
create function f1() returns int begin declare mx int; select max(a) from t1 into mx; return mx; end
create function f1() returns int begin declare n int; select count(*) into n from t1; return n; end
create function f1() returns int begin declare res int
create function f1() returns int begin declare v_out int; call p1(v_out); return v_out; end
create function f1() returns int begin declare x int; call p1(x); return x; end
create function f1() returns int begin drop event e2; return 1; end
create function f1() returns int begin show create event e1; return 1; end
create function f1(ab int) returns int begin declare i int; set i= (select max(a) from t1 where a < ab) ; return i; end
create function f11() returns int begin declare k int; set k= f1(); insert into t2 values (k+5); return k; end
create function f11() returns int begin declare k int; set k= f1(); insert into t2 values (k+5); return k; end
create function f14() returns int begin declare k int; call p2(k); insert into t2 values (k+5); return k; end
create function f14() returns int begin declare k int; call p2(k); insert into t2 values (k+5); return k; end
create function f15() returns int begin declare k int; call p2(k); return k; end
create function f15() returns int begin declare k int; call p2(k); return k; end
create function f17() returns int begin declare j int; select i from t1 where i = 1 into j; call p3; return 1; end
create function f2 () returns int begin declare v int; select s1 from t2 into v; return v; end
create function f2 () returns int begin declare v int; select s1 from t2 into v; return v; end
create function f2() returns int begin declare k int; select i from t1 where i = 1 into k; insert into t2 values (k + 5); return 0; end
create function f2() returns int begin declare k int; select i from t1 where i = 1 into k; insert into t2 values (k + 5); return 0; end
create function f2(ab int) returns int begin declare i int; set i= (select max(a) from t2 where a < ab) ; return i; end
create function f3() returns int begin declare n int; declare m int; set n:= (select min(data) from t1); set m:= (select max(data) from t1); return n < m; end
create function f3() returns varchar(255) begin declare res varchar(255); declare c cursor for select routine_name from information_schema.routines where routine_name='f1'; select f1() into @var; open c; fetch c into res; close c; select f2() into @var; return res; end
create function f6() returns int begin declare k int; select i from v1 where i = 1 into k; return k; end
create function f6() returns int begin declare k int; select i from v1 where i = 1 into k; return k; end
create function f6() returns int begin declare n int; set n:= f1(); return (select count(*) from t1 where data <= f7() and data <= n); end
create function f7() returns int begin declare k int; select j from v2 where j = 1 into k; return k; end
create function f7() returns int begin declare k int; select j from v2 where j = 1 into k; return k; end
create function f8() returns int begin declare k int; select i from v1 where i = 1 into k; insert into t2 values (k+5); return k; end
create function f8() returns int begin declare k int; select i from v1 where i = 1 into k; insert into t2 values (k+5); return k; end
create function f9() returns int begin declare a, b int; drop temporary table if exists t3; create temporary table t3 (id int); insert into t3 values (1), (2), (3); set a:= (select count(*) from t3); set b:= (select count(*) from t3 t3_alias); return a + b; end
create function fac(n int unsigned) returns bigint unsigned begin declare f bigint unsigned default 1; while n > 1 do set f = f * n; set n = n - 1; end while; return f; end
create function func1(x int) returns int deterministic begin declare z1, z2 int; set z1 = x; set z2 = z1+2; return z2; end
create function func_20028_a() returns integer begin declare temp integer; select i into temp from table_20028 limit 1; return ifnull(temp, 0); end
create function func_20028_a() returns integer begin declare temp integer; select i into temp from table_20028 limit 1; return ifnull(temp, 0); end
create function func_20028_c() returns integer begin declare div_zero integer; set SQL_MODE=''; select 1/0 into div_zero; return div_zero; end
create function func_20028_c() returns integer begin declare div_zero integer; set SQL_MODE='TRADITIONAL'; select 1/0 into div_zero; return div_zero; end
create function func_20713_a() returns int(11) begin declare id int; declare continue handler for sqlexception set id=null; set @in_func := 1; set id = (select id from bogus_table_20713 where id = 3); set @in_func := 2; return id; end
create function func_20713_b() returns int(11) begin declare id int; declare continue handler for sqlstate value '42S02' set id=null; set @in_func := 1; set id = (select id from bogus_table_20713 where id = 3); set @in_func := 2; return id; end
create function func_25345() returns int(11) begin call proc_25345(); return 1; end |
create function func_25345_b() returns int(11) begin declare c1 cursor for select a from table_25345_a; declare c2 cursor for select b from table_25345_b; return 1; end |
create function func_26093_a(x int) returns int begin set @invoked := @invoked + 1; return x; end
create function func_26093_b(x int, y int) returns int begin set @invoked := @invoked + 1; return x; end
create function func_8407_a() returns int begin declare x int; declare continue handler for sqlexception begin end; select 1 from no_such_view limit 1 into x; return x; end
create function func_8407_b() returns int begin declare x int default 0; declare continue handler for sqlstate '42S02' begin set x:= x+1000; end; case (select 1 from no_such_view limit 1) when 1 then set x:= x+1; when 2 then set x:= x+2; else set x:= x+100; end case; set x:=x + 500; return x; end
create function func_overflow() returns int BEGIN DECLARE x int default 0; BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN SET x=x+1; SET x=x+2; SET x=x+3; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; return x; END
create function getcount(s char(16)) returns int begin declare x int; select count(*) into x from t3 where v = s; if x = 0 then insert into t3 values (s, 1); else update t3 set c = c+1 where v = s; end if; return x; end
create function p(x int, x char(10)) begin end
create function t1max() returns int begin declare x int; select max(data) into x from t1; return x; end
create function test_signal_func() returns integer begin DECLARE v INT; DECLARE warn CONDITION FOR SQLSTATE "01XXX"; SIGNAL warn SET MESSAGE_TEXT = "This function SIGNAL a warning", MYSQL_ERRNO = 1012; SELECT @@warning_count INTO v; return v; end
create function имя_функции_в_кодировке_утф8_длиной_больше_чем_49() returns int return 0
create function очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_66() returns int return 0
create or replace view v1 (c,d,e,f) as select a,b, a in (select a+2 from t1), a = all (select a from t1) from t1
create procedure ``() select 1
create procedure ``.bug15658() select 1
create procedure b(x int) repeat insert into test.t1 values (repeat("b",3), x); set x = x-1; until x = 0 end repeat
create procedure b2(x int) repeat select 1 into outfile 'b2'; insert into test.t1 values (repeat("b2",3), x); set x = x-1; until x = 0 end repeat
create procedure bad_into(out param int) select x from t3 into param
create procedure bug10015_8() commit
create procedure bug10015_8() start transaction
create procedure bug10100pc(level int, lim int) begin declare lv int; declare c cursor for select a from t3; open c; if level < lim then select level; fetch c into lv; select lv; update t3 set a=level+lv; FLUSH TABLES; call bug10100pc(level+1, lim); else select * from t3; end if; close c; end
create procedure bug10100pd(level int, lim int) begin if level < lim then select level; prepare stmt1 from "update t3 set a=a+2"; execute stmt1; FLUSH TABLES; execute stmt1; FLUSH TABLES; execute stmt1; FLUSH TABLES; deallocate prepare stmt1; execute stmt2; select * from t3; call bug10100pd(level+1, lim); else execute stmt2; end if; end
create procedure bug10100pt(level int, lim int) begin if level < lim then update t3 set a=level; FLUSH TABLES; call bug10100pt(level+1, lim); else select * from t3; end if; end
create procedure bug10100pv(level int, lim int) begin if level < lim then update v1 set a=level; FLUSH TABLES; call bug10100pv(level+1, lim); else select * from v1; end if; end
create procedure bug10100t(prm int) begin declare res int; set res = 1; call bug10100p(prm, res); select res; end
create procedure bug10136() begin declare done int default 3; repeat select * from t3; set done = done - 1; until done <= 0 end repeat; end
create procedure bug10537() load data local infile '/tmp/somefile' into table t1
create procedure bug10656_create_index() begin create index bug10656_my_index on t3 (ID); end
create procedure bug10961() begin declare v char; declare x int; declare c cursor for select * from dual; declare continue handler for sqlexception select x; set x = 1; open c; set x = 2; fetch c into v; set x = 3; close c; end
create procedure bug10969() begin declare s1 int default 0; select default(s1) from t30; end
create procedure bug10969() begin declare s1 int default 0; select default(t30.s1) from t30; end
create procedure bug11333(i int) begin declare tmp varchar(128); set @x = 0; repeat select c1 into tmp from t3 where c1 = 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'; set @x = @x + 1; until @x >= i end repeat; end
create procedure bug11529() begin declare c cursor for select id, data from t1 where data in (10,13); open c; begin declare vid char(16); declare vdata int; declare exit handler for not found begin end; while true do fetch c into vid, vdata; end while; end; close c; end
create procedure bug12168(arg1 char(1)) begin declare b, c integer; if arg1 = 'a' then begin declare c1 cursor for select a from t3 where a % 2; declare continue handler for not found set b = 1; set b = 0; open c1; c1_repeat: repeat fetch c1 into c; if (b = 1) then leave c1_repeat; end if; insert into t4 values (c); until b = 1 end repeat; end; end if; if arg1 = 'b' then begin declare c2 cursor for select a from t3 where not a % 2; declare continue handler for not found set b = 1; set b = 0; open c2; c2_repeat: repeat fetch c2 into c; if (b = 1) then leave c2_repeat; end if; insert into t4 values (c); until b = 1 end repeat; end; end if; end
create procedure bug12589_1() begin declare spv1 decimal(3,3); set spv1= 123.456; set spv1 = 'test'; create temporary table tm1 as select spv1; show create table tm1; drop temporary table tm1; end
create procedure bug12589_2() begin declare spv1 decimal(6,3); set spv1= 123.456; create temporary table tm1 as select spv1; show create table tm1; drop temporary table tm1; end
create procedure bug12589_3() begin declare spv1 decimal(6,3); set spv1= -123.456; create temporary table tm1 as select spv1; show create table tm1; drop temporary table tm1; end
create procedure bug12849_1(inout x char) select x into x
create procedure bug12849_2(inout foo varchar(15)) begin select concat(foo, foo) INTO foo; end
create procedure bug12979_2() begin declare internal_var decimal(5); set internal_var= internal_var / 2; select internal_var; end
create procedure bug13012() BEGIN REPAIR TABLE t1,t2,t3,v1; OPTIMIZE TABLE t1,t2,t3,v1; ANALYZE TABLE t1,t2,t3,v1; END
create procedure bug13124() begin declare y integer; set @x=y; end
create procedure bug131333() begin begin declare a int; select a; set a = 1; select a; end; begin declare b int; select b; end; end
create procedure bug13510_1() begin declare password varchar(10); set password = 'foo1'; select password; end
create procedure bug13510_2() begin declare names varchar(10); set names = 'foo2'; select names; end
create procedure bug13510_3() begin declare password varchar(10); set `password` = 'foo3'; select password; end
create procedure bug13510_4() begin declare names varchar(10); set `names` = 'foo4'; select names; end
create procedure bug13825_0() begin rollback to savepoint x; end
create procedure bug13825_1() begin release savepoint x; end
create procedure bug13825_2() begin savepoint x; end
create procedure bug14210() begin declare a char(255); declare done int default 0; declare c cursor for select * from t3; declare continue handler for sqlstate '02000' set done = 1; open c; repeat fetch c into a; if not done then insert into t4 values (upper(a)); end if; until done end repeat; close c; end
create procedure bug14210_fill_table() begin declare table_size, max_table_size int default 0; select @@session.max_heap_table_size into max_table_size; delete from t3; insert into t3 (a) values (repeat('a', 255)); repeat insert into t3 select a from t3; select count(*)*255 from t3 into table_size; until table_size > max_table_size*2 end repeat; end
create procedure bug14376() begin declare x int default 42; begin declare x int default x; select x; end; end
create procedure bug14376() begin declare x int default x; end
create procedure bug14376(x int) begin declare x int default x; select x; end
create procedure bug14533_1() sql security definer desc db_bug14533.t1
create procedure bug14643_1() begin declare continue handler for sqlexception select 'boo' as 'Handler'; begin declare v int default undefined_var; if v = 1 then select 1; else select v, isnull(v); end if; end; end
create procedure bug14840_1() begin declare err int default 0; declare continue handler for sqlexception set err = err + 1; start transaction; update t3 set x = 1, y = 42 where x = 2; insert into t3 values (3, 4711); if err > 0 then rollback; else commit; end if; select * from t3; end
create procedure bug14840_2() begin declare err int default 0; declare continue handler for sqlexception begin set err = err + 1; select err as 'Ping'; end; update t3 set x = 1, y = 42 where x = 2; update t3 set x = 1, y = 42 where x = 2; insert into t3 values (3, 4711); select * from t3; end
create procedure bug14845() begin declare a char(255); declare done int default 0; declare c cursor for select count(*) from t1 where 1 = 0; declare continue handler for sqlstate '02000' set done = 1; open c; repeat fetch c into a; if not done then select a; end if; until done end repeat; close c; end
create procedure bug1495() begin declare x int; select data into x from t1 order by id limit 1; if x > 10 then insert into t1 values ("less", x-10); else insert into t1 values ("more", x+10); end if; end
create procedure bug15091() begin declare selectstr varchar(6000) default ' '; declare conditionstr varchar(5000)  default ''; set selectstr = concat(selectstr, ' and ', c.operatorid, 'in (',conditionstr, ')'); end
create procedure bug15217() begin declare var1 char(255); declare cur1 cursor for select * from t3; open cur1; fetch cur1 into var1; select concat('data was: /', var1, '/'); close cur1; end
create procedure bug15231_1() begin declare xid integer; declare xdone integer default 0; declare continue handler for not found set xdone = 1; set xid=null; call bug15231_2(xid); select xid, xdone; end
create procedure bug15231_2(inout ioid integer) begin select "Before NOT FOUND condition is triggered" as '1'; select id into ioid from t3 where id=ioid; select "After NOT FOUND condtition is triggered" as '2'; if ioid is null then set ioid=1; end if; end
create procedure bug15231_4() begin declare x decimal(2,1); set x = 'zap'; select 'Missed it (correct)' as 'Result'; show warnings; end
create procedure bug15231_6() begin declare x decimal(2,1); set x = 'zap'; select 'Missed it (correct)' as 'Result'; select id from t3; end
create procedure bug15441(county varchar(25)) begin declare c varchar(25) default "hello"; insert into t3 (id, county) values (1, county) on duplicate key update county= values(county); select * from t3; update t3 set id=2, county=values(id); select * from t3; end
create procedure bug1547(s char(16)) begin declare x int; select data into x from t1 where s = id limit 1; if x > 10 then insert into t1 values ("less", x-10); else insert into t1 values ("more", x+10); end if; end
create procedure bug16474_1() begin declare x int; select id from t1 order by x, id; end
create procedure bug1656(out p1 int, out p2 int) select * into p1, p1 from t70
create procedure bug16887() begin declare i int default 10; again: while i > 0 do begin declare breakchar varchar(1); declare done int default 0; declare t3_cursor cursor for select c from t3; declare continue handler for not found set done = 1; set i = i - 1; select i; if i = 3 then iterate again; end if; open t3_cursor; loop fetch t3_cursor into breakchar; if done = 1 then begin close t3_cursor; iterate again; end; end if; end loop; end; end while; end
create procedure bug1862() begin insert into t3 values(2); flush tables; end
create procedure bug1863(in1 int) begin declare ind int default 0; declare t1 int; declare t2 int; declare t3 int; declare rc int default 0; declare continue handler for 1065 set rc = 1; drop temporary table if exists temp_t1; create temporary table temp_t1 ( f1 int auto_increment, f2 varchar(20), primary key (f1) ); insert into temp_t1 (f2) select content from t3; select f2 into t3 from temp_t1 where f1 = 10; if (rc) then insert into t4 values (1, rc, t3); end if; insert into t4 values (2, rc, t3); end
create procedure bug1874() begin declare x int; declare y double; select max(data) into x from t1; insert into t2 values ("max", x, 0); select min(data) into x from t1; insert into t2 values ("min", x, 0); select sum(data) into x from t1; insert into t2 values ("sum", x, 0); select avg(data) into y from t1; insert into t2 values ("avg", 0, y); end
create procedure bug21416() show create procedure bug21416
create procedure bug2227(x int) begin declare y float default 2.6; declare z char(16) default "zzz"; select 1.3, x, y, 42, z; end
create procedure bug2259() begin declare v1 int; declare c1 cursor for select s1 from t1; fetch c1 into v1; end
create procedure bug2260() begin declare v1 int; declare c1 cursor for select data from t1; declare continue handler for not found set @x2 = 1; open c1; fetch c1 into v1; set @x2 = 2; close c1; end
create procedure bug2267_1() begin show procedure status where db='test'; end
create procedure bug2267_2() begin show function status where db='test'; end
create procedure bug2267_3() begin show create procedure bug2267_1; end
create procedure bug2267_4() begin show create function bug2267_4; end
create procedure bug2272() begin declare v int; update t1 set v = 42; end
create procedure bug2329_1() begin declare v int; insert into t1 (v) values (5); end
create procedure bug2329_2() begin declare v int; replace t1 set v = 5; end
create procedure bug3279(out y int) begin declare x int default 0; begin declare exit handler for sqlexception set x = x+1; insert into t3 values (5); end; if x < 2 then set x = x+1; insert into t3 values (6); end if; set y = x; end
create procedure bug336(out y int) begin declare x int; set x = (select sum(t.data) from test.t1 t); set y = x; end
create procedure bug3843() analyze table t1
create procedure bug4318() handler t3 read next
create procedure bug4344() drop function bug4344
create procedure bug4344() drop procedure bug4344
create procedure bug4579_1 () begin declare sf1 int; select f1 into sf1 from t3 where f1=1 and f2=1; update t3 set f2 = f2 + 1 where f1=1 and f2=1; call bug4579_2(); end
create procedure bug4726() begin declare tmp_o_id INT; declare tmp_d_id INT default 1; while tmp_d_id <= 2 do begin select f1 into tmp_o_id from t3 where f2=1 and f3=1; set tmp_d_id = tmp_d_id + 1; end; end while; end
create procedure bug4902() begin show charset like 'foo'; show collation like 'foo'; show create table t1; show create database test; show databases like 'foo'; show errors; show columns from t1; show keys from t1; show open tables like 'foo'; show status like 'foo'; show tables like 'foo'; show variables like 'foo'; show warnings; end
create procedure bug4905() begin declare v int; declare continue handler for sqlstate '23000' set v = 5; insert into t3 values (1); end
create procedure bug4941(out x int) begin declare c cursor for select i from t2 limit 1; open c; fetch c into x; close c; end
create procedure bug5251() checksum table t1
create procedure bug5258_aux() begin declare c, m char(19); select created,last_altered into c,m from information_schema.routines where routine_name = 'bug5258'; if c = m then select 'Ok'; else select c, m; end if; end
create procedure bug5963_1 () begin declare v int; set v = (select s1 from t3); select v; end;
create procedure bug5967(a varchar(255)) begin declare i varchar(255); declare c cursor for select a from t3; select a; select a from t3 into i; select i as 'Parameter takes precedence over table column';                     open c; fetch c into i; close c; select i as 'Parameter takes precedence over table column in cursors'; begin declare a varchar(255) default 'a - local variable'; declare c1 cursor for select a from t3; select a as 'A local variable takes precedence over parameter'; open c1; fetch c1 into i; close c1; select i as 'A local variable takes precedence over parameter in cursors'; begin declare a varchar(255) default 'a - local variable in a nested compound statement'; declare c2 cursor for select a from t3; select a as 'A local variable in a nested compound statement takes precedence over a local variable in the outer statement'; select a from t3 into i; select i as  'A local variable in a nested compound statement takes precedence over table column'; open c2; fetch c2 into i; close c2; select i as  'A local variable in a nested compound statement takes precedence over table column in cursors'; end; end; end
create procedure bug6063() begin lâbel: begin end; label: begin end; label1: begin end; end
create procedure bug6600() check table t1
create procedure bug6600() lock table t1 read
create procedure bug6600() unlock table t1
create procedure bug6857() begin declare t0, t1 int; declare plus bool default 0; set t0 = unix_timestamp(); select sleep(1.1); set t1 = unix_timestamp(); if t1 > t0 then set plus = 1; end if; select plus; end
create procedure bug7047() alter procedure bug7047
create procedure bug7088_2() läbel1: begin end
create procedure bug7299() begin declare v int; declare c cursor for select val from t1; declare exit handler for sqlexception select 'Error!'; open c; fetch c into v; end
create procedure bug7743 ( searchstring char(28) ) begin declare var mediumint(8) unsigned; select a into var from t4 where b = 2 and c = binary searchstring limit 1; show warnings; select var; end
create procedure bug7992() begin declare i int; select max(id)+1 into i from t3; end
create procedure bug7992_1() begin declare i int; select max(s1)+1 into i from t3; end
create procedure bug8116(in _userid int) select * from t3 where userid = _userid
create procedure bug822(a_id char(16), a_data int) begin declare n int; select count(*) into n from t1 where id = a_id and data = a_data; if n = 0 then insert into t1 (id, data) values (a_id, a_data); end if; end
create procedure bug8540() begin declare x int default 1; select x as y, x+0 as z; end
create procedure bug8692() begin declare v1 VARCHAR(10); declare v2 VARCHAR(10); declare v3 VARCHAR(10); declare v4 VARCHAR(10); declare v5 VARCHAR(10); declare v6 VARCHAR(10); declare v7 VARCHAR(10); declare c8692 cursor for select c1,c2,c3,c4,c5,c6,c7 from t3; open c8692; fetch c8692 into v1,v2,v3,v4,v5,v6,v7; select v1, v2, v3, v4, v5, v6, v7; end
create procedure bug8757() begin declare x int; declare c1 cursor for select data from t1 limit 1; begin declare y int; declare c2 cursor for select i from t2 limit 1; open c2; fetch c2 into y; close c2; select 2,y; end; open c1; fetch c1 into x; close c1; select 1,x; end
create procedure bug8850() begin truncate table t1; insert t1 values (1); rollback; end
create procedure bug8937() begin declare s,x,y,z int; declare a float; select sum(data),avg(data),min(data),max(data) into s,x,y,z from t1; select s,x,y,z; select avg(data) into a from t1; select a; end
create procedure bug9074() begin declare x1, x2, x3, x4, x5, x6 int default 0; begin declare continue handler for sqlstate '23000' set x5 = 1; insert into t3 values ('a', 'b'); set x6 = 1; end; begin1_label: begin declare continue handler for sqlstate '23000' set x1 = 1; insert into t3 values ('a', 'b'); set x2 = 1; begin2_label: begin declare exit handler for sqlstate '23000' set x3 = 1; set x4= 1; insert into t3 values ('a','b'); set x4= 0; end begin2_label; end begin1_label; select x1, x2, x3, x4, x5, x6; end
create procedure bug9367() begin declare v int; declare c cursor for select s1 from t1; open c; show warnings; fetch c into v; select v; end
create procedure bug9674_1(out arg int) begin declare temp_in1 int default 0; declare temp_fl1 int default 0; set temp_in1 = 100; set temp_fl1 = temp_in1/10; set arg = temp_fl1; end
create procedure bug9674_2() begin declare v int default 100; select v/10; end
create procedure bug9856() begin declare v int; declare c cursor for select data from t1; declare exit handler for sqlexception, not found select '16'; open c; fetch c into v; select v; end
create procedure cbv1() begin declare y int default 3; call cbv2(y+1, y); insert into test.t1 values ("cbv1", y); end
create procedure check_pk_inventory(in id integer) begin declare x integer; declare msg varchar(128); select count(item_id) from in_inventory where in_inventory.item_id = id into x; if (x != 1) then set msg= concat('Failed integrity constraint, table in_inventory, PK:', id); SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = msg, MYSQL_ERRNO = 10000; end if; end
create procedure check_pk_order(in id integer) begin declare x integer; declare msg varchar(128); select count(po_id) from po_order where po_order.po_id = id into x; if (x != 1) then set msg= concat('Failed integrity constraint, table po_order, PK:', id); SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = msg, MYSQL_ERRNO = 10000; end if; end
create procedure check_pk_person(in person_type char, in id integer) begin declare x integer; declare msg varchar(128); /* Test integrity constraints for an 'arc' relationship. Based on 'person_type', 'id' points to either a physical person, or a moral person. */ case person_type when 'P' then begin select count(person_id) from ab_physical_person where ab_physical_person.person_id = id into x; if (x != 1) then set msg= concat('No such physical person, PK:', id); SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = msg, MYSQL_ERRNO = 10000; end if; end; when 'M' then begin select count(company_id) from ab_moral_person where ab_moral_person.company_id = id into x; if (x != 1) then set msg= concat('No such moral person, PK:', id); SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = msg, MYSQL_ERRNO = 10000; end if; end; else begin set msg= concat('No such person type:', person_type); SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = msg, MYSQL_ERRNO = 50000; end; end case; end
create procedure code_sample(x int, out err int, out nulls int) begin declare count int default 0; set nulls = 0; begin declare c cursor for select name from t1; declare exit handler for not found close c; open c; loop begin declare n varchar(20); declare continue handler for sqlexception set err=1; fetch c into n; if isnull(n) then set nulls = nulls + 1; else set count = count + 1; update t2 set idx = count where name=n; end if; end; end loop; end; select t.name, t.idx from t2 t order by idx asc; end
create procedure cur1() begin declare a char(16); declare b int; declare c double; declare done int default 0; declare c cursor for select * from test.t2; declare continue handler for sqlstate '02000' set done = 1; open c; repeat fetch c into a, b, c; if not done then insert into test.t1 values (a, b+c); end if; until done end repeat; close c; end
create procedure cur2() begin declare done int default 0; declare c1 cursor for select id,data from test.t1 order by id,data; declare c2 cursor for select i from test.t2 order by i; declare continue handler for sqlstate '02000' set done = 1; open c1; open c2; repeat begin declare a char(16); declare b,c int; fetch from c1 into a, b; fetch next from c2 into c; if not done then if b < c then insert into test.t3 values (a, b); else insert into test.t3 values (a, c); end if; end if; end; until done end repeat; close c1; close c2; end
create procedure fib(n int unsigned) begin if n > 1 then begin declare x, y bigint unsigned; declare c cursor for select f from t3 order by f desc limit 2; open c; fetch c into y; fetch c into x; insert into t3 values (x+y); call fib(n-1); close c; end; end if; end
create procedure foo() create function bar() returns double return 2.3
create procedure foo() create procedure bar() set @x=3
create procedure h_ee() deterministic begin declare continue handler for 1062 -- ER_DUP_ENTRY select 'Outer (bad)' as 'h_ee'; begin declare continue handler for 1062 -- ER_DUP_ENTRY select 'Inner (good)' as 'h_ee'; insert into t3 values (1); end; end
create procedure h_en() deterministic begin declare continue handler for 1329 -- ER_SP_FETCH_NO_DATA select 'Outer (bad)' as 'h_en'; begin declare x int; declare continue handler for sqlstate '02000' -- no data select 'Inner (good)' as 'h_en'; select a into x from t3 where a = 42; end; end
create procedure h_es() deterministic begin declare continue handler for 1062 -- ER_DUP_ENTRY select 'Outer (bad)' as 'h_es'; begin declare continue handler for sqlstate '23000' select 'Inner (good)' as 'h_es'; insert into t3 values (1); end; end
create procedure h_ew() deterministic begin declare continue handler for 1264 -- ER_WARN_DATA_OUT_OF_RANGE select 'Outer (bad)' as 'h_ew'; begin declare continue handler for sqlwarning select 'Inner (good)' as 'h_ew'; insert into t3 values (123456789012); end; delete from t3; insert into t3 values (1); end
create procedure h_ex() deterministic begin declare continue handler for 1062 -- ER_DUP_ENTRY select 'Outer (bad)' as 'h_ex'; begin declare continue handler for sqlexception select 'Inner (good)' as 'h_ex'; insert into t3 values (1); end; end
create procedure h_ne() deterministic begin declare continue handler for not found select 'Outer (bad)' as 'h_ne'; begin declare x int; declare continue handler for 1329 -- ER_SP_FETCH_NO_DATA select 'Inner (good)' as 'h_ne'; select a into x from t3 where a = 42; end; end
create procedure h_nn() deterministic begin declare continue handler for not found select 'Outer (bad)' as 'h_nn'; begin declare x int; declare continue handler for not found select 'Inner (good)' as 'h_nn'; select a into x from t3 where a = 42; end; end
create procedure h_ns() deterministic begin declare continue handler for not found select 'Outer (bad)' as 'h_ns'; begin declare x int; declare continue handler for sqlstate '02000' -- no data select 'Inner (good)' as 'h_ns'; select a into x from t3 where a = 42; end; end
create procedure h_se() deterministic begin declare continue handler for sqlstate '23000' select 'Outer (bad)' as 'h_se'; begin declare continue handler for 1062 -- ER_DUP_ENTRY select 'Inner (good)' as 'h_se'; insert into t3 values (1); end; end
create procedure h_sn() deterministic begin declare continue handler for sqlstate '02000' -- no data select 'Outer (bad)' as 'h_sn'; begin declare x int; declare continue handler for not found select 'Inner (good)' as 'h_sn'; select a into x from t3 where a = 42; end; end
create procedure h_we() deterministic begin declare continue handler for sqlwarning select 'Outer (bad)' as 'h_we'; begin declare continue handler for 1264 -- ER_WARN_DATA_OUT_OF_RANGE select 'Inner (good)' as 'h_we'; insert into t3 values (123456789012); end; delete from t3; insert into t3 values (1); end
create procedure h_xe() deterministic begin declare continue handler for sqlexception select 'Outer (bad)' as 'h_xe'; begin declare continue handler for 1062 -- ER_DUP_ENTRY select 'Inner (good)' as 'h_xe'; insert into t3 values (1); end; end
create procedure hndlr1(val int) begin declare x int default 0; declare foo condition for 1136; declare bar condition for sqlstate '42S98';        # Just for testing syntax declare zip condition for sqlstate value '42S99';  # Just for testing syntax declare continue handler for foo set x = 1; insert into test.t1 values ("hndlr1", val, 2);  # Too many values if (x) then insert into test.t1 values ("hndlr1", val);   # This instead then end if; end
create procedure hndlr2(val int) begin declare x int default 0; begin declare exit handler for sqlstate '21S01' set x = 1; insert into test.t1 values ("hndlr2", val, 2); # Too many values end; insert into test.t1 values ("hndlr2", x); end
create procedure hndlr3(val int) begin declare x int default 0; declare continue handler for sqlexception        # Any error begin declare z int; set z = 2 * val; set x = 1; end; if val < 10 then begin declare y int; set y = val + 10; insert into test.t1 values ("hndlr3", y, 2);  # Too many values if x then insert into test.t1 values ("hndlr3", y); end if; end; end if; end
create procedure hndlr4() begin declare x int default 0; declare val int;	                           # No default declare continue handler for sqlstate '02000' set x=1; select data into val from test.t3 where id='z' limit 1;  # No hits insert into test.t3 values ('z', val); end
create procedure ifac(n int unsigned) begin declare i int unsigned default 1; if n > 20 then set n = 20;		# bigint overflow otherwise end if; while i <= n do begin insert into test.t3 values (i, fac(i)); set i = i + 1; end; end while; end
create procedure into_test(x char(16), y int) begin insert into test.t1 values (x, y); select id,data into x,y from test.t1 limit 1; insert into test.t1 values (concat(x, "2"), y+2); end
create procedure into_test2(x char(16), y int) begin insert into test.t1 values (x, y); select id,data into x,@z from test.t1 limit 1; insert into test.t1 values (concat(x, "2"), y+2); end
create procedure into_test3() begin declare x char(16); declare y int; select * into x,y from test.t1 limit 1; insert into test.t2 values (x, y, 0.0); end
create procedure into_test4() begin declare x int; select data into x from test.t1 limit 1; insert into test.t3 values ("into4", x); end
create procedure ip(m int unsigned) begin declare p bigint unsigned; declare i int unsigned; set i=45, p=201; while i < m do begin declare pp bool default 0; call opp(p, pp); if pp then insert into test.t3 values (i, p); set i = i+1; end if; set p = p+2; end; end while; end
create procedure locset(x char(16), y int) begin declare z1, z2 int; set z1 = y; set z2 = z1+2; insert into test.t1 values (x, z2); end
create procedure mixset(x char(16), y int) begin declare z int; set @z = y, z = 666; insert into test.t1 values (x, z); end
create procedure modes(out c1 int, out c2 int) begin declare done int default 0; declare x int; declare c cursor for select data from t1; declare continue handler for sqlstate '02000' set done = 1; select 1 || 2 into c1; set c2 = 0; open c; repeat fetch c into x; if not done then set c2 = c2 + 1; end if; until done end repeat; close c; end
create procedure mysqltest.p1() begin drop schema mysqltest; create schema mysqltest; end
create procedure mysqltest1.p1 (out prequestid varchar(100)) begin call mysqltest2.p2('call mysqltest3.p3(1, 2)'); end
create procedure mysqltest1.p1() begin alter database character set koi8r; end
create procedure mysqltest2.p2(in psql text) begin declare lsql text; set @lsql= psql; prepare lstatement from @lsql; execute lstatement; deallocate prepare lstatement; end
create procedure mysqltest_1 () begin begin declare continue handler for sqlexception begin end; update ignore t1 set a = 1 where a = 0; end; prepare stmt1 from 'alter table t1'; execute stmt1; end
create procedure nullset() begin declare ld date; declare li int; declare lf double; declare ls varchar(32); set ld = null, li = null, lf = null, ls = null; insert into t3 values (ld, li, lf, ls); insert into t3 (i, f, s) values ((ld is null), 1,    "ld is null"), ((li is null), 1,    "li is null"), ((li = 0),     null, "li = 0"), ((lf is null), 1,    "lf is null"), ((lf = 0),     null, "lf = 0"), ((ls is null), 1,    "ls is null"); end
create procedure opp(n bigint unsigned, out pp bool) begin declare r double; declare b, s bigint unsigned default 0; set r = sqrt(n); again: loop if s = 45 then set b = b+200, s = 0; else begin declare p bigint unsigned; select t.p into p from test.t3 t where t.i = s; if b+p > r then set pp = 1; leave again; end if; if mod(n, b+p) = 0 then set pp = 0; leave again; end if; set s = s+1; end; end if; end loop; end
create procedure p() begin declare c cursor for insert into test.t1 values ("foo", 42); open c; close c; end
create procedure p() begin declare c cursor for select * from t1; declare x int; end
create procedure p() begin declare continue handler for sqlexception begin end; create view a as select 1; end
create procedure p() begin declare utf8_var VARCHAR(128) CHARACTER SET UTF8; set utf8_var = concat(repeat('A', 128), 'X'); select length(utf8_var), utf8_var; end
create procedure p() begin declare utf8_var VARCHAR(128) CHARACTER SET UTF8; set utf8_var = concat(repeat('A', 128), 'X'); show warnings; select length(utf8_var), utf8_var; end
create procedure p() begin declare x float; declare x int; end
create procedure p() begin declare x int; declare c cursor for select * from t1; open c; fetch c into x, y; close c; end
create procedure p() begin declare x int; declare c cursor for select * from t1; open c; fetch c into x; close c; end
create procedure p() begin declare x int; declare c cursor for select * into x from test.t limit 1; open c; close c; end
create procedure p() begin declare x int; declare continue handler for sqlstate '42S99' set x = 1; declare c cursor for select * from t1; end
create procedure p() begin declare x int; declare continue handler for sqlstate '42S99' set x = 1; declare foo condition for sqlstate '42S99'; end
create procedure p() begin declare x int; declare y float; declare z int; declare c cursor for select * from t1; open c; fetch c into x, y, z; close c; end
create procedure p(val int, out res int) begin declare x int default 0; declare continue handler for foo set x = 1; insert into test.t1 values (val); if (x) then set res = 0; else set res = 1; end if; end
create procedure p(val int, out res int) begin declare x int default 0; declare foo condition for 1146; declare continue handler for bar set x = 1; insert into test.t1 values (val); if (x) then set res = 0; else set res = 1; end if; end
create procedure p1 () deterministic begin create view v1 as select 1; end;
create procedure p1 (a int) language sql deterministic begin declare rsql varchar(100); drop table if exists t1, t2; set @rsql= "create table t1 (a int)"; select @rsql; prepare pst from @rsql; execute pst; set @rsql= null; set @rsql= "create table t2 (a int)"; select @rsql; prepare pst from @rsql; execute pst; drop table if exists t1, t2; end
create procedure p1() begin alter event e1 rename to e2; end
create procedure p1() begin create view v1 as select 1; drop view v1; select f1() into @var; set @exec_count=@exec_count+1; end
create procedure p1() begin declare a char(10); set a="sp-variable"; set @a="mysql-variable"; prepare stmt from "select 'dynamic sql:', @a, a"; execute stmt; end
create procedure p1() begin declare a int; declare c cursor for select f1() from t1; declare continue handler for sqlstate '03000' select "caught 03000"; declare continue handler for 1326 select "caught cursor is not open"; select "Before open"; open c; select "Before fetch"; fetch c into a; select "Before close"; close c; end
create procedure p1() begin declare connection int; select max(t1.connection) into connection from t1; select concat("max=",connection) 'p1'; end
create procedure p1() begin declare counter integer default 0; declare continue handler for sqlexception begin set counter = counter + 10;end; repeat if rand()>0.5 then start transaction; end if; if rand()>0.5 then select var_samp(1), exists(select 1 from t1 lock in share mode) from t1 into @a,@b; end if; if rand()>0.5 then select var_samp(1), exists(select 1 from t1 for update) from t1 into @a,@b; end if; if rand()>0.5 then insert ignore into t1 values (); end if; if rand()>0.5 then insert ignore into t2 values (); end if; if rand()>0.5 then delete from t1; end if; if rand()>0.5 then delete from t2; end if; if rand()>0.5 then commit; end if; set counter = counter + 1; until counter >= 100 end repeat; end
create procedure p1() begin declare counter integer default 0; declare continue handler for sqlexception begin set counter = counter + 1;end; repeat if rand()>0.5 then start transaction; end if; if rand()>0.5 then select count(*) from t1 for update; end if; update t1 set a = 1 where a >= 0; set counter = counter + 1; until counter >= 50 end repeat; end
create procedure p1() begin declare done int default 3; repeat select (SELECT rs.t2_id FROM t2 rs WHERE rs.t1_id= (SELECT lt.t1_id FROM t1 lt WHERE lt.t3_id=a.t3_id) ORDER BY b DESC LIMIT 1) as x from t3 AS a; set done= done-1; until done <= 0 end repeat; end
create procedure p1() begin declare done integer default 0; declare vf1 char(100) ; declare vf2 mediumint; declare vf3 int ; declare vf4 real ; declare vf5 numeric ; declare cur1 cursor for select f1,f2,f3,f4,f5 from t1; declare continue handler for sqlstate '02000' set done = 1; open cur1; while done <> 1 do fetch cur1 into vf1, vf2, vf3, vf4, vf5; if not done then insert into t2 values (vf1, vf2, vf3, vf4, vf5); end if; end while; close cur1; end
create procedure p1() begin declare n int default 2; authors: while n > 0 do set n = n -1; end while authors; end
create procedure p1() begin declare v_stmt_text varchar(255); declare v_id integer; declare done int default 0; declare c cursor for select id, stmt_text from t1; declare continue handler for 1295 -- ER_UNSUPPORTED_PS set @status='not supported'; declare continue handler for 1064 -- ER_SYNTAX_ERROR set @status='syntax error'; declare continue handler for sqlstate '02000' set done = 1; prepare update_stmt from "update t1 set status=? where id=?"; open c; repeat if not done then fetch c into v_id, v_stmt_text; set @id=v_id, @stmt_text=v_stmt_text; set @status="supported"; prepare stmt from @stmt_text; execute update_stmt using @status, @id; end if; until done end repeat; deallocate prepare update_stmt; end
create procedure p1() begin drop event e1; end
create procedure p1() begin drop table if exists t1; create table t1 (id integer not null primary key, name varchar(20) not null); insert into t1 (id, name) values (1, 'aaa'), (2, 'bbb'), (3, 'ccc'); prepare stmt from "select name from t1"; execute stmt; select name from t1; execute stmt; prepare stmt from "select name from t1 where name=(select name from t1 where id=2)"; execute stmt; select name from t1 where name=(select name from t1 where id=2); execute stmt; end
create procedure p1() begin execute stmt; deallocate prepare stmt; end
create procedure p1() begin execute stmt; end
create procedure p1() begin prepare stmt from "create procedure p2() begin select 1; end"; execute stmt; deallocate prepare stmt; end
create procedure p1() begin prepare stmt from "drop procedure p2"; execute stmt; deallocate prepare stmt; end
create procedure p1() begin prepare stmt from "select 1"; execute stmt; execute stmt; execute stmt; deallocate prepare stmt; end
create procedure p1() begin prepare stmt from 'select 1 A'; execute stmt; end
create procedure p1() begin prepare stmt from 'select ? as a'; execute stmt using @a; end
create procedure p1() begin prepare stmt_drop from "drop table if exists t1"; execute stmt_drop; prepare stmt from "create table t1 (a int)"; execute stmt; deallocate prepare stmt; deallocate prepare stmt_drop; end
create procedure p1() begin prepare stmt_drop from "drop table if exists t1"; execute stmt_drop; prepare stmt from "create table t1 (a int)"; execute stmt; insert into t1 (a) values (1); select * from t1; prepare stmt_alter from "alter table t1 add (b int)"; execute stmt_alter; insert into t1 (a,b) values (2,1); deallocate prepare stmt_alter; deallocate prepare stmt; deallocate prepare stmt_drop; end
create procedure p1() begin select f1() into @var; execute stmt; end
create procedure p1() begin set @tab_name=concat("tab_", replace(curdate(), '-', '_')); set @drop_sql=concat("drop table if exists ", @tab_name); set @create_sql=concat("create table ", @tab_name, " (a int)"); set @insert_sql=concat("insert into ", @tab_name, " values (1), (2), (3)"); set @select_sql=concat("select * from ", @tab_name); select @tab_name; select @drop_sql; select @create_sql; select @insert_sql; select @select_sql; prepare stmt_drop from @drop_sql; execute stmt_drop; prepare stmt from @create_sql; execute stmt; prepare stmt from @insert_sql; execute stmt; prepare stmt from @select_sql; execute stmt; execute stmt_drop; deallocate prepare stmt; deallocate prepare stmt_drop; end
create procedure p1() create view v1 as select * from t1
create procedure p1() execute stmt
create procedure p1() flush hosts
create procedure p1() flush logs
create procedure p1() flush privileges
create procedure p1() flush status
create procedure p1() flush tables
create procedure p1() flush tables
create procedure p1() flush tables with read lock
create procedure p1() flush user_resources
create procedure p1() reset master
create procedure p1() reset slave
create procedure p1(a int) begin declare continue handler for 1436 -- ER_STACK_OVERRUN_NEED_MORE select 'exception'; call p1(a+1); end
create procedure p1(out param1 int) begin select count(*) into param1 from t3; end
create procedure p1(out sum int) begin declare n int default 0; declare c cursor for select * from t1; declare exit handler for not found begin close c; set sum = n; end; open c; loop begin declare x int; fetch c into x; if x > 3 then set n = n + x; end if; end; end loop; end
create procedure p1(out x int) select max(a) from t1 into x
create procedure p1(out x int) select max(a) from t2 into x
create procedure p1(tbl char(10), v int) begin set @s = concat('insert into ', tbl, ' values (?)'); set @v = v; prepare stmt1 from @s; execute stmt1 using @v; deallocate prepare stmt1; end
create procedure p2() begin declare msg VARCHAR(129) CHARACTER SET UTF8; set msg = concat(repeat('A', 128), 'X'); select length(msg), msg; signal sqlstate '55555' set message_text = msg; end
create procedure p2() begin declare msg VARCHAR(129) CHARACTER SET UTF8; set msg = concat(repeat('A', 128), 'X'); select length(msg), msg; signal sqlstate '55555' set message_text = msg; end
create procedure p2() begin declare n int default 2; contributors: while n > 0 do set n = n -1; end while contributors; end
create procedure p2(inout p int) begin select i from t1 where i = 1 into p; end
create procedure p2(inout p int) begin select i from t1 where i = 1 into p; end
create procedure p3 () reads sql data begin set profiling = ON; select 'This p3 should show up in profiling'; show profile; end
create procedure p3() begin declare name VARCHAR(65) CHARACTER SET UTF8; set name = concat(repeat('A', 64), 'X'); select length(name), name; signal sqlstate '55555' set message_text = 'Message', table_name = name; end
create procedure p3() begin declare name VARCHAR(65) CHARACTER SET UTF8; set name = concat(repeat('A', 64), 'X'); select length(name), name; signal sqlstate '55555' set message_text = 'Message', table_name = name; end
create procedure p_37228 () BEGIN DECLARE v INT DEFAULT 123; IF (v > 1) THEN SET v = 1; ELSEIF (v < 10) THEN SET v = 10; ELSEIF (v < 11) THEN SET v = 11; ELSEIF (v < 12) THEN SET v = 12; ELSEIF (v < 13) THEN SET v = 13; ELSEIF (v < 14) THEN SET v = 14; ELSEIF (v < 15) THEN SET v = 15; ELSEIF (v < 16) THEN SET v = 16; ELSEIF (v < 17) THEN SET v = 17; ELSEIF (v < 18) THEN SET v = 18; ELSEIF (v < 19) THEN SET v = 19; ELSEIF (v < 20) THEN SET v = 20; ELSEIF (v < 21) THEN SET v = 21; ELSEIF (v < 22) THEN SET v = 22; ELSEIF (v < 23) THEN SET v = 23; ELSEIF (v < 24) THEN SET v = 24; ELSEIF (v < 25) THEN SET v = 25; ELSEIF (v < 26) THEN SET v = 26; ELSEIF (v < 27) THEN SET v = 27; ELSEIF (v < 28) THEN SET v = 28; ELSEIF (v < 29) THEN SET v = 29; ELSEIF (v < 30) THEN SET v = 30; ELSEIF (v < 31) THEN SET v = 31; ELSEIF (v < 32) THEN SET v = 32; ELSEIF (v < 33) THEN SET v = 33; ELSEIF (v < 34) THEN SET v = 34; ELSEIF (v < 35) THEN SET v = 35; ELSEIF (v < 36) THEN SET v = 36; ELSEIF (v < 37) THEN SET v = 37; ELSEIF (v < 38) THEN SET v = 38; ELSEIF (v < 39) THEN SET v = 39; END IF; END
create procedure p_37269() begin declare done int default 0; declare varb int default 0; declare vara int default 0; repeat select now(); until done end repeat; while varb do select now(); begin select now(); repeat select now(); until done end repeat; if vara then select now(); repeat select now(); loop select now(); end loop; repeat select now(); label1: while varb do select now(); end while label1; if vara then select now(); repeat select now(); until done end repeat; begin select now(); while varb do select now(); label1: while varb do select now(); end while label1; if vara then select now(); while varb do select now(); loop select now(); end loop; repeat select now(); loop select now(); while varb do select now(); end while; repeat select now(); label1: loop select now(); if vara then select now(); end if; end loop label1; until done end repeat; end loop; until done end repeat; end while; end if; end while; end; end if; until done end repeat; until done end repeat; end if; end; end while; end
create procedure p_bug11247(lim int) begin declare v int default 0; while v < lim do set v= f_bug11247(v); end while; end
create procedure p_create() begin declare i int default 1; set @lock_table_stmt="lock table "; set @drop_table_stmt="drop table "; while i < @@global.table_definition_cache + 1 do set @table_name=concat("t_", i); set @opt_comma=if(i=1, "", ", "); set @lock_table_stmt=concat(@lock_table_stmt, @opt_comma, @table_name, " read"); set @drop_table_stmt=concat(@drop_table_stmt, @opt_comma, @table_name); set @create_table_stmt=concat("create table if not exists ", @table_name, " (a int)"); prepare stmt from @create_table_stmt; execute stmt; deallocate prepare stmt; set i= i+1; end while; end
create procedure p_verify_reprepare_count(expected int) begin declare old_reprepare_count int default @reprepare_count; select variable_value from performance_schema.session_status where variable_name='com_stmt_reprepare' into @reprepare_count; if old_reprepare_count + expected <> @reprepare_count then select concat("Expected: ", expected, ", actual: ", @reprepare_count - old_reprepare_count) as "ERROR"; else select '' as "SUCCESS"; end if; end
create procedure p_verify_reprepare_count(expected int) begin declare old_reprepare_count int default @reprepare_count; select variable_value from performance_schema.session_status where variable_name='com_stmt_reprepare' into @reprepare_count; if old_reprepare_count + expected <> @reprepare_count then select concat("Expected: ", expected, ", actual: ", @reprepare_count - old_reprepare_count) as "ERROR"; else select '' as "SUCCESS"; end if; end
create procedure p_verify_reprepare_count(expected int) begin declare old_reprepare_count int default @reprepare_count; select variable_value from performance_schema.session_status where variable_name='com_stmt_reprepare' into @reprepare_count; if old_reprepare_count + expected <> @reprepare_count then select concat("Expected: ", expected, ", actual: ", @reprepare_count - old_reprepare_count) as "ERROR"; else select '' as "SUCCESS"; end if; end
create procedure proc_1() install plugin my_plug soname '\\root\\some_plugin.dll'
create procedure proc_20028_a() begin declare temp integer; select i into temp from table_20028 limit 1; end
create procedure proc_20028_a() begin declare temp integer; select i into temp from table_20028 limit 1; end
create procedure proc_20028_c() begin declare div_zero integer; set SQL_MODE=''; select 1/0 into div_zero; end
create procedure proc_20028_c() begin declare div_zero integer; set SQL_MODE='TRADITIONAL'; select 1/0 into div_zero; end
create procedure proc_25345() begin declare c1 cursor for select a from table_25345_a; declare c2 cursor for select b from table_25345_b; select 1 as result; end |
create procedure proc_26503_ok_1(v int) begin declare i int default 5; declare continue handler for sqlexception begin select 'caught something'; retry: while i > 0 do begin set i = i - 1; select 'looping', i; iterate retry; select 'dead code'; end; end while retry; select 'leaving handler'; end; select 'do something'; insert into table_26503 values (v); select 'do something again'; insert into table_26503 values (v); end
create procedure proc_26503_ok_2(v int) begin declare i int default 5; declare continue handler for sqlexception begin select 'caught something'; retry: while i > 0 do begin set i = i - 1; select 'looping', i; leave retry; select 'dead code'; end; end while; select 'leaving handler'; end; select 'do something'; insert into table_26503 values (v); select 'do something again'; insert into table_26503 values (v); end
create procedure proc_26503_ok_3(v int) begin declare i int default 5; retry: begin declare continue handler for sqlexception begin select 'caught something'; retry: while i > 0 do begin set i = i - 1; select 'looping', i; iterate retry; select 'dead code'; end; end while retry; select 'leaving handler'; end; select 'do something'; insert into table_26503 values (v); select 'do something again'; insert into table_26503 values (v); end; end
create procedure proc_26503_ok_4(v int) begin declare i int default 5; retry: begin declare continue handler for sqlexception begin select 'caught something'; retry: while i > 0 do begin set i = i - 1; select 'looping', i; leave retry; select 'dead code'; end; end while; select 'leaving handler'; end; select 'do something'; insert into table_26503 values (v); select 'do something again'; insert into table_26503 values (v); end; end
create procedure proc_26977_broken(v int) begin declare i int default 5; declare continue handler for sqlexception begin select 'caught something'; retry: while i > 0 do begin set i = i - 1; select 'looping', i; end; end while retry; end; select 'do something'; insert into t1 values (v); select 'do something again'; insert into t1 values (v); end
create procedure proc_26977_works(v int) begin declare i int default 5; declare continue handler for sqlexception begin select 'caught something'; retry: while i > 0 do begin set i = i - 1; select 'looping', i; end; end while retry; select 'optimizer: keep hreturn'; end; select 'do something'; insert into t1 values (v); select 'do something again'; insert into t1 values (v); end
create procedure proc_33618_c(num int) begin declare count1 int default '0'; declare vb varchar(30); declare last_row int; while(num>=1) do set num=num-1; begin declare cur1 cursor for select `a` from t_33618; declare continue handler for not found set last_row = 1; set last_row:=0; open cur1; rep1: repeat begin declare cur2 cursor for select `b` from t_33618; fetch cur1 into vb; if (last_row = 1) then leave rep1; end if; end; until last_row=1 end repeat; close cur1; end; end while; end
create procedure proc_33618_h(num int) begin declare count1 int default '0'; declare vb varchar(30); declare last_row int; while(num>=1) do set num=num-1; begin declare cur1 cursor for select `a` from t_33618; declare continue handler for not found set last_row = 1; set last_row:=0; open cur1; rep1: repeat begin declare exit handler for 1062 begin end; fetch cur1 into vb; if (last_row = 1) then leave rep1; end if; end; until last_row=1 end repeat; close cur1; end; end while; end
create procedure proc_bug19733() begin declare v int default 0; while v < 100 do create index i on t3 (s1); drop index i on t3; set v = v + 1; end while; end
create procedure proc_middle_a(p1 integer) begin DECLARE l integer; DECLARE EXIT HANDLER for 1 /* not sure how to handle exceptions */ begin select "Oops ... now what ?"; end; select "In prod_middle()"; create temporary table t1(a integer, b integer); select GET_LOCK("user_mutex", 10) into l; insert into t1 set a = p1, b = p1; call proc_bottom_a(p1); select RELEASE_LOCK("user_mutex") into l; drop temporary table t1; end
create procedure proc_middle_b(p1 integer) begin DECLARE l integer; DECLARE EXIT HANDLER for SQLEXCEPTION, NOT FOUND begin begin DECLARE CONTINUE HANDLER for SQLEXCEPTION, NOT FOUND begin /* Ignore errors from the cleanup code */ end; select "Doing cleanup !"; select RELEASE_LOCK("user_mutex") into l; drop temporary table t1; end; RESIGNAL; end; select "In prod_middle()"; create temporary table t1(a integer, b integer); select GET_LOCK("user_mutex", 10) into l; insert into t1 set a = p1, b = p1; call proc_bottom_b(p1); select RELEASE_LOCK("user_mutex") into l; drop temporary table t1; end
create procedure px5 () begin declare v int; declare c cursor for select version from information_schema.tables where table_schema <> 'information_schema'; open c; fetch c into v; select v; close c; end;
create procedure scope(a int, b float) begin declare b int; declare c float; begin declare c int; end; end
create procedure setcontext() begin declare data int default 2; insert into t1 (id, data) values ("foo", 1); replace t1 set data = data, id = "bar"; update t1 set id = "kaka", data = 3 where t1.data = data; end
create procedure solver(initial_leftm varchar(200), initial_rightm varchar(200)) begin declare initial_leftm_j  json; declare initial_rightm_j json; set initial_leftm_j  = cast(initial_leftm as json), initial_rightm_j = cast(initial_rightm as json); with recursive number_of_lines (value) as (select json_length(initial_rightm_j)), number_of_columns (value) as (select json_length(json_extract(initial_leftm_j,"$[0]"))), line_numbers (n) as ( select 0 union all select n+1 from line_numbers, number_of_lines where n<(value-1) ), column_numbers (n) as ( select 0 union all select n+1 from line_numbers, number_of_columns where n<(value-1) ), equations (null_if_done, leftm, rightm, pivot_lines, pivot_columns) as ( select 0, initial_leftm_j, initial_rightm_j, cast("" as char(200)), cast("" as char(200)) union all select cur_pivot.cur_pivot_line , ( select "[" || group_concat( ( select "[" || group_concat( json_extract(json_extract(eq.leftm, "$[" || ln.n || "]"), "$[" || cn.n || "]") - (case when find_in_set(ln.n,eq.pivot_lines)=0 and ln.n<>cur_pivot.cur_pivot_line then json_extract(json_extract(eq.leftm, "$[" || ln.n || "]"), "$[" || cur_pivot.cur_pivot_column || "]") * json_extract(json_extract(eq.leftm, "$[" || cur_pivot.cur_pivot_line || "]"), "$[" || cn.n || "]") / cur_pivot.cur_pivot_value else 0 end) order by cn.n separator ',') || "]" from column_numbers cn ) order by ln.n separator ',') || "]" from line_numbers ln ), ( select "[" || group_concat( json_extract(eq.rightm, "$[" || ln.n || "]") - (case when find_in_set(ln.n,eq.pivot_lines)=0 and ln.n<>cur_pivot.cur_pivot_line then json_extract(json_extract(eq.leftm, "$[" || ln.n || "]"), "$[" || cur_pivot.cur_pivot_column || "]") * json_extract(eq.rightm, "$[" || cur_pivot.cur_pivot_line || "]") / cur_pivot.cur_pivot_value else 0 end) order by ln.n separator ',') || "]" from line_numbers ln ), coalesce(cur_pivot.cur_pivot_line, "") || "," || eq.pivot_lines, coalesce(cur_pivot.cur_pivot_column, "") || "," || eq.pivot_columns from equations eq left join lateral ( select ln.n as cur_pivot_line, cn.n as cur_pivot_column, ( json_extract(json_extract(eq.leftm, "$[" || ln.n || "]"), "$[" || cn.n || "]") ) as cur_pivot_value from line_numbers ln join column_numbers cn where find_in_set(ln.n,eq.pivot_lines)=0 and json_extract(json_extract(eq.leftm, "$[" || ln.n || "]"), "$[" || cn.n || "]") <> 0 order by cur_pivot_line,cur_pivot_column limit 1 ) as cur_pivot on 1 where eq.null_if_done is not null ), final_equations as ( select * from equations where null_if_done is null ) select json_extract(eq.leftm, "$[" || ln.n || "]")  as left_member, json_extract(eq.rightm, "$[" || ln.n || "]") as right_member, free.value as list_of_free_unknowns from final_equations eq, line_numbers ln, ( select group_concat(cn.n+1) as value from final_equations eq, column_numbers cn where find_in_set(cn.n,eq.pivot_columns)=0 ) as free order by find_in_set(ln.n,eq.pivot_lines), ln.n; end
create procedure sp1() begin declare a int; set a= (select f1(4) + count(*) A from t1, v1); end
create procedure sp1() begin declare x int; declare c cursor for select f1(3) + count(*) from v1; open c; fetch c into x; end;
create procedure sub2(id char(16)) begin declare x int; set x = (select sum(t.i) from test.t2 t); insert into test.t1 values (id, x); end
create procedure sudoku_solve(p_naive boolean, p_all boolean) deterministic modifies sql data begin drop temporary table if exists sudoku_work, sudoku_schedule; create temporary table sudoku_work ( `row` smallint not null, col smallint not null, dig smallint not null, cnt smallint, key using btree (cnt), key using btree (`row`), key using btree (col), unique key using hash (`row`,col) ); create temporary table sudoku_schedule ( idx int not null auto_increment primary key, `row` smallint not null, col smallint not null ); call sudoku_init(); if p_naive then update sudoku_work set cnt = 0 where dig = 0; else call sudoku_count(); end if; insert into sudoku_schedule (`row`,col) select `row`,col from sudoku_work where cnt is not null order by cnt desc; begin declare v_scounter bigint default 0; declare v_i smallint default 1; declare v_dig smallint; declare v_schedmax smallint; select count(*) into v_schedmax from sudoku_schedule; more: loop begin declare v_tcounter bigint default 0; sched: while v_i <= v_schedmax do begin declare v_row, v_col smallint; select `row`,col into v_row,v_col from sudoku_schedule where v_i = idx; select dig into v_dig from sudoku_work where v_row = `row` and v_col = col; case v_dig when 0 then set v_dig = 1; update sudoku_work set dig = 1 where v_row = `row` and v_col = col; when 9 then if v_i > 0 then update sudoku_work set dig = 0 where v_row = `row` and v_col = col; set v_i = v_i - 1; iterate sched; else select v_scounter as 'Solutions'; leave more; end if; else set v_dig = v_dig + 1; update sudoku_work set dig = v_dig where v_row = `row` and v_col = col; end case; set v_tcounter = v_tcounter + 1; if not sudoku_digit_ok(v_row, v_col, v_dig) then iterate sched; end if; set v_i = v_i + 1; end; end while sched; select dig from sudoku_work; select v_tcounter as 'Tests'; set v_scounter = v_scounter + 1; if p_all and v_i > 0 then set v_i = v_i - 1; else leave more; end if; end; end loop more; end; drop temporary table sudoku_work, sudoku_schedule; end
create procedure syntaxerror(t int)
create procedure syntaxerror(t int)
create procedure syntaxerror(t int)
create procedure t_sysdate() begin select sysdate() into @a; do sleep(2); select sysdate() into @b; select @a != @b; end;
create procedure test_invalid() begin SIGNAL; end
create procedure test_resignal() begin DECLARE x integer; DECLARE c cursor for select * from t_cursor; DECLARE CONTINUE HANDLER for not found begin select "before RESIGNAL"; RESIGNAL SQLSTATE "02444" SET MESSAGE_TEXT = "RESIGNAL to a not found", MYSQL_ERRNO = 55555 ; select "after RESIGNAL"; end; open c; fetch c into x; close c; end
create procedure test_resignal() begin DECLARE x integer; DECLARE c cursor for select * from t_cursor; DECLARE CONTINUE HANDLER for not found begin select "before RESIGNAL"; RESIGNAL SQLSTATE "44444" SET MESSAGE_TEXT = "RESIGNAL to an error", MYSQL_ERRNO = 55555 ; select "after RESIGNAL"; end; open c; fetch c into x; close c; end
create procedure test_signal() begin DECLARE 'céèçà' CONDITION FOR SQLSTATE '12345'; SIGNAL 'céèçà' SET MYSQL_ERRNO = 1000; end
create procedure test_signal() begin DECLARE aaa VARCHAR(64); DECLARE bbb VARCHAR(64); DECLARE ccc VARCHAR(64); DECLARE ddd VARCHAR(64); DECLARE eee VARCHAR(64); DECLARE fff VARCHAR(64); DECLARE ggg VARCHAR(64); DECLARE hhh VARCHAR(64); DECLARE iii VARCHAR(64); DECLARE jjj VARCHAR(64); DECLARE kkk VARCHAR(64); DECLARE warn CONDITION FOR SQLSTATE "01234"; set aaa= repeat("A", 64); set bbb= repeat("B", 64); set ccc= repeat("C", 64); set ddd= repeat("D", 64); set eee= repeat("E", 64); set fff= repeat("F", 64); set ggg= repeat("G", 64); set hhh= repeat("H", 64); set iii= repeat("I", 64); set jjj= repeat("J", 64); set kkk= repeat("K", 64); SIGNAL warn SET CLASS_ORIGIN = aaa, SUBCLASS_ORIGIN = bbb, CONSTRAINT_CATALOG = ccc, CONSTRAINT_SCHEMA = ddd, CONSTRAINT_NAME = eee, CATALOG_NAME = fff, SCHEMA_NAME = ggg, TABLE_NAME = hhh, COLUMN_NAME = iii, CURSOR_NAME = jjj, MESSAGE_TEXT = kkk, MYSQL_ERRNO = 65535; end
create procedure test_signal() begin DECLARE céèçà foo CONDITION FOR SQLSTATE '12345'; SIGNAL céèçà SET MYSQL_ERRNO = 1000; end
create procedure test_signal() begin DECLARE something CONDITION FOR SQLSTATE '99999'; DECLARE message_text VARCHAR(64) DEFAULT "Local string variable"; DECLARE sqlcode INTEGER DEFAULT 1234; SIGNAL something SET MESSAGE_TEXT = message_text, MYSQL_ERRNO = sqlcode; end
create procedure u() use sptmp
create procedure wg2() begin declare v int default 1; declare tdec decimal(5) default 0; while v <= 9 do set tdec =tdec * 10; select v, tdec; set v = v + 1; end while; end
create procedure zap(x int, out y int) begin declare z int; set z = x+1, y = z; end
create procedure zip(x char(16), y int) begin declare z int; call zap(y, z); call bar(x, z); end
create procedure имя_процедуры_в_кодировке_утф8_длиной_больше_чем_50() begin end
create procedure очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_66() begin end
create table BIT_XOR (a int)
create table BIT_XOR (a int)
create table BIT_XOR(a int)
create table BIT_XOR(a int)
create table `#mysql50#abc``def` ( id int )
create table `` (a int)
create table ```a` (i int)
create table `about:text` ( _id int not null auto_increment, `about:text` varchar(255) not null default '', primary key (_id) )
create table `t1a``b` (col1 char(2))
create table `t``1`(a int) engine=myisam
create table `t``1`(a int) engine=myisam
create table b15776 (data blob(-1))
create table b15776 (data blob(2147483648))
create table b15776 (data blob(4294967294))
create table b15776 (data blob(4294967295))
create table b15776 (data blob(4294967296))
create table t (i)
create table t1 ( a int not null references t2, b int not null references t2 (c), primary key (a,b), foreign key (a) references t3 match full, foreign key (a) references t3 match partial, foreign key (a,b) references t3 (c,d) on delete no action on update no action, foreign key (a,b) references t3 (c,d) on update cascade, foreign key (a,b) references t3 (c,d) on delete set default, foreign key (a,b) references t3 (c,d) on update set null) engine=myisam
create table t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by range (a) subpartition by hash (a+b) ( partition x1 values less than (1) ( subpartition x11 nodegroup 0, subpartition x12 nodegroup 1), partition x2 values less than (5) ( subpartition x21 nodegroup 0, subpartition x22 nodegroup 1), partition x3 values less than (10) ( subpartition x31 max_rows=50, subpartition x32 nodegroup 1) )
create table t1 ( c1 int NOT NULL, c2 int NOT NULL, PRIMARY KEY USING HASH (c1), INDEX USING BTREE(c2) )
create table t1 ( dummyKey INTEGER NOT NULL AUTO_INCREMENT, a001 TINYINT, a010 TINYINT, a012 TINYINT, a015 TINYINT, a016 TINYINT, a017 TINYINT, a019 TINYINT, a029 TINYINT, a030 TINYINT, a031 TINYINT, a032 TINYINT, a042 TINYINT, a043 TINYINT, a044 TINYINT, a3001 TINYINT, a3002 TINYINT, a3003 TINYINT, a3004 TINYINT, a3005 TINYINT, a3021 TINYINT, a3022 TINYINT, a BIT(6), b BIT(6), c BIT(6), d TINYINT, e TINYINT, f TINYINT, g TINYINT, h TINYINT, i TINYINT, j TINYINT, k TINYINT, l TINYINT, m TINYINT, n TINYINT, o TINYINT, a034 TINYINT, PRIMARY KEY USING HASH (dummyKey) ) engine=archive
create table t1 ( min_num   dec(6,6)     default .000001)
create table t1 ( min_num   dec(6,6)     default .000001)
create table t1 ( min_num   dec(6,6)     default 0.000001)
create table t1 (,b int)
create table t1 (`` int)
create table t1 (a char(10), unique using btree (a)) charset latin1 engine=heap
create table t1 (a int not null, key `a` key_block_size=1024 (a))
create table t1 (a int not null, key key_block_size=1024 (a))
create table t1 (a int not null,b int not null, primary key using BTREE (a)) engine=heap comment="testing heaps"
create table t1 (a int not null,b int not null, primary key using BTREE (a)) engine=heap comment="testing heaps"
create table t1 (a int not null,b int not null, primary key using BTREE (a)) engine=heap comment="testing heaps" avg_row_length=100 min_rows=1 max_rows=100
create table t1 (a int not null,b int not null, primary key using HASH (a)) engine=heap comment="testing heaps"
create table t1 (a int not null,b int not null, primary key using HASH (a)) engine=heap comment="testing heaps"
create table t1 (a int not null,b int not null, primary key using HASH (a)) engine=heap comment="testing heaps" avg_row_length=100 min_rows=1 max_rows=100
create table t1 (a int) partition by key(a) partitions -1
create table t1 (a int) partition by key(a) partitions 0.2+e1
create table t1 (a int) partition by range (a) ( partition p0 values less than (NULL), partition p1 values less than (MAXVALUE))
create table t1 (a int) partition by range (a) ( partition p0 values less than (maxvalue))
create table t1 (a int) transactional=0
create table t1 (a int, b char(10), c varchar(25), d datetime) partition by range columns(a,b,c,d) subpartition by hash (to_seconds(d)) subpartitions 4 ( partition p0 values less than (1, '0', MAXVALUE, '1900-01-01'), partition p1 values less than (1, 'a', MAXVALUE, '1999-01-01'), partition p2 values less than (1, 'b', MAXVALUE, MAXVALUE), partition p3 values less than (1, MAXVALUE, MAXVALUE, MAXVALUE))
create table t1 (a int, b char(10), c varchar(25), d datetime) partition by range columns(a,b,c,d) subpartition by hash (to_seconds(d)) subpartitions 4 ( partition p0 values less than (1, 0, MAXVALUE, '1900-01-01'), partition p1 values less than (1, 'a', MAXVALUE, '1999-01-01'), partition p2 values less than (1, 'a', MAXVALUE, MAXVALUE), partition p3 values less than (1, MAXVALUE, MAXVALUE, MAXVALUE))
create table t1 (a int, b int) partition by list columns(a,b) ( partition p0 values in ((maxvalue, 0)))
create table t1 (a int, b int) partition by list columns(a,b) (partition p0 values in ((maxvalue,maxvalue)))
create table t1 (a int, b int) partition by range columns (a,b) ( partition p0 values less than (maxvalue, 10), partition p1 values less than (maxvalue, maxvalue))
create table t1 (a int, b int) partition by range columns (a,b) (partition p0 values less than (NULL, maxvalue))
create table t1 (a int, b int) partition by range columns(a,b) (partition p0 values less than (1, 0), partition p1 values less than (2, maxvalue), partition p2 values less than (3, 3), partition p3 values less than (10, maxvalue))
create table t1 (a int, b int) partition by range columns(a,b) (partition p0 values less than (maxvalue, 10))
create table t1 (a int, b int) partition by range columns(a,b) (partition p0 values less than (maxvalue,maxvalue))
create table t1 (a int, b int, c int) partition by range columns (a,b,c) ( partition p0 values less than (1, maxvalue, 10), partition p1 values less than (1, maxvalue, maxvalue))
create table t1 (a int,)
create table t1 (a int,,b int)
create table t1 (a timestamp default now())
create table t1 (b int4 unsigned not null)
create table t1 (btn char(10) not null, key using BTREE (btn)) charset utf8mb4 engine=heap
create table t1 (btn char(10) not null, key using HASH (btn)) charset utf8mb4 engine=heap
create table t1 (c national character varying(10))
create table t1 (i int, index `` (i))
create table t1 (id int unsigned not null, primary key  using BTREE (id)) engine=HEAP
create table t1 (id int unsigned not null, primary key  using HASH (id)) engine=HEAP
create table t1 (id int) partition by range (id) (partition p0 values less than (1000), partition p1 values less than (maxvalue))
create table t1 (k int, index (k), index using hash (k)) engine=heap
create table t1 (k int, index using btree (k)) charset utf8mb4 engine=innodb
create table t1 (k int, index using btree (k), index (k)) engine=innodb
create table t1 (k int, index using btree (k), index using hash (k)) engine=heap
create table t1 (k int, index using btree (k), index using hash (k)) engine=innodb
create table t1 (k int, index using hash (k)) charset utf8mb4 engine=heap
create table t1 (s1 int) partition by list (s1) (partition c values in (1), partition Ç values in (3))
create table t1 (t1 timestamp not null default '2003-01-01 00:00:00' on update now(), t2 datetime)
create table t1 (t1 timestamp not null default now() on update now(), t2 datetime)
create table t1 (t1 timestamp not null default now(), t2 datetime, t3 timestamp NOT NULL DEFAULT '0000-00-00 00:00:00')
create table t1 (t6 timestamp) type=myisam
create table t1 (v varchar(10), c char(10), t varchar(50), key using btree (v), key using btree (c), key using btree (t(10))) charset latin1
create table t1 charset latin1 select bin(130), oct(130), conv(130,16,10), hex(130), char(130), format(130,10), left(_latin2'a',1), right(_latin2'a',1), lcase(_latin2'a'), ucase(_latin2'a'), substring(_latin2'a',1,1), concat(_latin2'a',_latin2'b'), lpad(_latin2'a',4,_latin2'b'), rpad(_latin2'a',4,_latin2'b'), concat_ws(_latin2'a',_latin2'b'), make_set(255,_latin2'a',_latin2'b',_latin2'c'), export_set(255,_latin2'y',_latin2'n',_latin2' '), trim(_latin2' a '), ltrim(_latin2' a '), rtrim(_latin2' a '), trim(LEADING _latin2' ' FROM _latin2' a '), trim(TRAILING _latin2' ' FROM _latin2' a '), trim(BOTH _latin2' ' FROM _latin2' a '), repeat(_latin2'a',10), reverse(_latin2'ab'), quote(_latin2'ab'), soundex(_latin2'ab'), substring(_latin2'ab',1), insert(_latin2'abcd',2,3,_latin2'ef'), replace(_latin2'abcd',_latin2'b',_latin2'B')
create table t1 charset latin1 select weight_string(repeat('t',66000)) as w
create table t1 select null as c00, if(1, null, 'string') as c01, if(0, null, 'string') as c02, ifnull(null, 'string') as c03, ifnull('string', null) as c04, case when 0 then null else 'string' end as c05, case when 1 then null else 'string' end as c06, coalesce(null, 'string') as c07, coalesce('string', null) as c08, least('string',null) as c09, least(null, 'string') as c10, greatest('string',null) as c11, greatest(null, 'string') as c12, nullif('string', null) as c13, nullif(null, 'string') as c14, trim('string' from null) as c15, trim(null from 'string') as c16, substring_index('string', null, 1) as c17, substring_index(null, 'string', 1) as c18, elt(1, null, 'string') as c19, elt(1, 'string', null) as c20, concat('string', null) as c21, concat(null, 'string') as c22, concat_ws('sep', 'string', null) as c23, concat_ws('sep', null, 'string') as c24, concat_ws(null, 'string', 'string') as c25, make_set(3, 'string', null) as c26, make_set(3, null, 'string') as c27, export_set(3, null, 'off', 'sep') as c29, export_set(3, 'on', null, 'sep') as c30, export_set(3, 'on', 'off', null) as c31, replace(null, 'from', 'to') as c32, replace('str', null, 'to') as c33, replace('str', 'from', null) as c34, insert('str', 1, 2, null) as c35, insert(null, 1, 2, 'str') as c36, lpad('str', 10, null) as c37, rpad(null, 10, 'str') as c38
create table t1( bool_col bool, boolean_col boolean, bit_col bit(5), tiny tinyint, tiny_uns tinyint unsigned, small smallint, small_uns smallint unsigned, medium mediumint, medium_uns mediumint unsigned, int_col int, int_col_uns int unsigned, big bigint, big_uns bigint unsigned, decimal_col decimal(10,5), numeric_col numeric(10), fixed_col fixed(10), dec_col dec(10), decimal_col_uns decimal(10,5) unsigned, fcol float, fcol_uns float unsigned, dcol double, double_precision_col double precision, dcol_uns double unsigned, date_col date, time_col time, timestamp_col timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, year_col year, datetime_col datetime, char_col char(5), varchar_col varchar(10), binary_col binary(10), varbinary_col varbinary(10), tinyblob_col tinyblob, blob_col blob, mediumblob_col mediumblob, longblob_col longblob, text_col text, mediumtext_col mediumtext, longtext_col longtext, enum_col enum("A","B","C"), set_col set("F","E","D") )
create table t1(a int not null, key using btree(a)) engine=heap
create table t1(a varchar(255), b varchar(255), key using btree (a,b)) engine=memory
create table t1(column.name int)
create table t1(t1.name int)
create table t1(test.column.name int)
create table t1(xyz.t1.name int)
create table t2 (a int) page_checksum=1
create table t2 (b timestamp default now())
create table t2 (primary key (auto)) select auto+1 as auto,1 as t1, 'a' as t2, repeat('a',256) as t3, binary repeat('b',256) as t4, repeat('a',4096) as t5, binary repeat('b',4096) as t6, '' as t7, binary '' as t8 from t1
create table t2 select default(str) as str, default(strnull) as strnull, default(intg) as intg, default(rel) as rel from t1
create table t2(test.t2.name int)
create table t3 (a int) row_format=page
create table t3 select t1.* as 'with_alias' from t1
create table t3 select t2.* as 'with_alias', 1, 2 from t2
create table t3 select t2.* as 'with_alias', d as 'x', d as 'z' from t2
create table t3 select t2.*, t2.* as 'with_alias', 3 from t2
create table t9 (a date not null) partition by RANGE(TO_DAYS(a)) ( partition p0 values less than (732299), -- 2004-12-19 partition p1 values less than (732468), -- 2005-06-06 partition p2 values less than (732664)  -- 2005-12-19 )
create table t_34455 ( a int not null, foreign key (a) references t3 (a) match full match partial)
create table t_34455 ( a int not null, foreign key (a) references t3 (a) on delete set default match full)
create table t_34455 ( a int not null, foreign key (a) references t3 (a) on delete set default on delete set default)
create table t_34455 ( a int not null, foreign key (a) references t3 (a) on update set default match full)
create table t_34455 ( a int not null, foreign key (a) references t3 (a) on update set default on update set default)
create table t_illegal (a int, b int, check a>b)
create table t_illegal (a int, b int, constraint abc check a>b)
create table t_illegal (a int, b int, constraint abc)
create table test_reserved (condition int)
create table test_reserved (resignal int)
create table test_reserved (signal int)
create table th (k int, index using btree (k)) charset utf8mb4 engine=heap
create table ti (k int, index using btree (k)) charset utf8mb4 engine=innodb
create table ti (k int, index using hash (k)) charset utf8mb4 engine=innodb
create table tm (k int, index using btree (k)) charset utf8mb4 engine=myisam
create table İ (s1 int)
create table İİ (s1 int)
create table имя_таблицы_в_кодировке_утф8_длиной_больше_чем_48 ( имя_поля_в_кодировке_утф8_длиной_больше_чем_45 int, index имя_индекса_в_кодировке_утф8_длиной_больше_чем_48 (имя_поля_в_кодировке_утф8_длиной_больше_чем_45) )
create tablespace ndb_ts1 add datafile 'ndb_ts1.dat' use logfile group ndb_lg1 engine=myisam
create tablespace ndb_ts1 add datafile 'ndb_ts1.dat' use logfile group ndb_lg1 engine=myisam
create tablespace ndb_ts1 add datafile 'ndb_ts1.dat' use logfile group ndb_lg1 engine=myisam initial_size=32M
create temporary table tg (i int not null) engine=merge union=()
create trigger ad after delete on t1 for each row set @a:= old.at
create trigger ai after insert on t1 for each row set @a:= new.at
create trigger au after update on t1 for each row set @a:= new.at
create trigger bd before delete on t1 for each row set @a:= old.bt
create trigger bi before insert on t1 for each row set @a:= new.bt
create trigger bu before update on t1 for each row set @a:= new.bt
create trigger t1_ad after delete on t1 for each row set @log:= concat(@log, "(AFTER_DELETE: old=(id=", old.id, ", data=", old.data,"))")
create trigger t1_ai after insert on t1 for each row begin DECLARE msg VARCHAR(128); DECLARE error CONDITION FOR SQLSTATE "03XXX"; set msg= concat("This trigger SIGNAL an error, a=", NEW.a); SIGNAL error SET MESSAGE_TEXT = msg, MYSQL_ERRNO = 1012; end
create trigger t1_ai after insert on t1 for each row begin DECLARE msg VARCHAR(128); DECLARE not_found CONDITION FOR SQLSTATE "02XXX"; set msg= concat("This trigger SIGNAL a not found, a=", NEW.a); SIGNAL not_found SET MESSAGE_TEXT = msg, MYSQL_ERRNO = 1012; end
create trigger t1_ai after insert on t1 for each row begin DECLARE msg VARCHAR(128); DECLARE warn CONDITION FOR SQLSTATE "01XXX"; set msg= concat("This trigger SIGNAL a warning, a=", NEW.a); SIGNAL warn SET MESSAGE_TEXT = msg, MYSQL_ERRNO = 1012; end
create trigger t1_ai after insert on t1 for each row begin declare sn numeric(15,2); select sum(n) into sn from t1 where i=new.i; replace into t2 values(new.i, sn); end
create trigger t1_ai after insert on t1 for each row flush hosts
create trigger t1_ai after insert on t1 for each row flush logs
create trigger t1_ai after insert on t1 for each row flush privileges
create trigger t1_ai after insert on t1 for each row flush status
create trigger t1_ai after insert on t1 for each row flush tables
create trigger t1_ai after insert on t1 for each row flush tables with read lock
create trigger t1_ai after insert on t1 for each row flush user_resources
create trigger t1_ai after insert on t1 for each row reset master
create trigger t1_ai after insert on t1 for each row reset slave
create trigger t1_ai after insert on t1 for each row set @a := 7
create trigger t1_ai after insert on t1 for each row set @a:= (select max(a) from t1)
create trigger t1_ai after insert on t1 for each row set @a:=bug11555_1()
create trigger t1_ai after insert on t1 for each row set @log:= concat(@log, "(AFTER_INSERT: new=(id=", new.id, ", data=", new.data,"))")
create trigger t1_ai after insert on t1 for each row show create event e1
create trigger t1_ai after insert on test.t1 for each row set @b:=new.id
create trigger t1_au after update on t1 for each row set @log:= concat(@log, "(AFTER_UPDATE: old=(id=", old.id, ", data=", old.data, ") new=(id=", new.id, ", data=", new.data,"))")
create trigger t1_bd before delete on t1 for each row set @log:= concat(@log, "(BEFORE_DELETE: old=(id=", old.id, ", data=", old.data,"))")
create trigger t1_bi before insert on t1 for each row begin if new.id > f1() then set new.id:= f1(); end if; end
create trigger t1_bi before insert on t1 for each row begin insert into t2 values (new.id, new.v); update t2 set v=v+1 where id= new.id; replace t3 values (new.id, 0); update t2, t3 set t2.v=new.v, t3.v=new.v where t2.id=t3.id; create temporary table t5 select * from t1; delete from t5; insert into t5 select * from t1; insert into t4 values (0); set @check= (select count(*) from t5); update t4 set c= @check; drop temporary table t5; set @a:=1/0; end
create trigger t1_bi before insert on t1 for each row begin set new.a := upper(new.a); set new.b := new.b + 3; end
create trigger t1_bi before insert on t1 for each row set @a:= f1() + 10
create trigger t1_bi before insert on t1 for each row set @a:=1
create trigger t1_bi before insert on t1 for each row set @a:=1
create trigger t1_bi before insert on t1 for each row set @a:=1/0
create trigger t1_bi before insert on t1 for each row set @a:=new.id
create trigger t1_bi before insert on t1 for each row set @a:=new.id
create trigger t1_bi before insert on t1 for each row set @log:= concat(@log, "(BEFORE_INSERT: new=(id=", new.id, ", data=", new.data,"))")
create trigger t1_bi before insert on t1 for each row set NEW.b := "In trigger t1_bi"
create trigger t1_bi before insert on t1 for each row set new.udt:= convert_tz(new.ldt, 'Europe/Moscow', 'UTC')
create trigger t1_bi before insert on test.t1 for each row set @a:=0
create trigger t1_bu before update on t1 for each row set @log:= concat(@log, "(BEFORE_UPDATE: old=(id=", old.id, ", data=", old.data, ") new=(id=", new.id, ", data=", new.data,"))")
create trigger t1_trg before insert on t1 for each row set NEW.id:= 1
create trigger t1_whoupdated before update on t1 for each row begin declare user varchar(32); declare i int; select user() into user; set NEW.username = user; select count(*) from ((select 1) union (select 2)) as d1 into i; end
create trigger t2_ai after insert on t2 for each row set @a:= (select max(a) from t2)
create trigger t2_bd before delete on t2 for each row begin insert into t1 values (2); savepoint x; insert into t1 values (3); rollback to savepoint x; insert into t1 values (4); end
create trigger t2_bi before insert on t2 for each row rollback to savepoint x
create trigger t2_bi before insert on t2 for each row set @a:=1
create trigger t2_bi before insert on t2 for each row set @a:=1
create trigger t2_bi before insert on t2 for each row set @a:=1
create trigger t2_bu before update on t2 for each row release savepoint x
create trigger t4_bi before insert on t4 for each row begin declare k int; select i from t1 where i=1 into k; set new.l= k+1; end
create trigger t4_bi before insert on t4 for each row begin declare k int; select i from t1 where i=1 into k; set new.l= k+1; end
create trigger t4_bi before insert on t4 for each row set @t4_bi_called:=1
create trigger t4_bu before update on t4 for each row set @t4_bu_called:=1
create trigger t5_bu before update on t5 for each row begin declare j int; call p2(j); set new.l= j + 1; end
create trigger t5_bu before update on t5 for each row begin declare j int; call p2(j); set new.l= j + 1; end
create trigger t_16_bi before insert on t_16 for each row create event  e_16 on schedule every 1 second do set @a=5
create trigger test.t1_bi before insert on t1 for each row set @a:=0
create trigger test.trg1 before insert on t1 for each row set @a:= 1
create trigger trg after delete on t1 for each row set @del:= 1
create trigger trg after insert on t1 for each row set @a:= if(@a,concat(@a, ":", new.i), new.i)
create trigger trg after insert on t1 for each row set @a:=1
create trigger trg after update on t1 for each row set @total_change:=@total_change + new.i - old.i
create trigger trg after update on t1 for each row set new.i:=1
create trigger trg before delete on t1 for each row set @a:= new.i
create trigger trg before delete on t1 for each row set @del_sum:= @del_sum + old.i
create trigger trg before delete on t1 for each row set new.i:=1
create trigger trg before insert on t1 for each row begin declare done int default 0; set done= not done; end
create trigger trg before insert on t1 for each row begin if isnull(new.j) then set new.j:= new.i * 10; end if; end
create trigger trg before insert on t1 for each row begin select event_name from information_schema.events; end|                                                                                                                                                    --error ER_EVENT_RECURSION_FORBIDDEN create function f1() returns int begin create event e2 on schedule every 10 hour do select 1; return 1; end
create trigger trg before insert on t1 for each row begin show create event e1; end
create trigger trg before insert on t1 for each row set @a:= old.i
create trigger trg before insert on t1 for each row set @a:=1
create trigger trg before insert on t1 for each row set @a:=1
create trigger trg before insert on t1 for each row set @a:=1
create trigger trg before insert on t1 for each row set @a:=new.i
create trigger trg before insert on t2 for each row set @a:=1
create trigger trg before insert on t3 for each row set @a:=1
create trigger trg before insert on v1 for each row set @a:=1
create trigger trg before update on t1 for each row begin declare loc_err varchar(255); if abs(new.balance - old.balance) > 1000 then set new.balance:= old.balance; set loc_err := concat("Too big change for aid = ", new.aid); set @update_failed:= if(@update_failed, concat(@a, ":", loc_err), loc_err); end if; end
create trigger trg before update on t1 for each row set @a:=old.j
create trigger trg before update on t1 for each row set new.j:=1
create trigger trg before update on t1 for each row set old.i:=1
create trigger trg1 before delete on t1 for each row set @del_before:= @del_before + old.i
create trigger trg1 before insert on mysqltest.t1 for each row set @a:= 1
create trigger trg1 before insert on t1 for each row begin if new.a > 10 then set new.a := 10; set new.a := 11; end if; end
create trigger trg1 before insert on t1 for each row begin if new.i = 1 then set new.j := 1; end if; end
create trigger trg1 before insert on t1 for each row begin if new.j > 10 then set new.j := 10; end if; end
create trigger trg1 before insert on t1 for each row begin if new.j > 10 then set new.j := 10; end if; end
create trigger trg1 before insert on t1 for each row set @a:= 1
create trigger trg1 before insert on t1 for each row set @a:=1
create trigger trg1 before update on t1 for each row set @a:= @a + new.j - old.j
create trigger trg2 after delete on t1 for each row set @del_after:= @del_after + old.i
create trigger trg2 after insert on t1 for each row set @a:= 1
create trigger trg2 after insert on t1 for each row set @b:= "Fired"
create trigger trg2 after update on t1 for each row set @b:= "Fired"
create trigger trg2 before insert on t3 for each row set @a:=1
create trigger trg2 before update on t1 for each row begin if old.a % 2 = 0 then set new.b := 12; end if; end
create trigger trg2 before update on t1 for each row begin if old.i % 2 = 0 then set new.j := -1; end if; end
create trigger trg2 before update on t1 for each row begin if old.i % 2 = 0 then set new.j := -1; end if; end
create trigger trg3 after update on t1 for each row begin if new.a = -1 then set @fired:= "Yes"; end if; end
create trigger trg3 after update on t1 for each row begin if new.j = -1 then set @fired:= "Yes"; end if; end
create trigger trg3 after update on t1 for each row begin if new.j = -1 then set @fired:= "Yes"; end if; end
create trigger trg3 before delete on t1 for each row set @c:= @c + old.j
create trigger trg4 before delete on t2 for each row set @d:= @d + old.i
create trigger trg4 before insert on t2 for each row begin if new.a > 10 then set @fired:= "No"; end if; end
create trigger trg5 after delete on t1 for each row set @e:= "After delete t1 fired"
create trigger trg6 after delete on t2 for each row set @f:= "After delete t2 fired"
create trigger trigger_overflow before insert on table_overflow for each row BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN SET NEW.b := NEW.a; SET NEW.b := NEW.b + 1; SET NEW.b := NEW.b + 2; SET NEW.b := NEW.b + 3; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END
create trigger wont_work after update on event for each row begin set @a:= 1; end
create trigger wont_work after update on mysql.user for each row begin set @a:= 1; end
create trigger имя_триггера_в_кодировке_утф8_длиной_больше_чем_49 before insert on имя_таблицы_в_кодировке_утф8_длиной_больше_чем_48 for each row set @a:=1
create trigger очень_очень_очень_очень_очень_очень_очень_очень_длинная_строка_66 before insert on имя_таблицы_в_кодировке_утф8_длиной_больше_чем_48 for each row set @a:=1
create user test@127.0.0.1 identified by "gambling"
create view bug12602983_v1 as select mysqltest_db.f1()
create view bug12602983_v1 as select mysqltest_db.f_does_not_exist()
create view information_schema.v1
create view v1 (c,d,e,f) as select a,b, a in (select a+2 from t1), a = all (select a from t1) from t1
create view v1 (c,d,e,f) as select a,b, a in (select a+2 from t1), a = all (select a from t1) from t1
create view v1 as select t1.a as f1, dt.a as f2 from t1, lateral (select t1.a+t2.a as a from t2) dt
create view v1 as select test.`f``1` ()
create view v3 as select bug23491_original.f1()
create view имя_вью_кодировке_утф8_длиной_больше_чем_42 as select имя_поля_в_кодировке_утф8_длиной_больше_чем_45 from имя_таблицы_в_кодировке_утф8_длиной_больше_чем_48