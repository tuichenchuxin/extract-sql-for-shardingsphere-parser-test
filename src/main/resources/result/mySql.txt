CALL mtr.add_suppression("default_storage_engine is set to a disabled storage engine .*")
CALL mtr.add_suppression("default_tmp_storage_engine is set to a disabled storage engine .*")
CALL mtr.add_suppression("Plugin mysqlx reported: 'All I/O interfaces are disabled")
CREATE TABLESPACE tb1 ADD DATAFILE 't1.ibd' ENGINE=INNODB
CREATE TABLESPACE t1 ADD DATAFILE 't1.ibd' ENGINE=INNODB
CREATE TABLESPACE t1 ADD DATAFILE 't1.ibd' ENGINE=HEAP
RENAME TABLE t1 to t2
LOCK TABLES t2 WRITE
RENAME TABLE t2 TO t1
UNLOCK TABLES
LOCK TABLE t1 WRITE
RENAME TABLE t1 TO t3
UNLOCK TABLES
LOCK TABLES t2 WRITE
RENAME TABLE t2 TO t1
UNLOCK TABLES
LOCK TABLES v1 WRITE
RENAME TABLE v1 TO v2
UNLOCK TABLES
flush table
PREPARE check_view_columns FROM 'SELECT table_name, column_name, column_type FROM information_schema.columns WHERE table_name= ? ORDER BY table_name, column_name'
PREPARE check_view_status FROM 'SELECT table_name, table_comment FROM information_schema.tables WHERE table_name= ?'
EXECUTE check_view_columns USING @view
EXECUTE check_view_columns USING @view
EXECUTE check_view_columns USING @view
EXECUTE check_view_columns USING @view
EXECUTE check_view_columns USING @view
EXECUTE check_view_columns USING @view
EXECUTE check_view_columns USING @view
EXECUTE check_view_columns USING @view
EXECUTE check_view_columns USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_columns USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_columns USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_columns USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_columns USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
RENAME TABLE t2 TO t5
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
RENAME TABLE t5 to t2
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
LOCK TABLE t1 WRITE
UNLOCK TABLES
EXECUTE check_view_columns USING @view
EXECUTE check_view_columns using @view
LOCK TABLE t1 WRITE
UNLOCK TABLES
EXECUTE check_view_columns using @view
EXECUTE check_view_columns USING @view
EXECUTE check_view_columns USING @view
LOCK TABLE t2 WRITE
UNLOCK TABLES
EXECUTE check_view_columns USING @view
EXECUTE check_view_columns USING @view
EXECUTE check_view_status USING @view
LOCK TABLE t1 WRITE
UNLOCK TABLES
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
LOCK TABLE t1 WRITE
UNLOCK TABLES
EXECUTE check_view_status USING @view
LOCK TABLE t2 WRITE
UNLOCK TABLES
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
LOCK TABLE t2 WRITE
UNLOCK TABLES
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
LOCK TABLE t2 WRITE
UNLOCK TABLES
EXECUTE check_view_status USING @view
EXECUTE check_view_status USING @view
DEALLOCATE PREPARE check_view_columns
DEALLOCATE PREPARE check_view_status
UNLOCK TABLES
UNLOCK TABLES
CALL mtr.add_suppression("Failed to find tablespace")
CALL mtr.add_suppression("Ignoring tablespace")
CALL mtr.add_suppression("Cannot rename")
CALL mtr.add_suppression("Cannot calculate")
CALL mtr.add_suppression("Cannot open datafile")
CALL mtr.add_suppression("The error means the system cannot find")
CALL mtr.add_suppression("File ./s/t_innodb.ibd")
CALL mtr.add_suppression("Operating system error number")
CALL mysql.p1()
CALL mysql.p1()
disable_query_log
enable_query_log
call mtr.add_suppression("Column count of mysql.* is wrong. " "Expected .*, found .*. " "The table is probably corrupted")
CREATE PROCEDURE account.account(OUT ac CHAR(20)) BEGIN SELECT account.`account`.account INTO ac FROM account.account; END
CALL account.account(@account)
select _rowid,t1._rowid,skey,sval from t1
echo '#________________________VAR_09_INNODB_LOG_FILE_SIZE__________________#' echo '##' SELECT COUNT(@@GLOBAL.innodb_log_file_size)
CALL mtr.add_suppression("Failed to set up SSL because of the following *")
cat_file $MYSQLD_DATADIR/test_system_variable_source.log
remove_file $MYSQLD_DATADIR/test_system_variable_source.log
cat_file $MYSQLD_DATADIR/test_system_variable_source.log
remove_file $MYSQLD_DATADIR/test_system_variable_source.log
cat_file $MYSQLD_DATADIR/test_system_variable_source.log
remove_file $MYSQLD_DATADIR/test_system_variable_source.log
cat_file $MYSQLD_DATADIR/test_system_variable_source.log
remove_file $MYSQLD_DATADIR/test_system_variable_source.log
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR CURRENT_USER() USING r1
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR u1@localhost USING r1,r2
SHOW GRANTS FOR u1@localhost USING r1,r2
SHOW GRANTS FOR u1@localhost USING r1,r2
SHOW GRANTS FOR u1@localhost USING r1,r2
SHOW GRANTS FOR u1@localhost USING r1,r2
SHOW GRANTS FOR u1@localhost USING r1,r2
SHOW GRANTS FOR u1@localhost USING r1,r2
SHOW GRANTS FOR u1@localhost USING r1,r2
SHOW GRANTS FOR u1@localhost
call mtr.add_suppression("192.0.2.4")
PREPARE s FROM "SELECT * FROM t1 ot WHERE ot.b<0 OR EXISTS(SELECT it.b FROM v2 it WHERE ot.a=it.a+1)"
EXECUTE s
( K INT NOT NULL AUTO_INCREMENT, I INT, A INT, PRIMARY KEY(K), KEY IX(A) ) engine = InnoDB
SELECT INSERT(`å­—æ®µä¸€`, 1, 1, 'ãŠ') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 1, 2, 'ãŠ') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 1, 3, 'ãŠ') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 1, 4, 'ãŠ') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 1, 5, 'ãŠ') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 4, 1, 'ð » ') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 4, 2, 'ð » ') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 5, 1, 'ð » ') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 1, 1, ' ') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 1, 2, '  ') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 1, 3, '   ') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 1, 4, '    ') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 1, 5, '     ') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 4, 1, ' ') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 4, 2, '  ') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 5, 1, ' ') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 1, 1, 'å²') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 1, 2, 'å²å²') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 1, 3, 'å²å²å²') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 1, 4, 'å²å²å²å²') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 1, 5, 'å²å²å²å²å²') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 4, 1, 'ð €‚') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 4, 2, 'ð €‚ð €‚') FROM `è¡¨ä¸€`
SELECT INSERT(`å­—æ®µä¸€`, 5, 1, 'ð €‚') FROM `è¡¨ä¸€`
SELECT c1, TRIM(TRAILING 'ð »ž' FROM c1) FROM `è¡¨ä¸€`
SELECT c1, TRIM(LEADING 'ð »ž' FROM c1) FROM `è¡¨ä¸€`
SELECT c1, TRIM(BOTH 'ð »ž' FROM c1) FROM `è¡¨ä¸€`
PREPARE stmt1 FROM 'SELECT ? FROM t3'
PREPARE stmt2 FROM 'SELECT * FROM t3 ORDER BY ?'
PREPARE stmt3 FROM 'SELECT COUNT(*) FROM t3 GROUP BY ?'
PREPARE stmt4 FROM 'SELECT CHAR_LENGTH(?)'
PREPARE stmt5 FROM 'SELECT CHARSET(?)'
PREPARE stmt6 FROM 'SELECT INSERT(c1,1,1,?) FROM t1'
PREPARE stmt7 FROM 'SELECT INSTR(c1,?) FROM t2'
PREPARE stmt8 FROM 'SELECT LOCATE(?,c1) FROM t2'
PREPARE stmt9 FROM 'SELECT LPAD(c1,9,?) FROM t1'
PREPARE stmt10 FROM 'SELECT REPLACE(c1,?,\'x\') FROM t2'
PREPARE stmt11 FROM 'SELECT REPLACE(c1,\'x\',?) FROM t1'
PREPARE stmt12 FROM 'SELECT RPAD(c1,9,?) FROM t1'
PREPARE stmt13 FROM 'UPDATE t4 SET c1=\'x\' WHERE c1=?'
PREPARE stmt14 FROM 'UPDATE t4 SET c1=? WHERE c1=\'x\''
EXECUTE stmt1 USING @arg
EXECUTE stmt2 USING @arg
EXECUTE stmt3 USING @arg
EXECUTE stmt4 USING @arg
EXECUTE stmt5 USING @arg
EXECUTE stmt6 USING @arg
EXECUTE stmt7 USING @arg
EXECUTE stmt8 USING @arg
EXECUTE stmt9 USING @arg
EXECUTE stmt10 USING @arg
EXECUTE stmt11 USING @arg
EXECUTE stmt12 USING @arg
EXECUTE stmt13 USING @arg
EXECUTE stmt14 USING @arg
EXECUTE stmt1 USING @arg
EXECUTE stmt2 USING @arg
EXECUTE stmt3 USING @arg
EXECUTE stmt4 USING @arg
EXECUTE stmt5 USING @arg
EXECUTE stmt6 USING @arg
EXECUTE stmt7 USING @arg
EXECUTE stmt8 USING @arg
EXECUTE stmt9 USING @arg
EXECUTE stmt10 USING @arg
EXECUTE stmt11 USING @arg
EXECUTE stmt12 USING @arg
EXECUTE stmt13 USING @arg
EXECUTE stmt14 USING @arg
EXECUTE stmt1 USING @arg
EXECUTE stmt2 USING @arg
EXECUTE stmt3 USING @arg
EXECUTE stmt4 USING @arg
EXECUTE stmt5 USING @arg
EXECUTE stmt6 USING @arg
EXECUTE stmt7 USING @arg
EXECUTE stmt8 USING @arg
EXECUTE stmt9 USING @arg
EXECUTE stmt10 USING @arg
EXECUTE stmt11 USING @arg
EXECUTE stmt12 USING @arg
EXECUTE stmt13 USING @arg
EXECUTE stmt14 USING @arg
DEALLOCATE PREPARE stmt1
DEALLOCATE PREPARE stmt2
DEALLOCATE PREPARE stmt3
DEALLOCATE PREPARE stmt4
DEALLOCATE PREPARE stmt5
DEALLOCATE PREPARE stmt6
DEALLOCATE PREPARE stmt7
DEALLOCATE PREPARE stmt8
DEALLOCATE PREPARE stmt9
DEALLOCATE PREPARE stmt10
DEALLOCATE PREPARE stmt11
DEALLOCATE PREPARE stmt12
DEALLOCATE PREPARE stmt13
DEALLOCATE PREPARE stmt14
send INSERT INTO t1 VALUES (3), (NULL), (4)
reap
send INSERT INTO t1 VALUES (3), (NULL), (4)
reap
send INSERT INTO t1 SELECT * FROM t2
reap
send INSERT INTO t1 SELECT * FROM t2
reap
prepare s1 from ' select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1 where a in ( select a from t1) )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))'
execute s1
call mtr.add_suppression('Can not read and process value of User_attributes column from mysql.user table for user')
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
write_file $BOOTSTRAP_SQL
call mtr.add_suppression("Resizing redo log from")
call mtr.add_suppression("Upgrading redo log")
call mtr.add_suppression("Starting to delete and rewrite log files")
call mtr.add_suppression("New log files created")
call mtr.add_suppression("Unknown system variable 'show_compatibility_56'")
call mtr.add_suppression("You need to use --log-bin to make --binlog-format work")
call mtr.add_suppression("Creating routine without parsing routine body")
call mtr.add_suppression("Resolving dependency for the view")
call mtr.add_suppression("references invalid")
call mtr.add_suppression("doesn't exist")
call mtr.add_suppression("information_schema")
call mtr.add_suppression("Storage engine '.*' does not support system tables. \\[mysql.*\\]")
call mtr.add_suppression("Table 'mysql.component' doesn't exist")
call mtr.add_suppression("is expected to be transactional")
call mtr.add_suppression("table is missing or has an incorrect definition")
call mtr.add_suppression("ACL DDLs will not work unless mysql_upgrade is executed")
call mtr.add_suppression(".* Native table .* has the wrong structure")
call mtr.add_suppression("Column count of mysql.* is wrong")
call mtr.add_suppression("Column count of performance_schema.events_statements_summary_by_digest is wrong.*")
call mtr.add_suppression("The privilege system failed to initialize correctly.*")
call mtr.add_suppression(".*The system table mysql.global_grants is missing.*")
call mtr.add_suppression("Unable to delete statistics for table mysql.")
call mtr.add_suppression("Column count of performance_schema.replication_group_members is wrong. Expected 7, found 5.*")
call mtr.add_suppression("Column count of performance_schema.replication_group_member_stats is wrong. Expected 13, found 9.*")
call mtr.add_suppression("Column count of performance_schema.threads is wrong. Expected 18, found 17.*")
call mtr.add_suppression("ACL table mysql.[a-zA-Z_]* missing. Some operations may fail.")
call mtr.add_suppression("Info table is not ready to be used. Table 'mysql.slave_master_info' cannot be opened")
call mtr.add_suppression("Error in checking mysql.slave_master_info repository info type of TABLE")
call mtr.add_suppression("Error creating master info: Error checking repositories.")
call mtr.add_suppression("Slave: Failed to initialize the master info structure for channel")
call mtr.add_suppression("Failed to create or recover replication info repositories.")
call mtr.add_suppression("\\[Warning\\] .*MY-\\d+.* Missing .ibd file for table `test`\.`t1` .* ")
create table t1 (id int) partition by range (id) (partition p0 values less than (1000), partition p1 values less than (maxvalue))
LOCK TABLE t1 WRITE
SELECT AES_ENCRYPT('a', 'a') = AES_ENCRYPT(REPEAT('a',1000), 'a')
SELECT AES_ENCRYPT('a', 'a') = AES_ENCRYPT('a', REPEAT('a',1000))
SELECT AES_ENCRYPT('a', 'a') = AES_ENCRYPT('a', 'a', REPEAT('a', 16))
SELECT AES_ENCRYPT('a', 'a') = AES_ENCRYPT('a', 'a', REPEAT('b', 16))
SELECT TO_BASE64(AES_ENCRYPT('a', 'a', REPEAT('a', 1024)))
SELECT AES_DECRYPT(AES_ENCRYPT(_UTF8'Ð–Ð¾Ñ€Ð¾', 'a'), 'a') = _UTF8'Ð–Ð¾Ñ€Ð¾'
SELECT 'a' = AES_DECRYPT(AES_ENCRYPT('a', 'a'), 'a', REPEAT('a',16))
SELECT 'a' = AES_DECRYPT(AES_ENCRYPT('a', 'a'), 'a', REPEAT('a',100))
INSERT INTO aes_ecb (a) VALUES ('a'), ('Ð–Ð¾Ñ€Ð¾'), (REPEAT('a', 10))
source include/func_aes_block.inc
RENAME TABLE T1 TO T2
RENAME TABLE T2 TO t3
RENAME TABLE T3 TO T1
LOCK TABLE T2 WRITE
UNLOCK TABLES
RENAME TABLE T2 TO T1
RENAME TABLE T1 TO T2
RENAME TABLE T2 TO t3
RENAME TABLE T3 TO T1
LOCK TABLE T2 WRITE
UNLOCK TABLES
RENAME TABLE T2 TO T1
RENAME TABLE T1 to T2
RENAME TABLE T2 to T1
RENAME TABLE T1 to T2
RENAME TABLE T2 TO T3
RENAME TABLE t3 TO T4
RENAME TABLE T2 TO T3
call mtr.add_suppression("\\[Warning\\] .*MY-\\d+.* Parent table of FTS auxiliary table.*")
call mtr.add_suppression("You need to use --log-bin to make --binlog-format work")
TYPE=TRIGGERS triggers='CREATE DEFINER=`root`@`localhost` TRIGGER tr1_bi BEFORE INSERT ON vt2 FOR EACH ROW SET @a:=1' sql_modes=1073741824 1073741824 definers='root@localhost' 'root@localhost' client_cs_names='latin1' 'latin1' db_cl_names='latin1_swedish_ci' 'latin1_swedish_ci' TYPE=TRIGGERNAME trigger_table=vt2 SET sql_mode=''
INSERT INTO test.proc VALUES ('sp','bug24805140','PROCEDURE','bug24805140','SQL', 'CONTAINS_SQL','NO','DEFINER','out a int','', 'begin select requesting_trx_id from ' 'information_schema.INNODB_LOCK_WAITS limit 1 into a; end', 'root@localhost','2016-10-05 21:44:21', '2016-10-05 21:44:21', 'ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,' 'NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,' 'NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION', '','utf8','utf8_general_ci','latin1_swedish_ci', 'begin select requesting_trx_id from ' 'information_schema.INNODB_LOCK_WAITS limit 1 into a; end'), ('sp','proc2','PROCEDURE','proc2','SQL', 'CONTAINS_SQL','NO','DEFINER','out b int','', 'begin select   @@show_compatibility_56 into b; end', 'root@localhost','2016-10-05 21:55:05', '2016-10-05 21:55:05','ONLY_FULL_GROUP_BY,' 'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,' 'NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,' 'NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION','', 'utf8','utf8_general_ci','latin1_swedish_ci', 'begin select   @@show_compatibility_56 into b; end')
INSERT INTO `proc` VALUES ('test','downgrade_alter_proc','PROCEDURE', 'downgrade_alter_proc', 'SQL','CONTAINS_SQL','NO','INVOKER','','', 'BEGIN\n      SELECT c1, English, French FROM t1 ' 'JOIN t2 ON t1.c3 = t2.col2;\n     END', 'root@localhost','1988-04-25 20:45:00', '1988-04-25 20:45:00','NO_ZERO_DATE','','latin1', 'latin1_swedish_ci','latin1_swedish_ci', 'BEGIN\n      SELECT c1, English, French FROM t1 ' 'JOIN t2 ON t1.c3 = t2.col2;\n     END'), ('test','my_test_func','FUNCTION','myfunc','SQL', 'CONTAINS_SQL','NO','DEFINER', '', 'varchar(20) CHARSET latin1', 'BEGIN\n  RETURN \'Ã¥\';\nEND', 'root@localhost','2017-03-08 09:07:36', '2017-03-08 09:07:36', 'ONLY_FULL_GROUP_BY,' 'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,' 'ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,' 'NO_ENGINE_SUBSTITUTION','','latin1','latin1_swedish_ci', 'latin1_swedish_ci','BEGIN\n  RETURN \'ÃƒÂ¥\';\nEND')
write_file $DB_OPT_FILE
default-character-set=koi8r default-collation=koi8r_bin perl
my $log= $ENV{'ENV_MYSQLD_LOG'} or die
open(FILE, "$log") or die
my $c_e= grep(/\[Warning\] Parsing \'sys\.diagnostics\' routine body failed\. Creating routine without parsing routine body/gi,<FILE>)
print "# Sys Schema routine parsing warning found : $c_e times.\n"
seek(FILE,0,0)
$c_e= grep(/\[ERROR\] .* Unknown system variable \'show_compatibility_56\'/gi,<FILE>)
print "# Sys Schema routine parsing error found : $c_e times.\n"
seek(FILE,0,0)
$c_e= grep(/\[Warning\] Resolving dependency for the view \'sys\.innodb_lock_waits\' failed\. View is no more valid to use/gi,<FILE>)
print "# Sys Schema view parsing warning found : $c_e times.\n"
seek(FILE,0,0)
$c_e= grep(/\[ERROR\] .* Unknown table \'INNODB_LOCK_WAITS\' in information_schema/gi,<FILE>)
print "# Sys Schema view parsing error found : $c_e times.\n"
close(FILE)
SHOW CREATE DATABASE db_charset_koi8r
call sp.bug24805140()
call mtr.add_suppression("You need to use --log-bin to make --binlog-format work")
UNLOCK TABLES
LOCK TABLES t1 READ, t2 READ
UNLOCK TABLES
LOCK TABLES t1 READ, temp WRITE
UNLOCK TABLES
LOCK TABLES t1 WRITE
LOCK TABLES t1 READ, t2 READ
UNLOCK TABLES
LOCK TABLES t2 READ
UNLOCK TABLES
LOCK TABLES t1 READ, t2 READ
UNLOCK TABLES
echo =============Test of '::1' ========================================
echo =============Test of '127.0.0.1' (IPv4) ===========================
echo =============Test of '::1/128' ====================================
echo =============Test of '0000:0000:0000:0000:0000:0000:0000:0001' ====
echo =============Test of '0:0:0:0:0:0:0:1' ============================
WHERE PROCESSLIST_ID = $thread_id AND ATTR_NAME IN ('program_name', '_client_replication_channel_name', '_client_role')
perl
my $mysqlbinlog= $ENV{'MYSQL_BINLOG'}
my $port= $ENV{'MASTER_MYPORT'}
my $binlog_file= $ENV{'BINLOG_FILE'}
system("$mysqlbinlog --stop-never --read-from-remote-server --user=root --host=127.0.0.1 --port=$port $binlog_file > /dev/null &")
WHERE PROCESSLIST_ID = $thread_id AND ATTR_NAME IN ('program_name', '_client_replication_channel_name', '_client_role')
CREATE TABLE ```ab``cd``` (i INT)
SHOW CREATE TABLE ```ab``cd```
DROP TABLE ```ab``cd```
CREATE TABLE ```ab````cd``` (i INT)
SHOW CREATE TABLE ```ab````cd```
DROP TABLE ```ab````cd```
CREATE TABLE ```a` (i INT)
SHOW CREATE TABLE ```a`
DROP TABLE ```a`
show create database mysqltest
show create database mysqltest
show create database mysqltest
show create database mysqltest
create table t1 ( c1 int NOT NULL, c2 int NOT NULL, PRIMARY KEY USING HASH (c1), INDEX USING BTREE(c2) )
show slave hosts
show create database test
SHOW CREATE DATABASE mysqltest1
SELECT SPECIFIC_NAME, ROUTINE_CATALOG, ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE, DTD_IDENTIFIER, ROUTINE_BODY, ROUTINE_DEFINITION, EXTERNAL_NAME, drop table if exists t1
select concat("a",NULL),replace(NULL,"a","b"),replace("string","i",NULL),replace("string",NULL,"i"),insert("abc",1,1,NULL),left(NULL,1)
select repeat("a",0),repeat("ab",5+5),repeat("ab",-1),reverse(NULL)
select 2 between null and 1,2 between 3 AND NULL,NULL between 1 and 2,2 between NULL and 3, 2 between 1 AND null
explain select 2 between null and 1,2 between 3 AND NULL,NULL between 1 and 2,2 between NULL and 3, 2 between 1 AND null
create table t1 select null as c00, if(1, null, 'string') as c01, if(0, null, 'string') as c02, ifnull(null, 'string') as c03, ifnull('string', null) as c04, case when 0 then null else 'string' end as c05, case when 1 then null else 'string' end as c06, coalesce(null, 'string') as c07, coalesce('string', null) as c08, least('string',null) as c09, least(null, 'string') as c10, greatest('string',null) as c11, greatest(null, 'string') as c12, nullif('string', null) as c13, nullif(null, 'string') as c14, trim('string' from null) as c15, trim(null from 'string') as c16, substring_index('string', null, 1) as c17, substring_index(null, 'string', 1) as c18, elt(1, null, 'string') as c19, elt(1, 'string', null) as c20, concat('string', null) as c21, concat(null, 'string') as c22, concat_ws('sep', 'string', null) as c23, concat_ws('sep', null, 'string') as c24, concat_ws(null, 'string', 'string') as c25, make_set(3, 'string', null) as c26, make_set(3, null, 'string') as c27, export_set(3, null, 'off', 'sep') as c29, export_set(3, 'on', null, 'sep') as c30, export_set(3, 'on', 'off', null) as c31, replace(null, 'from', 'to') as c32, replace('str', null, 'to') as c33, replace('str', 'from', null) as c34, insert('str', 1, 2, null) as c35, insert(null, 1, 2, 'str') as c36, lpad('str', 10, null) as c37, rpad(null, 10, 'str') as c38
select case 'str' when 'STR' then 'str' when null then 'null' end as c01, case 'str' when null then 'null' when 'STR' then 'str' end as c02, field(null, 'str1', 'str2') as c03, field('str1','STR1', null) as c04, field('str1', null, 'STR1') as c05, 'string' in ('STRING', null) as c08, 'string' in (null, 'STRING') as c09
INSERT INTO t2 (a, b) VALUES (REPEAT('a', 512), REPEAT('b', 512))
INSERT INTO t2 (a, b) VALUES (REPEAT('A', 512), REPEAT('B', 512))
INSERT INTO t2 (a, b) VALUES (REPEAT('a', 10000), REPEAT('b', 10000))
xa start 0x7465737462, 0x2030405060, 0xb
SEND UPDATE t1 SET a=5 WHERE a=2
WHERE ID=$conn_id AND STATE='Searching rows for update'
REAP
SEND UPDATE t1 SET a=5 WHERE a=2
WHERE ID=$conn_id AND STATE='Searching rows for update'
REAP
xa start 0xABCDEF1234567890, 0x01, 0x02
xa end 0xABCDEF1234567890, 0x01, 0x02
xa prepare 0xABCDEF1234567890, 0x01, 0x02
xa rollback 0xABCDEF1234567890, 0x01, 0x02
xa start 0x4142434445, 0x46, 0x02
xa end 0x4142434445, 0x46, 0x02
xa prepare 0x4142434445, 0x46, 0x02
xa rollback 0x4142434445, 0x46, 0x02
call mtr.add_suppression("Found 1 prepared XA transactions")
flush table with read lock
unlock tables
unlock tables
SHOW GRANTS FOR u1
call mtr.add_suppression("When binlog_format=STATEMENT, the option binlog_row_value_options=PARTIAL_JSON")
call mtr.add_suppression("When binlog_row_image=FULL, the option binlog_row_value_options=PARTIAL_JSON")
call mtr.add_suppression("When binlog_row_value_options=PARTIAL_JSON, the option log_bin_use_v1_row_events=1")
call mtr.add_suppression("When the binary log is disabled, the option binlog_row_value_options=PARTIAL_JSON")
call mtr.add_suppression("You need to use --log-bin to make --binlog-format work.")
CREATE UNDO TABLESPACE undo_003 ADD DATAFILE 'undo_003.ibu' ENGINE InnoDB
ALTER UNDO TABLESPACE undo_003 SET ACTIVE ENGINE InnoDB
ALTER UNDO TABLESPACE undo_003 SET INACTIVE ENGINE InnoDB
source include/wait_until_undo_space_is_empty.inc
select (1,2,3) IN ((3,2,3), (1,2,3), (1,3,3))
select row(10,2,3) IN (row(3,2,3), row(1,2,3), row(1,3,3))
select row(1,2,3) IN (row(3,NULL,3), row(1,2,3), row(1,3,3))
select row(10,2,3) IN (row(3,NULL,3), row(1,2,3), row(1,3,3))
select row('a',1.5,3) IN (row(1,2,3), row('a',1.5,3), row('a','a','a'))
select row('a',0,3) IN (row(3,2,3), row('a','a','3'), row(1,3,3))
select row('a',0,3) IN (row(3,2,3), row('a','0','3'), row(1,3,3))
select row('a',1.5,3) IN (row(3,NULL,3), row('a',1.5,3), row(1,3,3))
select row('b',1.5,3) IN (row(3,NULL,3), row('a',1.5,3), row(1,3,3))
select row('b',1.5,3) IN (row('b',NULL,3), row('a',1.5,3), row(1,3,3))
select row('b',1.5,3) IN (row('b',NULL,4), row('a',1.5,3), row(1,3,3))
select (1,2,(3,4)) IN ((3,2,(3,4)), (1,2,(3,4)))
select row(1,2,row(3,4)) IN (row(3,2,row(3,4)), row(1,2,4))
select row(1,2,row(3,4)) IN (row(3,2,row(3,4)), row(1,2,row(3,NULL)))
explain select row(1,2,row(3,4)) IN (row(3,2,row(3,4)), row(1,2,row(3,NULL)))
select row(1,2,row(3,null)) IN (row(3,2,row(3,4)), row(1,2,row(4,5)))
select row(1,2,row(3,null)) IN (row(3,2,row(3,4)), row(1,2,row(3,5)))
select ROW(a,2,3) IN(row(1,b,c), row(2,3,1)) from t1
select ROW(c,2,3) IN(row(1,b,a), row(2,3,1)) from t1
select ROW(a,b,c) IN(row(1,2,3), row(3,2,1)) from t1
select ROW(1,2,3) IN(row(a,b,c), row(1,2,3)) from t1
SELECT ROW(1,ROW(2,3)) IN (ROW(1,ROW(2,3)),ROW(1,1))
SELECT ROW(1,ROW(2,3)) IN (ROW(1,ROW(2,3)),ROW(1,1),ROW(1,ROW(2,3)))
SELECT ROW(1,ROW(2,3)) IN (ROW(1,ROW(2,3)),ROW(1,ROW(2,2,2)))
SELECT ROW(1,ROW(2,3,4)) IN (ROW(1,ROW(2,3,4)),ROW(1,ROW(2,2)))
SELECT ROW(1,ROW(2,3)) IN (ROW(1,ROW(2,3)),(SELECT 1,1))
SELECT ROW(1,ROW(2,3)) IN (ROW(1,ROW(2,3)),(SELECT 1,1),ROW(1,ROW(2,4)))
SELECT ROW(1,ROW(2,3)) IN ((SELECT 1,1),ROW(1,ROW(2,3)))
SELECT ROW(2,1) IN (ROW(21,2),ROW(ROW(1,1,3),0))
SELECT ROW(2,1) IN (ROW(ROW(1,1,3),0),ROW(21,2))
SET @x:= (SELECT h FROM t1 WHERE (a,b,c,d,e,f,g)=(1,2,3,4,5,6,7))
SELECT ROW(a, 1) IN (SELECT SUM(b), 1) FROM t1 GROUP BY a
SELECT ROW(a, 1) IN (SELECT SUM(b), 3) FROM t1 GROUP BY a
CREATE TABLE v0(v1 DEC, v2 INT)
DO ST_ASTEXT(ST_UNION(ST_GEOMFROMTEXT('POLYGON((525000 183300,525400 183300,525400 18370, 525000 183700,525000 183300))'), ST_GeomFromText('POLYGON((525298.67 183511.53,525296.57 183510.39,525296.42 183510.31,525289.11 183506.62,525283.17 183503.47,525280.98 183502.26,525278.63 183500.97,525278.39 183500.84,525276.79 183500,525260.7 183491.55,525263.95 183484.75,525265.58 183481.95,525278.97 183488.73,525276.5 183493.45,525275.5 183495.7,525280.35 183498.2,525282.3 183499.1,525282.2 183499.3,525283.55 183500,525301.75 183509.35,525304.45 183504.25,525307.85 183504.95,525304.5 183510.83,525302.81 183513.8,525298.67 183511.53),(525275.06 183489.89,525272.06 183488.37,525268.94 183494.51,525271.94 183496.03,525275.06 183489.89),(525263.26 183491.55,525266.15 183493.04,525269.88 183485.82,525266.99 183484.33,525263.26 183491.55))'))) st_u
select (ST_aswkb(cast(st_union(multipoint( point(8,6), point(1,-17679), point(-9,-9)), linestring(point(91,12), point(-77,49), point(53,-81)))as char(18)))) in  ('1','2')
DO ST_AsText(@centroid_point) as centroid
DO MBRWITHIN(@centroid_point, ST_INTERSECTION(ST_GEOMFROMTEXT('MULTILINESTRING((541 -927,-414 316,-429 -444,212 260,-125 104,445 563,-713 -975,-976 514),(-830 882,-377 914,-915 919,-535 -23,-508 979),(806 347,-87 220,226 -22,-12 468,707 598,83 951,-592 701,833 964,270 -932,743 -514,231 469,-575 -122,-99 -245,416 465,801 -587))'), ST_GEOMFROMTEXT('LINESTRING(-96 -182,-373 75,697 687,-881 -463,-557 -959,-493 810)'))) as result
do st_distance(linestring(point(26,87),point(13,95)), geometrycollection(point(4.297374e+307,8.433875e+307)))
DO ST_AsText(@centroid_point) as centroid
DO MBRWITHIN(@centroid_point, ST_INTERSECTION(ST_GEOMFROMTEXT('MULTILINESTRING((541 -927,-414 316,-429 -444,212 260,-125 104,445 563,-713 -975,-976 514),(-830 882,-377 914,-915 919,-535 -23,-508 979),(806 347,-87 220,226 -22,-12 468,707 598,83 951,-592 701,833 964,270 -932,743 -514,231 469,-575 -122,-99 -245,416 465,801 -587))'), ST_GEOMFROMTEXT('LINESTRING(-96 -182,-373 75,697 687,-881 -463,-557 -959,-493 810)'))) as result
DO ST_ASTEXT(ST_UNION(ST_GEOMFROMTEXT('GEOMETRYCOLLECTION(POLYGON((4 -10,-3 0,-5 6,9 9,5 7,9 -6,9 -10,7 9,0 -4,-6 10,0 -3,9 3, 4 -10)), GEOMETRYCOLLECTION(), GEOMETRYCOLLECTION(MULTIPOLYGON(((-8 0,-2 -6,-10 -9,-9 7,-2 -10,7 -9,3 -6,-5 -8,-10 -7,-6 10,4 -10,-7 -8,6 -1, -8 0)),((-4 -3,7 -10,-4 -1,-10 -3,3 -3,-10 -4,-1 2,-2 -10,6 -7,-9 -8, -4 -3))), POINT(5 0), MULTIPOINT(-3 0,-4 -8,-3 -4,10 4,0 7,-7 2,4 -8,1 -6), MULTILINESTRING((-10 10,-10 5,9 -9,2 2,-7 2,0 -3,2 3,-6 -4,0 -2),(5 -9,0 -9,6 -4,1 -4,-1 6,2 -9,5 -7,8 10)), MULTILINESTRING((-10 10,-10 5,9 -9,2 2,-7 2,0 -3,2 3,-6 -4,0 -2),(5 -9,0 -9,6 -4,1 -4,-1 6,2 -9,5 -7,8 10)), LINESTRING(10 5,-4 7,-5 -8,-4 4,-4 6,-5 9,-1 6,0 -5)), GEOMETRYCOLLECTION(MULTILINESTRING((-8 5,9 -10,-9 9,-9 4,3 -2,4 -6),(3 -10,3 8,-10 4,6 -3,8 -2,3 3,4 -7,-8 6,-3 2,5 3,0 10,2 4,1 -5,-6 1),(10 3,-4 2,4 -4,3 -1,-8 0,-7 -2,10 9,-5 5,-3 6),(0 3,3 7,0 2,4 -1,8 8,-10 -4,2 7,-4 5)), POINT(2 -1), MULTIPOLYGON(((-10 8,1 -4,0 -8,9 2,-8 -6,-3 -7,-10 -1,-10 -9,10 -3, -10 8)),((-6 7,-1 3,2 8,10 -6,-8 4,-9 -10,-8 -8,-2 -1,-9 7,6 -9,5 1,-1 -6, -6 7)),((8 9,0 1,-5 -8,0 8,-3 -6,-9 -2,9 -6,-5 5,-1 -3,-8 2,2 -9,5 -5,7 -7,-9 3,0 -3, 8 9)),((1 -4,-7 -10,10 10,5 3,8 -9,-6 5,2 2,-5 5,-1 5, 1 -4))), MULTIPOLYGON(((-10 8,1 -4,0 -8,9 2,-8 -6,-3 -7,-10 -1,-10 -9,10 -3, -10 8)),((-6 7,-1 3,2 8,10 -6,-8 4,-9 -10,-8 -8,-2 -1,-9 7,6 -9,5 1,-1 -6, -6 7)),((8 9,0 1,-5 -8,0 8,-3 -6,-9 -2,9 -6,-5 5,-1 -3,-8 2,2 -9,5 -5,7 -7,-9 3,0 -3, 8 9)),((1 -4,-7 -10,10 10,5 3,8 -9,-6 5,2 2,-5 5,-1 5, 1 -4)))), MULTIPOLYGON(((8 0,7 -6,7 -2,-7 -9,-3 10,-4 -3,3 -10, 8 0)),((7 3,7 6,1 8,4 6,-8 -7,-6 -7,9 -4,-1 3,-7 10, 7 3)),((3 -6,5 4,-3 -6,-5 1,-6 0,0 0,0 -7,-2 -10,-4 8,9 9,4 6, 3 -6)),((7 -7,3 4,-5 0, 7 -7)),((4 -9,-2 -9,-2 10, 4 -9))), POLYGON((-3 -6,-3 0,3 -10,3 10,1 -4,-6 -10,8 -5,-9 -8,2 -4,9 10,1 -3, -3 -6)), POLYGON((2 -5,0 -2,-3 9,0 4,6 -6,5 -4,-4 2,-6 6,3 -4,1 0,-10 -7,1 6,-7 2, 2 -5)), MULTIPOINT(7 8,-6 -3,-1 -7,0 7,-2 1,-8 -8))'), ST_GEOMFROMTEXT('GEOMETRYCOLLECTION()'))) as result
DO ST_ASTEXT(ST_UNION(ST_INTERSECTION(ST_GEOMFROMTEXT('MULTIPOINT(7 2,-4 -5,6 -9,-7 3,-10 5,8 -6,0 -10,10 -4,8 -10,2 6,8 -4,-8 2,-4 2)'), ST_GEOMFROMTEXT('MULTIPOLYGON(((6 2,1 1,-4 5,1 4,-3 -4,-7 9,-10 2,-6 1,10 -7,0 1,9 4, 6 2)))')), ST_UNION(ST_GEOMFROMTEXT('LINESTRING(-1 -5,0 -6,4 6,3 3,2 8,-2 6,-4 5,6 -7,-1 -1,-8 6,4 -2)'), ST_GEOMFROMTEXT('MULTIPOLYGON(((5 -4,-5 -9,-1 -6,-3 0,5 -2, 5 -4)),((-5 -10,-8 -2,-3 7,1 5,5 -10,1 -5,0 10,3 2,1 1, -5 -10)),((4 -2,6 3,7 5,1 2,8 -9,-10 -5,7 -10,-2 -9,-2 0,2 -8,-8 3,5 0, 4 -2)),((6 -4,0 4,-8 -2,10 -10,-6 5, 6 -4)))')))) as result
do st_buffer(point(-5,0),8772, st_buffer_strategy('point_circle',1024*1024*1024))
do st_union(cast(point(1,1)as char(12)),point(1,1))
do st_union(cast(point(1,1)as char(13)),point(1,1))
CALL mtr.add_suppression("Storage engine '.*' does not support system tables. \\[mysql.*\\]")
CALL mtr.add_suppression("Column count of mysql.* is wrong. " "Expected .*, found .*. " "The table is probably corrupted")
CALL mtr.add_suppression("Cannot load from mysql.*. The table is probably corrupted")
send ALTER USER u1@h, u2@h, u3@h PASSWORD EXPIRE INTERVAL 250 DAY
CREATE PROCEDURE p1() SET PASSWORD FOR u1@h = '12345'
delimiter
CREATE FUNCTION f1() RETURNS INT BEGIN SET PASSWORD FOR u1@h = '12345'; RETURN 0; END;
call mtr.add_suppression("Did not write failed .*")
call mtr.add_suppression("REVOKE/GRANT failed .* An incident event has been written to the binary log which will stop the slaves.")
CREATE PROCEDURE p1() SET @a :=1
CREATE USER user1@
GRANT UPDATE (a) ON t1 TO user1@
DROP USER user1@
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
CALL mtr.add_suppression(".*Out of memory *")
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u2@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
SHOW GRANTS FOR u1@h
RENAME TABLE mysql.user TO mysql.user_bak
RENAME TABLE mysql.db TO mysql.db_bak
RENAME TABLE mysql.columns_priv TO mysql.columns_priv_bak
RENAME TABLE mysql.procs_priv TO mysql.procs_priv_bak
RENAME TABLE mysql.proxies_priv TO mysql.proxies_priv_bak
RENAME TABLE mysql.tables_priv TO mysql.tables_priv_bak
RENAME TABLE mysql.user_bak TO mysql.user
RENAME TABLE mysql.db_bak TO mysql.db
RENAME TABLE mysql.columns_priv_bak TO mysql.columns_priv
RENAME TABLE mysql.procs_priv_bak TO mysql.procs_priv
RENAME TABLE mysql.proxies_priv_bak TO mysql.proxies_priv
RENAME TABLE mysql.tables_priv_bak TO mysql.tables_priv
RENAME TABLE mysql.user TO mysql.user_bak
RENAME TABLE mysql.db TO mysql.db_bak
RENAME TABLE mysql.columns_priv TO mysql.columns_priv_bak
RENAME TABLE mysql.procs_priv TO mysql.procs_priv_bak
RENAME TABLE mysql.proxies_priv TO mysql.proxies_priv_bak
RENAME TABLE mysql.tables_priv TO mysql.tables_priv_bak
call mtr.add_suppression("mysql.user has no `Event_priv` column at position 28")
RENAME TABLE mysql.user_bak TO mysql.user
RENAME TABLE mysql.db_bak TO mysql.db
RENAME TABLE mysql.columns_priv_bak TO mysql.columns_priv
RENAME TABLE mysql.procs_priv_bak TO mysql.procs_priv
RENAME TABLE mysql.proxies_priv_bak TO mysql.proxies_priv
RENAME TABLE mysql.tables_priv_bak TO mysql.tables_priv
WHERE state = 'Waiting for table metadata lock' AND info = 'GRANT ALL ON t1 TO \'u1\''
DELIMITER
query_attributes a b
query_attributes a b c d
query_attributes 'a' "b c"
query_attributes '' 'a'
write_file $MYSQLTEST_VARDIR/tmp/wl12542.sql
query_attributes a b
exec $MYSQL < $MYSQLTEST_VARDIR/tmp/wl12542.sql
remove_file $MYSQLTEST_VARDIR/tmp/wl12542.sql
write_file $MYSQLTEST_VARDIR/tmp/wl12542.sql
query_attributes a b
query_attributes a c
exec $MYSQL < $MYSQLTEST_VARDIR/tmp/wl12542.sql
remove_file $MYSQLTEST_VARDIR/tmp/wl12542.sql
write_file $MYSQLTEST_VARDIR/tmp/wl12542.sql
query_attributes a
exec $MYSQL < $MYSQLTEST_VARDIR/tmp/wl12542.sql
remove_file $MYSQLTEST_VARDIR/tmp/wl12542.sql
write_file $MYSQLTEST_VARDIR/tmp/wl12542.sql
query_attributes a b c d
exec $MYSQL < $MYSQLTEST_VARDIR/tmp/wl12542.sql
remove_file $MYSQLTEST_VARDIR/tmp/wl12542.sql
write_file $MYSQLTEST_VARDIR/tmp/wl12542.sql
query_attributes 'a' 'b c'
exec $MYSQL < $MYSQLTEST_VARDIR/tmp/wl12542.sql
remove_file $MYSQLTEST_VARDIR/tmp/wl12542.sql
write_file $MYSQLTEST_VARDIR/tmp/wl12542.sql
query_attributes 'a' 'b c'
resetconnection
exec $MYSQL < $MYSQLTEST_VARDIR/tmp/wl12542.sql
remove_file $MYSQLTEST_VARDIR/tmp/wl12542.sql
query_attributes 'a' 'b c'
reset_connection
create procedure p_verify_reprepare_count(expected int) begin declare old_reprepare_count int default @reprepare_count; select variable_value from performance_schema.session_status where variable_name='com_stmt_reprepare' into @reprepare_count; if old_reprepare_count + expected <> @reprepare_count then select concat("Expected: ", expected, ", actual: ", @reprepare_count - old_reprepare_count) as "ERROR"; else select '' as "SUCCESS"; end if; end
prepare stmt from "repair table t1"
execute stmt
execute stmt
execute stmt
execute stmt
prepare stmt from "analyze table t1"
execute stmt
execute stmt
execute stmt
execute stmt
prepare stmt from "optimize table t1"
execute stmt
execute stmt
execute stmt
execute stmt
CALL mtr.add_suppression("Out of sort memory")
KILL @id
INSERT INTO t1 VALUES (REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), 1, REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096))
INSERT INTO t1 VALUES (REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), 2, REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096))
INSERT INTO t1 VALUES (REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), 3, REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096), REPEAT('x', 4096))
CALL mtr.add_suppression("Out of sort memory")
1 2 3 SELECT * FROM b12688860_db.b12688860_tab
LOCK TABLE t1 WRITE
UNLOCK TABLES
PREPARE stmt1 FROM "SELECT *, SLEEP(0.5) FROM t1 WHERE b= 'new_string'"
PREPARE stmt2 FROM "SELECT /*+ MAX_EXECUTION_TIME(2) */ *, SLEEP(0.5) FROM t1 WHERE b= 'new_string'"
PREPARE stmt3 FROM "SELECT /*+ MAX_EXECUTION_TIME(3600000) */ count(*) FROM t1"
EXECUTE stmt1
EXECUTE stmt2
EXECUTE stmt3
DEALLOCATE PREPARE stmt1
DEALLOCATE PREPARE stmt2
DEALLOCATE PREPARE stmt3
select sum(col1) as co12 from t1 group by col2 having col2 10
CREATE FUNCTION next_seq_value() RETURNS INT BEGIN DECLARE next_val INT; SELECT val INTO next_val FROM series; UPDATE series SET val=mod(val + 1, 2); UPDATE seq_calls SET c=c+1; RETURN next_val; END;
PREPARE STMT FROM 'SELECT t, next_seq_value() r FROM t1 FORCE INDEX(t) GROUP BY t HAVING (SELECT 1 FROM t1 WHERE r = 1 LIMIT 1) ORDER BY t1.u'
EXECUTE stmt
EXECUTE stmt
DEALLOCATE PREPARE stmt
SELECT 1 HAVING json_objectagg(utc_date(), 1416) <> 0
LOCK TABLE t2 read
UNLOCK TABLES
source include/compare_digests.inc
source include/compare_digests.inc
select !0,NOT 0=1,!(0=0),1 AND 1,1 && 0,0 OR 1,1 || NULL, 1=1 or 1=1 and 1=0
select 2 between 1 and 3, "monty" between "max" and "my",2=2 and "monty" between "max" and "my" and 3=3
select 'b' between 'a' and 'c', 'B' between 'a' and 'c'
select 2 in (3,2,5,9,5,1),"monty" in ("david","monty","allan"), 1.2 in (1.4,1.2,1.0)
select 5 between 0 and 10 between 0 and 1,(5 between 0 and 10) between 0 and 1
CREATE TABLE t2 AS SELECT COALESCE(5, -5) AS c1, COALESCE(5, 5.5) AS c2, COALESCE(5, 5.5e5) AS c3, COALESCE(5, '5') AS c4, COALESCE(20010101, date '2005-05-05') AS c5, COALESCE(010101, time '05:05:05.555555') AS c6, COALESCE(010101, timestamp '2005-05-05 05:05:05.555555') AS c7, COALESCE(20010101, NOW(0)) AS c8, COALESCE(5.55, 88.8) AS c11, COALESCE(5.5, 5.5e5) AS c12, COALESCE(5.5, '5') AS c13, COALESCE(010101.5, date '2005-05-05') AS c14, COALESCE(5.5, time '05:05:05.555555') AS c15, COALESCE(010101.5, timestamp '2005-05-05 05:05:05.555555') AS c16, COALESCE(5.5e5, '5') AS c21, COALESCE(2004041e1, date '2005-05-05') AS c22, COALESCE(150505.0e5, time '05:05:05.555555') AS c23, COALESCE(2004041e1, timestamp '2005-05-05 05:05:05.555555') AS c24, COALESCE('010101', date '2005-05-05') AS c31, COALESCE('5', time '05:05:05.555555') AS c32, COALESCE('010101', timestamp '2005-05-05 05:05:05.555555') AS c33, COALESCE(date '2005-05-05', time '05:05:05.555555') AS c41, COALESCE(date '2005-05-05', timestamp '2005-05-05 05:05:05.555555') AS c42, COALESCE(time '05:05:05.555555', timestamp '2005-05-05 05:05:05.555555') AS c51, COALESCE(x'c3a5', '1') AS c61, COALESCE(x'c3a5', _binary '1') AS c62, COALESCE(_utf8mb4 x'c3a5', '1') AS c63, COALESCE(_utf8mb4 x'c3a5', _binary '1') AS c64, COALESCE(JSON_OBJECT('a', 1), NULL) AS c71
CREATE TABLE t3 AS SELECT GREATEST(5, -5) AS c1, GREATEST(5, 5.5) AS c2, GREATEST(5, 5.5e5) AS c3, GREATEST(5, '5') AS c4, GREATEST(20010101, date '2005-05-05') AS c5, GREATEST(010101, time '05:05:05.555555') AS c6, GREATEST(010101, timestamp '2005-05-05 05:05:05.555555') AS c7, GREATEST(20010101, NOW(0)) AS c8, GREATEST(5.55, 88.8) AS c11, GREATEST(5.5, 5.5e5) AS c12, GREATEST(5.5, '5') AS c13, GREATEST(010101.5, date '2005-05-05') AS c14, GREATEST(5.5, time '05:05:05.555555') AS c15, GREATEST(010101.5, timestamp '2005-05-05 05:05:05.555555') AS c16, GREATEST(5.5e5, '5') AS c21, GREATEST(2004041e1, date '2005-05-05') AS c22, GREATEST(150505.0e5, time '05:05:05.555555') AS c23, GREATEST(2004041e1, timestamp '2005-05-05 05:05:05.555555') AS c24, GREATEST('010101', date '2005-05-05') AS c31, GREATEST('5', time '05:05:05.555555') AS c32, GREATEST('010101', timestamp '2005-05-05 05:05:05.555555') AS c33, GREATEST(date '2005-05-05', time '05:05:05.555555') AS c41, GREATEST(date '2005-05-05', timestamp '2005-05-05 05:05:05.555555') AS c42, GREATEST(time '05:05:05.555555', timestamp '2005-05-05 05:05:05.555555') AS c51, GREATEST(x'c3a5', '1') AS c61, GREATEST(x'c3a5', _binary '1') AS c62, GREATEST(_utf8mb4 x'c3a5', '1') AS c63, GREATEST(_utf8mb4 x'c3a5', _binary '1') AS c64
SET @a:='11'
DO GREATEST(RIGHT(@a,1),1)
DO LEAST(RIGHT(@a,1),1)
DO NULLIF((GREATEST(FROM_UNIXTIME(1537024679) , _utf32 "*b!" )), (FROM_UNIXTIME(1537013301) ) )
["Afghanistan", "Bangladesh", "Cambodia"], ["Albania", "Belgium", "Cyprus"], ["Argentina", "Bolivia", "Colombia"], ["Angola", "Burundi", "Cameroon"] ]
{ "author": "Kerstin Ekman", "title": "Grand final i skojarbranschen" }, { "author": "Bjarne Stroustrup", "title": "The C++ Programming Language" }, { "author": "Pelle Holmberg and Hans Marklund", "title": "Nya svampboken" } ]
{ "name": "Apple", "fruit_color": "red", "flower_color": "white" }, { "name": "Tussilago", "flower_color": "yellow" }, { "name": "Chanterelle", "fruit_color": "yellow" } ]
{ "species": "ant", "color": "brown", "legs": 6 }, { "species": "bear", "color": "black" }, { "species": "cat", "color": "orange" } ]
"first": "Ain't Talkin'", "second": "Don't Think Twice, It's All Right", "third": "It Ain't Me, Babe", "fourth": "Rollin' and Tumblin'", "fifth": "Where are you?" }
INSERT INTO t1 VALUES ( 2, REPEAT('-', 1048576) )
INSERT INTO t1 VALUES ( 1, REPEAT('x', 1048576) )
create table t9 (a date not null) partition by RANGE(TO_DAYS(a)) ( partition p0 values less than (732299), -- 2004-12-19 partition p1 values less than (732468), -- 2005-06-06 partition p2 values less than (732664)  -- 2005-12-19 )
set @a:=0
set @a:=0
set @a:=0
create trigger t1_bi before insert on t1 for each row set @a:=1
source include/show_binlog_events.inc
source include/show_binlog_events.inc
call mtr.add_suppression("Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT")
dirty_close con1
dirty_close con1
create procedure scope(a int, b float) begin declare b int; declare c float; begin declare c int; end; end
create procedure locset(x char(16), y int) begin declare z1, z2 int; set z1 = y; set z2 = z1+2; insert into test.t1 values (x, z2); end
create procedure setcontext() begin declare data int default 2; insert into t1 (id, data) values ("foo", 1); replace t1 set data = data, id = "bar"; update t1 set id = "kaka", data = 3 where t1.data = data; end
create procedure nullset() begin declare ld date; declare li int; declare lf double; declare ls varchar(32); set ld = null, li = null, lf = null, ls = null; insert into t3 values (ld, li, lf, ls); insert into t3 (i, f, s) values ((ld is null), 1,    "ld is null"), ((li is null), 1,    "li is null"), ((li = 0),     null, "li = 0"), ((lf is null), 1,    "lf is null"), ((lf = 0),     null, "lf = 0"), ((ls is null), 1,    "ls is null"); end
create procedure mixset(x char(16), y int) begin declare z int; set @z = y, z = 666; insert into test.t1 values (x, z); end
create procedure zip(x char(16), y int) begin declare z int; call zap(y, z); call bar(x, z); end
create procedure zap(x int, out y int) begin declare z int; set z = x+1, y = z; end
create procedure cbv1() begin declare y int default 3; call cbv2(y+1, y); insert into test.t1 values ("cbv1", y); end
create procedure sub2(id char(16)) begin declare x int; set x = (select sum(t.i) from test.t2 t); insert into test.t1 values (id, x); end
CREATE TABLE ðŸ¬(a INT)
CREATE TABLE t1(ðŸ¬ INT)
DROP TABLE ðŸ¬
PREPARE stmt FROM "SELECT 'x' AS 'ðŸ¬'"
EXECUTE stmt
CREATE TABLE ðŸ¬(a INT)
CREATE TABLE t1(ðŸ¬ INT)
PREPARE stmt FROM "SELECT 'x' AS 'ðŸ¬'"
EXECUTE stmt
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2)
(SELECT COUNT(a) AS cnt FROM t2) AS derived ON TRUE WHERE t1.a > derived.cnt
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2) OR t1.a = 2
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2) AND t1.a < (SELECT MAX(a) * 4 AS mx FROM t2)
LEFT JOIN (SELECT COUNT(a) AS cnt FROM t2) AS lj1 ON TRUE LEFT JOIN (SELECT MAX(a) * 4 AS mx FROM t2) AS lj2 ON TRUE WHERE t1.a > cnt AND t1.a < mx
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t3)
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t3 GROUP BY a)
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 1)
WHERE t1.a > (SELECT a from t1 WHERE false)
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 1 LIMIT 1)
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 1 LIMIT 1 OFFSET 1)
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 1 LIMIT 1 OFFSET 0)
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 1 LIMIT 2 OFFSET 0)
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 1 LIMIT 2 OFFSET 1)
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION (SELECT 1 LIMIT 1))
WHERE t1.a > (SELECT a FROM t2 LIMIT 1)
WHERE t1.a > (SELECT a FROM t2)
FROM t1 JOIN t2 ON t1.a+t2.a = (SELECT COUNT(*) FROM t1)
FROM t1 JOIN t2 ON t1.a+t2.a = (SELECT COUNT(*) FROM t1) JOIN t3 ON t1.a + (SELECT MIN(a) FROM t1) = t3.b
FROM t1 LEFT JOIN ( t2 JOIN t3 ON t2.a = (SELECT COUNT(*) FROM t1) ) ON t1.a + (SELECT MIN(a) FROM t1) = t3.b
FROM t1 STRAIGHT_JOIN ( t2 STRAIGHT_JOIN t3 ON t2.a = (SELECT COUNT(*) FROM t1) ) ON t1.a + (SELECT MIN(a) FROM t1) = t3.b
FROM t2 LEFT OUTER JOIN (SELECT -SUM(a) AS cnt FROM t1) AS derived ON TRUE
SELECT derived0.cnct AS subq FROM t1 LEFT JOIN LATERAL (WITH RECURSIVE dt AS (SELECT t1.a AS a UNION SELECT (dt.a + 1) FROM dt WHERE dt.a < 10) SELECT t1.a * CONCAT(COUNT(0), '.', FLOOR(AVG(dt.a))) AS cnct FROM dt) derived0 ON TRUE
SELECT (derived_1.`COUNT(*) + outer_t.a` + IFNULL(derived_0.`MAX(b)`,0)) + 1 + 5 AS mx FROM (SELECT STRAIGHT_JOIN MAX(outer_t.b) AS `MAX(b)`, outer_t.a AS d_1 FROM t1 outer_t GROUP BY outer_t.a) derived_0 LEFT JOIN LATERAL (SELECT (COUNT(0) + derived_0.d_1) AS `COUNT(*) + outer_t.a` FROM t1) derived_1 ON(true) WHERE true
EXECUTE p
DROP PREPARE p
PREPARE s FROM 'SELECT a FROM t1 WHERE a=(SELECT MAX(a) FROM t1) AND (a="20060606155555")'
EXECUTE s
PREPARE s FROM 'SELECT a FROM t1 WHERE a=(SELECT MAX(a) FROM t1) AND (a="20060606155555")'
EXECUTE s
EXECUTE p
EXECUTE p
EXECUTE p
PREPARE prep_stmt FROM 'SELECT col_varchar_key FROM (SELECT * FROM X WHERE X.col_varchar_key > (SELECT MIN(col_varchar_key) FROM X)) AS table1'
EXECUTE prep_stmt
PREPARE prep_stmt FROM 'SELECT (SELECT t2.pk FROM (m AS t1 JOIN (m AS t2 JOIN m AS t3))), (SELECT SUM(pk) FROM m), MIN(table1.pk) FROM (m AS table1 JOIN ((view_m AS table2 JOIN m AS table3)) ON (table3.pk = table2.pk))'
EXECUTE prep_stmt
PREPARE p FROM 'SELECT (SELECT MAX(i) FROM n) AS field2, COUNT(table1.i) AS field3 , (SELECT AVG(i) FROM n) AS field4 FROM (n AS table1 JOIN ( view_n AS table2 JOIN n AS table3 ON true ) ON (table2.i = table2.i))'
EXECUTE p
SELECT alias1.col_decimal_10_8 AS field1 , ( SELECT SUM(table1.col_smallint ) AS SQ1_field1 FROM ( t1 as table1 RIGHT JOIN t1 as table2 ON 1 ) ) AS field2 , GROUPING( LOG(alias1.col_int) ) AS field3 FROM ( t1 AS alias1 JOIN t1 AS alias2 ON 1  ) WHERE alias2.pk IN ( SELECT col_char_255 FROM t1 ) GROUP BY field1, field2, LOG(alias1.col_int) WITH ROLLUP ORDER BY alias1.col_datetime, field1, field2, LOG(alias1.col_int)
LET $MYSQL_TMP_DIR_UCASE= `SELECT upper('$MYSQL_TMP_DIR')`
LET $MYSQL_TMP_DIR_LCASE= `SELECT lower('$MYSQL_TMP_DIR')`
call mtr.add_suppression("Failed to set up SSL because of the following SSL library error")
FROM performance_schema.status_by_thread WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0 AND THREAD_ID IN (SELECT thread_id from test.thread_to_monitor)
LOCK TABLE t1 WRITE
UNLOCK TABLES
LOCK TABLE t1 READ, t1 as TableAlias READ
UNLOCK TABLES
LOCK TABLE t1 WRITE
UNLOCK TABLES
LOAD DATA INFILE 'loadtest.txt' INTO TABLE t1 PARTITION (pNeg)
LOAD DATA INFILE 'loadtest.txt' INTO TABLE t1 PARTITION (pNeg, subp4, subp5)
LOCK TABLE t1 WRITE
LOAD DATA INFILE 'loadtest.txt' INTO TABLE t1 PARTITION (pNeg, `p10-99`) CHARACTER SET latin1
UNLOCK TABLES
LOCK TABLE t1 WRITE
UNLOCK TABLES
LOCK TABLE t1 WRITE
UNLOCK TABLES
DELETE t1 PARTITION (pNeg), t3 FROM t1, t3 FLUSH STATUS
SET @old_innodb_thread_concurrency := @@innodb_thread_concurrency
SET @old_innodb_thread_sleep_delay := @@innodb_thread_sleep_delay
CREATE TABLE t1 (user_num BIGINT, hours SMALLINT, KEY user_num (user_num)) ENGINE = InnoDB PARTITION BY RANGE COLUMNS (hours) (PARTITION hour_003 VALUES LESS THAN (3), PARTITION hour_004 VALUES LESS THAN (4), PARTITION hour_005 VALUES LESS THAN (5), PARTITION hour_last VALUES LESS THAN (MAXVALUE))
SET @old_transaction_isolation := @@session.transaction_isolation
INSERT INTO t1 VALUES (concat(repeat('MySQL',100),'1'),repeat('0',257))
INSERT INTO t1 VALUES (concat(repeat('MySQL',100),'3'),repeat('0',257))
INSERT INTO t1 VALUES (concat(repeat('MySQL',100),'2'),repeat('0',257))
SELECT right(a,1) FROM t1 WHERE b = repeat('0',257) ORDER BY a ASC
SELECT right(a,1) FROM t1 WHERE b = repeat('0',257) ORDER BY a DESC
SELECT right(a,1) FROM t1 WHERE b = repeat('0',257) ORDER BY a ASC
SELECT right(a,1) FROM t1 WHERE b = repeat('0',257) ORDER BY a DESC
UNLOCK TABLES
CREATE TABLE t5 ( f1 INT, f2 INT ) ENGINE=InnoDB PARTITION BY RANGE COLUMNS(f1,f2) ( PARTITION p0 VALUES LESS THAN (10000,12), PARTITION p1 VALUES LESS THAN (MAXVALUE, MAXVALUE) )
CREATE TABLE t6 ( a INT, b INT ) ENGINE=InnoDB PARTITION BY RANGE COLUMNS(a,b) SUBPARTITION BY KEY(a,b) SUBPARTITIONS 2 ( PARTITION p0 VALUES LESS THAN (10000,12), PARTITION p1 VALUES LESS THAN (MAXVALUE, MAXVALUE) )
LET $MYSQL_DATA_DIR = `select @@datadir`
`f1` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, `f2` MEDIUMTEXT NOT NULL, `f3` CHAR(100) NOT NULL, `f4` TINYINT(1) unsigned NOT NULL, PRIMARY KEY (`f1`,`f4`) ) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=latin1 PARTITION BY LIST (`f4`) (PARTITION p0 VALUES IN (0) ENGINE = InnoDB, PARTITION p1 VALUES IN (1) DATA DIRECTORY = '$MYSQL_TMP_DIR/temp_dir' ENGINE = InnoDB)
call mtr.add_suppression("Missing .ibd file for table")
HANDLER t1 OPEN
HANDLER t1 READ `PRIMARY` FIRST
HANDLER t1 READ `PRIMARY` NEXT
HANDLER t1 READ `PRIMARY` NEXT
HANDLER t1 READ `PRIMARY` NEXT
HANDLER t1 READ `PRIMARY` NEXT
HANDLER t1 READ `PRIMARY` LAST
HANDLER t1 READ `PRIMARY` PREV
HANDLER t1 READ `PRIMARY` PREV
HANDLER t1 READ `PRIMARY` PREV
HANDLER t1 READ ab_asc FIRST
HANDLER t1 READ ab_asc NEXT
HANDLER t1 READ ab_asc NEXT
HANDLER t1 READ ab_asc NEXT
HANDLER t1 READ ab_asc NEXT
HANDLER t1 READ ab_asc LAST
HANDLER t1 READ ab_asc PREV
HANDLER t1 READ ab_asc PREV
HANDLER t1 READ ab_asc PREV
HANDLER t1 CLOSE
lock tables mysql.general_log WRITE
lock tables mysql.slow_log WRITE
lock tables mysql.general_log READ
lock tables mysql.slow_log READ
prepare st_ins from 'insert into t1 set emp = ?, salary = ?, l = ?, r = ?'
execute st_ins using @arg_nam, @arg_sal, @arg_l, @arg_r
execute st_ins using @arg_nam, @arg_sal, @arg_l, @arg_r
execute st_ins using @arg_nam, @arg_sal, @arg_l, @arg_r
execute st_ins using @arg_nam, @arg_sal, @arg_l, @arg_r
execute st_ins using @arg_nam, @arg_sal, @arg_l, @arg_r
execute st_ins using @arg_nam, @arg_sal, @arg_l, @arg_r
prepare st_raise_base from 'update t1 set salary = salary * ( 1 + ? ) where r - l = 1'
prepare st_raise_mgr  from 'update t1 set salary = salary + ? where r - l > 1'
prepare st_round from 'update t1 set salary = salary + ? - ( salary MOD ? )'
execute st_round using @arg_round, @arg_round
CREATE TABLE t0 ( skip INT, locked INT, nowait INT )
CREATE PROCEDURE p1() BEGIN skip: LOOP LEAVE skip; END LOOP skip; END
source include/have_debug.inc
source include/have_debug_sync.inc
send INSERT INTO result(c1, c2, c3) SELECT * FROM t1 ON DUPLICATE KEY UPDATE c2=t1.c2, c3='UT1', update_count=update_count+1
reap
HANDLER t OPEN
HANDLER t READ k1= (5)
HANDLER t CLOSE
HANDLER t1 OPEN
LOCK TABLE t1 WRITE
send TRUNCATE TABLE t1
KILL QUERY @id
reap
UNLOCK TABLES
HANDLER t1 CLOSE
send TRUNCATE TABLE t1
KILL QUERY @id
reap
UNLOCK TABLES
source include/dd_pfs_save_state.inc
source include/dd_pfs_report_state.inc
CHANGE REPLICATION SOURCE TO SOURCE_USER=     'plug_user', SOURCE_PASSWORD= 'plug_user', SOURCE_RETRY_COUNT= 0
WHERE t1.f1 IN (SELECT f1 FROM t4) AND t2.f1 IN (SELECT f1 FROM t5)
WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t2) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t2)
WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5)
WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5)
WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5)
WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5)
FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5)
WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5)
WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5)
WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5)
FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5)
FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5)
FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5)
FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5)
JOIN_ORDER(t2, t5@subq2, t4@subq1, t3, t1) JOIN_PREFIX(t2, t5@subq2, t4@subq1, t3, t1) */ count(*) FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5)
WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5)
WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5)
WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5)
WHERE t1.f1 IN (SELECT f1 FROM t4) AND t2.f1 IN (SELECT f1 FROM t5)
WHERE t1.f1 IN (SELECT f1 FROM t4) AND t2.f1 IN (SELECT f1 FROM t5)
WHERE t1.f1 IN (SELECT f1 FROM t4) AND t2.f1 IN (SELECT f1 FROM t5)
WHERE t1.f1 IN (SELECT f1 FROM t4) AND t2.f1 IN (SELECT f1 FROM t5)
FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5)
FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5)
FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5)
SELECT INSERT(a, 10, 2, b) FROM t1
SELECT INSERT(a, 1, 2, b) FROM t1
PREPARE stmt1 FROM @str2
EXECUTE stmt1 USING @ivar
PREPARE stmt FROM 'SELECT utext FROM t1 where utext like ?'
EXECUTE stmt USING @param1
EXECUTE stmt USING @param1
DEALLOCATE PREPARE stmt
PREPARE stmt FROM 'SELECT utext FROM t1 where utext like ?'
EXECUTE stmt USING @param1
EXECUTE stmt USING @param1
DEALLOCATE PREPARE stmt
CREATE TABLE t1 AS SELECT REPEAT('abcd', 128) AS a
CREATE TABLE t1 AS SELECT REPEAT('abcd', 128) AS a LIMIT 0
CREATE TABLE t1 AS SELECT REPEAT('a',2) as s1 LIMIT 0
CREATE TABLE t1 AS SELECT REPEAT(' ', 10) as c LIMIT 0
CREATE PROCEDURE p1(IN val BLOB) BEGIN SET @tval = val; SET @sql_cmd = CONCAT_WS(' ', 'insert into t1(f1) values(?)'); PREPARE stmt FROM @sql_cmd; EXECUTE stmt USING @tval; DEALLOCATE PREPARE stmt; END
SET @`tcontent`:=_binary 0x50434B000900000000000000E9000000 COLLATE `binary`/*!*/
RENAME TABLE t1 to t2
copy_file $MYSQLD_DATADIR/binlog.000001 $MYSQLD_DATADIR/binlog.saved
UNLOCK TABLES
LOCK TABLE t1 READ, v1 READ
UNLOCK TABLES
DELIMITER
CREATE FUNCTION func1() RETURNS INT DETERMINISTIC BEGIN DECLARE a int; SELECT COUNT(*) INTO a FROM information_schema.columns WHERE table_name='db'; RETURN a; END
CREATE PROCEDURE proc1() BEGIN DECLARE i INT; SELECT (func1() + COUNT(*)) INTO i FROM information_schema.tables m JOIN information_schema.columns n ON m.table_name = n.table_name WHERE m.table_name='db'; INSERT INTO t1 VALUES (i); END
LOCK TABLE t1 WRITE, t1 as X READ, t3 READ
UNLOCK TABLES
LOCK TABLE t1 WRITE, t2 WRITE
UNLOCK TABLES
LOCK TABLES t1 READ
UNLOCK TABLES
perl
use File::stat
my $file= $ENV{'GREP_FILE'} or die("grep file not set")
my $pattern="^20"
my $stime= $ENV{'GREP_START'}
open(FILE, "$file") or die("Unable to open $file: $!")
while (<FILE>) { my $line = $_
my $ts = 0
if ($stime == 0) { print "$line"
} elsif ($line =~ /$pattern/) { $line =~ /([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])T([0-9][0-9]):([0-9][0-9]):([0-9][0-9])\.([0-9][0-9][0-9][0-9][0-9][0-9])[-+Z][0-9:]* *[0-9]* *?(\[.*)
$ts=$1.$2.$3.$4.$5.$6.$7
if ($ts >= $stime) { $stime= 0
} } } close(FILE)
CALL mtr.add_suppression("Plugin test_plugin_server reported: 'Wrong password supplied for plug_dest'")
CALL mtr.add_suppression("The plugin 'new_plugin_server' used to authenticate user 'new_user'@'%' is not loaded. Nobody can currently login using this account.")
[mysqlpump] exclude_databases=db1,mysql,mtr CREATE DATABASE db1
CALL mtr.add_suppression("Incorrect information in file")
call mtr.add_suppression("Dictionary file not specified")
CALL mtr.add_suppression("currently unknown variable 'validate_password_*")
CALL mtr.add_suppression("currently unknown variable 'validate_password_*")
RENAME TABLE t1 TO t123456789012345678901234567890123456789012345678901234567890
LOAD DATA INFILE 'tmp1.txt' INTO TABLE t1
LOAD DATA INFILE 'tmp2.txt' INTO TABLE t1
LOAD DATA INFILE 'tmp2.txt' IGNORE INTO TABLE t1
LOAD DATA INFILE '../../std_data/loaddata3.dat' IGNORE INTO TABLE t1 FIELDS TERMINATED BY '' ENCLOSED BY '' IGNORE 1 LINES
remove_file $MYSQLD_DATADIR/test/tmp1.txt
remove_file $MYSQLD_DATADIR/test/tmp2.txt
remove_file $MYSQLTEST_VARDIR/tmp/tmp1.xml
remove_file $MYSQLTEST_VARDIR/tmp/tmp2.xml
RENAME TABLE t1 TO t2
RENAME TABLE t1 TO t3, t2 TO t1, t3 TO t2
ALTER TABLE t1 MODIFY COLUMN c1 FLOAT(10.3), DROP CHECK t1_chk_1, ADD CONSTRAINT CHECK(C1 > 10.1) ENFORCED
CREATE TABLE t1 (f1 INT CHECK (f1 = default(f1)))
CREATE TABLE t1 (f1 DATETIME CHECK (f1 + UTC_DATE() > '2011-11-21'))
CREATE TABLE t1 (f1 DATETIME CHECK (f1 + UTC_TIME() > '23:11:21'))
PREPARE stmt1 FROM 'INSERT INTO t1 VALUES(1)'
EXECUTE stmt1
DEALLOCATE PREPARE stmt1
PREPARE stmt2 FROM 'INSERT INTO t1 VALUES(20)'
EXECUTE stmt2
DEALLOCATE PREPARE stmt2
remove_file $MYSQLTEST_VARDIR/tmp/tmp1.txt
remove_file $MYSQLTEST_VARDIR/tmp/tmp1.txt
remove_file $MYSQLTEST_VARDIR/tmp/tmp1.txt
remove_file $MYSQLTEST_VARDIR/tmp/tmp1.txt
remove_file $MYSQLTEST_VARDIR/tmp/tmp1.txt
DELIMITER
remove_file $MYSQLTEST_VARDIR/tmp/tmp1.txt
remove_file $MYSQLTEST_VARDIR/tmp/tmp1.txt
remove_file $MYSQLTEST_VARDIR/tmp/tmp1.txt
remove_file $MYSQLTEST_VARDIR/tmp/tmp1.xml
remove_file $MYSQLTEST_VARDIR/tmp/tmp1.txt
remove_file $MYSQLTEST_VARDIR/tmp/tmp1.txt
remove_file $MYSQLTEST_VARDIR/tmp/tmp1.xml
FLUSH TABLE t1 FOR EXPORT
UNLOCK TABLES
IMPORT TABLE FROM 't1_*.sdi'
call mtr.add_suppression("You need to use --log-bin to make --binlog-format work.")
call mtr.add_suppression("You need to use --log-bin to make --log-replica-updates work.")
PREPARE stmt1 FROM ' EXPLAIN SELECT a FROM t1 ORDER BY b '
EXECUTE stmt1
PREPARE stmt1 FROM ' EXPLAIN SELECT a FROM t1 WHERE a > ? ORDER BY b '
EXECUTE stmt1 USING @arg00
RENAME TABLE t1 TO t1_1, t9 TO t9_1
RENAME TABLE t1 TO t1_2, t9 TO t9_2
send SELECT f1()
reap
SHOW FUNCTION CODE testdb.func_root
SHOW FUNCTION CODE testdb.func_definer
SHOW FUNCTION CODE testdb.func_root
SHOW FUNCTION CODE testdb.func_definer
SHOW FUNCTION CODE testdb.func_root
SHOW FUNCTION CODE testdb.func_definer
SHOW FUNCTION CODE testdb.func_root
SHOW FUNCTION CODE testdb.func_definer
SHOW FUNCTION CODE testdb.func_root
SHOW FUNCTION CODE testdb.func_definer
SHOW FUNCTION CODE testdb.func_root
SHOW FUNCTION CODE testdb.func_definer
SHOW FUNCTION CODE testdb.func_root
SHOW FUNCTION CODE testdb.func_definer
SHOW FUNCTION CODE testdb.func_root
SHOW FUNCTION CODE testdb.func_definer
SHOW FUNCTION CODE testdb.func_root
SHOW FUNCTION CODE testdb.func_definer
SHOW FUNCTION CODE testdb.func_root
SHOW FUNCTION CODE testdb.func_definer
disable_query_log
call mtr.add_suppression("Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT")
enable_query_log
create procedure bug8850() begin truncate table t1; insert t1 values (1); rollback; end
create function bug10015_2() returns int begin declare i, s int; set i:= (select min(id) from t1); set s:= (select max(id) from t1); return (s - i); end
create function bug10015_4(i int) returns int begin declare m int; set m:= (select max(id) from t2); insert into t2 values (i, m); return m; end
create function bug10015_6(i int) returns int begin declare continue handler for sqlexception set @error_in_func:= 1; if (i = 5) then insert into t2 values (4, 0), (1, 0); end if; return i; end
set @error_in_func:= 0
create function bug10015_7() returns int begin start transaction; return 1; end
create function bug10015_7() returns int begin commit; return 1; end
create procedure bug10015_8() start transaction
create procedure bug10015_8() commit
create function bug13825_0() returns int begin rollback to savepoint x; return 1; end
create function bug13825_1() returns int begin release savepoint x; return 1; end
create function bug13825_2() returns int begin insert into t1 values (2); savepoint x; insert into t1 values (3); rollback to savepoint x; insert into t1 values (4); return 1; end
create procedure bug13825_0() begin rollback to savepoint x; end
create procedure bug13825_1() begin release savepoint x; end
create procedure bug13825_2() begin savepoint x; end
create trigger t2_bi before insert on t2 for each row rollback to savepoint x
create trigger t2_bu before update on t2 for each row release savepoint x
create trigger t2_bd before delete on t2 for each row begin insert into t1 values (2); savepoint x; insert into t1 values (3); rollback to savepoint x; insert into t1 values (4); end
create function bug13825_3(rb int) returns int begin insert into t1 values(1); savepoint x; insert into t1 values(2); if rb then rollback to savepoint x; end if; insert into t1 values(3); return rb; end
create function bug13825_4() returns int begin savepoint x; insert into t1 values(2); rollback to savepoint x; return 0; end
create function bug13825_5(p int) returns int begin savepoint x; insert into t2 values(p); rollback to savepoint x; insert into t2 values(p+1); return p; end
set @a:= bug13825_0()
set @a:= bug13825_1()
set @a:= bug13825_2()
release savepoint x
set @a:= bug13825_2()
set @a:= bug13825_4()
create procedure bug14840_1() begin declare err int default 0; declare continue handler for sqlexception set err = err + 1; start transaction; update t3 set x = 1, y = 42 where x = 2; insert into t3 values (3, 4711); if err > 0 then rollback; else commit; end if; select * from t3; end
create procedure bug14840_2() begin declare err int default 0; declare continue handler for sqlexception begin set err = err + 1; select err as 'Ping'; end; update t3 set x = 1, y = 42 where x = 2; update t3 set x = 1, y = 42 where x = 2; insert into t3 values (3, 4711); select * from t3; end
create procedure bug10656_create_index() begin create index bug10656_my_index on t3 (ID); end
create procedure bug14210_fill_table() begin declare table_size, max_table_size int default 0; select @@session.max_heap_table_size into max_table_size; delete from t3; insert into t3 (a) values (repeat('a', 255)); repeat insert into t3 select a from t3; select count(*)*255 from t3 into table_size; until table_size > max_table_size*2 end repeat; end
create procedure bug14210() begin declare a char(255); declare done int default 0; declare c cursor for select * from t3; declare continue handler for sqlstate '02000' set done = 1; open c; repeat fetch c into a; if not done then insert into t4 values (upper(a)); end if; until done end repeat; close c; end
CREATE PROCEDURE p1() SHOW ENGINE INNODB STATUS;
CREATE FUNCTION bug13575 ( p1 integer ) returns varchar(3) BEGIN DECLARE v1 VARCHAR(10) DEFAULT null; SELECT f2 INTO v1 FROM t3 WHERE f1 = p1; RETURN v1; END
INSERT INTO t1 VALUES(1,repeat('a',1000)),(2,repeat('def',600))
SELECT * FROM t1, LATERAL ( SELECT MAX(1) FROM t2 GROUP BY t1.f1 ) AS l1
SELECT STD(0) FROM t2, LATERAL ( SELECT f1 FROM t1 GROUP BY f2,f1 ) AS d1
SELECT /*+ no_merge() */  outr.pk AS x FROM ( SELECT * FROM  t1  ) AS  outr WHERE outr.col_int_key  IN ( SELECT /*+ no_merge() no_semijoin() */ id FROM JSON_TABLE( IF(outr.col_date_key<>NOW(), '[{"a":"3"},{"a":2},{"b":1},{"a":0}]', '') , '$[*]' columns (id for ordinality, jpath varchar(100) path '$.a', jexst int exists path '$.b')   ) AS qn ) ORDER BY outr.col_datetime
SELECT * FROM t1 JOIN LATERAL ( SELECT GROUP_CONCAT(t.id) AS c FROM t2 t WHERE (t.id = t1.id) ) d0 ON (1)
EXPLAIN SELECT * FROM t1 JOIN LATERAL (SELECT a+t1.a from t2 GROUP BY a) AS dt
SELECT * FROM t1 JOIN LATERAL (SELECT a+t1.a from t2 GROUP BY a) AS dt
SELECT 1 FROM v1 AS table1 RIGHT OUTER JOIN LATERAL (SELECT 1 FROM v1 AS table2 RIGHT OUTER JOIN LATERAL ( SELECT 1 FROM v1 AS table3 ) AS table4 ON table1.c1 = 1) AS table5 ON 1
SELECT * FROM t1 LEFT JOIN ( t3, LATERAL ( SELECT * FROM t2 WHERE table_id = t3.id ) l1 ) ON TRUE
SELECT * FROM t1 LEFT JOIN ( t1 AS t2 LEFT JOIN t1 AS t3 ON TRUE ) ON TRUE, LATERAL ( SELECT SUM(t1.a), t2.a FROM t1 ) AS d1
SELECT * FROM t1 AS tbl1 LEFT JOIN t1 AS tbl3 ON FALSE WHERE tbl1.id NOT IN (SELECT id FROM t1 AS tbl2 JOIN LATERAL (SELECT 1 FROM t2 WHERE id = tbl2.id LIMIT 10) AS d1)
SELECT /*+ JOIN_PREFIX(tbl1, tbl2) */ * FROM t1 AS tbl1 LEFT JOIN t1 AS tbl3 ON FALSE WHERE tbl1.id NOT IN (SELECT id FROM t1 AS tbl2 JOIN LATERAL (SELECT 1 FROM t2 WHERE id = tbl2.id LIMIT 10) AS d1)
query_get_value(SELECT @@global.max_allowed_packet, @@global.max_allowed_packet, 1)
c1 LONGTEXT ) ENGINE=$engine_type DEFAULT CHARSET latin1
INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 4194304))
INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 2097152))
INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 262144))
INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 32768))
query_vertical SELECT LENGTH(c1) FROM t1
query_vertical SELECT LENGTH(c1) FROM t1
CREATE FUNCTION service_get_read_locks  RETURNS INT SONAME "$LOCKING_SERVICE"
CREATE FUNCTION service_get_write_locks RETURNS INT SONAME "$LOCKING_SERVICE"
CREATE FUNCTION service_release_locks   RETURNS INT SONAME "$LOCKING_SERVICE"
SELECT COUNT(*) = 1 FROM information_schema.processlist WHERE state = 'Waiting for locking service lock' AND id =
KILL @aux
file_exists $MYSQLTEST_VARDIR/tmp/master_log.err
file_exists $MYSQLTEST_VARDIR/mysqld.1/data/master-bin.000002
file_exists $MYSQLTEST_VARDIR/mysqld.2/data/slave-relay-bin.000003
file_exists $MYSQLTEST_VARDIR/mysqld.2/data/slave-relay-bin.000003
file_exists $MYSQLTEST_VARDIR/mysqld.1/data/master-bin.000002
file_exists $MYSQLTEST_VARDIR/mysqld.1/data/master-bin.000002
file_exists $MYSQLTEST_VARDIR/mysqld.1/data/master-bin.000002
file_exists $MYSQLTEST_VARDIR/mysqld.1/data/master-bin.000002
file_exists $MYSQLTEST_VARDIR/mysqld.1/data/master-bin.000002
file_exists $MYSQLTEST_VARDIR/mysqld.1/data/master-bin.000002
file_exists $MYSQLTEST_VARDIR/mysqld.1/data/master-bin.000001
file_exists $MYSQLTEST_VARDIR/mysqld.2/data/slave-relay-bin.000006
file_exists $MYSQLTEST_VARDIR/tmp/master_log.err
file_exists $MYSQLTEST_VARDIR/mysqld.1/data/master-bin.000003
file_exists $MYSQLTEST_VARDIR/mysqld.2/data/slave-relay-bin.000006
file_exists $MYSQLTEST_VARDIR/mysqld.2/data/slave-relay-bin.000007
file_exists $MYSQLTEST_VARDIR/mysqld.2/data/slave-relay-bin.000008
file_exists $MYSQLTEST_VARDIR/tmp/master_log.err
file_exists $MYSQLTEST_VARDIR/mysqld.1/data/master-bin.000003
file_exists $MYSQLTEST_VARDIR/mysqld.2/data/slave-relay-bin.000007
file_exists $MYSQLTEST_VARDIR/mysqld.2/data/slave-relay-bin.000008
CREATE TABLE t1 (a INT NOT NULL,b INT NOT NULL, PRIMARY KEY USING BTREE (a)) ENGINE=MYISAM COMMENT="TESTING" PACK_KEYS=1 DELAY_KEY_WRITE=1 STATS_PERSISTENT=1 CHECKSUM=1 MIN_ROWS=1 MAX_ROWS=100
CREATE TABLE t2 (a INT NOT NULL,b INT NOT NULL, PRIMARY KEY USING BTREE (a)) ENGINE=MYISAM COMMENT="TESTING" PACK_KEYS=0 DELAY_KEY_WRITE=1 STATS_PERSISTENT=1 CHECKSUM=1 MIN_ROWS=1 MAX_ROWS=100
select hex(weight_string('a' as char(-1)))
create table t1 charset latin1 select weight_string(repeat('t',66000)) as w
DO ltrim(weight_string(1))
DO rtrim(weight_string(1))
create table t1 (a int not null,b int not null, primary key using BTREE (a)) engine=heap comment="testing heaps" avg_row_length=100 min_rows=1 max_rows=100
alter table t1 add c int not null, add key using BTREE (c,a)
create table t1 (a int not null,b int not null, primary key using BTREE (a)) engine=heap comment="testing heaps"
CREATE TABLE t1 ( a int not null default 0, b int not null default 0,  key  using BTREE (a,b),  key  using BTREE (b)  ) ENGINE=HEAP
create table t1 (id int unsigned not null, primary key  using BTREE (id)) engine=HEAP
create table t1 (btn char(10) not null, key using BTREE (btn)) charset utf8mb4 engine=heap
alter table t1 add column new_col char(1) not null, add key using BTREE (btn,new_col), drop key btn
CREATE TABLE t1 (a int, b int, c int, key using BTREE (a, b, c)) engine=heap
CREATE TABLE t1 (a int not null, primary key using BTREE (a)) engine=heap
create table t1(a int not null, key using btree(a)) engine=heap
CREATE TABLE t1 ( c1 CHAR(3), c2 INTEGER, KEY USING BTREE(c1), KEY USING BTREE(c2) ) ENGINE= MEMORY
CREATE TABLE t1 ( c1 ENUM('1', '2'), UNIQUE USING BTREE(c1) ) ENGINE= MEMORY DEFAULT CHARSET= utf8
CREATE TABLE t1 ( c1 SET('1', '2'), UNIQUE USING BTREE(c1) ) ENGINE= MEMORY DEFAULT CHARSET= utf8
CREATE TABLE t1 (a INT, KEY USING BTREE(a)) ENGINE=MEMORY
CREATE TABLE t1(val INT, KEY USING BTREE(val)) ENGINE=memory
CREATE TABLE t1 (a INT, UNIQUE USING BTREE(a)) ENGINE=MEMORY
create table t1(a varchar(255), b varchar(255), key using btree (a,b)) engine=memory
CREATE TABLE t1(a INT, KEY USING BTREE (a)) ENGINE=MEMORY
CREATE TABLE t1( id INT AUTO_INCREMENT PRIMARY KEY, c1 INT NOT NULL, c2 INT NOT NULL, UNIQUE KEY USING BTREE (c2,c1)) ENGINE = MEMORY
show create schema foo
WHERE state= $drop_schema_target_state AND info='DROP SCHEMA schema1'
LOCK TABLE schema1.t1 WRITE
WHERE state='Waiting for schema metadata lock' and info='DROP SCHEMA schema1'
UNLOCK TABLES
HANDLER db1.t1 OPEN
WHERE state='Waiting for table metadata lock' AND info='DROP DATABASE db1'
HANDLER t1 CLOSE
WHERE state= $drop_schema_target_state
CALL mtr.add_suppression("Failed to find tablespace")
CALL mtr.add_suppression("Ignoring tablespace")
CALL mtr.add_suppression("Cannot rename")
CALL mtr.add_suppression("Cannot calculate")
CALL mtr.add_suppression("Cannot open datafile")
CALL mtr.add_suppression("The error means the system cannot find")
CALL mtr.add_suppression("File ./s/t_innodb.ibd")
CALL mtr.add_suppression("Operating system error number")
SHOW CREATE SCHEMA s
SHOW CREATE SCHEMA s
CALL mtr.add_suppression("Problem while dropping database. Can't remove database directory .* Please remove it manually.")
SELECT db1.f1()
WHERE state= 'Waiting for stored function metadata lock' AND info='DROP DATABASE db1'
call mtr.add_suppression("\\[Warning\\] .*MY-\\d+.* Tablespace .*, name '.*', file '.*' is missing!")
SHOW CREATE SCHEMA s
SHOW CREATE SCHEMA s
HANDLER t1 OPEN
SHOW CREATE DATABASE test1
call mtr.add_suppression("Dictionary file not specified")
PREPARE p1 FROM 'SELECT i FROM test.t'
DEALLOCATE PREPARE p1
PREPARE p1 FROM 'SELECT i FROM test.t'
DEALLOCATE PREPARE p1
PREPARE p1 FROM 'SELECT i FROM test.t'
PREPARE p2 FROM 'SELECT i FROM test.t'
DEALLOCATE PREPARE p1
DEALLOCATE PREPARE p2
PREPARE p1 FROM 'SELECT i FROM test.t'
DEALLOCATE PREPARE p1
PREPARE p1 FROM 'SELECT i FROM test.t'
DEALLOCATE PREPARE p1
PREPARE p1 FROM 'SELECT i FROM test.t'
DEALLOCATE PREPARE p1
PREPARE p1 FROM 'SELECT i FROM test.t'
DEALLOCATE PREPARE p1
PREPARE p1 FROM 'SELECT i FROM test.t'
DEALLOCATE PREPARE p1
PREPARE p1 FROM 'SELECT i FROM test.t'
EXECUTE p1
DEALLOCATE PREPARE p1
INSERT INTO t1 VALUES (REPEAT('1',200))
INSERT INTO t1 VALUES (REPEAT('2', 1800))
echo $str
CALL mtr.add_suppression("Option --protocol-compression-algorithms is reset to default value.")
disable_query_log
enable_query_log
send drop table t2
unlock tables
reap
send drop database mysqltest
unlock tables
reap
dirty_close con1
lock table t1 write
lock table t1 read
unlock tables
lock table t1 write
lock table t1 read
lock table t1 write
unlock tables
lock table t1 read, t2 read, t3 write
lock table t1 read, t2 read, t3 read
unlock tables
lock table t1 write
send flush tables with read lock
send insert into t2 values(1)
unlock tables
reap
reap
lock tables t1 write
unlock tables
lock tables t1 read, t2 write
unlock tables
lock tables t1 read
unlock tables
unlock tables
unlock tables
unlock tables
lock table t2 read
unlock tables
lock table t1 read, t2 read
unlock tables
lock table no_such_table read
unlock tables
flush table t1, t2 with read lock
lock table no_such_table read
unlock tables
flush table t1 with read lock
unlock tables
unlock tables
flush table t1 with read lock
flush table t2 with read lock
unlock tables
unlock tables
flush table t1 with read lock
unlock tables
lock table t1 read, t2 read
unlock tables
unlock tables
flush table v1, v2, v3 with read lock
flush table v1 with read lock
flush table v2 with read lock
flush table v3 with read lock
flush table v1 with read lock
flush table v1 with read lock
unlock tables
handler t1 open
handler t1 read a next
handler t1 read a next
handler t1 read a next
unlock tables
handler t1 read a next
handler t1 close
lock table t1 read
send flush table t1
send select * from t1
unlock tables
reap
reap
lock table t1 read
send flush tables
send select * from t1
unlock tables
reap
reap
handler t1 open
unlock tables
handler t1 close
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t3 READ
UNLOCK TABLES
LOCK TABLES t4 WRITE
UNLOCK TABLES
CREATE TABLE m1(a INT) ENGINE=MERGE UNION=()
ALTER TABLE m1 UNION=()
LOCK TABLE t1 WRITE, t2 WRITE, t3 WRITE
UNLOCK TABLES
LOCK TABLE t1 WRITE, t2 WRITE, t3 WRITE
UNLOCK TABLES
LOCK TABLE t4 WRITE
UNLOCK TABLES
send REPAIR TABLE t1
sleep 1; # let repair run into its sleep INSERT INTO t2 VALUES (1)
reap
LOCK TABLE t1 WRITE
send INSERT INTO t2 VALUES (1)
sleep 1; # Let INSERT go into thr_multi_lock(). REPAIR TABLE t1
sleep 2; # con1 performs busy waiting during this sleep. UNLOCK TABLES
reap
LOCK TABLE t1 WRITE
send INSERT INTO t1 VALUES (1)
sleep 1; # Let INSERT go into thr_multi_lock(). FLUSH TABLES
sleep 1; # Let INSERT go through wait_for_tables() where it sleeps. FLUSH TABLES
UNLOCK TABLES
reap
LOCK TABLES t3 WRITE, t2 WRITE, t1 WRITE
UNLOCK TABLES
RENAME TABLE t4 TO t5
RENAME TABLE t5 TO t4
RENAME TABLE t2 TO t5
RENAME TABLE t5 TO t2
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE
RENAME TABLE t2 TO t5
RENAME TABLE t5 TO t2
UNLOCK TABLES
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE
UNLOCK TABLES
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE
RENAME TABLE t3 TO t5
RENAME TABLE t5 TO t3
UNLOCK TABLES
LOCK TABLES t1 WRITE, t2 WRITE
UNLOCK TABLES
LOCK TABLES t1 WRITE, t2 WRITE
UNLOCK TABLES
LOCK TABLES t4 WRITE, t3 WRITE, t2 WRITE
UNLOCK TABLES
LOCK TABLES t4 WRITE, t3 WRITE, t2 WRITE, t1 WRITE
UNLOCK TABLES
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE, t4 WRITE
UNLOCK TABLES
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE
UNLOCK TABLES
LOCK TABLES t4 WRITE, t3 WRITE, t2 WRITE, t1 WRITE
UNLOCK TABLES
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE, t4 WRITE
UNLOCK TABLES
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE
UNLOCK TABLES
LOCK TABLES t4 WRITE, t3 WRITE, t2 WRITE, t1 WRITE
FLUSH TABLE t4
FLUSH TABLE t2
UNLOCK TABLES
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE, t4 WRITE
FLUSH TABLE t4
FLUSH TABLE t2
UNLOCK TABLES
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE
FLUSH TABLE t4
FLUSH TABLE t2
UNLOCK TABLES
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE
UNLOCK TABLES
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE
UNLOCK TABLES
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE
UNLOCK TABLES
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE
UNLOCK TABLES
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE
UNLOCK TABLES
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE
UNLOCK TABLES
send SELECT COUNT(DISTINCT a1.id) FROM t3 AS a1, t3 AS a2 WHERE a1.id = a2.id GROUP BY a2.grp
sleep 1
reap
LOCK TABLES t2 WRITE, t1 WRITE
UNLOCK TABLES
LOCK TABLES t2 WRITE, t1 WRITE
UNLOCK TABLES
LOCK TABLES t1 WRITE, m1 WRITE
FLUSH TABLE t1
UNLOCK TABLES
LOCK TABLES m1 WRITE, t1 WRITE
FLUSH TABLE t1
UNLOCK TABLES
LOCK TABLE t1 WRITE, t2 WRITE
UNLOCK TABLES
LOCK TABLE t1 WRITE, t2 WRITE
UNLOCK TABLES
LOCK TABLE t1 WRITE, m1 WRITE
UNLOCK TABLES
LOCK TABLES t1 WRITE, t3 WRITE
UNLOCK TABLES
HANDLER m1 OPEN
LOCK TABLE m1 READ
UNLOCK TABLES
prepare stmt from @a
execute stmt
prepare stmt from "select * from t_parent"
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
DATA DIRECTORY='$MYSQLTEST_VARDIR/tmp' INDEX DIRECTORY='$MYSQLTEST_VARDIR/tmp'
DATA DIRECTORY='$MYSQLTEST_VARDIR/tmp' INDEX DIRECTORY='$MYSQLTEST_VARDIR/tmp'
CREATE FUNCTION f1() RETURNS INT BEGIN CREATE TEMPORARY TABLE t2 (c1 INT); ALTER TEMPORARY TABLE tm1 UNION=(t1,t2); INSERT INTO t2 (c1) VALUES (2); RETURN (SELECT MAX(c1) FROM tm1); END
LOCK TABLE tm1 WRITE
UNLOCK TABLES
LOCK TABLE tm1 WRITE
UNLOCK TABLES
LOCK TABLE t2 WRITE
UNLOCK TABLES
LOCK TABLE t9 WRITE
UNLOCK TABLES
LOCK TABLE t9 WRITE
UNLOCK TABLES
LOCK TABLE t2 WRITE
UNLOCK TABLES
LOCK TABLE tm1 WRITE, t1 WRITE
UNLOCK TABLES
LOCK TABLE t1 WRITE, tm1 WRITE
UNLOCK TABLES
LOCK TABLE tm1 WRITE, t1 WRITE
UNLOCK TABLES
LOCK TABLE t1 WRITE, tm1 WRITE
UNLOCK TABLES
LOCK TABLE tm1 WRITE, t1 WRITE, t2 WRITE, t3 WRITE, t4 WRITE, t5 WRITE
send UPDATE t2, tm1 SET t2.c1=f1()
UNLOCK TABLES
reap
LOCK TABLE m1 WRITE, m2 WRITE
UNLOCK TABLES
LOCK TABLE m1 WRITE, t1 WRITE, t2 WRITE
UNLOCK TABLES
LOCK TABLE m1 WRITE
LOCK TABLE m1 WRITE, m2 WRITE
UNLOCK TABLES
LOCK TABLE m1 WRITE
LOCK TABLE m1 WRITE, m2 WRITE
LOCK TABLE m1 WRITE, m2 WRITE
UNLOCK TABLES
HANDLER t3 OPEN
HANDLER t3 OPEN
prepare stmt from "select * from t4 where c1 < f1()"
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
LOCK TABLE m1 WRITE
UNLOCK TABLES
LOCK TABLE m1 WRITE
LOCK TABLE m1 WRITE, t1 WRITE
UNLOCK TABLES
LOCK TABLES t1 READ, m1 WRITE
UNLOCK TABLES
RENAME TABLE t1 TO t2
disable_query_log
enable_query_log
send check table t1 extended
reap
LOCK TABLE t1 WRITE
UNLOCK TABLES
RENAME TABLE t1 TO t2
RENAME TABLE temp_t2 TO temp_t3
HANDLER t1 OPEN
HANDLER t1 READ FIRST
HANDLER t1 CLOSE
HANDLER temp_t2 OPEN
HANDLER temp_t2 READ FIRST
HANDLER temp_t2 CLOSE
PREPARE stmt FROM "DELETE FROM t1"
PREPARE stmt FROM "DELETE FROM temp_t2"
EXECUTE stmt
DEALLOCATE PREPARE stmt
LOCK TABLE t1 WRITE
LOCK TABLE t1 READ
UNLOCK TABLES
CREATE PROCEDURE p1() BEGIN DECLARE only INT DEFAULT 1; END
CREATE PROCEDURE p1() SET SESSION TRANSACTION READ ONLY
CREATE PROCEDURE p1() SET SESSION TRANSACTION READ ONLY, ISOLATION LEVEL SERIALIZABLE
CREATE FUNCTION f1() RETURNS INT BEGIN SET SESSION TRANSACTION READ ONLY; RETURN 1; END
CREATE FUNCTION f1() RETURNS INT BEGIN SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE, READ ONLY; RETURN 1; END
CREATE UNDO TABLESPACE undo_003 ADD DATAFILE 'undo_003.ibu' ENGINE MyISAM
ALTER UNDO TABLESPACE undo_003 SET ACTIVE ENGINE MyISAM
ALTER UNDO TABLESPACE undo_003 SET INACTIVE ENGINE MyISAM
source include/func_aes_block.inc
source include/search_pattern.inc
EXPLAIN WITH cte AS ( SELECT alias1 . col_time_key AS field1 FROM  cc AS alias1  LEFT OUTER JOIN view_c AS alias2 ON  alias1 . col_varchar_key =  alias2 . col_blob_key WHERE  alias2 . col_varchar_key >= 'n' ORDER BY field1 LIMIT 1000 OFFSET 9) DELETE  FROM outr1.*, outr2.* USING c AS outr1 RIGHT OUTER JOIN c AS outr2 ON ( outr1 . col_blob_key = outr2 . col_blob ) RIGHT JOIN cte AS outrcte ON outr2 . col_blob = outrcte.field1 WHERE outr1 . col_blob_key <> ( SELECT DISTINCT innr1 . col_blob AS y FROM bb AS innr1 LEFT JOIN cte AS innrcte ON innr1.pk <> innrcte.field1 )
WITH cte AS ( SELECT alias1 . col_int AS field1 FROM  dd AS alias1  LEFT  JOIN d AS alias2 ON  alias1 . col_blob =  alias2 . col_blob_key WHERE  alias2 . col_varchar_key  IN ('m') ORDER BY field1  LIMIT 10) DELETE IGNORE FROM outr2.* USING dd AS outr1 JOIN d AS outr2 ON ( outr1 . col_blob = outr2 . col_varchar ) JOIN d AS outr3 ON ( outr1 . pk = outr3 . col_int ) LEFT OUTER JOIN cte AS outrcte ON outr2 . pk = outrcte.field1 WHERE outrcte . field1 = ( SELECT  innr1 . col_int AS y FROM dd AS innr2 RIGHT OUTER JOIN dd AS innr1 ON ( innr2 . col_date > innr1 . col_date ) INNER JOIN cte AS innrcte ON innr2.col_int_key <= innrcte.field1 WHERE innr1 . col_varchar_key <= 'u' ORDER BY innr1 . col_int_key )
EXPLAIN WITH cte AS ( SELECT alias1 . col_date AS field1 , alias1 . col_blob AS field2 , alias1 . pk AS field3 , alias1 . pk AS field4 FROM  dd AS alias1  LEFT  JOIN d AS alias2 ON  alias1 . col_varchar_key =  alias2 . col_varchar_key WHERE  alias2 . pk != 0 OR  alias2 . col_varchar_key >= 'v' ORDER BY field4 ) DELETE /*+ NO_MERGE(outrcte) */  outr2.* FROM d AS outr1 JOIN d AS outr2 ON ( outr1 . col_datetime_key = outr2 . col_date ) JOIN cte AS outrcte ON outr1 . pk = outrcte.field1 WHERE outr1 . col_int_key = ( SELECT  innr1 . col_int AS y FROM dd AS innr1 INNER JOIN cte AS innrcte ON innr1.col_int_key = innrcte.field1 WHERE innr1 . col_blob_key = 'h' ORDER BY innr1 . col_varchar )
EXPLAIN WITH cte AS ( SELECT alias1 . col_date AS field1 , alias2 . col_blob AS field2 FROM  view_d AS alias1  LEFT  JOIN view_dd AS alias2 ON  alias1 . col_blob_key =  alias2 . col_blob_key WHERE  alias1 . col_varchar_key IS  NULL AND  alias2 . col_int_key > 6 AND alias2 . col_int_key <= ( 7 + 5 ) OR alias1 . col_blob_key >= 'a' ) DELETE /*+ MERGE(outrcte) */ FROM outr1.*, outr2.* USING d AS outr1 LEFT OUTER JOIN d AS outr2 ON ( outr1 . col_date = outr2 . col_date ) JOIN cte AS outrcte ON outr2 . col_blob_key = outrcte.field1 WHERE outr1 . col_blob  IN ( SELECT DISTINCT innr1 . col_blob_key AS y FROM dd AS innr1 RIGHT OUTER JOIN cte AS innrcte ON innr1.pk >= innrcte.field1 WHERE outr1 . col_int_key > 6  )
EXPLAIN WITH cte AS ( SELECT alias2 . col_datetime_key AS field1 , alias1 . col_varchar_key AS field2 , alias2 . col_int_key AS field3 FROM  view_b AS alias1  LEFT  JOIN  cc AS alias2  LEFT  JOIN view_d AS alias3 ON  alias2 . col_varchar_key =  alias3 . col_blob_key ON  alias1 . col_blob =  alias3 . col_blob_key WHERE  alias3 . col_varchar_key  LIKE ( 'w' ) OR  alias2 . pk <> 4  ) DELETE /*+ NO_MERGE(outrcte) */  QUICK outr1.*, outr2.* FROM d AS outr1 LEFT OUTER JOIN d AS outr2 ON ( outr1 . col_int = outr2 . col_int ) INNER JOIN cte AS outrcte ON outr1 . pk = outrcte.field1 WHERE (4, 7 )  IN ( SELECT DISTINCT innr1 . col_int_key AS x , innr1 . col_int AS y FROM cc AS innr1 JOIN cte AS innrcte ON innr1.pk = innrcte.field1 WHERE innr1 . col_int >= innr1 . pk )
WITH cte AS ( SELECT alias1 . col_int_key AS field1 FROM  a AS alias1  LEFT  JOIN c AS alias2 ON  alias1 . col_blob =  alias2 . col_blob_key WHERE  alias2 . pk > 3 AND alias2 . pk < ( 3 + 10 ) OR  alias1 . col_varchar_key >= 'z' AND alias1 . col_varchar_key <= 'k'  ) DELETE /*+ NO_MERGE(outrcte) */ LOW_PRIORITY QUICK  outr1.*, outr2.* FROM d AS outr1 LEFT JOIN c AS outr2 ON ( outr1 . col_int = outr2 . pk ) JOIN a AS outr3 ON ( outr1 . col_int_key = outr3 . pk ) RIGHT JOIN cte AS outrcte ON outr1 . col_int_key = outrcte.field1 WHERE outr1 . col_blob_key <> ( SELECT  innr1 . col_blob AS y FROM a AS innr2 INNER JOIN a AS innr1 ON ( innr2 . col_datetime >= innr1 . col_datetime ) RIGHT OUTER JOIN cte AS innrcte ON innr2.col_int_key < innrcte.field1 WHERE innr1 . col_datetime = '2006-02-24'  )
EXPLAIN WITH cte AS ( SELECT alias1 . pk AS field1 , alias2 . col_blob AS field2 FROM  bb AS alias1  LEFT  JOIN dd AS alias2 ON  alias1 . col_varchar_key =  alias2 . col_varchar_key WHERE  alias2 . pk > 3 AND alias2 . pk < ( 1 + 1 ) OR alias2 . pk  IN (7, 5) AND  alias2 . pk <> 3 AND  alias2 . pk IS NOT NULL  ) DELETE /*+ NO_MERGE(outrcte) */ LOW_PRIORITY outr2.* FROM d AS outr1 INNER JOIN a AS outr2 ON ( outr1 . col_int = outr2 . col_int_key ) LEFT OUTER JOIN cte AS outrcte ON outr2 . col_int_key = outrcte.field1 WHERE outr1 . col_int_key < ( SELECT DISTINCT innr1 . col_int AS y FROM cc AS innr1 LEFT OUTER JOIN cte AS innrcte ON innr1.col_int_key <= innrcte.field1 WHERE innr1 . col_int = 4  )
WITH cte AS ( SELECT alias1 . col_datetime_key AS field1 FROM  view_c AS alias1  RIGHT  JOIN view_bb AS alias2 ON  alias1 . col_blob_key =  alias2 . col_blob_key WHERE alias2 . col_varchar_key >= 'r' AND alias2 . col_varchar_key <= 'z' AND alias2 . col_varchar_key > 'x' AND alias2 . col_varchar_key <= 'z' AND  alias2 . pk > 3 AND alias2 . pk < ( 7 + 1 ) OR  alias2 . col_int_key  IN (5) ORDER BY field1  , field1 ) DELETE     outr1.* FROM b AS outr1 JOIN e AS outr2 ON ( outr1 . col_int_key = outr2 . col_int ) JOIN c AS outr3 ON ( outr1 . col_datetime_key = outr3 . col_date_key ) LEFT JOIN cte AS outrcte ON outr1 . col_blob = outrcte.field1 WHERE ( _utf8 'g' )  IN ( SELECT  innrcte . field1 AS x FROM aa AS innr1 JOIN cte AS innrcte ON innr1.pk = innrcte.field1 WHERE outr1 . col_int_key <> 0 ORDER BY innr1 . col_blob )
with t1 as (select * from t1 where a=3) delete from t1
with t1 as (select * from t1 where a=3) delete t1.* from t1, t1 as t2
perl
$datadir= $ENV{'MYSQLD_DATADIR'}
$conn_id= $ENV{'CONN_ID'}
open(FILE, "$datadir/bug45387_general.log") or die("Unable to read log file $datadir/bug45387_general.log: $!\n")
while(<FILE>) { if (/\d{4}-\d+-\d+T\d+:\d+:\d+\.\d{6}Z[ \t]+(\d+)[ \t]+Query[ \t]+SELECT CONNECTION_ID/) { $found= $1
break
} } if ($found == $conn_id) { print "Bug#45387: ID match.\n"
} else { print "Bug#45387: Expected ID '$conn_id', found '$found' in log file.\n"
print "Contents of log file:\n"
seek(FILE, 0, 0)
while($line= <FILE>) { print $line
} } close(FILE)
CREATE ROLE skip
DROP ROLE skip, locked, nowait
PREPARE p FROM "SELECT id, sex, NTH_VALUE(id, ?) OVER () FROM t1"
EXECUTE p USING @p1
EXECUTE p USING @p1
EXECUTE p USING @p1
EXECUTE p USING @p1
DROP PREPARE p
begin work
PREPARE stmt FROM 'EXPLAIN FOR CONNECTION 1'
PREPARE stmt FROM 'SELECT * FROM t1'
CREATE PROCEDURE proc6369() EXPLAIN FOR CONNECTION 1
GROUP BY f1 NOT IN (SELECT f1+10 AS f2 FROM t1 AS t2 GROUP BY f2 NOT IN (SELECT f1+100 AS f3 FROM t1 AS t3))
ORDER BY f1 NOT IN (SELECT f1+10 AS f2 FROM t2 GROUP BY f2 NOT IN (SELECT f1+100 AS f3 FROM t2 AS t3))
WHERE t1.f1>(SELECT t3.f1 FROM t1 AS t3 LIMIT 1)
WHERE t1.f1>(SELECT t3.f1 FROM t1 AS t3 LIMIT 1)
WHERE t1.f1>(SELECT t3.f1 FROM t1 AS t3 LIMIT 1)
ROW(f1,f1) >= ROW('1', (SELECT 1 FROM t1 WHERE f1 > 1234))
LOCK TABLE v1 READ
UNLOCK TABLES
load data infile '../../std_data/bad_gis_data.dat' into table t1
SELECT ST_AsText(ST_GeometryFromText(CONCAT( 'MULTIPOLYGON(((', REPEAT ('-0.00000000001234567890123456789012 -0.123456789012345678,', 1000), '-0.00000000001234567890123456789012 -0.123456789012345678', ')))' ))) AS a
CREATE TABLE t1(col1 MULTIPOLYGON NOT NULL, CREATE TABLE t2(col1 MULTIPOLYGON NOT NULL)
CREATE TABLE lakes ( fid INTEGER NOT NULL PRIMARY KEY, name CHARACTER VARYING(64), shore POLYGON)
CREATE TABLE road_segments ( fid INTEGER NOT NULL PRIMARY KEY, name CHARACTER VARYING(64), aliases CHARACTER VARYING(64), num_lanes INTEGER, centerline LINESTRING)
CREATE TABLE divided_routes ( fid INTEGER NOT NULL PRIMARY KEY, name CHARACTER VARYING(64), num_lanes INTEGER, centerlines MULTILINESTRING)
CREATE TABLE forests ( fid INTEGER NOT NULL PRIMARY KEY, name CHARACTER VARYING(64), boundary MULTIPOLYGON)
CREATE TABLE bridges ( fid INTEGER NOT NULL PRIMARY KEY, name CHARACTER VARYING(64), position POINT)
CREATE TABLE streams ( fid INTEGER NOT NULL PRIMARY KEY, name CHARACTER VARYING(64), centerline LINESTRING)
CREATE TABLE buildings ( fid INTEGER NOT NULL PRIMARY KEY, address CHARACTER VARYING(64), position POINT, footprint POLYGON)
CREATE TABLE ponds ( fid INTEGER NOT NULL PRIMARY KEY, name CHARACTER VARYING(64), type CHARACTER VARYING(64), shores MULTIPOLYGON)
CREATE TABLE named_places ( fid INTEGER NOT NULL PRIMARY KEY, name CHARACTER VARYING(64), boundary POLYGON)
delimiter
INSERT INTO t1 VALUES ( UNHEX('00000000010F0000000100000001030000000100000004000000000000000000000000' '00000000000000000000000000F03F0000000000000000000000000000F03F00000000' '0000F03F00000000000000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001100000000100000001030000000100000004000000000000000000000000' '00000000000000000000000000F03F0000000000000000000000000000F03F00000000' '0000F03F00000000000000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001110000000100000004000000000000000000000000000000000000000000' '00000000F03F0000000000000000000000000000F03F000000000000F03F0000000000' '0000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001EA0300000200000000000000000000000000000000000000000000000000' '0000000000000000F03F000000000000F03F0000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001EB0300000100000004000000000000000000000000000000000000000000' '000000000000000000000000F03F000000000000000000000000000000000000000000' '00F03F000000000000F03F000000000000000000000000000000000000000000000000' '0000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001EC0300000100000001E90300000000000000000000000000000000000000' '00000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001ED030000010000000000000001EA03000002000000000000000000000000' '000000000000000000000000000000000000000000F03F000000000000F03F00000000' '00000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001EE0300000100000001EB0300000100000004000000000000000000000000' '000000000000000000000000000000000000000000F03F000000000000000000000000' '00000000000000000000F03F000000000000F03F000000000000000000000000000000' '0000000000000000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001EF0300000100000001E90300000000000000000000000000000000000000' '00000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001F70300000100000001EB0300000100000004000000000000000000000000' '000000000000000000000000000000000000000000F03F000000000000000000000000' '00000000000000000000F03F000000000000F03F000000000000000000000000000000' '0000000000000000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001F80300000100000001EB0300000100000004000000000000000000000000' '000000000000000000000000000000000000000000F03F000000000000000000000000' '00000000000000000000F03F000000000000F03F000000000000000000000000000000' '0000000000000000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001F90300000100000001EB0300000100000004000000000000000000000000' '000000000000000000000000000000000000000000F03F000000000000000000000000' '00000000000000000000F03F000000000000F03F000000000000000000000000000000' '0000000000000000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001D20700000200000000000000000000000000000000000000000000000000' '0000000000000000F03F000000000000F03F0000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001D30700000100000004000000000000000000000000000000000000000000' '000000000000000000000000F03F000000000000000000000000000000000000000000' '00F03F000000000000F03F000000000000000000000000000000000000000000000000' '0000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001D40700000100000001E90300000000000000000000000000000000000000' '00000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001D5070000010000000000000001EA03000002000000000000000000000000' '000000000000000000000000000000000000000000F03F000000000000F03F00000000' '00000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001D60700000100000001EB0300000100000004000000000000000000000000' '000000000000000000000000000000000000000000F03F000000000000000000000000' '00000000000000000000F03F000000000000F03F000000000000000000000000000000' '0000000000000000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001D70700000100000001E90300000000000000000000000000000000000000' '00000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001DF0700000100000001EB0300000100000004000000000000000000000000' '000000000000000000000000000000000000000000F03F000000000000000000000000' '00000000000000000000F03F000000000000F03F000000000000000000000000000000' '0000000000000000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001E00700000100000001EB0300000100000004000000000000000000000000' '000000000000000000000000000000000000000000F03F000000000000000000000000' '00000000000000000000F03F000000000000F03F000000000000000000000000000000' '0000000000000000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001E10700000100000001EB0300000100000004000000000000000000000000' '000000000000000000000000000000000000000000F03F000000000000000000000000' '00000000000000000000F03F000000000000F03F000000000000000000000000000000' '0000000000000000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001B90B00000000000000000000000000000000000000000000000000000000' '0000000000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001BA0B00000200000000000000000000000000000000000000000000000000' '00000000000000000000000000000000F03F000000000000F03F000000000000000000' '00000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001BB0B00000100000004000000000000000000000000000000000000000000' '0000000000000000000000000000000000000000F03F00000000000000000000000000' '0000000000000000000000000000000000F03F000000000000F03F0000000000000000' '0000000000000000000000000000000000000000000000000000000000000000000000' '0000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001BC0B00000100000001B90B00000000000000000000000000000000000000' '0000000000000000000000000000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001BD0B00000100000001BA0B00000200000000000000000000000000000000' '00000000000000000000000000000000000000000000000000F03F000000000000F03F' '00000000000000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001BE0B00000100000001BB0B00000100000004000000000000000000000000' '0000000000000000000000000000000000000000000000000000000000F03F00000000' '0000000000000000000000000000000000000000000000000000F03F000000000000F0' '3F00000000000000000000000000000000000000000000000000000000000000000000' '0000000000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001BF0B00000100000001B90B00000000000000000000000000000000000000' '0000000000000000000000000000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001C70B00000100000001BB0B00000100000004000000000000000000000000' '0000000000000000000000000000000000000000000000000000000000F03F00000000' '0000000000000000000000000000000000000000000000000000F03F000000000000F0' '3F00000000000000000000000000000000000000000000000000000000000000000000' '0000000000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001C80B00000100000001BB0B00000100000004000000000000000000000000' '0000000000000000000000000000000000000000000000000000000000F03F00000000' '0000000000000000000000000000000000000000000000000000F03F000000000000F0' '3F00000000000000000000000000000000000000000000000000000000000000000000' '0000000000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001C90B00000100000001EB0300000100000004000000000000000000000000' '000000000000000000000000000000000000000000F03F000000000000000000000000' '00000000000000000000F03F000000000000F03F000000000000000000000000000000' '0000000000000000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001030000000100000002000000000000000000000000000000000000000000' '00000000F03F0000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001030000000100000003000000000000000000000000000000000000000000' '00000000F03F000000000000000000000000000000000000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001040000000100000001020000000200000000000000000000000000000000' '000000000000000000F03F000000000000F03F'))
INSERT INTO t1 VALUES ( UNHEX('0000000001070000000100000001040000000100000001020000000200000000000000' '000000000000000000000000000000000000F03F000000000000F03F'))
INSERT INTO t1 VALUES ( UNHEX('0000000001070000000100000001050000000100000001010000000000000000000000' '0000000000000000'))
INSERT INTO t1 VALUES ( UNHEX('0000000001070000000100000001060000000100000001010000000000000000000000' '0000000000000000'))
SELECT ST_GeomFromText('POINT(0 0)') IN (SELECT b FROM t) AS result
SELECT ST_AsWKB(ST_GeomFromText('POINT(0 0)')) IN (SELECT b FROM t) AS result
SELECT ST_GeomFromText('POINT(0 0)') IN (SELECT b FROM t) AS result
SELECT ST_AsWKB(ST_GeomFromText('POINT(0 0)')) IN (SELECT b FROM t) AS result
SELECT ST_GeomFromText('POINT(0 0)') IN (SELECT b FROM t1) AS result
SELECT ST_AsWKB(ST_GeomFromText('POINT(0 0)')) IN (SELECT b FROM t1) AS result
SELECT ST_GeomFromText('POINT(0 0)') IN (SELECT b FROM t1) AS result
SELECT ST_AsWKB(ST_GeomFromText('POINT(0 0)')) IN (SELECT b FROM t1) AS result
SELECT point(1,1) IN ('1',1,'1') AS res
SELECT st_centroid(point(1,1)) IN ('1',1,'1') AS res
DO st_centroid(point(1,1)) IN ('1',1,'1')
DO (SELECT ST_ASBINARY(r.p) FROM d INNER JOIN dp ON d.id = dp.d_id INNER JOIN r ON d.r_id = r.id ORDER BY d.i)
DO ST_GEOMCOLLFROMTEXT(@wkt_pt)
DO ST_GEOMCOLLFROMTEXT(@wkt_ls)
DO ST_GEOMCOLLFROMTEXT(@wkt_py)
DO ST_GEOMCOLLFROMTEXT(@wkt_mpt)
DO ST_GEOMCOLLFROMTEXT(@wkt_mls)
DO ST_GEOMCOLLFROMTEXT(@wkt_mpy)
DO ST_GEOMCOLLFROMTEXT(@wkt_gc)
DO ST_GEOMCOLLFROMTXT(@wkt_pt)
DO ST_GEOMCOLLFROMTXT(@wkt_ls)
DO ST_GEOMCOLLFROMTXT(@wkt_py)
DO ST_GEOMCOLLFROMTXT(@wkt_mpt)
DO ST_GEOMCOLLFROMTXT(@wkt_mls)
DO ST_GEOMCOLLFROMTXT(@wkt_mpy)
DO ST_GEOMCOLLFROMTXT(@wkt_gc)
DO ST_GEOMETRYCOLLECTIONFROMTEXT(@wkt_pt)
DO ST_GEOMETRYCOLLECTIONFROMTEXT(@wkt_ls)
DO ST_GEOMETRYCOLLECTIONFROMTEXT(@wkt_py)
DO ST_GEOMETRYCOLLECTIONFROMTEXT(@wkt_mpt)
DO ST_GEOMETRYCOLLECTIONFROMTEXT(@wkt_mls)
DO ST_GEOMETRYCOLLECTIONFROMTEXT(@wkt_mpy)
DO ST_GEOMETRYCOLLECTIONFROMTEXT(@wkt_gc)
DO ST_GEOMETRYFROMTEXT(@wkt_pt)
DO ST_GEOMETRYFROMTEXT(@wkt_ls)
DO ST_GEOMETRYFROMTEXT(@wkt_py)
DO ST_GEOMETRYFROMTEXT(@wkt_mpt)
DO ST_GEOMETRYFROMTEXT(@wkt_mls)
DO ST_GEOMETRYFROMTEXT(@wkt_mpy)
DO ST_GEOMETRYFROMTEXT(@wkt_gc)
DO ST_GEOMFROMTEXT(@wkt_pt)
DO ST_GEOMFROMTEXT(@wkt_ls)
DO ST_GEOMFROMTEXT(@wkt_py)
DO ST_GEOMFROMTEXT(@wkt_mpt)
DO ST_GEOMFROMTEXT(@wkt_mls)
DO ST_GEOMFROMTEXT(@wkt_mpy)
DO ST_GEOMFROMTEXT(@wkt_gc)
DO ST_LINEFROMTEXT(@wkt_pt)
DO ST_LINEFROMTEXT(@wkt_ls)
DO ST_LINEFROMTEXT(@wkt_py)
DO ST_LINEFROMTEXT(@wkt_mpt)
DO ST_LINEFROMTEXT(@wkt_mls)
DO ST_LINEFROMTEXT(@wkt_mpy)
DO ST_LINEFROMTEXT(@wkt_gc)
DO ST_LINESTRINGFROMTEXT(@wkt_pt)
DO ST_LINESTRINGFROMTEXT(@wkt_ls)
DO ST_LINESTRINGFROMTEXT(@wkt_py)
DO ST_LINESTRINGFROMTEXT(@wkt_mpt)
DO ST_LINESTRINGFROMTEXT(@wkt_mls)
DO ST_LINESTRINGFROMTEXT(@wkt_mpy)
DO ST_LINESTRINGFROMTEXT(@wkt_gc)
DO ST_MLINEFROMTEXT(@wkt_pt)
DO ST_MLINEFROMTEXT(@wkt_ls)
DO ST_MLINEFROMTEXT(@wkt_py)
DO ST_MLINEFROMTEXT(@wkt_mpt)
DO ST_MLINEFROMTEXT(@wkt_mls)
DO ST_MLINEFROMTEXT(@wkt_mpy)
DO ST_MLINEFROMTEXT(@wkt_gc)
DO ST_MPOINTFROMTEXT(@wkt_pt)
DO ST_MPOINTFROMTEXT(@wkt_ls)
DO ST_MPOINTFROMTEXT(@wkt_py)
DO ST_MPOINTFROMTEXT(@wkt_mpt)
DO ST_MPOINTFROMTEXT(@wkt_mls)
DO ST_MPOINTFROMTEXT(@wkt_mpy)
DO ST_MPOINTFROMTEXT(@wkt_gc)
DO ST_MPOLYFROMTEXT(@wkt_pt)
DO ST_MPOLYFROMTEXT(@wkt_ls)
DO ST_MPOLYFROMTEXT(@wkt_py)
DO ST_MPOLYFROMTEXT(@wkt_mpt)
DO ST_MPOLYFROMTEXT(@wkt_mls)
DO ST_MPOLYFROMTEXT(@wkt_mpy)
DO ST_MPOLYFROMTEXT(@wkt_gc)
DO ST_MULTILINESTRINGFROMTEXT(@wkt_pt)
DO ST_MULTILINESTRINGFROMTEXT(@wkt_ls)
DO ST_MULTILINESTRINGFROMTEXT(@wkt_py)
DO ST_MULTILINESTRINGFROMTEXT(@wkt_mpt)
DO ST_MULTILINESTRINGFROMTEXT(@wkt_mls)
DO ST_MULTILINESTRINGFROMTEXT(@wkt_mpy)
DO ST_MULTILINESTRINGFROMTEXT(@wkt_gc)
DO ST_MULTIPOINTFROMTEXT(@wkt_pt)
DO ST_MULTIPOINTFROMTEXT(@wkt_ls)
DO ST_MULTIPOINTFROMTEXT(@wkt_py)
DO ST_MULTIPOINTFROMTEXT(@wkt_mpt)
DO ST_MULTIPOINTFROMTEXT(@wkt_mls)
DO ST_MULTIPOINTFROMTEXT(@wkt_mpy)
DO ST_MULTIPOINTFROMTEXT(@wkt_gc)
DO ST_MULTIPOLYGONFROMTEXT(@wkt_pt)
DO ST_MULTIPOLYGONFROMTEXT(@wkt_ls)
DO ST_MULTIPOLYGONFROMTEXT(@wkt_py)
DO ST_MULTIPOLYGONFROMTEXT(@wkt_mpt)
DO ST_MULTIPOLYGONFROMTEXT(@wkt_mls)
DO ST_MULTIPOLYGONFROMTEXT(@wkt_mpy)
DO ST_MULTIPOLYGONFROMTEXT(@wkt_gc)
DO ST_POINTFROMTEXT(@wkt_pt)
DO ST_POINTFROMTEXT(@wkt_ls)
DO ST_POINTFROMTEXT(@wkt_py)
DO ST_POINTFROMTEXT(@wkt_mpt)
DO ST_POINTFROMTEXT(@wkt_mls)
DO ST_POINTFROMTEXT(@wkt_mpy)
DO ST_POINTFROMTEXT(@wkt_gc)
DO ST_POLYFROMTEXT(@wkt_pt)
DO ST_POLYFROMTEXT(@wkt_ls)
DO ST_POLYFROMTEXT(@wkt_py)
DO ST_POLYFROMTEXT(@wkt_mpt)
DO ST_POLYFROMTEXT(@wkt_mls)
DO ST_POLYFROMTEXT(@wkt_mpy)
DO ST_POLYFROMTEXT(@wkt_gc)
DO ST_POLYGONFROMTEXT(@wkt_pt)
DO ST_POLYGONFROMTEXT(@wkt_ls)
DO ST_POLYGONFROMTEXT(@wkt_py)
DO ST_POLYGONFROMTEXT(@wkt_mpt)
DO ST_POLYGONFROMTEXT(@wkt_mls)
DO ST_POLYGONFROMTEXT(@wkt_mpy)
DO ST_POLYGONFROMTEXT(@wkt_gc)
DO ST_GEOMCOLLFROMWKB(@wkb_pt)
DO ST_GEOMCOLLFROMWKB(@wkb_ls)
DO ST_GEOMCOLLFROMWKB(@wkb_py)
DO ST_GEOMCOLLFROMWKB(@wkb_mpt)
DO ST_GEOMCOLLFROMWKB(@wkb_mls)
DO ST_GEOMCOLLFROMWKB(@wkb_mpy)
DO ST_GEOMCOLLFROMWKB(@wkb_gc)
DO ST_GEOMETRYCOLLECTIONFROMWKB(@wkb_pt)
DO ST_GEOMETRYCOLLECTIONFROMWKB(@wkb_ls)
DO ST_GEOMETRYCOLLECTIONFROMWKB(@wkb_py)
DO ST_GEOMETRYCOLLECTIONFROMWKB(@wkb_mpt)
DO ST_GEOMETRYCOLLECTIONFROMWKB(@wkb_mls)
DO ST_GEOMETRYCOLLECTIONFROMWKB(@wkb_mpy)
DO ST_GEOMETRYCOLLECTIONFROMWKB(@wkb_gc)
DO ST_GEOMETRYFROMWKB(@wkb_pt)
DO ST_GEOMETRYFROMWKB(@wkb_ls)
DO ST_GEOMETRYFROMWKB(@wkb_py)
DO ST_GEOMETRYFROMWKB(@wkb_mpt)
DO ST_GEOMETRYFROMWKB(@wkb_mls)
DO ST_GEOMETRYFROMWKB(@wkb_mpy)
DO ST_GEOMETRYFROMWKB(@wkb_gc)
DO ST_GEOMFROMWKB(@wkb_pt)
DO ST_GEOMFROMWKB(@wkb_ls)
DO ST_GEOMFROMWKB(@wkb_py)
DO ST_GEOMFROMWKB(@wkb_mpt)
DO ST_GEOMFROMWKB(@wkb_mls)
DO ST_GEOMFROMWKB(@wkb_mpy)
DO ST_GEOMFROMWKB(@wkb_gc)
DO ST_LINEFROMWKB(@wkb_pt)
DO ST_LINEFROMWKB(@wkb_ls)
DO ST_LINEFROMWKB(@wkb_py)
DO ST_LINEFROMWKB(@wkb_mpt)
DO ST_LINEFROMWKB(@wkb_mls)
DO ST_LINEFROMWKB(@wkb_mpy)
DO ST_LINEFROMWKB(@wkb_gc)
DO ST_LINESTRINGFROMWKB(@wkb_pt)
DO ST_LINESTRINGFROMWKB(@wkb_ls)
DO ST_LINESTRINGFROMWKB(@wkb_py)
DO ST_LINESTRINGFROMWKB(@wkb_mpt)
DO ST_LINESTRINGFROMWKB(@wkb_mls)
DO ST_LINESTRINGFROMWKB(@wkb_mpy)
DO ST_LINESTRINGFROMWKB(@wkb_gc)
DO ST_MLINEFROMWKB(@wkb_pt)
DO ST_MLINEFROMWKB(@wkb_ls)
DO ST_MLINEFROMWKB(@wkb_py)
DO ST_MLINEFROMWKB(@wkb_mpt)
DO ST_MLINEFROMWKB(@wkb_mls)
DO ST_MLINEFROMWKB(@wkb_mpy)
DO ST_MLINEFROMWKB(@wkb_gc)
DO ST_MPOINTFROMWKB(@wkb_pt)
DO ST_MPOINTFROMWKB(@wkb_ls)
DO ST_MPOINTFROMWKB(@wkb_py)
DO ST_MPOINTFROMWKB(@wkb_mpt)
DO ST_MPOINTFROMWKB(@wkb_mls)
DO ST_MPOINTFROMWKB(@wkb_mpy)
DO ST_MPOINTFROMWKB(@wkb_gc)
DO ST_MPOLYFROMWKB(@wkb_pt)
DO ST_MPOLYFROMWKB(@wkb_ls)
DO ST_MPOLYFROMWKB(@wkb_py)
DO ST_MPOLYFROMWKB(@wkb_mpt)
DO ST_MPOLYFROMWKB(@wkb_mls)
DO ST_MPOLYFROMWKB(@wkb_mpy)
DO ST_MPOLYFROMWKB(@wkb_gc)
DO ST_MULTILINESTRINGFROMWKB(@wkb_pt)
DO ST_MULTILINESTRINGFROMWKB(@wkb_ls)
DO ST_MULTILINESTRINGFROMWKB(@wkb_py)
DO ST_MULTILINESTRINGFROMWKB(@wkb_mpt)
DO ST_MULTILINESTRINGFROMWKB(@wkb_mls)
DO ST_MULTILINESTRINGFROMWKB(@wkb_mpy)
DO ST_MULTILINESTRINGFROMWKB(@wkb_gc)
DO ST_MULTIPOINTFROMWKB(@wkb_pt)
DO ST_MULTIPOINTFROMWKB(@wkb_ls)
DO ST_MULTIPOINTFROMWKB(@wkb_py)
DO ST_MULTIPOINTFROMWKB(@wkb_mpt)
DO ST_MULTIPOINTFROMWKB(@wkb_mls)
DO ST_MULTIPOINTFROMWKB(@wkb_mpy)
DO ST_MULTIPOINTFROMWKB(@wkb_gc)
DO ST_MULTIPOLYGONFROMWKB(@wkb_pt)
DO ST_MULTIPOLYGONFROMWKB(@wkb_ls)
DO ST_MULTIPOLYGONFROMWKB(@wkb_py)
DO ST_MULTIPOLYGONFROMWKB(@wkb_mpt)
DO ST_MULTIPOLYGONFROMWKB(@wkb_mls)
DO ST_MULTIPOLYGONFROMWKB(@wkb_mpy)
DO ST_MULTIPOLYGONFROMWKB(@wkb_gc)
DO ST_POINTFROMWKB(@wkb_pt)
DO ST_POINTFROMWKB(@wkb_ls)
DO ST_POINTFROMWKB(@wkb_py)
DO ST_POINTFROMWKB(@wkb_mpt)
DO ST_POINTFROMWKB(@wkb_mls)
DO ST_POINTFROMWKB(@wkb_mpy)
DO ST_POINTFROMWKB(@wkb_gc)
DO ST_POLYFROMWKB(@wkb_pt)
DO ST_POLYFROMWKB(@wkb_ls)
DO ST_POLYFROMWKB(@wkb_py)
DO ST_POLYFROMWKB(@wkb_mpt)
DO ST_POLYFROMWKB(@wkb_mls)
DO ST_POLYFROMWKB(@wkb_mpy)
DO ST_POLYFROMWKB(@wkb_gc)
DO ST_POLYGONFROMWKB(@wkb_pt)
DO ST_POLYGONFROMWKB(@wkb_ls)
DO ST_POLYGONFROMWKB(@wkb_py)
DO ST_POLYGONFROMWKB(@wkb_mpt)
DO ST_POLYGONFROMWKB(@wkb_mls)
DO ST_POLYGONFROMWKB(@wkb_mpy)
DO ST_POLYGONFROMWKB(@wkb_gc)
DO ST_GEOMCOLLFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_pt)))
DO ST_GEOMCOLLFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_ls)))
DO ST_GEOMCOLLFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_py)))
DO ST_GEOMCOLLFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpt)))
DO ST_GEOMCOLLFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mls)))
DO ST_GEOMCOLLFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpy)))
DO ST_GEOMCOLLFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_gc)))
DO ST_GEOMETRYCOLLECTIONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_pt)))
DO ST_GEOMETRYCOLLECTIONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_ls)))
DO ST_GEOMETRYCOLLECTIONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_py)))
DO ST_GEOMETRYCOLLECTIONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpt)))
DO ST_GEOMETRYCOLLECTIONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mls)))
DO ST_GEOMETRYCOLLECTIONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpy)))
DO ST_GEOMETRYCOLLECTIONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_gc)))
DO ST_GEOMETRYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_pt)))
DO ST_GEOMETRYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_ls)))
DO ST_GEOMETRYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_py)))
DO ST_GEOMETRYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpt)))
DO ST_GEOMETRYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mls)))
DO ST_GEOMETRYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpy)))
DO ST_GEOMETRYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_gc)))
DO ST_GEOMFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_pt)))
DO ST_GEOMFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_ls)))
DO ST_GEOMFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_py)))
DO ST_GEOMFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpt)))
DO ST_GEOMFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mls)))
DO ST_GEOMFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpy)))
DO ST_GEOMFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_gc)))
DO ST_LINEFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_pt)))
DO ST_LINEFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_ls)))
DO ST_LINEFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_py)))
DO ST_LINEFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpt)))
DO ST_LINEFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mls)))
DO ST_LINEFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpy)))
DO ST_LINEFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_gc)))
DO ST_LINESTRINGFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_pt)))
DO ST_LINESTRINGFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_ls)))
DO ST_LINESTRINGFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_py)))
DO ST_LINESTRINGFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpt)))
DO ST_LINESTRINGFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mls)))
DO ST_LINESTRINGFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpy)))
DO ST_LINESTRINGFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_gc)))
DO ST_MLINEFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_pt)))
DO ST_MLINEFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_ls)))
DO ST_MLINEFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_py)))
DO ST_MLINEFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpt)))
DO ST_MLINEFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mls)))
DO ST_MLINEFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpy)))
DO ST_MLINEFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_gc)))
DO ST_MPOINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_pt)))
DO ST_MPOINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_ls)))
DO ST_MPOINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_py)))
DO ST_MPOINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpt)))
DO ST_MPOINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mls)))
DO ST_MPOINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpy)))
DO ST_MPOINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_gc)))
DO ST_MPOLYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_pt)))
DO ST_MPOLYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_ls)))
DO ST_MPOLYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_py)))
DO ST_MPOLYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpt)))
DO ST_MPOLYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mls)))
DO ST_MPOLYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpy)))
DO ST_MPOLYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_gc)))
DO ST_MULTILINESTRINGFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_pt)))
DO ST_MULTILINESTRINGFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_ls)))
DO ST_MULTILINESTRINGFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_py)))
DO ST_MULTILINESTRINGFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpt)))
DO ST_MULTILINESTRINGFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mls)))
DO ST_MULTILINESTRINGFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpy)))
DO ST_MULTILINESTRINGFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_gc)))
DO ST_MULTIPOINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_pt)))
DO ST_MULTIPOINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_ls)))
DO ST_MULTIPOINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_py)))
DO ST_MULTIPOINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpt)))
DO ST_MULTIPOINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mls)))
DO ST_MULTIPOINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpy)))
DO ST_MULTIPOINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_gc)))
DO ST_MULTIPOLYGONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_pt)))
DO ST_MULTIPOLYGONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_ls)))
DO ST_MULTIPOLYGONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_py)))
DO ST_MULTIPOLYGONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpt)))
DO ST_MULTIPOLYGONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mls)))
DO ST_MULTIPOLYGONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpy)))
DO ST_MULTIPOLYGONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_gc)))
DO ST_POINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_pt)))
DO ST_POINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_ls)))
DO ST_POINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_py)))
DO ST_POINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpt)))
DO ST_POINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mls)))
DO ST_POINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpy)))
DO ST_POINTFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_gc)))
DO ST_POLYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_pt)))
DO ST_POLYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_ls)))
DO ST_POLYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_py)))
DO ST_POLYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpt)))
DO ST_POLYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mls)))
DO ST_POLYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpy)))
DO ST_POLYFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_gc)))
DO ST_POLYGONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_pt)))
DO ST_POLYGONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_ls)))
DO ST_POLYGONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_py)))
DO ST_POLYGONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpt)))
DO ST_POLYGONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mls)))
DO ST_POLYGONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_mpy)))
DO ST_POLYGONFROMWKB(St_AsWKB(ST_GEOMFROMTEXT(@wkt_gc)))
DO ST_EXTERIORRING(x'000000000107000000010000000101000000000000000000')
DO ST_EXTERIORRING(x'000000000107000000010000000102000000000000000000')
DO ST_EXTERIORRING(x'000000000107000000010000000103000000000000000000')
DO ST_EXTERIORRING(x'00000000010700000001000000010400000001000000')
DO ST_EXTERIORRING(x'00000000010700000001000000010500000001000000')
DO ST_EXTERIORRING(x'00000000010700000001000000010600000001000000')
DO (SELECT DISTINCT SQL_BIG_RESULT ST_SIMPLIFY(POINT(a,1),1) FROM t)
LOAD DATA INFILE 'bug26412713.csv' INTO TABLE t1 (x)
CREATE TABLE t1 (g GEOMCOLLECTION)
DO ST_GEOMFROMTEXT('GEOMCOLLECTION(POINT(0 0))')
DO ST_GEOMFROMTEXT('GEOMETRYCOLLECTION(POINT(0 0))')
DO ST_ASWKB(JSON_UNQUOTE(JSON_SET('{"a":""}', '$', '')))
write_file $SHUTDOWN_SQL
CALL mtr.add_suppression("Dictionary file not specified")
CALL mtr.add_suppression("Dictionary file open failed")
CALL mtr.add_suppression("Since the validate_password_policy is mentioned ")
CALL mtr.add_suppression("Dictionary file size exceeded")
CALL mtr.add_suppression("Effective value of validate_password.length is changed.")
PREPARE stmt1 FROM 'UPDATE mysql.user SET authentication_string=(?) where USER = ?'
SET @a = REPEAT('a',2147483647)
EXECUTE stmt1 USING @a,@b
DEALLOCATE PREPARE stmt1
PREPARE stmt1 FROM 'UPDATE mysql.user SET authentication_string=(?) where USER = ?'
SET @a = REPEAT('a',1048576)
EXECUTE stmt1 USING @a,@b
DEALLOCATE PREPARE stmt1
password validate password validate monkey CREATE USER 'user1'@'localhost' IDENTIFIED BY 'passWORD123#'
remove_file $MYSQLTEST_VARDIR/tmp/dictionary.txt
remove_file $MYSQLTEST_VARDIR/tmp/dictionary2.txt
call mtr.add_suppression("Dictionary file not specified")
SELECT VALIDATE_PASSWORD_STRENGTH(REPEAT("aA1#", 26))
SELECT @@GLOBAL.VALIDATE_PASSWORD.LENGTH
SELECT @@GLOBAL.VALIDATE_PASSWORD.NUMBER_COUNT
SELECT @@GLOBAL.VALIDATE_PASSWORD.MIXED_CASE_COUNT
SELECT @@GLOBAL.VALIDATE_PASSWORD.SPECIAL_CHAR_COUNT
SELECT @@GLOBAL.VALIDATE_PASSWORD.LENGTH
SELECT @@GLOBAL.VALIDATE_PASSWORD.LENGTH
SELECT @@GLOBAL.VALIDATE_PASSWORD.LENGTH
SELECT @@GLOBAL.VALIDATE_PASSWORD.LENGTH
SELECT @@GLOBAL.VALIDATE_PASSWORD.LENGTH
SELECT @@GLOBAL.VALIDATE_PASSWORD.LENGTH
SELECT @@GLOBAL.VALIDATE_PASSWORD.LENGTH
SELECT @@GLOBAL.VALIDATE_PASSWORD.LENGTH
SELECT @@GLOBAL.VALIDATE_PASSWORD.LENGTH
SELECT @@GLOBAL.VALIDATE_PASSWORD.NUMBER_COUNT
SELECT @@GLOBAL.VALIDATE_PASSWORD.MIXED_CASE_COUNT
SELECT @@GLOBAL.VALIDATE_PASSWORD.SPECIAL_CHAR_COUNT
password validate SELECT VALIDATE_PASSWORD_STRENGTH( 0x6E616E646F73617135234552 )
remove_file $MYSQLTEST_VARDIR/tmp/dictionary.txt
DO validate_password_strength(export_set('a','a','a','a','a'))
CREATE PROCEDURE p1() BEGIN DECLARE get INT DEFAULT 1; DELIMITER ;
CREATE PROCEDURE p1() BEGIN DECLARE `get` INT DEFAULT 1; SELECT `get`; END
CREATE PROCEDURE p1() BEGIN DECLARE current INT DEFAULT 1; DECLARE diagnostics INT DEFAULT 2; DECLARE number INT DEFAULT 3; DECLARE returned_sqlstate INT DEFAULT 4; SELECT current, diagnostics, number, returned_sqlstate; END
GET DIAGNOSTICS var
CREATE PROCEDURE p1() BEGIN GET DIAGNOSTICS var; END
CREATE PROCEDURE p1() BEGIN DECLARE var INT; GET DIAGNOSTICS var; DELIMITER ;
CREATE PROCEDURE p1() BEGIN DECLARE var INT; GET DIAGNOSTICS var = INVALID; DELIMITER ;
CREATE PROCEDURE p1() BEGIN DECLARE var CONDITION FOR SQLSTATE '12345'; GET DIAGNOSTICS var = NUMBER; END
CREATE PROCEDURE p1() BEGIN DECLARE var INT; GET DIAGNOSTICS var = NUMBER, var1 = ROW_COUNT; END
GET DIAGNOSTICS @var = NUMBER
GET DIAGNOSTICS @var = ROW_COUNT
GET DIAGNOSTICS @var1 = NUMBER, @var2 = ROW_COUNT
GET DIAGNOSTICS @var1 = ROW_COUNT, @var2 = NUMBER
CREATE PROCEDURE p1() BEGIN DECLARE var  INT; DECLARE var1 INT; DECLARE var2 INT; GET DIAGNOSTICS var = NUMBER; GET DIAGNOSTICS var = ROW_COUNT; GET DIAGNOSTICS var1 = NUMBER, var2 = ROW_COUNT; GET DIAGNOSTICS var1 = ROW_COUNT, var2 = NUMBER; END
GET DIAGNOSTICS CONDITION 1 var
CREATE PROCEDURE p1() BEGIN GET DIAGNOSTICS CONDITION 1 var; END
CREATE PROCEDURE p1() BEGIN DECLARE var INT; GET DIAGNOSTICS CONDITION 1 var; DELIMITER ;
CREATE PROCEDURE p1() BEGIN DECLARE var INT; GET DIAGNOSTICS CONDITION 1 var = INVALID; DELIMITER ;
CREATE PROCEDURE p1() BEGIN DECLARE var CONDITION FOR SQLSTATE '12345'; GET DIAGNOSTICS CONDITION 1 var = NUMBER; END
CREATE PROCEDURE p1() BEGIN DECLARE var INT; GET DIAGNOSTICS CONDITION 1 var = CLASS_ORIGIN, var1 = SUBCLASS_ORIGIN; END
GET DIAGNOSTICS CONDITION 1 @var = CLASS_ORIGIN
GET DIAGNOSTICS CONDITION 1 @var = SUBCLASS_ORIGIN
GET DIAGNOSTICS CONDITION 1 @var1 = CLASS_ORIGIN, @var2 = SUBCLASS_ORIGIN
GET DIAGNOSTICS CONDITION 1 @var1 = SUBCLASS_ORIGIN, @var2 = CLASS_ORIGIN
CREATE PROCEDURE p1() BEGIN DECLARE var  INT; DECLARE var1 INT; DECLARE var2 INT; GET DIAGNOSTICS CONDITION 1 var = CLASS_ORIGIN; GET DIAGNOSTICS CONDITION 1 var = SUBCLASS_ORIGIN; GET DIAGNOSTICS CONDITION 1 var1 = CLASS_ORIGIN, var2 = SUBCLASS_ORIGIN; GET DIAGNOSTICS CONDITION 1 var1 = SUBCLASS_ORIGIN, var2 = CLASS_ORIGIN; END
GET DIAGNOSTICS CONDITION 1.1 @var = CLASS_ORIGIN
GET DIAGNOSTICS CONDITION "1" @var = CLASS_ORIGIN
GET DIAGNOSTICS CONDITION 9999 @var = CLASS_ORIGIN
GET DIAGNOSTICS CONDITION NULL @var = CLASS_ORIGIN
GET DIAGNOSTICS CONDITION a @var = CLASS_ORIGIN
GET DIAGNOSTICS CONDITION @cond @var1 = CLASS_ORIGIN
GET DIAGNOSTICS CONDITION @cond @var1 = CLASS_ORIGIN
CREATE PROCEDURE p1() BEGIN DECLARE cond INT DEFAULT 1; DECLARE var INT; GET DIAGNOSTICS CONDITION cond var = CLASS_ORIGIN; END
CREATE PROCEDURE p1() BEGIN DECLARE cond TEXT; DECLARE var INT; GET DIAGNOSTICS CONDITION cond var = CLASS_ORIGIN; END
PREPARE stmt FROM "GET DIAGNOSTICS CONDITION 1 @var = CLASS_ORIGIN"
PREPARE stmt FROM "GET DIAGNOSTICS @var = NUMBER"
GET DIAGNOSTICS @var = NUMBER
GET DIAGNOSTICS CONDITION 99999 @var = CLASS_ORIGIN
GET DIAGNOSTICS @var = NUMBER
GET DIAGNOSTICS @var = NUMBER
GET DIAGNOSTICS @var = ROW_COUNT
GET DIAGNOSTICS @var = ROW_COUNT
CREATE PROCEDURE p1() BEGIN DECLARE number INT; DECLARE row_count INT; SELECT CAST(-19999999999999999999 AS SIGNED), CAST(-19999999999999999999 AS SIGNED); GET DIAGNOSTICS number = NUMBER; CREATE TABLE t1 (a INT); INSERT INTO t1 VALUES (1),(2),(3); GET DIAGNOSTICS row_count = ROW_COUNT; DROP TABLE t1; SELECT number, row_count; END
GET DIAGNOSTICS CONDITION 1 @class_origin = CLASS_ORIGIN, @subclass_origin = SUBCLASS_ORIGIN, @constraint_catalog = CONSTRAINT_CATALOG, @constraint_schema = CONSTRAINT_SCHEMA, @constraint_name = CONSTRAINT_NAME, @catalog_name = CATALOG_NAME, @schema_name = SCHEMA_NAME, @table_name = TABLE_NAME, @column_name = COLUMN_NAME, @cursor_name = CURSOR_NAME, @message_text = MESSAGE_TEXT, @mysql_errno = MYSQL_ERRNO, @returned_sqlstate = RETURNED_SQLSTATE
CREATE PROCEDURE p1() BEGIN DECLARE class_origin TEXT DEFAULT "a"; DECLARE subclass_origin TEXT DEFAULT "a"; DECLARE constraint_catalog TEXT DEFAULT "a"; DECLARE constraint_schema TEXT DEFAULT "a"; DECLARE constraint_name TEXT DEFAULT "a"; DECLARE catalog_name TEXT DEFAULT "a"; DECLARE schema_name TEXT DEFAULT "a"; DECLARE table_name TEXT DEFAULT "a"; DECLARE column_name TEXT DEFAULT "a"; DECLARE cursor_name TEXT DEFAULT "a"; DECLARE message_text TEXT DEFAULT "a"; DECLARE mysql_errno INT DEFAULT 1; DECLARE returned_sqlstate TEXT DEFAULT "a"; SELECT CAST(-19999999999999999999 AS SIGNED); GET DIAGNOSTICS CONDITION 1 class_origin = CLASS_ORIGIN, subclass_origin = SUBCLASS_ORIGIN, constraint_catalog = CONSTRAINT_CATALOG, constraint_schema = CONSTRAINT_SCHEMA, constraint_name = CONSTRAINT_NAME, catalog_name = CATALOG_NAME, schema_name = SCHEMA_NAME, table_name = TABLE_NAME, column_name = COLUMN_NAME, cursor_name = CURSOR_NAME, message_text = MESSAGE_TEXT, mysql_errno = MYSQL_ERRNO, returned_sqlstate = RETURNED_SQLSTATE; SELECT class_origin, subclass_origin, constraint_catalog, constraint_schema, constraint_name, catalog_name, schema_name, table_name, column_name, cursor_name, message_text, mysql_errno, returned_sqlstate; END
CREATE PROCEDURE p1() BEGIN DECLARE errno1 INT; DECLARE errno2 INT; DECLARE msg1 TEXT; DECLARE msg2 TEXT; SELECT CAST(-19999999999999999999 AS SIGNED); GET DIAGNOSTICS CONDITION 99999 msg1 = MESSAGE_TEXT; GET DIAGNOSTICS CONDITION 1 errno1 = MYSQL_ERRNO, msg1 = MESSAGE_TEXT; GET DIAGNOSTICS CONDITION 2 errno2 = MYSQL_ERRNO, msg2 = MESSAGE_TEXT; SELECT errno1, msg1, errno2, msg2; END
CREATE PROCEDURE p1() BEGIN DECLARE errno INT DEFAULT 0; DECLARE msg TEXT DEFAULT "foo"; DECLARE cond CONDITION FOR SQLSTATE "01234"; DECLARE CONTINUE HANDLER for 1012 BEGIN GET DIAGNOSTICS CONDITION 1 errno = MYSQL_ERRNO, msg = MESSAGE_TEXT; END; SIGNAL cond SET MESSAGE_TEXT = "Signal message", MYSQL_ERRNO = 1012; SELECT errno, msg; END
GET DIAGNOSTICS CONDITION 1 @mysql_errno = MYSQL_ERRNO, @message_text = MESSAGE_TEXT, @returned_sqlstate = RETURNED_SQLSTATE, @class_origin = CLASS_ORIGIN
GET DIAGNOSTICS CONDITION 1 @class_origin = CLASS_ORIGIN, @subclass_origin = SUBCLASS_ORIGIN, @constraint_catalog = CONSTRAINT_CATALOG, @constraint_schema = CONSTRAINT_SCHEMA, @constraint_name = CONSTRAINT_NAME, @catalog_name = CATALOG_NAME, @schema_name = SCHEMA_NAME, @table_name = TABLE_NAME, @column_name = COLUMN_NAME, @cursor_name = CURSOR_NAME, @message_text = MESSAGE_TEXT, @mysql_errno = MYSQL_ERRNO, @returned_sqlstate = RETURNED_SQLSTATE
CREATE PROCEDURE p1() BEGIN DECLARE var INT; GET DIAGNOSTICS var = NUMBER, @var = NUMBER; SELECT var, @var; END
CREATE PROCEDURE p1() BEGIN DECLARE v VARCHAR(64); DECLARE CONTINUE HANDLER FOR SQLEXCEPTION GET DIAGNOSTICS CONDITION 1 v = TABLE_NAME; DROP TABLE no_such_table; SELECT v; END
CREATE PROCEDURE p1() BEGIN DECLARE v CHAR(1); CREATE TABLE IF NOT EXISTS t1 (a INT); GET DIAGNOSTICS CONDITION 1 v = MESSAGE_TEXT; SELECT v; END
CREATE PROCEDURE p1(IN param INT) LANGUAGE SQL BEGIN DECLARE v INT DEFAULT 0; DECLARE rcount_each INT; DECLARE rcount_total INT DEFAULT 0; WHILE v < 5 DO UPDATE t1 SET a = a * 1.1  WHERE b = param; GET DIAGNOSTICS rcount_each = ROW_COUNT; SET rcount_total = rcount_total + rcount_each; SET v = v + 1; END WHILE; SELECT rcount_total; END
CREATE PROCEDURE p1(OUT number INT, INOUT message TEXT) BEGIN DECLARE warn CONDITION FOR SQLSTATE "01234"; DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN GET DIAGNOSTICS number = NUMBER; GET DIAGNOSTICS CONDITION 1 message = MESSAGE_TEXT; END; SELECT message; SIGNAL warn SET MESSAGE_TEXT = "inout parameter"; END
CREATE PROCEDURE p1(IN number INT) BEGIN SELECT number; GET DIAGNOSTICS number = NUMBER; SELECT number; END
CREATE FUNCTION f1() RETURNS TEXT BEGIN DECLARE message TEXT; DECLARE warn CONDITION FOR SQLSTATE "01234"; DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN GET DIAGNOSTICS CONDITION 1 message = MESSAGE_TEXT; END; SIGNAL warn SET MESSAGE_TEXT = "message text"; return message; END
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN DECLARE var INT DEFAULT row_count(); GET DIAGNOSTICS @var1 = ROW_COUNT; SET @var2 = var; END
GET DIAGNOSTICS @var1 = ROW_COUNT
GET DIAGNOSTICS @var2 = ROW_COUNT
GET DIAGNOSTICS CONDITION 1 @var1 = MESSAGE_TEXT, @var2 = CLASS_ORIGIN
GET DIAGNOSTICS @var1 = NUMBER
CREATE PROCEDURE p1() BEGIN DECLARE stacked INT DEFAULT 1; SELECT stacked; END
GET STACKED DIAGNOSTICS @var1 = NUMBER
CREATE PROCEDURE p1() BEGIN DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN GET CURRENT DIAGNOSTICS CONDITION 1 @msg1 = MESSAGE_TEXT, @errno1 = MYSQL_ERRNO; GET STACKED DIAGNOSTICS CONDITION 1 @msg2 = MESSAGE_TEXT, @errno2 = MYSQL_ERRNO; SELECT @msg1, @errno1; SELECT @msg2, @errno2; SELECT * FROM t1;   # Clear first diagnostics area GET CURRENT DIAGNOSTICS @cno = NUMBER; SELECT @cno; GET STACKED DIAGNOSTICS CONDITION 1 @msg4 = MESSAGE_TEXT, @errno4 = MYSQL_ERRNO; SELECT @msg4, @errno4; END; DROP TABLE non_existent; END
CREATE PROCEDURE p1() BEGIN DROP VIEW v1; CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b, 3 AS c; END
CREATE PROCEDURE p1() BEGIN DROP VIEW v1; CREATE VIEW v1 AS SELECT 2 AS b, 3 AS c; END
CREATE PROCEDURE p3() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN SELECT 'SQLEXCEPTION caught' AS msg; CREATE VIEW v1 AS SELECT 1 AS a, 2 AS b; END; SELECT * FROM v1; SELECT * FROM v1; DROP VIEW v1; END
CREATE PROCEDURE p2() BEGIN DECLARE v INT DEFAULT 1; IF v * (SELECT * FROM t1) THEN SELECT 1; ELSE SELECT 2; END IF; END
CREATE FUNCTION f2() RETURNS INT BEGIN DECLARE v INT DEFAULT 1; IF v * (SELECT * FROM t1) THEN RETURN 1; ELSE RETURN 2; END IF; RETURN 3; END
CREATE PROCEDURE p1() BEGIN DECLARE v INT DEFAULT (SELECT * FROM t1); SELECT v; END
CREATE PROCEDURE p1() BEGIN DECLARE x INT; SET x = (SELECT * FROM t1); SELECT x; END
CREATE PROCEDURE p1() BEGIN DECLARE v INT; DECLARE c CURSOR FOR SELECT * FROM t1; ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2; ALTER TABLE t1 DROP COLUMN a; OPEN c; FETCH c INTO v; CLOSE c; SELECT v; END
CREATE PROCEDURE p1() BEGIN DECLARE v INT; DECLARE c CURSOR FOR SELECT * FROM t1; ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2; ALTER TABLE t1 DROP COLUMN a; OPEN c; FETCH c INTO v; CLOSE c; SELECT v; END
CREATE PROCEDURE p1() BEGIN DECLARE v INT; DECLARE c CURSOR FOR SELECT * FROM t1; OPEN c; ALTER TABLE t1 ADD COLUMN b INT DEFAULT 2; ALTER TABLE t1 DROP COLUMN a; FETCH c INTO v; CLOSE c; SELECT v; END
CREATE PROCEDURE p1() BEGIN DECLARE f1 INT; DECLARE f2 INT; DECLARE f3 INT; DECLARE x INT DEFAULT 1; DECLARE y INT DEFAULT 2; DECLARE c CURSOR FOR SELECT x, y, t1.a FROM t1; ALTER TABLE t1 ADD COLUMN b INT; BEGIN DECLARE x INT DEFAULT 10; DECLARE y INT DEFAULT 20; OPEN c; FETCH c INTO f1, f2, f3; SELECT f1, f2, f3; CLOSE c; END; END
CALL mtr.add_suppression("Table 'mysql.component' doesn't exis")
CALL mtr.add_suppression("The mysql.component table is missing or has an incorrect definition.")
CALL mtr.add_suppression("Enabling keys got errno")
disable_query_log
enable_query_log
LOCK TABLES t1 WRITE
update t1 set b=repeat('a',256)
explain select * from t1 use index() where c=1
insert into t1 (b) values (repeat('a',100)),(repeat('b',100)),(repeat('c',100))
update t1 set b=repeat(left(b,1),200) where a=1
update t1 set b=repeat('e',200) where a=1
disable_query_log
enable_query_log
update t1 set b=repeat(left(b,1),255) where a between 1 and 5
update t1 set b=repeat(left(b,1),10) where a between 32 and 43
update t1 set b=repeat(left(b,1),2) where a between 64 and 66
update t1 set b=repeat(left(b,1),65) where a between 67 and 70
insert into t1 (b) values (repeat('z',100))
lock tables t1 read local, t2 read local
select straight_join * from t1,t2 force index (primary) where t1.a=t2.a
select straight_join * from t1,t2 force index (primary) where t1.a=t2.a
unlock tables
LOCK TABLES t1 READ LOCAL, t2 READ LOCAL
UNLOCK TABLES
SELECT _id FROM t1
DELETE FROM t1 WHERE _id < 8
SELECT _id FROM t1
SELECT _id FROM t1
DELETE FROM t1 WHERE _id < 8
SELECT _id FROM t1
source include/varchar.inc
lock table t1 read local
unlock tables
lock table t1 read local
unlock tables
lock table t1 read local
unlock tables
lock table t1 read local
unlock tables
create table t1 (a int not null, key key_block_size=1024 (a))
create table t1 (a int not null, key `a` key_block_size=1024 (a))
INSERT INTO t1 VALUES (10, REPEAT('a', CEIL(RAND(10) * 300))), (11, REPEAT('b', CEIL(RAND() * 300))), (12, REPEAT('c', CEIL(RAND() * 300))), (13, REPEAT('d', CEIL(RAND() * 300))), (14, REPEAT('e', CEIL(RAND() * 300))), (15, REPEAT('f', CEIL(RAND() * 300))), (16, REPEAT('g', CEIL(RAND() * 300))), (17, REPEAT('h', CEIL(RAND() * 300))), (18, REPEAT('i', CEIL(RAND() * 300))), (19, REPEAT('j', CEIL(RAND() * 300))), (20, REPEAT('k', CEIL(RAND() * 300))), (21, REPEAT('l', CEIL(RAND() * 300))), (22, REPEAT('m', CEIL(RAND() * 300))), (23, REPEAT('n', CEIL(RAND() * 300))), (24, REPEAT('o', CEIL(RAND() * 300))), (25, REPEAT('p', CEIL(RAND() * 300))), (26, REPEAT('q', CEIL(RAND() * 300))), (27, REPEAT('r', CEIL(RAND() * 300))), (28, REPEAT('s', CEIL(RAND() * 300))), (29, REPEAT('t', CEIL(RAND() * 300))), (30, REPEAT('u', CEIL(RAND() * 300))), (31, REPEAT('v', CEIL(RAND() * 300))), (32, REPEAT('w', CEIL(RAND() * 300))), (33, REPEAT('x', CEIL(RAND() * 300))), (34, REPEAT('y', CEIL(RAND() * 300))), (35, REPEAT('z', CEIL(RAND() * 300)))
INSERT INTO t1 VALUES(REPEAT("a",128), 'b')
INSERT INTO t1 VALUES(REPEAT("a",128), 'b')
INSERT INTO t1 VALUES(REPEAT("a",128), 'b')
UPDATE t1 SET c1=REPEAT("a",128) LIMIT 90
INSERT INTO t1 VALUES(REPEAT(_utf8 x'e0ae85',43), 'b')
INSERT INTO t1 VALUES(REPEAT(_utf8 x'e0ae85',43), 'b')
INSERT INTO t1 VALUES(REPEAT(_utf8 x'e0ae85',43), 'b')
UPDATE t1 SET c1=REPEAT(_utf8 x'e0ae85',43) LIMIT 90
REPLACE INTO t1 VALUES (1, REPEAT('a', 129015)),(1, NULL), (2, NULL),(3, NULL),(4, NULL),(5, NULL),(6, NULL),(7, NULL), (1, REPEAT('b', 129016)),(1, NULL), (1, REPEAT('c', 129015)),(1, REPEAT('d', 129015))
FLUSH TABLE t1
LOCK TABLE t1 WRITE
UNLOCK TABLES
SET @before:= (SELECT MAX_DATA_LENGTH FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME='t1' AND TABLE_SCHEMA='test')
SET @after:= (SELECT MAX_DATA_LENGTH FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME='t1' AND TABLE_SCHEMA='test')
SELECT @before=@after
call mtr.add_suppression("Got an error from thread_id=.*ha_myisam.cc:")
call mtr.add_suppression("MySQL thread id .*, query id .* localhost.*root Checking table")
call mtr.add_suppression(" '\..test.t1'")
source 'include/function_defaults.inc'
WHERE PLUGIN_NAME like 'pfs_example%' and PLUGIN_STATUS='INACTIVE'
WHERE PLUGIN_NAME like 'pfs_example%' and PLUGIN_STATUS='ACTIVE'
WHERE PLUGIN_NAME like 'pfs_example%' and PLUGIN_STATUS ='DELETING'
do str_to_date(1, "%#")
do timestamp(date_format('2011-11-11', right("12345" + 1, 3)))
SELECT * FROM t1 LEFT JOIN t2 IGNORE INDEX(PRIMARY) ON t2.a = 'test1' AND t2.b = '20161213' WHERE t1.a = 'test1'
SELECT b, b IN ('20161213'), b in ('20161213', 0) FROM t2
SELECT b, b in ('121314'), b in ('121314', 0) FROM t3
RENAME TABLE t TO tmp2, tmp TO t
RENAME TABLE tmp2 TO t
CREATE TABLE tp (a VARCHAR(24), b DATETIME, PRIMARY KEY (a,b)) PARTITION BY RANGE COLUMNS (a, b) (PARTITION p0 VALUES LESS THAN ("Middle", '0000-00-00'), PARTITION p1 VALUES LESS THAN (MAXVALUE, '9999-12-31 23:59:59'))
call mtr.add_suppression("row in wrong partition:")
call mtr.add_suppression("Cannot find index .PRIMARY. in InnoDB index translation table.")
ENGINE = InnoDB DATA DIRECTORY = '$MYSQL_TMP_DIR/t1_dir'
ENGINE = InnoDB PARTITION BY LIST (a) (PARTITION p1 VALUES IN (1,3,5,7,9) DATA DIRECTORY = '$MYSQL_TMP_DIR/p1_dir', PARTITION p2 VALUES IN (0,2,4,6,8) DATA DIRECTORY = '$MYSQL_TMP_DIR/p2_dir')
ENGINE = InnoDB DATA DIRECTORY = '$MYSQL_TMP_DIR/t1_dir'
ENGINE = InnoDB PARTITION BY range (a) (PARTITION p1 VALUES less than (10) DATA DIRECTORY = '$MYSQL_TMP_DIR/p1_dir', PARTITION p2 VALUES less than (20) DATA DIRECTORY = '$MYSQL_TMP_DIR/p2_dir')
ENGINE = InnoDB DATA DIRECTORY = '$MYSQL_TMP_DIR/t1_dir'
PARTITION BY RANGE( YEAR(purchased) ) SUBPARTITION BY HASH( TO_DAYS(purchased) ) ( PARTITION p0 VALUES LESS THAN (1990) ( SUBPARTITION s0 data directory='$MYSQL_TMP_DIR/sp0_dir', SUBPARTITION s1), PARTITION p1 VALUES LESS THAN (2000) ( SUBPARTITION s2, SUBPARTITION s3 data directory='$MYSQL_TMP_DIR/sp3_dir' ))
CALL mtr.add_suppression("World-writable config file .* is ignored")
CALL mtr.add_suppression("World-writable config file .* has been removed.")
INSERT INTO t1 VALUES(default(a), default(b))
UPDATE t1 SET b=default(b)
cat_file $MYSQLD_DATADIR/test_string_service_charset.log
remove_file $MYSQLD_DATADIR/test_string_service_charset.log
CALL mtr.add_suppression("Could not parse key-value pairs in property string.*")
PREPARE stmt FROM 'show events'
EXECUTE stmt
LOCK TABLE t1 READ
CONNECT (con1, localhost, root)
CONNECTION default
UNLOCK TABLES
DISCONNECT con1
DROP PREPARE stmt
CREATE TABLE t1(f1 INT, f2 VARCHAR(64) NOT NULL, PRIMARY KEY (f1)) PARTITION BY RANGE(f1) ( PARTITION p1 VALUES LESS THAN (3), PARTITION p2 VALUES LESS THAN (maxvalue) )
call mtr.add_suppression("Plugin \'InnoDB\'")
call mtr.add_suppression("Shift expected at '' for COLLATION : utf8_test")
CREATE TABLE t1 ( f1 CHAR(20) COLLATE utf8mb4_0900_ai_ci  # A NO PAD collation. )
ENGINE archive $data_directory $index_directory
ENGINE archive $data_directory $index_directory
ENGINE archive $data_directory
ENGINE archive DATA DIRECTORY '$MYSQLD_DATADIR/test'
ENGINE archive INDEX DIRECTORY '$MYSQLD_DATADIR/test'
insert into t1 values (1, concat(repeat('1', 300), '2')), (1, concat(repeat('1', 300), '2')), (1, concat(repeat('0', 300), '1')), (2, concat(repeat('1', 300), '2')), (2, concat(repeat('1', 300), '2')), (2, concat(repeat('0', 300), '1'))
insert into t1 values (1,repeat('a',255)),(2,repeat('b',255))
INSERT INTO t1 VALUES (1,REPEAT(CONCAT('A',CAST(CHAR(0) AS BINARY),'B'), 40000))
insert into t1 values (repeat('a', 1022), 0), (repeat(_utf8 0xc3b7, 4), 0)
insert into t1 values (1,repeat('a',255)),(2,repeat('b',255))
INSERT INTO t1 VALUES ( repeat( 'a', 10 ), 1), ( repeat( 'b', 10 ), 2)
INSERT INTO t2 VALUES( REPEAT( 'a', 5000 ) )
INSERT INTO t2 VALUES( REPEAT( 'b', 5000 ) )
INSERT INTO t2 VALUES( REPEAT( 'a', 5000 ) )
INSERT INTO t3 VALUES( REPEAT( 'a', 65534 ), 1 )
INSERT INTO t3 VALUES( REPEAT( 'a', 65535 ), 2 )
INSERT IGNORE INTO t3 VALUES( REPEAT( 'a', 65536 ), 3 )
PREPARE stmt FROM "SELECT GROUP_CONCAT(t1.a ORDER BY t1.a) FROM t1 JOIN t1 t2 GROUP BY t1.a WITH ROLLUP"
EXECUTE stmt
EXECUTE stmt
DEALLOCATE PREPARE stmt
SELECT POLYGON((SELECT 1 FROM (SELECT 1 IN (GROUP_CONCAT(t1.f1)) FROM t1, t1 t GROUP BY t.f1 ) d))
INSERT INTO t1 VALUES (REPEAT('a', 500000), 0), (REPEAT('b', 500000), 1), (REPEAT('c', 500000), 2)
INSERT INTO t1 VALUES (REPEAT('a', 499999), 3), (REPEAT('b', 500000), 4)
prepare s from 'DO GROUP_CONCAT((SELECT COUNT(1)) ORDER BY 1)'
execute s
execute s
deallocate prepare s
prepare s from ' SELECT GROUP_CONCAT(a2.name ORDER BY a2.name) AS mbrcontains FROM v a1 JOIN v a2 ON MBRContains(a1.square, a2.square) WHERE a1.name = "center" GROUP BY a1.name'
execute s
execute s
deallocate prepare s
PREPARE ps FROM "SELECT GROUP_CONCAT(o_id) FROM t1;"
EXECUTE ps
PREPARE ps FROM "SELECT GROUP_CONCAT(o_id) FROM t1;"
EXECUTE ps
PREPARE ps FROM "SELECT GROUP_CONCAT(o_id) FROM t1;"
EXECUTE ps
PREPARE ps FROM "SELECT GROUP_CONCAT(o_id) FROM t1;"
EXECUTE ps
RENAME TABLE non_atomic_t1 TO non_atomic_t2, child TO siebling
RENAME TABLE child TO siebling, non_atomic_t1 TO non_atomic_t3, non_atomic_t3 TO non_atomic_t2
LOCK TABLES t1 WRITE
UNLOCK TABLES
source include/show_binlog_events.inc
call mtr.add_suppression("\\[Warning\\] \\[[^]]*\\] \\[[^]]*\\] Unsafe statement written .* = STATEMENT.")
send INSERT INTO t1 VALUES (3), (NULL), (4)
reap
send INSERT INTO t1 VALUES (3), (NULL), (4)
reap
send INSERT INTO t1 SELECT * FROM t2
reap
send INSERT INTO t1 SELECT * FROM t2
reap
CREATE TABLESPACE `ts6` ADD DATAFILE 'ts6.ibd' ENGINE=INNODB
CREATE TABLESPACE ts ADD DATAFILE 'ts.ibd' ENGINE=InnoDB
CREATE TABLESPACE innodb_system ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE innodb_file_per_table ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE innodb_temporary ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE mysql ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE `innodb_file_per_table.2` ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE innodb_file_per_table_whatever ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE innodb_file_per_table ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE ts ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE ts ADD DATAFILE 'f.ibd' ENGINE InnoDB
ALTER TABLESPACE ts RENAME TO innodb_system
ALTER TABLESPACE ts RENAME TO innodb_file_per_table
ALTER TABLESPACE ts RENAME TO innodb_temporary
ALTER TABLESPACE ts RENAME TO mysql
ALTER TABLESPACE innodb_system RENAME TO ts3
ALTER TABLESPACE innodb_temporary RENAME TO ts3
ALTER TABLESPACE mysql RENAME TO ts3
ALTER TABLESPACE ts RENAME TO `innodb_file_per_table.2`
ALTER TABLESPACE ts RENAME TO innodb_file_per_table_whatever
ALTER TABLESPACE ts RENAME TO innodb_file_per_table
CREATE TABLESPACE altering ADD DATAFILE 'altering.ibd' ENGINE InnoDB
ALTER TABLESPACE ts RENAME TO ts2
CREATE TABLESPACE ts1 ADD DATAFILE 'df1.ibd'
ALTER TABLESPACE ts1 RENAME TO ts2
BEGIN WORK
CREATE TABLESPACE ts1 ADD DATAFILE 'df1.ibd'
BEGIN WORK
ALTER TABLESPACE ts1 RENAME TO ts2
BEGIN WORK
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1.ibd' Engine=InnoDB
ALTER TABLESPACE ts1 RENAME TO ts11
CREATE TABLESPACE ts Engine=InnoDB
CREATE TABLESPACE ts1 Engine=InnoDB
CREATE PROCEDURE cr(IN start BIGINT) BEGIN SET @idx =start; WHILE (@idx > 0) DO CREATE TABLESPACE x; DROP TABLESPACE x; SET @idx = @idx - 1; END WHILE; END
CREATE TABLESPACE ts1 Engine=InnoDB
CREATE TABLESPACE ts2 ADD DATAFILE 'ts2.ibd' Engine=InnoDB
ALTER TABLESPACE ts2 RENAME TO ts3
CREATE TABLESPACE ts2 Engine=InnoDB
CREATE TABLESPACE ts2 Engine=InnoDB
CREATE TABLESPACE ts ADD DATAFILE 'f.ibd' ENGINE InnoDB
LOCK TABLE t1 read
KILL QUERY @id
UNLOCK TABLES
CREATE TABLESPACE ts ADD DATAFILE 'f.ibd' ENGINE InnoDB
LOCK TABLE t1 READ, performance_schema.threads READ
UNLOCK TABLES
CREATE TABLESPACE ts1
CREATE TABLESPACE ts1
ALTER TABLESPACE ts1 RENAME TO ts11
ALTER TABLESPACE ts1 RENAME TO ts11
CREATE TABLESPACE ts1 ENGINE_ATTRIBUTE=''
CREATE TABLESPACE ts2 ENGINE_ATTRIBUTE='{"c": "v"}'
CREATE TABLESPACE ts3 ENGINE_ATTRIBUTE='{"c": v}'
ALTER TABLESPACE ts1 ENGINE_ATTRIBUTE='{"foo": "bar}'
ALTER TABLESPACE ts1 ENGINE_ATTRIBUTE='{"foo": "bar"}'
ALTER TABLESPACE ts1 RENAME TO ts11
prepare s from "select 1 limit ?"
execute s using @a
execute s using @a
prepare s from "select 1 limit 1, ?"
execute s using @a
prepare s from "select 1 limit ?, ?"
execute s using @a, @a
execute s using @a, @a
execute s using @a, @a
PREPARE stmt FROM "SELECT * FROM t1 WHERE id > ?"
EXECUTE stmt using @a
EXECUTE stmt using @a
EXECUTE stmt USING @a
DEALLOCATE PREPARE stmt
PREPARE stmt FROM "(SELECT * FROM t1 LIMIT 2) UNION ALL (SELECT * FROM t1 ORDER BY 1)"
EXECUTE stmt
EXECUTE stmt
DEALLOCATE PREPARE stmt
SELECT INSERT('ðŒ†ãƒ†Ã€a', 2, 2, 'ãƒ†b')
INSERT INTO t1 VALUES(_utf16 0x1EC2), (_utf16 0x1EC3), (_utf16 0x1EC5), (_utf16 0x1EC0), (_utf16 0x1EC7), (_Utf16 0x1EBF)
call mtr.add_suppression("\\[Warning\\] .*MY-\\d+.* Tablespace .*, name '.*', file '.*' is missing")
WHERE USER != 'event_scheduler'`
LOCK TABLE t1 READ
PREPARE st2 FROM "SELECT TABLE_SCHEMA, TABLE_NAME, TABLE_TYPE FROM information_schema.tables WHERE table_name='t1'"
EXECUTE st2
DEALLOCATE PREPARE st2
UNLOCK TABLES
send SELECT TABLE_NAME, ENGINE, TABLE_ROWS INTO @v1, @v2, @v3 FROM INFORMATION_SCHEMA.TABLES WHERE table_name='t0'
send SELECT TABLE_NAME, ENGINE, TABLE_ROWS INTO @v1, @v2, @v3 FROM INFORMATION_SCHEMA.TABLES WHERE table_name='t0'
send ANALYZE TABLE t0
call mtr.add_suppression("\\[Warning\\] \\[[^]]*\\] \\[[^]]*\\] You need to use --log-bin to make --binlog-format work.")
call mtr.add_suppression("\\[Warning\\] \\[[^]]*\\] \\[[^]]*\\] You need to use --log-bin to make --binlog-expire-logs-seconds work.")
CREATE TABLE t3 (a INT PRIMARY KEY, d INT DEFAULT (-a + 1), c INT DEFAULT (DEFAULT(d)) )
SELECT DEFAULT(d) from t3
SELECT DEFAULT(c) from t3
CREATE TABLE t(i INT, b TINYBLOB  DEFAULT (repeat('b', i)))
ALTER TABLE t ADD COLUMN b TINYBLOB DEFAULT (repeat('b', i))
ALTER TABLE t ALTER COLUMN b SET DEFAULT (repeat('b', i))
CREATE TABLE t(i BIGINT, b MEDIUMBLOB  DEFAULT (repeat('b', i)))
ALTER TABLE t ADD COLUMN b MEDIUMBLOB DEFAULT (repeat('b', i))
ALTER TABLE t ALTER COLUMN b SET DEFAULT (repeat('b', i))
CREATE TABLE t(i INT, b BLOB DEFAULT (repeat('b', i)))
ALTER TABLE t ADD COLUMN b BLOB DEFAULT (repeat('b', i))
ALTER TABLE t ALTER COLUMN b SET DEFAULT (repeat('b', i))
CREATE TABLE t(i BIGINT, b LONGBLOB  DEFAULT (repeat('b', i)))
CREATE TABLE t(i INT, b BLOB DEFAULT (repeat('b', i)))
ALTER TABLE t ADD COLUMN b BLOB DEFAULT (repeat('b', i))
ALTER TABLE t ALTER COLUMN b SET DEFAULT (repeat('b', i))
CREATE TABLE t(i INT, b VARCHAR(20) DEFAULT (repeat('b', i)))
CREATE TABLE t1 (a INT, b TIMESTAMP DEFAULT (TIMESTAMPADD(MINUTE, 1,'2003-01-02')) ON UPDATE NOW())
CREATE TABLE t1 (a datetime, b datetime DEFAULT (utc_date()))
CREATE TABLE t1 (a datetime, b datetime DEFAULT (utc_time()))
CREATE TABLE t2 (a INT, b INT DEFAULT (select count(*) from t1))
CREATE TABLE t2 (a INT, b INT DEFAULT (select * from t1))
CREATE TABLE t2 (a INT, b INT DEFAULT (select 1))
CREATE TABLE t2 (i INT, j DOUBLE DEFAULT (SQRT(i)), k DOUBLE DEFAULT (DEFAULT(j)))
ALTER TABLE t1 MODIFY COLUMN i INT AUTO_INCREMENT PRIMARY KEY DEFAULT(GROUPING(r))
ALTER TABLE t1 ALTER COLUMN i SET DEFAULT(GROUPING(r))
CREATE TABLE t1 (created DATETIME NOT NULL DEFAULT (UTC_DATE()))
CREATE TABLE t1 (created DATETIME NOT NULL DEFAULT (UTC_TIME()))
delimiter
create procedure p1() begin declare counter integer default 0; declare continue handler for sqlexception begin set counter = counter + 10;end; repeat if rand()>0.5 then start transaction; end if; if rand()>0.5 then select var_samp(1), exists(select 1 from t1 lock in share mode) from t1 into @a,@b; end if; if rand()>0.5 then select var_samp(1), exists(select 1 from t1 for update) from t1 into @a,@b; end if; if rand()>0.5 then insert ignore into t1 values (); end if; if rand()>0.5 then insert ignore into t2 values (); end if; if rand()>0.5 then delete from t1; end if; if rand()>0.5 then delete from t2; end if; if rand()>0.5 then commit; end if; set counter = counter + 1; until counter >= 100 end repeat; end
create temporary table tg (i int not null) engine=merge union=()
echo
SHOW GRANTS FOR 'select_only_c1'@'localhost'
echo
echo "after fix privs"
SHOW GRANTS FOR 'show_view_tbl'@'localhost'
echo
SHOW GRANTS FOR 'select_only_c1'@'localhost'
echo
ALTER TABLE t1 ORDER BY t1.id, t1.status, t1.type_id, t1.user_id, t1.body
LOCK TABLES t1 WRITE
UNLOCK TABLES
LOCK TABLES t1 WRITE
UNLOCK TABLES
CHECK TABLES t1
LOCK TABLES t1 WRITE
UNLOCK TABLES
CHECK TABLES t1
LOCK TABLES t1 WRITE
UNLOCK TABLES
LOCK TABLES t1 WRITE
RIGHT JOIN (SELECT 1 FROM g9) AS d1 ON 1 LEFT JOIN (SELECT 1 FROM g9) AS d2 ON 1
SELECT GROUPING(alias2.pk) AS field2 FROM t2 AS alias1 LEFT JOIN t1 AS alias2 ON 0 GROUP BY alias2.pk WITH ROLLUP ORDER BY GROUPING(alias2.pk)
SELECT ((table1.col_int) * (table1.col_int)) AS field2 FROM (t1 AS table1) WHERE (table1.col_int != 1 OR table1.pk) GROUP BY field2 WITH ROLLUP HAVING (field2 <> 239 ) ORDER BY GROUPING(field2)
ALTER USER method_alter@localhost IDENTIFIED WITH 'sha256_password'
RENAME TABLE mysql.password_history TO mysql.password_history_backup
ALTER USER no_pwd_history@localhost IDENTIFIED WITH 'sha256_password'
RENAME TABLE mysql.password_history_backup TO mysql.password_history
CREATE TABLE t1(f1 INT INVISIBLE, f2 INT)
CREATE TABLE t1 (f1 INT, f2 INT PRIMARY KEY INVISIBLE)
CREATE TABLE t1 (f1 INT, f2 INT PRIMARY KEY INVISIBLE)
CREATE TABLE t2 (f1 INT PRIMARY KEY INVISIBLE, f2 INT, CONSTRAINT FOREIGN KEY (f1) REFERENCES t1(f2))
CREATE TABLE t1 (f1 INT, f2 INT PRIMARY KEY INVISIBLE)
ALTER TABLE t1 ALTER COLUMN f1 SET INVISIBLE, ALGORITHM = INPLACE
ALTER TABLE t1 CHANGE f1 f1 INT VISIBLE, ALGORITHM = INPLACE
ALTER TABLE t1 MODIFY f1 INT INVISIBLE, ALGORITHM = INPLACE
ALTER TABLE t1 ALTER COLUMN f1 SET INVISIBLE, ALGORITHM = INPLACE
ALTER TABLE t1 ALTER COLUMN f1 SET INVISIBLE, ALGORITHM = INSTANT
ALTER TABLE t1 CHANGE f1 f1 INT VISIBLE, ALGORITHM = INSTANT
ALTER TABLE t1 MODIFY f1 INT INVISIBLE, ALGORITHM = INSTANT
ALTER TABLE t1 ALTER COLUMN f1 SET INVISIBLE, ALGORITHM = INSTANT
CREATE TABLE t1(a INT, b DATE NOT NULL INVISIBLE) PARTITION BY RANGE( YEAR(b) ) ( PARTITION p0 VALUES LESS THAN (1960), PARTITION p1 VALUES LESS THAN (1970), PARTITION p2 VALUES LESS THAN (1980), PARTITION p3 VALUES LESS THAN (1990))
CREATE TABLE t1(id INT NOT NULL INVISIBLE, name VARCHAR(10)) PARTITION BY LIST(id) ( PARTITION p0 VALUES IN (10,19), PARTITION p1 VALUES IN (20,29), PARTITION p2 VALUES IN (30,39), PARTITION p3 VALUES IN (40,49))
CREATE TABLE t1(id INT NOT NULL INVISIBLE, name VARCHAR(40)) PARTITION BY HASH(id) PARTITIONS 4
CREATE TABLE t1(id INT PRIMARY KEY NOT NULL INVISIBLE, name VARCHAR(40)) PARTITION BY KEY() PARTITIONS 4
COUNT(*), SUM(LENGTH(t1.text_col)), SUM(t2.bigint_col) FROM t1, t1 AS t2 WHERE t1.int_col = t2.int_col ORDER BY t1.int_col
t1.col1, t2.col1 FROM t1, t2 WHERE t1.col1 = t2.col1 AND t1.col1 = FLOOR(RAND() / 2 + 2)
FROM (SELECT * FROM c) AS table1 JOIN (SELECT * FROM c) AS table2 ON table2.col1 = table1.col1
JOIN t2 ON t1.col1 + 10 = t2.col1 JOIN t3 ON t2.col1 = t3.col1
t1.col_varchar_key AS field1 FROM (t1, t1 as alias1) WHERE NOT EXISTS( SELECT alias2.col_varchar_key FROM t1 AS alias2 WHERE alias2.col_varchar_key >= t1.col_varchar ) GROUP BY field1
CREATE TABLE t1 ( col_int_key INTEGER, col_json JSON, KEY mv_idx ((CAST(col_json->'$[*]' AS CHAR(40) ARRAY))) )
JOIN t1 ON 1 WHERE (CAST("1" AS JSON) MEMBER OF( t1.col_json->'$[*]'))
INNER JOIN a AS table2 ON table2.pk = table1.pk OR table1.col_varchar < 'D') WHERE (NOT EXISTS (SELECT 1 FROM (b AS alias3 STRAIGHT_JOIN a AS alias4 ON alias4.col_varchar = alias3.col_varchar_key) WHERE alias3.pk >= table1.pk))
INSERT INTO t1 VALUES (REPEAT('A', 50000)), (REPEAT('A', 50000))
INSERT INTO t2 SELECT REPEAT("a", 255) FROM t1
FROM cc AS alias1 LEFT JOIN ( ( bb AS alias2 INNER JOIN (SELECT DISTINCT sq1_alias1.* FROM bb AS sq1_alias1) AS alias3 ON alias3.col_int_key = alias2.col_int_key ) ) ON alias3.col_varchar_key = alias2.col_varchar_key WHERE alias1.col_varchar_key IN ( SELECT sq2_alias1.col_varchar AS sq2_field1 FROM c AS sq2_alias1 WHERE sq2_alias1.col_varchar_key != alias2.col_varchar AND sq2_alias1.col_int > alias2.pk )
alias1.pk AS field1 FROM ( SELECT sq1_alias2.* FROM cc AS sq1_alias1 RIGHT JOIN cc AS sq1_alias2 ON sq1_alias2.col_varchar_key = sq1_alias1.col_varchar_key LIMIT 100 ) AS alias1 WHERE alias1.col_varchar_key IN ( SELECT sq2_alias1.col_varchar_key AS sq2_field1 FROM (cc AS sq2_alias1, c AS sq2_alias2) WHERE sq2_alias1.col_varchar_key != alias1.col_varchar ) GROUP BY field1 HAVING field1 != 'pg' ORDER BY alias1.col_int_key DESC, field1 LIMIT 2 OFFSET 2
table1.col_varchar FROM ( SELECT subquery1_t1.* FROM b AS subquery1_t1 INNER JOIN cc AS subquery1_t2 ON subquery1_t1.col_varchar = subquery1_t2.col_varchar ) AS table1 LEFT JOIN ( SELECT col_varchar FROM cc AS subquery2_t1 GROUP BY subquery2_t1.col_varchar ) AS table2 ON table2.col_varchar = table1.col_varchar AND table1.col_varchar IN ( SELECT lower(subquery3_t1.pk) AS subquery3_field1 FROM b AS subquery3_t1 )
FROM t1 JOIN t2 ON t1.col1 = t2.col1 WHERE t2.col2 > 0 OR t2.col3 > 0 LIMIT 10
* FROM ( SELECT DISTINCT t1.* FROM t1 ) AS table1 JOIN t2 WHERE table1.col1 = 1 LIMIT 50
INSERT INTO t1 SELECT ST_GeomFromText(CONCAT('GEOMETRYCOLLECTION(POINT(1 1)', REPEAT(',POINT(1 1)', 100), ')'))
INSERT INTO t1 SELECT ST_GeomFromText(CONCAT('GEOMETRYCOLLECTION(POINT(1 1)', REPEAT(',POINT(1 1)', 100), ')')) FROM t1
INSERT INTO t1 SELECT ST_GeomFromText(CONCAT('GEOMETRYCOLLECTION(POINT(1 1)', REPEAT(',POINT(1 1)', 100), ')')) FROM t1
RIGHT OUTER JOIN (VALUES ROW(4), ROW(5)) AS const_table ON TRUE WHERE NOT EXISTS ( SELECT t1.col1 FROM t1 INNER JOIN t1 AS t1_2 ON t1_2.col1 = t1.col1 WHERE t1.col1 <> t2.col1 ) AND t2.col1 < 49
WHERE (t1.a,t2.a) IN (SELECT a, a FROM t3)
WHERE t1.aid NOT IN (SELECT aid FROM t2 WHERE bid = t1.bid)
WHERE 1 IN (SELECT 1 FROM t2 WHERE t1.col1 = t2.col1) IS FALSE
LEFT JOIN ( t2 LEFT JOIN t3 ON t2.col1 = t3.col1) ON t2.col1 = t1.col1 ORDER BY t1.col1, t2.col1, t3.col1
t1 LEFT JOIN ( t2 LEFT JOIN ( t3 LEFT JOIN t4 ON t4.i = t3.i ) ON t3.i = t2.i ) ON t2.i = t1.i
ON t1.col1 = t2.col1
tt.t FROM (SELECT 'crash1' AS t, f2 FROM t1) AS tt LEFT JOIN t1 ON tt.t = 'crash2' AND tt.f2 = t1.f2 WHERE tt.t = 'crash1'
WHERE (SELECT a, b FROM t1 WHERE table1.a <> 6) IN (SELECT a, b FROM t1)
WHERE (SELECT a FROM t1 WHERE table1.a <> 6) IN (SELECT a FROM t1)
INSERT INTO t VALUES(1, REPEAT('abs',1000))
INSERT INTO t VALUES(2, REPEAT('ajs',1000))
INSERT INTO t VALUES(3, REPEAT('ajj',1000))
INSERT INTO t VALUES(4, REPEAT('jjs',1000))
WHERE USER != 'event_scheduler'`
do concat('111','11111111111111111111111111', substring_index(uuid(),0,1.111111e+308))
do concat_ws(',','111','11111111111111111111111111', substring_index(uuid(),0,1.111111e+308))
LOCK TABLE t1 WRITE
LOCK TABLE t1 READ
unlock tables
LOCK TABLE t1 WRITE,t2 write
lock tables t1 write, t2 read
unlock tables
lock tables t1 write
unlock tables
lock tables t1 write, t1 as t1_alias read
unlock tables
lock table t1 write, t2 write
unlock tables
LOCK TABLES m1 WRITE
FLUSH TABLE m1
UNLOCK TABLES
sum(distinct(if('a', (select adddate(elt(convert($nines,decimal(64,0)),count(*)), interval 1 day)) , .1))) as foo
SELECT g.calc_var, g.if_var, g.case_var FROM ( SELECT unq_id, IF ( var_fld  > 5000, (     1 / var_fld ) , 5000 ) calc_var, IF ( var_fld  > 5000, ( 00001 / var_fld ) , 5000 ) if_var, CASE  var_fld  > 5000 WHEN TRUE THEN ( 1 / var_fld ) ELSE 5000 END case_var FROM test_grids_1 ) g JOIN test_grid_dtl_1 d USING (unq_id) ORDER BY 1
DO NULLIF(CAST(DATABASE() AS TIME), 1)
DO NULLIF(CAST(DATABASE() AS DATE), 1)
DO NULLIF(CAST(DATABASE() AS DATETIME), 1)
DO GROUP_CONCAT(NULLIF(ELT(1, @e), POINT(250,41)) ORDER BY 1)
PREPARE ps FROM 'INSERT INTO t SET t_date = NULLIF(?, '''')'
EXECUTE ps USING @t_date
DEALLOCATE PREPARE ps
CALL mtr.add_suppression('Found \\d+ sys .*, but expected \\d+. Re-installing the sys schema.')
CALL mtr.add_suppression("'NO_ZERO_DATE', 'NO_ZERO_IN_DATE' and 'ERROR_FOR_DIVISION_BY_ZERO' sql modes should be used with strict mode. They will be merged with strict mode in a future release.")
CALL mtr.add_suppression("Cannot load from .* The table is probably corrupted")
PREPARE stmt FROM 'UPDATE t1, (SELECT DISTINCT b FROM t1 t1i) d SET a = 0 WHERE 1=0'
PREPARE stmt FROM 'UPDATE t1, ((SELECT 1 FROM t1 t1i) UNION (SELECT 2 FROM t1 t1ii)) e SET a = 0 WHERE 1=0'
CREATE PROCEDURE bug11758414() BEGIN SET @@GLOBAL.default_storage_engine="MyISAM"; SET @@SESSION.default_storage_engine="MyISAM"; SHOW GLOBAL VARIABLES LIKE 'default_storage_engine'; SHOW SESSION VARIABLES LIKE 'default_storage_engine'; CREATE TABLE t1 (id int); CREATE TABLE t2 (id int) ENGINE=InnoDB; SHOW CREATE TABLE t1; SHOW CREATE TABLE t2; END;
LOCK TABLES t1 WRITE
create procedure proc_1() install plugin my_plug soname '/root/some_plugin.so'
prepare abc from "install plugin my_plug soname '/root/some_plugin.so'"
execute abc
execute abc
deallocate prepare abc
call mtr.add_suppression("Got an error from thread_id=.*ha_myisam.cc:")
call mtr.add_suppression("MySQL thread id .*, query id .* localhost.*root Checking table")
call mtr.add_suppression(" '\..test.t1'")
create procedure p_create() begin declare i int default 1; set @lock_table_stmt="lock table "; set @drop_table_stmt="drop table "; while i < @@global.table_definition_cache + 1 do set @table_name=concat("t_", i); set @opt_comma=if(i=1, "", ", "); set @lock_table_stmt=concat(@lock_table_stmt, @opt_comma, @table_name, " read"); set @drop_table_stmt=concat(@drop_table_stmt, @opt_comma, @table_name); set @create_table_stmt=concat("create table if not exists ", @table_name, " (a int)"); prepare stmt from @create_table_stmt; execute stmt; deallocate prepare stmt; set i= i+1; end while; end
flush table t1
flush table t1
unlock tables
prepare stmt from @drop_table_stmt
execute stmt
deallocate prepare stmt
flush table t1
flush table t1
SELECT attrs.* FROM t_json, JSON_TABLE(json_col, '$[*]' COLUMNS (nickname JSON PATH '$.nickname')) as attrs
call mtr.add_suppression(" In RENAME TABLE table `test`.`parent` is referenced in foreign key constraints which are not compatible with the new table definition.")
create table t_34455 ( a int not null, create table t_34455 ( a int not null, create table t_34455 ( a int not null, create table t_34455 ( a int not null, foreign key (a) references t3 (a) create table t_34455 ( a int not null, foreign key (a) references t3 (a) create table t_34455 (a int not null)
alter table t_34455 alter table t_34455 alter table t_34455 alter table t_34455 add foreign key (a) references t3 (a) alter table t_34455 add foreign key (a) references t3 (a) drop table t_34455
RENAME TABLE t5 to t6
RENAME TABLE t5 TO t6
RENAME TABLE t6 TO t2
RENAME TABLE t2 TO t3
RENAME TABLE t3 TO t4
RENAME TABLE t2 TO t123456789012345678901234567890123456789012345678901234567
RENAME TABLE t2 TO t12345678901234567890123456789012345678901234567890123456
CREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=0
LOCK TABLE parent WRITE
UNLOCK TABLES
LOCK TABLES parent WRITE
UNLOCK TABLES
LOCK TABLE parent2 WRITE
UNLOCK TABLES
LOCK TABLE parent WRITE
UNLOCK TABLES
LOCK TABLE parent WRITE
UNLOCK TABLES
LOCK TABLE parent WRITE
UNLOCK TABLES
RENAME TABLES child1 TO child
RENAME TABLES child TO child1
RENAME TABLES parent1 TO parent
RENAME TABLES parent TO parent1
RENAME TABLES parent1 TO parent
RENAME TABLES parent TO parent1
RENAME TABLES child TO child1
LOCK TABLE parent WRITE
UNLOCK TABLES
RENAME TABLES child1 TO child
RENAME TABLES parent1 TO parent
RENAME TABLES parent1 TO parent
LOCK TABLE parent WRITE
UNLOCK TABLES
LOCK TABLE parent WRITE
UNLOCK TABLES
LOCK TABLE parent WRITE
UNLOCK TABLES
LOCK TABLE parent WRITE
UNLOCK TABLES
RENAME TABLES child1 TO child
RENAME TABLES parent1 TO parent
RENAME TABLES parent1 TO parent
LOCK TABLE parent WRITE
UNLOCK TABLES
LOCK TABLE parent WRITE
UNLOCK TABLES
LOCK TABLE parent WRITE
UNLOCK TABLES
LOCK TABLE parent WRITE
UNLOCK TABLES
RENAME TABLES child1 TO child
RENAME TABLES parent1 TO parent
RENAME TABLES parent1 TO parent
LOCK TABLE parent WRITE
UNLOCK TABLES
LOCK TABLE parent WRITE
UNLOCK TABLE
LOCK TABLE parent WRITE
UNLOCK TABLE
LOCK TABLES child WRITE, parent WRITE
UNLOCK TABLES
LOCK TABLES child WRITE
UNLOCK TABLES
LOCK TABLES child WRITE, parent READ
UNLOCK TABLES
LOCK TABLES child WRITE
UNLOCK TABLES
LOCK TABLES parent WRITE
UNLOCK TABLES
LOCK TABLES child1 WRITE, parent1 WRITE
UNLOCK TABLES
LOCK TABLES child WRITE, parent1 WRITE
UNLOCK TABLES
LOCK TABLES child WRITE, parent WRITE
UNLOCK TABLES
LOCK TABLE parent WRITE
UNLOCK TABLES
LOCK TABLE parent WRITE, child READ
UNLOCK TABLES
LOCK TABLE parent WRITE, child WRITE
UNLOCK TABLES
HANDLER t1 OPEN
HANDLER t1 CLOSE
HANDLER t1 OPEN AS a
HANDLER t1 OPEN AS b
HANDLER a CLOSE
HANDLER b CLOSE
HANDLER t2 OPEN
HANDLER t3 OPEN AS a
HANDLER t3 OPEN AS b
HANDLER t2 CLOSE
HANDLER a CLOSE
HANDLER b CLOSE
HANDLER t2 OPEN
HANDLER t3 OPEN AS a
HANDLER t3 OPEN AS b
HANDLER t2 CLOSE
HANDLER a CLOSE
HANDLER b CLOSE
HANDLER t2 OPEN
HANDLER t3 OPEN AS a
HANDLER t3 OPEN AS b
PREPARE stmt FROM 'INSERT INTO t3 VALUES (1)'
EXECUTE stmt
EXECUTE stmt
EXECUTE stmt
EXECUTE stmt
DEALLOCATE PREPARE stmt
LOCK TABLE t1 READ
UNLOCK TABLES
LOCK TABLES t0 WRITE
UNLOCK TABLES
RENAME TABLE t2 TO t3
RENAME TABLE t3 TO mysqltest.t3
RENAME TABLE mysqltest.t3 TO t4
RENAME TABLE T2 TO T3
RENAME TABLE parent1 TO parent
RENAME TABLE parent1 TO parent
RENAME TABLE parent0 TO parent
RENAME TABLE parent0 TO parent
RENAME TABLE parent0 TO parent
RENAME TABLE parent0 TO parent
PREPARE stmt1 FROM 'ALTER TABLE child ADD FOREIGN KEY (fk) REFERENCES parent (pk)'
EXECUTE stmt1
EXECUTE stmt1
DEALLOCATE PREPARE stmt1
ALTER TABLE child ADD CONSTRAINT c2 FOREIGN KEY (fk) REFERENCES parent /*! (id) */ /*!40008 ON DELETE SET NULL */
/*!50101 CREATE TABLE child (fk INT, FOREIGN KEY (fk) REFERENCES parent(pk)) */
/*! ALTER TABLE child ADD FOREIGN KEY (fk) REFERENCES parent(pk) */
CALL mtr.add_suppression("Master's UUID has changed, its old UUID is")
[auto] CREATE TABLE t1(a int) TABLESPACE ts ENGINE=MyISAM
CREATE TABLESPACE ts ADD DATAFILE 'f.ibd' ENGINE InnoDB
CREATE TABLESPACE ts1 ADD DATAFILE 'df1.ibd' ENGINE=InnoDB
SET @start_value= @@global.syseventlog.facility
SELECT @@global.syseventlog.facility, @start_value
SELECT @@global.syseventlog.facility
SELECT @@global.syseventlog.facility
SELECT @@global.syseventlog.facility
SELECT @@global.syseventlog.facility
SELECT @@global.syseventlog.facility
SET @start_value= @@global.syseventlog.include_pid
SELECT @@global.syseventlog.include_pid
SELECT @@global.syseventlog.include_pid
SELECT @@global.syseventlog.include_pid
SELECT @@global.syseventlog.include_pid
SELECT @@global.syseventlog.include_pid
SELECT @@global.syseventlog.include_pid
SET @start_value= @@global.syseventlog.tag
SELECT @@global.syseventlog.tag
SELECT @@global.syseventlog.tag
SELECT @@global.syseventlog.tag
call mysqltest.sp1()
create function f1(ab int) returns int begin declare i int; set i= (select max(a) from t1 where a < ab) ; return i; end
create function f2(ab int) returns int begin declare i int; set i= (select max(a) from t2 where a < ab) ; return i; end
create procedure sp1() begin declare a int; set a= (select f1(4) + count(*) A from t1, v1); end
create procedure sp1() begin declare x int; declare c cursor for select f1(3) + count(*) from v1; open c; fetch c into x; end;
prepare stmt from "select bug15683()"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "delete t1 from t1, t2 where t1.id = t2.id and bug19634()"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "delete t1 from t1, t2 where t1.id = t2.id"
execute stmt
execute stmt
deallocate prepare stmt
LOCK TABLE t1 WRITE
UNLOCK TABLES
LOCK TABLE t1 READ
UNLOCK TABLES
PREPARE stmt1 FROM "CREATE TEMPORARY TABLE tmp2 AS SELECT b FROM (SELECT f1() AS b FROM tmp1) AS t"
EXECUTE stmt1
DEALLOCATE PREPARE stmt1
LET $ID= `SELECT connection_id()`
enable_connect_log
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
query_vertical SELECT command_type, argument FROM mysql.general_log WHERE command_type='Query'
disable_connect_log
do nullif( ( rtrim( make_set((cast(('%S') as unsigned)), (point((0xaf),('')))) ) ), (''))
do dayofmonth( ( not( trim( trailing( convert((''), binary(4))) from( make_set( ('>>'), ('`')))) )))
do quote(make_set((''), (cast(('-2147483649.1') as binary(513)))))
do trim( both(-8388607) from( make_set( ( extract( minute_second from ( str_to_date((rpad(1.0,4,1)), (''))) ) ), ( char((connection_id()) using macce))) ) )
SELECT 1 IN (SELECT MAKE_SET(-1, 1, (SELECT 1 FROM t)) FROM t)
write_file $BOOTSTRAP_SQL
perl
my $log= $ENV{'ENV_MYSQLD_LOG'} or die
open(FILE, "$log") or die
my $c_w= grep(/No data dictionary version number found./gi,<FILE>)
print "#     Data Dictionary initialization error found $c_w times.\n"
close(FILE)
remove_file $BOOTSTRAP_SQL
write_file $BOOTSTRAP_SQL
perl
my $log= $ENV{'ENV_MYSQLD_LOG'} or die
open(FILE, "$log") or die
my $c_w= grep(/The used command is not allowed with this MySQL version/gi,<FILE>)
print "#     Data Dictionary initialization error found $c_w times.\n"
close(FILE)
remove_file $BOOTSTRAP_SQL
write_file $BOOTSTRAP_SQL
perl
my $log= $ENV{'ENV_MYSQLD_LOG'} or die
open(FILE, "$log") or die
my $c_w= grep(/The used command is not allowed with this MySQL version/gi,<FILE>)
print "#     Data Dictionary initialization error found $c_w times.\n"
close(FILE)
remove_file $BOOTSTRAP_SQL
write_file $BOOTSTRAP_SQL
remove_file $BOOTSTRAP_SQL
write_file $BOOTSTRAP_SQL
perl
my $log= $ENV{'ENV_MYSQLD_LOG'} or die
open(FILE, "$log") or die
my $c_w= grep(/Access to data dictionary table \'mysql.st_spatial_reference_systems\' is rejected/gi,<FILE>)
print "#     Data Dictionary table access error found $c_w times.\n"
close(FILE)
remove_file $BOOTSTRAP_SQL
write_file $BOOTSTRAP_SQL
perl
my $log= $ENV{'ENV_MYSQLD_LOG'} or die
open(FILE, "$log") or die
my $c_w= grep(/Access to data dictionary table \'mysql.tables\' is rejected/gi,<FILE>)
print "#     Data Dictionary initialization error found $c_w times.\n"
close(FILE)
remove_file $BOOTSTRAP_SQL
write_file $BOOTSTRAP_SQL
remove_file $BOOTSTRAP_SQL
remove_file $MYSQLD_LOG
remove_file $MYSQLD_LOG
abcd CREATE TABLE t1 (id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, name TINYBLOB NOT NULL, modified TIMESTAMP DEFAULT '0000-00-00 00:00:00', INDEX namelocs (name(255))) ENGINE = InnoDB PARTITION BY HASH(id) PARTITIONS 2
INTO TABLE t1 (name)
select insert(_utf16 0x006100620063,10,2,_utf16 0x006400650066)
select insert(_utf16 0x006100620063,1,2,_utf16 0x006400650066)
prepare stmt1 from @str2
execute stmt1 using @ivar
prepare stmt from 'select utext from t1 where utext like ?'
execute stmt using @param1
execute stmt using @param1
deallocate prepare stmt
prepare stmt from 'select utext from t1 where utext like ?'
execute stmt using @param1
execute stmt using @param1
deallocate prepare stmt
CREATE TABLE t1 AS SELECT repeat('a',2) as s1 LIMIT 0
SELECT id, CHAR_LENGTH(GROUP_CONCAT(body)) AS l FROM (SELECT 'a' AS id, REPEAT('foo bar', 100) AS body UNION ALL SELECT 'a' AS id, REPEAT('bla bla', 100) AS body) t1 GROUP BY id ORDER BY l DESC
PREPARE s1 FROM "SELECT HEX(b & c), HEX(b & 0x31393838), b & NULL, HEX(b & 0b00000000000000000000000000001011), HEX(0x31393838 & b), NULL & b, HEX(0b00000000000000000000000000001011 & b), HEX(b | c), HEX(b | 0x31393838), b | NULL, HEX(b | 0b00000000000000000000000000001011), HEX(0x31393838 | b), NULL | b, HEX(0b00000000000000000000000000001011 | b), HEX(b ^ c), HEX(b ^ 0x31393838), b ^ NULL, HEX(b ^ 0b00000000000000000000000000001011), HEX(0x31393838 ^ b), NULL ^ b, HEX(0b00000000000000000000000000001011 ^ b), BIT_COUNT(b), HEX( ~b), HEX(b << 1), HEX(b >> 1) FROM t1;"
EXECUTE s1
EXECUTE s1
PREPARE s2 from "SELECT HEX(BIT_AND(b)), HEX(BIT_OR(b)), HEX(BIT_XOR(b)) FROM t1 GROUP BY a"
EXECUTE s2
EXECUTE s2
PREPARE s2 from "SELECT HEX(BIT_AND(b)), HEX(BIT_OR(b)), HEX(BIT_XOR(b)) FROM t1"
EXECUTE s2
EXECUTE s2
SELECT _binary '12' | '12'
SELECT _binary '12' | _binary '12'
SELECT _binary '12' | 0x0001
SELECT _binary '12' | 1
SELECT _binary '12' << 1
PREPARE ps FROM 'SELECT (~?)'
SET @a:=0
EXECUTE ps USING @a
SET @a:='abcd'
EXECUTE ps USING @a
SET @a:=_binary 'abcd'
EXECUTE ps USING @a
SET @a:=34
EXECUTE ps USING @a
SELECT (_binary x'31' | x'31')
SELECT _binary '1' + 0
SELECT (_binary x'31' | x'31') + 0
SELECT 1.0 * (_binary x'312E35' | x'312E35')
SELECT HEX(_binary 0x0003 << (_binary 0x38 | NULL))
SELECT (_binary x'31' | NULL) + 0
SELECT DATEDIFF((_binary '2012-05-19 09:06:07' | _binary '2012-05-19 09:06:07'), '2012-05-21 09:06:07')
SELECT SUBTIME((_binary '2012-05-19 09:06:07' | _binary '2012-05-19 09:06:07'),'1 1:1:1.000002')
SELECT DATEDIFF((_binary '12012-05-19 09:06:07' | _binary '12012-05-19 09:06:07'), '2012-05-21 09:06:07')
SELECT SUBTIME((_binary '12007-12-31 23:59:59.999999' | _binary '12007-12-31 23:59:59.999999'),'1 1:1:1.000002')
SELECT * FROM (VALUES ROW(1),ROW(1)) AS dt(a) WHERE EXISTS( WITH RECURSIVE qn AS (SELECT a*0 AS b UNION ALL SELECT b+1 FROM qn WHERE b=0) SELECT * FROM qn WHERE b=a )
SELECT * FROM (VALUES ROW(1),ROW(1)) AS dt(a) WHERE NOT EXISTS( WITH RECURSIVE qn AS (SELECT a*0 AS b UNION ALL SELECT b+1 FROM qn WHERE b=0) SELECT * FROM qn WHERE b=a )
select 1ea10.1a20,1e+ 1e+10 from 1ea10
create table `` (a int)
drop table if exists ``
create table t1 (`` int)
create table t1 (i int, index `` (i))
lock tables t1 read
unlock tables
create table t1 (a int,)
create table t1 (a int,,b int)
create table t1 (,b int)
lock tables t1 read
unlock tables
create table t2 select default(str) as str, default(strnull) as strnull, default(intg) as intg, default(rel) as rel from t1
unlock tables
show create database mysqltest
lock tables t1 read
unlock tables
lock tables t1 read
unlock tables
lock table t1 read, t2 read
unlock tables
lock table t1 read, t2 write
unlock tables
lock tables t1 read
unlock tables
CREATE TABLE t1(c1 VARCHAR(33), KEY USING BTREE (c1))
CREATE TABLE t1(c1 VARCHAR(33), KEY USING BTREE (c1) USING HASH) ENGINE=MEMORY
CREATE TABLE t1(c1 VARCHAR(33), KEY USING HASH (c1) USING BTREE) ENGINE=MEMORY
SHOW CREATE DATABASE aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
create database Ð¸Ð¼Ñ_Ð±Ð°Ð·Ñ‹_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_45
use Ð¸Ð¼Ñ_Ð±Ð°Ð·Ñ‹_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_45
drop database Ð¸Ð¼Ñ_Ð±Ð°Ð·Ñ‹_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_45
create table Ð¸Ð¼Ñ_Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñ‹_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_48 ( Ð¸Ð¼Ñ_Ð¿Ð¾Ð»Ñ_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_45 int, index Ð¸Ð¼Ñ_Ð¸Ð½Ð´ÐµÐºÑÐ°_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_48 (Ð¸Ð¼Ñ_Ð¿Ð¾Ð»Ñ_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_45) )
create view Ð¸Ð¼Ñ_Ð²ÑŒÑŽ_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_42 as select Ð¸Ð¼Ñ_Ð¿Ð¾Ð»Ñ_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_45 from Ð¸Ð¼Ñ_Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñ‹_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_48
select * from Ð¸Ð¼Ñ_Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñ‹_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_48
show create table Ð¸Ð¼Ñ_Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñ‹_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_48
show create view Ð¸Ð¼Ñ_Ð²ÑŒÑŽ_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_42
create trigger Ð¸Ð¼Ñ_Ñ‚Ñ€Ð¸Ð³Ð³ÐµÑ€Ð°_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_49 before insert on Ð¸Ð¼Ñ_Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñ‹_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_48 for each row set @a:=1
drop trigger Ð¸Ð¼Ñ_Ñ‚Ñ€Ð¸Ð³Ð³ÐµÑ€Ð°_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_49
create trigger Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_66 before insert on Ð¸Ð¼Ñ_Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñ‹_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_48 for each row set @a:=1
drop trigger Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_66
create procedure Ð¸Ð¼Ñ_Ð¿Ñ€Ð¾Ñ†ÐµÐ´ÑƒÑ€Ñ‹_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_50() begin end
drop procedure Ð¸Ð¼Ñ_Ð¿Ñ€Ð¾Ñ†ÐµÐ´ÑƒÑ€Ñ‹_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_50
create procedure Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_66() begin end
create function Ð¸Ð¼Ñ_Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_49() returns int return 0
drop function Ð¸Ð¼Ñ_Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_49
create function Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_66() returns int return 0
drop view Ð¸Ð¼Ñ_Ð²ÑŒÑŽ_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_42
drop table Ð¸Ð¼Ñ_Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñ‹_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_48
create function f1() returns int begin declare res int
set res:= (select count(*) from t1)
return res
end| create table t1 as select 1
CREATE TRIGGER f BEFORE INSERT ON t1 FOR EACH ROW BEGIN INSERT INTO t1 ( `int` ) VALUES (4 ),( 8 ),( 2 )
END ; | INSERT INTO t1 (pk, int_key) SELECT `pk` , `int_key` FROM B
CREATE TRIGGER f BEFORE INSERT ON t1 FOR EACH ROW BEGIN UPDATE A SET `pk`=1 WHERE `pk`=0
END ;| DROP TABLE t1
HANDLER t1 OPEN AS A
HANDLER t1 OPEN AS A
HANDLER t1 OPEN AS A
CREATE TABLE t4( c0 DECIMAL ZEROFILL  UNIQUE KEY STORAGE MEMORY, c1 DECIMAL ZEROFILL  PRIMARY KEY COLUMN_FORMAT DYNAMIC UNIQUE KEY STORAGE MEMORY NOT NULL, c2 FLOAT ZEROFILL  COMMENT 'asdf'  COLUMN_FORMAT FIXED NULL STORAGE MEMORY, c3 TINYINT(120) ZEROFILL   STORAGE DISK UNIQUE KEY NULL COMMENT 'asdf' CREATE TABLE t1(a INT) ENGINE=myisam key_block_size=65535
source include/have_log_bin.inc
CALL mtr.add_suppression("Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT.")
CALL mtr.add_suppression("REVOKE/GRANT failed while storing table level " "and column level grants in the privilege " "tables. An incident event has been written to " "the binary log which will stop the slaves.")
CALL mtr.add_suppression("REVOKE/GRANT failed while granting/revoking " "privileges in databases. An incident event " "has been written to the binary log which " "will stop the slaves.")
delete from mysql.user where user=_binary'mysqltest_1'
disable_query_log
enable_query_log
disable_query_log
enable_query_log
LOCK TABLES t1 write, t2 read
unlock tables
LOCK TABLES t1 write, t2 write
unlock tables
delete from mysql.user where user=_binary'mysqltest_1'
lock table t1 write
send alter table t1 add column c int default 100 after a
where state= 'Waiting for table metadata lock'
send update t1, v1 set t1.b=t1.a+t1.b+v1.b where t1.a=v1.a
where state= 'Waiting for table metadata lock'
unlock tables
reap
reap
WHERE t1.c1=t2.c2 AND t2.c1=t3.c2
UPDATE (VALUES ROW(1),ROW(2)) AS dt(a) LEFT JOIN performance_schema.setup_instruments ON dt.a=enabled SET enabled = 'YES' WHERE name = 'wait/lock/metadata/sql/mdl'
PREPARE s FROM 'UPDATE t1, (SELECT 1 FROM DUAL) AS dt SET a=a+1'
EXECUTE s
EXECUTE s
DEALLOCATE PREPARE s
INSERT INTO t1 VALUES(default(a),default(b), default(c), default(d), default(e), default(f))
CREATE PROCEDURE t_cache() BEGIN SET @A= 20; SELECT * FROM t1; SELECT * FROM t1; PREPARE x FROM 'SELECT 1'; SELECT * FROM t1; SELECT * FROM t1; END ;
SHOW GRANTS FOR bug23721446_u1@'%'
SHOW GRANTS FOR bug23721446_u2@'%'
SHOW GRANTS FOR bug23721446_u1@'%'
SHOW GRANTS FOR bug23721446_u2@'%'
CREATE TABLESPACE `mytbsp` ADD DATAFILE 'mytbsp.ibd' ENGINE INNODB
CREATE VIEW V_T1_C AS SELECT DB29023216.TESTFUNC()
CREATE TABLE t1(f1 INT INVISIBLE, f2 INT, f3 INT AS (f1 + 10), f4 INT AS (f2 + 10) INVISIBLE)
remove_file $MYSQLTEST_VARDIR/tmp/test1.sql
CREATE FUNCTION test_fn() RETURNS INTEGER BEGIN DECLARE rId bigint; RETURN rId; END
CREATE FUNCTION test_fn2() RETURNS INTEGER BEGIN DECLARE rId bigint; RETURN rId; END
create procedure proc_1() install plugin my_plug soname '\\root\\some_plugin.dll'
prepare abc from "install plugin my_plug soname '\\\\root\\\\some_plugin.dll'"
execute abc
execute abc
deallocate prepare abc
CALL mtr.add_suppression("innodb_open_files should not be greater than the open_files_limit.")
CALL mtr.add_suppression("You must raise the value of innodb_open_files in my.cnf! Remember that InnoDB keeps all")
CALL mtr.add_suppression("log files and all system tablespace files open for the whole time mysqld is running, and");CALL mtr.add_suppression("needs to open also some .ibd files if the file-per-table storage model is used. Current open files .*, max allowed open files 1.")
CALL mtr.add_suppression("Too many (.*) files stay open while the maximum allowed value would be 1. You may need to raise the value of innodb_open_files in my.cnf.")
CALL mtr.add_suppression("Open files 7 exceeds the limit 1")
echo '#________________________VAR_05_table_open_cache__________________#' echo '##' SELECT COUNT(@@GLOBAL.table_open_cache)
CREATE PROCEDURE sp1(OUT x INT) BEGIN SELECT MIN(a) INTO x FROM t1; END
CREATE FUNCTION f2() RETURNS int BEGIN DECLARE a int; SET @a=20; CALL sp1(a); RETURN a; END
CREATE FUNCTION f3() RETURNS int BEGIN DECLARE a, b int; DROP TEMPORARY TABLE IF EXISTS t3; CREATE TEMPORARY TABLE t3 (id INT); INSERT INTO t3 VALUES (1), (2), (3); SET a:= (SELECT COUNT(*) FROM t3); SET b:= (SELECT COUNT(*) FROM t3 t3_alias); RETURN a + b; END
CREATE FUNCTION f4() RETURNS int BEGIN DECLARE x int; DECLARE c CURSOR FOR SELECT * FROM t1 limit 1; SET NAMES 'utf8'; SET @var1=20; OPEN c; FETCH c INTO x; CLOSE c; RETURN x; END
CREATE PROCEDURE cursor1() BEGIN DECLARE v1 int; DECLARE done INT DEFAULT FALSE; DECLARE cur1 CURSOR FOR SELECT * FROM t1; DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; SET @@session.transaction_isolation='READ-COMMITTED'; OPEN cur1; read_loop: LOOP FETCH cur1 INTO v1; IF done THEN LEAVE read_loop; END IF; END LOOP; SELECT v1; CLOSE cur1; END
CREATE PROCEDURE cursor2() BEGIN DECLARE x int; DECLARE y int; DECLARE c1 CURSOR FOR SELECT * FROM t1 limit 1; DECLARE c2 CURSOR FOR SELECT * FROM t2 limit 1; SET @@session.transaction_isolation='READ-COMMITTED'; OPEN c1; OPEN c2; FETCH c1 INTO x; FETCH c2 INTO y; SELECT (x+y); SELECT "session state sent as part of above SELECT" AS col_heading; CLOSE c1; CLOSE c2; END
CREATE PROCEDURE t_cache() BEGIN SET @A= 20; SELECT * FROM t1; SELECT * FROM t1; PREPARE x FROM 'SELECT 1'; SELECT * FROM t1; SELECT * FROM t1; END
WHERE TIMEDIFF(end_ts,start_ts) - @sleep_time_per_result_row * @row_count BETWEEN 0 AND @max_acceptable_delay
create function func_26093_a(x int) returns int begin set @invoked := @invoked + 1; return x; end
create function func_26093_b(x int, y int) returns int begin set @invoked := @invoked + 1; return x; end
set @invoked := 0
set @invoked := 0
SELECT * FROM t1 WHERE a = NAME_CONST('reportDate', _binary'2009-01-09' COLLATE 'binary')
SELECT '1' IN ('1', INET_NTOA(0))
SELECT '1' IN ('1', INET_NTOA(0))
DO DATEDIFF(UUID_TO_BIN(UUID()), 0x32df2ce8)
DO (!(SECOND(0xb16beeb7)))
PREPARE st FROM "SELECT * FROM t1 WHERE pk = 5 AND (col_time, col_varchar) IN ((23, 'Y'), (92, 'W'))"
EXECUTE st
EXECUTE st
DEALLOCATE PREPARE st
do (is_ipv4_mapped(bin_to_uuid(@a:=34))) <=> (json_objectagg('key2',42 ) and rtrim(""))
WHERE info LIKE 'select%' AND state='User lock'
source include/wait_condition.inc
KILL QUERY @aux
reap
WHERE info LIKE 'select%' AND state='User sleep'
source include/wait_condition.inc
reap
WHERE id = $con1_id
source include/wait_condition.inc
WHERE info LIKE 'select%' AND state='User lock'
source include/wait_condition.inc
reap
LOCK TABLE t1 WRITE
UNLOCK TABLES
UNLOCK TABLES
WHERE info LIKE 'select%' AND state = 'User lock'
source include/wait_condition.inc
reap
WHERE info LIKE 'rename%' AND state = 'Waiting for table metadata lock'
source include/wait_condition.inc
reap
RENAME TABLE t2 TO t1
LOCK TABLE t1 WRITE
WHERE info LIKE 'select%' AND state = 'User lock'
source include/wait_condition.inc
reap
UNLOCK TABLES
WHERE info LIKE 'SET @aux%' AND state = 'User lock'
source include/wait_condition.inc
RENAME TABLE t1 TO t1x
RENAME TABLE t1x TO t1
reap
CREATE TRIGGER trig_t1_ins BEFORE INSERT ON t1 FOR EACH ROW BEGIN SET @aux = GET_LOCK(2,1)
IF @aux <> 1 THEN SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'LOCK 2 not got. Abort.', MYSQL_ERRNO = 9999
END IF
END;| SELECT GET_LOCK(CAST(2 AS CHAR),0)
WHERE info LIKE 'select%' AND state = 'User lock'
source include/wait_condition.inc
SELECT GET_LOCK(REPEAT('a', 64), 0) = 1 AS expect_1
SELECT IS_USED_LOCK(REPEAT('a', 64)) = CONNECTION_ID() AS expect_1
SELECT IS_FREE_LOCK(REPEAT('a', 64)) = 0 AS expect_1
SELECT RELEASE_LOCK(REPEAT('a', 64)) = 1 AS expect_1
SELECT GET_LOCK(REPEAT('a', 65), 0)
SELECT IS_USED_LOCK(REPEAT('a', 65))
SELECT IS_FREE_LOCK(REPEAT('a', 65))
SELECT RELEASE_LOCK(REPEAT('a', 65))
WHERE info LIKE 'select%' AND state = 'User lock'
source include/wait_condition.inc
reap
reap
create procedure fib(n int unsigned) begin if n > 1 then begin declare x, y bigint unsigned; declare c cursor for select f from t3 order by f desc limit 2; open c; fetch c into y; fetch c into x; insert into t3 values (x+y); call fib(n-1); close c; end; end if; end
delimiter
create procedure p1() begin declare counter integer default 0; declare continue handler for sqlexception begin set counter = counter + 1;end; repeat if rand()>0.5 then start transaction; end if; if rand()>0.5 then select count(*) from t1 for update; end if; update t1 set a = 1 where a >= 0; set counter = counter + 1; until counter >= 50 end repeat; end
( a int, b varchar(30), primary key(a) ) engine = $type
( c1  tinyint, c2  smallint, c3  mediumint, c4  int, c5  integer, c6  bigint, c7  float, c8  double, c9  double precision, c10 real, c11 decimal(7, 4), c12 numeric(8, 4), c13 date, c14 datetime, c15 timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, c16 time, c17 year, c18 tinyint, c19 bool, c20 char, c21 char(10), c22 varchar(30), c23 varchar(100), c24 varchar(100), c25 varchar(100), c26 varchar(100), c27 varchar(100), c28 varchar(100), c29 varchar(100), c30 varchar(100), c31 enum('one', 'two', 'three'), c32 set('monday', 'tuesday', 'wednesday'), primary key(c1) ) engine = $type
call mtr.add_suppression("Got an error from thread_id=.*ha_myisam.cc:")
call mtr.add_suppression("MySQL thread id .*, query id .* localhost.*root Checking table")
FLUSH TABLE t1
select a, not(not(a)) from t1
explain select a, not(not(a)), not(a <= 2 and not(a)), not(a not like "1"), not (a not in (1,2)), not(a != 2) from t1 where not(not(a)) having not(not(a))
BEGIN WORK
BEGIN WORK
RENAME TABLE t1 TO t1_new
RENAME TABLE t1_new TO t1
CREATE TABLE t1 ENGINE=MYISAM AS SELECT repeat('a', 5) AS s1 LIMIT 0
echo =============Test of '127.0.0.1' (IPv4) ===========================
echo =============Test of '0:0:0:0:0:FFFF:127.0.0.1' ===================
echo =============Test of '0000:0000:0000:0000:0000:FFFF:127.0.0.1' ====
echo =============Test of '0:0000:0000:0:0000:FFFF:127.0.0.1' ====
echo =============Test of '0::0000:FFFF:127.0.0.1' ====
echo =============Test of '0:0:0:0:0:FFFF:127.0.0.1/96' ================
echo =============Test of '::FFFF:127.0.0.1' ===========================
echo =============Test of '::FFFF:127.0.0.1/96' ========================
echo =============Test of '::1' ========================
disable_query_log
enable_query_log
prepare stmt1 from ' replace into t1 (a,a) select 100, ''hundred'' '
execute stmt
execute stmt
execute stmt
PREPARE st1 FROM 'INSERT INTO v2 (pk) VALUES ( 1 )'
EXECUTE st1
PREPARE st1 FROM "INSERT INTO v1 (pk) VALUES (2)"
EXECUTE st1
PREPARE stmt FROM "INSERT INTO v1 (col_blob, pk, col_varchar) SELECT col_blob, col_int, col_blob FROM t2 WHERE pk BETWEEN 7 AND 8 LIMIT 1"
EXECUTE stmt
EXECUTE stmt
EXECUTE stmt
DEALLOCATE PREPARE stmt
CREATE TABLE t1 ( Ã‘ INTEGER, N INTEGER, a INTEGER, b INTEGER, c INTEGER, d INTEGER, e INTEGER, f INTEGER, g INTEGER, h INTEGER, i INTEGER, j INTEGER, k INTEGER, l INTEGER, m INTEGER, na INTEGER, o INTEGER, p INTEGER, q INTEGER, r INTEGER, s INTEGER, t INTEGER, u INTEGER, v INTEGER, w INTEGER, x INTEGER, y INTEGER, z INTEGER, aa INTEGER, ab INTEGER, ac INTEGER, ad INTEGER )
INSERT INTO t1 (Ã‘, N) VALUES (1, 2)
WHERE USER != 'event_scheduler'`
where STATE = "User lock" and INFO = "update t1 set n = get_lock('mysqltest_lock', 100)"
where ID = (select connection_id()) and STATE = "Waiting for table level lock"
reap
SELECT a IN (SELECT a FROM t1) FROM t1 LIMIT 1
create function f1 (x INTEGER) returns integer begin declare ret integer; set ret = x * 10; return ret; end
CREATE FUNCTION f1() RETURNS INTEGER BEGIN DECLARE foo INTEGER; DECLARE bar INTEGER; SET foo=1; SET bar=2; RETURN foo; END
CREATE PROCEDURE proc_19194_codegen( IN proc_name VARCHAR(50), IN count INTEGER, IN simple INTEGER, OUT body MEDIUMTEXT) BEGIN DECLARE code MEDIUMTEXT; DECLARE i INT DEFAULT 1; SET code = concat("CREATE PROCEDURE ", proc_name, "(i INT)\n"); SET code = concat(code, "BEGIN\n"); SET code = concat(code, "  DECLARE str CHAR(10);\n"); IF (simple) THEN SET code = concat(code, "  CASE i\n"); ELSE SET code = concat(code, "  CASE\n"); END IF; WHILE (i <= count) DO IF (simple) THEN SET code = concat(code, "    WHEN ", i, " THEN SET str=\"", i, "\";\n"); ELSE SET code = concat(code, "    WHEN i=", i, " THEN SET str=\"", i, "\";\n"); END IF; SET i = i + 1; END WHILE; SET code = concat(code, "    ELSE SET str=\"unknown\";\n"); SET code = concat(code, "  END CASE;\n"); SET code = concat(code, "  SELECT str;\n"); SET code = concat(code, "END\n"); SET body = code; END
begin work
begin work
begin work
begin work
begin work
begin work
begin work
begin work
begin work
begin work
begin work
begin work
begin work
PREPARE stmt1 FROM "SELECT /*+ BKA(t2) */ t2.f1, t2.f2, t2.f3 FROM t1,t2 WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1"
EXECUTE stmt1
EXECUTE stmt1
DEALLOCATE PREPARE stmt1
PREPARE stmt1 FROM "SELECT /*+ BKA(@qb1 t2) */ * FROM (SELECT /*+ QB_NAME(QB1) */ t2.f1, t2.f2, t2.f3 FROM t1,t2 WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1) AS s1"
EXECUTE stmt1
EXECUTE stmt1
DEALLOCATE PREPARE stmt1
call mtr.add_suppression('Can not read and process value of User_attributes column from mysql.user table for user')
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
remove_file $file
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
GRANT PROXY ON proxied_to_user@localhost TO proxy_user@localhost
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
change_user foo,,test
enable_query_log
disable_query_log
change_user foo,,test
enable_query_log
disable_query_log
change_user foo,,test
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
ALTER USER foo@localhost ATTRIBUTE "{ \"test\": \"account locking\" }"
ALTER USER foo@localhost COMMENT "This is a test account for verifying that password locking and user attributes won't interfer with one and another."
disable_query_log
change_user foo,,test
enable_query_log
disable_query_log
change_user foo,,test
enable_query_log
disable_query_log
change_user foo,,test
enable_query_log
CREATE PROCEDURE p1() BEGIN SET @@SESSION.GTID_NEXT = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:2'; START TRANSACTION; COMMIT; SET @@SESSION.GTID_NEXT = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:3'; START TRANSACTION; COMMIT; END
source include/func_aes_block.inc
UPDATE t1 set data=repeat('a',18*1024*1024)
INSERT INTO t1 (data) VALUES (repeat('a',1*1024*1024))
INSERT INTO t1 (data) VALUES (repeat('b',16*1024*1024-1024))
UPDATE t1 set data=repeat('c',17*1024*1024)
INSERT INTO t1 set data=repeat('a',18*1024*1024)
UPDATE IGNORE t1 set data=repeat('a',18*1024*1024)
where event_name='event_2' and status='DISABLED'
where event_name='event_3'
where event_name='event_4' and status='DISABLED'
RENAME TABLE child TO siebling
LOCK TABLES parent WRITE
UNLOCK TABLES
PREPARE stmt FROM 'DELETE FROM parent WHERE pk = ?'
EXECUTE stmt USING @a
EXECUTE stmt USING @a
EXECUTE stmt USING @a
RENAME TABLE parent TO mother, mother TO father
RENAME TABLE child TO sister, sister TO brother
RENAME TABLE father TO mother, brother TO sister, mother TO parent, sister TO child
RENAME TABLE parent TO mother, mother TO father
RENAME TABLE parent TO mother
SELECT CURRENT_TIME(6) RLIKE '^[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{6}$'
SELECT CURRENT_TIMESTAMP(6) RLIKE '^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{6}$'
SELECT MICROSECOND(CURRENT_TIME(6))=MICROSECOND(UTC_TIME(6))
CREATE TABLE t1 AS SELECT CONCAT(CURRENT_TIME()), CONCAT(CURRENT_TIME(6)), CONCAT(UTC_TIME()), CONCAT(UTC_TIME(6)), CONCAT(CURRENT_TIMESTAMP()), CONCAT(CURRENT_TIMESTAMP(6)), CONCAT(UTC_TIMESTAMP()), CONCAT(UTC_TIMESTAMP(6)), CONCAT(LOCALTIME()), CONCAT(LOCALTIME(6)), CONCAT(LOCALTIMESTAMP()), CONCAT(LOCALTIMESTAMP(6)), CONCAT(SYSDATE()), CONCAT(SYSDATE(6))
PREPARE stmt FROM 'INSERT INTO t1 VALUES (?)'
EXECUTE stmt USING @a
DEALLOCATE PREPARE stmt
PREPARE stmt FROM 'SELECT * FROM t1 WHERE a=?'
EXECUTE stmt USING @a
EXECUTE stmt USING @b
EXECUTE stmt USING @c
DEALLOCATE PREPARE stmt
CREATE PROCEDURE p1 () BEGIN DECLARE a TIME(6); SET a='11:22:33.123'; SELECT a; END
CREATE PROCEDURE p1() BEGIN DECLARE a TIME(6); CREATE TABLE t1 AS SELECT a; SHOW CREATE TABLE t1; DROP TABLE t1; END
query_vertical SELECT CAST('10:10:10.9999994' AS TIME), CAST('10:10:10.9999995' AS TIME), CAST('10:10:10.9999994' AS TIME(6)), CAST('10:10:10.9999995' AS TIME(6)), CAST(101010.9999994 AS TIME), CAST(101010.9999995 AS TIME), CAST(101010.9999994 AS TIME(6)), CAST(101010.9999995 AS TIME(6))
query_vertical SELECT EXTRACT(MICROSECOND FROM '00:00:00.9999994'), EXTRACT(MICROSECOND FROM '00:00:00.9999995'), EXTRACT(MICROSECOND FROM 0.9999994), EXTRACT(MICROSECOND FROM 0.9999995)
query_vertical SELECT CAST(bi AS DATETIME(1)), CAST(d AS DATETIME(1)), CAST(dc AS DATETIME(1)), CAST(10101101112 AS DATETIME(1)), CAST(10101101112.1 AS DATETIME(1)), CAST(20010101101112 AS DATETIME(1)), CAST(20010101101112.1 AS DATETIME(1)) FROM t1
PREPARE stmt FROM 'INSERT INTO t1 VALUES (?)'
EXECUTE stmt USING @a
EXECUTE stmt USING @c
DEALLOCATE PREPARE stmt
PREPARE stmt FROM 'SELECT * FROM t1 WHERE a=?'
EXECUTE stmt USING @a
EXECUTE stmt USING @b
EXECUTE stmt USING @c
DEALLOCATE PREPARE stmt
CREATE PROCEDURE p1 () BEGIN DECLARE a DATETIME(6); SET a='2001-01-01 11:22:33.123'; SELECT a; END
CREATE PROCEDURE p1() BEGIN DECLARE a DATETIME(6); CREATE TABLE t1 AS SELECT a; SHOW CREATE TABLE t1; DROP TABLE t1; END
query_vertical SELECT CAST('2001-01-01 10:10:10.9999994' AS DATETIME), CAST('2001-01-01 10:10:10.9999995' AS DATETIME), CAST('2001-01-01 10:10:10.9999994' AS DATETIME(6)), CAST('2001-01-01 10:10:10.9999995' AS DATETIME(6)), CAST(20010101101010.9999994 AS DATETIME), CAST(20010101101010.9999995 AS DATETIME), CAST(20010101101010.9999994 AS DATETIME(6)), CAST(20010101101010.9999995 AS DATETIME(6))
query_vertical SELECT EXTRACT(MICROSECOND FROM '2001-01-01 00:00:00.9999994'), EXTRACT(MICROSECOND FROM '2001-01-01 00:00:00.9999995'), EXTRACT(MICROSECOND FROM 20010101000000.9999994), EXTRACT(MICROSECOND FROM 20010101000000.9999995)
PREPARE stmt FROM 'INSERT INTO t1 VALUES (?)'
EXECUTE stmt USING @a
EXECUTE stmt USING @c
DEALLOCATE PREPARE stmt
PREPARE stmt FROM 'SELECT * FROM t1 WHERE a=?'
EXECUTE stmt USING @a
EXECUTE stmt USING @b
EXECUTE stmt USING @c
DEALLOCATE PREPARE stmt
CREATE PROCEDURE p1 () BEGIN DECLARE a TIMESTAMP(6); SET a='2001-01-01 11:22:33.123'; SELECT a; END
CREATE PROCEDURE p1() BEGIN DECLARE a TIMESTAMP(6); CREATE TABLE t1 AS SELECT a; SHOW CREATE TABLE t1; DROP TABLE t1; END
SELECT 3 IN (SELECT MAX(a) FROM t1)
SELECT ADDTIME(UTC_DATE, '23:28:14.014837') FROM dual
SELECT SUBTIME(UTC_DATE, '04:44:03.014042') FROM dual
SELECT TIMEDIFF('0000-00-00 00:00:00.00000', UTC_DATE) FROM dual
SELECT EXTRACT(HOUR_SECOND FROM CURRENT_DATE) FROM t1
SELECT col_datetime_3_key , COUNT( col_timestamp_5_key ) FROM t1 FORCE KEY (PRIMARY, col_datetime_5_not_null_key, col_datetime_6_key, col_time_5_key, col_time_2_key) WHERE (col_time_4_not_null_key NOT BETWEEN '2002-01-01 21:50:38.023562' AND '20090504151448.022774' AND col_time_1_not_null_key IN ('2000-07-13 21:35:51.034786', '2004-10-13 19:51:18.029716', '2001-11-23 10:22:42.001689', '2001-12-07 06:56:47.034426', '20081109153313.042580' ) ) AND (col_timestamp_4_key BETWEEN '0000-00-00 00:00:00' AND '2008-06-16 10:42:11.032174' OR col_time_not_null_key BETWEEN '2007-02-13 14:29:42.008072' AND '2009-05-18 17:06:18.036503' ) AND ( (col_datetime_key <> '2004-09-06 19:57:07.024714') AND col_datetime_5_not_null_key NOT IN ('20061212182915.005997', '0000-00-00 00:00:00', '20000920051358.001283', '2000-09-03 00:07:36.061713' ) ) AND (col_datetime_4_not_null_key IS NULL OR col_time_5_key BETWEEN '20051201163954.001782' AND '0000-00-00 00:00:00') GROUP BY col_datetime_6_not_null_key
SELECT col_time_5_key AS c1, col_time_key AS c2, col_timestamp AS c3 FROM t1 WHERE col_time_not_null NOT BETWEEN EXTRACT(YEAR_MONTH FROM '0000-00-00 00:00:00') AND COALESCE (col_time_6_not_null_key, col_datetime_key) ORDER BY 1, 2
SELECT col_timestamp_3 AS c1, col_date AS c2, CURTIME() AS c3 FROM t1 WHERE col_time_3_not_null NOT IN (col_time_not_null, CAST(col_time_5 AS DATETIME(3)), MAKEDATE(DAYOFMONTH('2002-09-13'), DATEDIFF('2009-12-15', col_timestamp_6)), CURRENT_DATE()) AND col_time_3_key NOT BETWEEN LEAST(CURRENT_TIME(), TIMESTAMPADD(HOUR, 187, MAKETIME(209, 60, 1))) AND CURTIME() AND col_datetime_2_not_null NOT IN (DATE('2009-03-28'), col_timestamp_2_not_null_key, ADDDATE(col_timestamp_2_key, 28), col_datetime_3, UTC_DATE()) OR col_time_6_key IS NOT NULL AND col_timestamp_3_not_null IN (col_timestamp_1, col_datetime_3_key, col_time_4_key) OR col_time_6_not_null_key BETWEEN TIMESTAMP('0000-00-00', '16:50:23.062015') AND col_datetime_5 AND col_datetime_4 >= col_time_2_key AND col_time_5_not_null BETWEEN col_timestamp_3_not_null AND col_datetime_1_not_null_key ORDER BY col_time_4_key, col_datetime_3_key
SELECT col_timestamp_not_null AS c1, col_datetime_6_not_null_key AS c2 FROM t1 WHERE col_timestamp IS NOT NULL AND col_timestamp_2 <> col_time_1_not_null AND col_timestamp_key BETWEEN col_datetime_3_not_null AND CURRENT_TIME() OR col_time_6_not_null != LEAST(col_time_6, UTC_TIME())
SELECT col_datetime_5_not_null AS c1, col_time_1_not_null_key AS c2 FROM t1 WHERE col_time_4_not_null = MAKETIME(24, 60, 3 ) AND col_time_3 NOT IN ( col_datetime_5, UTC_DATE(), col_timestamp_5_key, ADDDATE('0000-00-00 00:00:00', DATEDIFF('2001-09-21',FROM_UNIXTIME(1018888192, CONCAT_WS('-','%s','%V','%u')))), col_timestamp_4) AND col_timestamp_2 NOT BETWEEN col_datetime AND '2005-09-12' ORDER BY 1
SELECT col_datetime_5_not_null AS c1, col_time_1_not_null_key AS c2 FROM t1 WHERE col_time_4_not_null=MAKETIME(24,60, 3) AND col_time_3 NOT IN (col_datetime_5, UTC_DATE(), col_timestamp_5_key,  col_timestamp_4) AND col_timestamp_2 NOT BETWEEN col_datetime AND '2005-09-12' ORDER BY 1
SELECT UNIX_TIMESTAMP(col_datetime_4_not_null) AS c1 FROM t1 WHERE col_time_4_key NOT BETWEEN '2001-07-06' AND LEAST(FROM_DAYS(col_timestamp_key), col_timestamp_5) OR CONVERT_TZ(MAKETIME(24, 5, 7), 'Japan', 'Japan') IS NULL OR CURRENT_TIMESTAMP() IS NOT NULL OR col_datetime_not_null_key >= UTC_TIME() ORDER BY 1
SELECT SUBTIME(col_timestamp_3_not_null_key , SYSDATE()) AS c1 FROM t1 WHERE col_timestamp_1_not_null_key NOT IN (col_datetime_4_key , GREATEST(DATE('2006-04-26'), UTC_DATE())) ORDER BY col_datetime_6 , col_time_2_not_null_key , col_time_5_not_null_key
SELECT col_timestamp_6_not_null_key AS c1, col_datetime_key AS c2, UTC_DATE() AS c3 FROM t1 WHERE col_time_1_key BETWEEN TIMESTAMPADD(MONTH, 38 ,CONVERT_TZ( DATE(MAKEDATE(207, 38 )), '+00:00','+04:00')) AND LOCALTIMESTAMP() ORDER BY col_datetime_4_not_null_key , col_time_5 , col_time_3_not_null
SELECT EXTRACT(MINUTE_MICROSECOND FROM a) FROM t1
SELECT EXTRACT(MINUTE_MICROSECOND FROM '0000-00-00 00:00:00.000000')
SELECT EXTRACT(DAY FROM (-0.1111111111)), EXTRACT(YEAR FROM (-0.1111111)), EXTRACT(YEAR_MONTH FROM (-0.1111111111)), EXTRACT(DAY FROM (-0.1111111)), EXTRACT(QUARTER FROM (-0.1111111111)), EXTRACT(MONTH FROM (-0.1111111)), EXTRACT(WEEK FROM (-0.1111111)), DATE(-0.1111111), QUARTER(-0.1111111111), TIMESTAMP(-0.1111111111), LAST_DAY(-0.1111111111), DAY(-0.1111111111), MONTH(-0.1111111111), YEAR(-0.1111111), DAYOFMONTH(-0.1111111111), TIMESTAMP((-0.1111111111),'{$x'), DATE_FORMAT(-0.1111111111,'+'), CONVERT(-0.1111111,DATE), CAST(-0.1111111111 AS DATE)
do date_add(utc_time(), interval(oct(-11779)) microsecond)
SELECT current_date IN ( MAX(NULL), 1 )
SELECT current_time IN ( MAX(NULL), 1 )
show create database mysqltest2
show create database mysqltest2
show create database mysqltest2
load data infile 'tmp1.txt' into table t1 character set binary
remove_file $MYSQLD_DATADIR/test/tmp1.txt
RENAME TABLE testdb.t1 TO testdb.t1_renamed
CREATE USER u1@120.0.0.1
GRANT INSERT,UPDATE,DELETE ON mysql.* to u1@120.0.0.1
CREATE USER u3@120.0.0.1
GRANT SELECT ON mysql.user to u3@120.0.0.1
DROP USER u1@localhost,u3@120.0.0.1,u1@120.0.0.1,u2
DROP USER u1@120.0.0.1,u2
CREATE USER u1@120.0.0.1
GRANT INSERT,UPDATE,DELETE ON mysql.* to u1@120.0.0.1
CREATE USER u3@120.0.0.1
GRANT SELECT ON mysql.user to u3@120.0.0.1
DROP USER u1@localhost,u3@120.0.0.1,u1@120.0.0.1,u2
DROP USER u1@localhost,u3@120.0.0.1
CREATE DEFINER = u1@localhost FUNCTION f2() RETURNS int BEGIN DECLARE n int; DECLARE m int; SET n:= (SELECT min(a) FROM t1); SET m:= (SELECT max(a) FROM t1); RETURN n < m; END ;
cat_file $MYSQLD_DATADIR/test_string_service_long.log
remove_file $MYSQLD_DATADIR/test_string_service_long.log
select 1.1 IN (1.0, 1.2)
select 1.1 IN (1.0, 1.2, 1.1, 1.4, 0.5)
select 1.1 IN (1.0, 1.2, NULL, 1.4, 0.5)
select 0.5 IN (1.0, 1.2, NULL, 1.4, 0.5)
select 1 IN (1.11, 1.2, 1.1, 1.4, 1, 0.5)
select 1 IN (1.11, 1.2, 1.1, 1.4, NULL, 0.5)
select 0.1 in (1.0, 1.2, 1.1, a, 1.4, 0.5) from t1
create procedure wg2() begin declare v int default 1; declare tdec decimal(5) default 0; while v <= 9 do set tdec =tdec * 10; select v, tdec; set v = v + 1; end while; end
999999999999999999999999999999999999999999999999999999999999999999999999999999999
interval ((SELECT date_add((0x77500000), interval ('Oml') second))) day_minute) AS foo
CREATE TABLE t1 SELECT /* 81 */ 100000000000000000000000000000000000000000000000000000000000000000000000000000001. AS c1
SET @decimal= 1.1
CREATE TABLE t1 SELECT @decimal AS c1
PREPARE stmt FROM 'SELECT * FROM t1 WHERE value = ?'
EXECUTE stmt using @a
EXECUTE stmt using @a
DEALLOCATE PREPARE stmt
do 1 div nullif(min(from_days(1)),_utf8mb4'2000-01-01')
SET @d:=' '
LOCK INSTANCE FOR BACKUP
UNLOCK INSTANCE
query_vertical SELECT CAST('2001-01-01 10:10:10.9999994' AS DATETIME) AS c1, CAST('2001-01-01 10:10:10.9999995' AS DATETIME) AS c2, CAST('2001-01-01 10:10:10.9999994' AS DATETIME(6)) AS c3, CAST('2001-01-01 10:10:10.9999995' AS DATETIME(6)) AS c4, CAST(20010101101010.9999994 AS DATETIME) AS c5, CAST(20010101101010.9999995 AS DATETIME) AS c6, CAST(20010101101010.9999994 AS DATETIME(6)) AS c7, CAST(20010101101010.9999995 AS DATETIME(6)) AS c8
query_vertical SELECT EXTRACT(MICROSECOND FROM '2001-01-01 00:00:00.9999994') AS c1, EXTRACT(MICROSECOND FROM '2001-01-01 00:00:00.9999995') AS c2, EXTRACT(MICROSECOND FROM 20010101000000.9999994) AS c3, EXTRACT(MICROSECOND FROM 20010101000000.9999995) AS c4
CREATE  VIEW v1 AS SELECT GROUPING(`ß¸ß¸ß¸ß¸ß¸ß¸ß¸ß¸ß¸ß¸0123456789012345678901234567890123456789`.a), GROUPING(`ß¸ß¸ß¸ß¸ß¸ß¸ß¸ß¸ß¸ß¸0123456789012345678901234567890123456789`.a), GROUPING(`ß¸ß¸ß¸ß¸ß¸ß¸ß¸ß¸ß¸ß¸0123456789012345678901234567890123456789`.a) FROM t1 AS `ß¸ß¸ß¸ß¸ß¸ß¸ß¸ß¸ß¸ß¸0123456789012345678901234567890123456789` GROUP BY a WITH ROLLUP
CREATE VIEW v1 AS SELECT GROUPING(a2345678901234567890123456789012345678901234.a), GROUPING(a2345678901234567890123456789012345678901234.a), GROUPING(a2345678901234567890123456789012345678901234.a) FROM t1 AS a2345678901234567890123456789012345678901234 GROUP BY a WITH ROLLUP
CREATE VIEW v2 AS SELECT GROUPING(a2345678901234567890123456789012345678901234xxxxxxxxxxxxxxxx.a), GROUPING(a2345678901234567890123456789012345678901234xxxxxxxxxxxxxxxx.a), GROUPING(a2345678901234567890123456789012345678901234xxxxxxxxxxxxxxxx.a) FROM t1 AS a2345678901234567890123456789012345678901234xxxxxxxxxxxxxxxx GROUP BY a WITH ROLLUP
CALL mtr.add_suppression("Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT")
load data infile '../../std_data/words.dat' into table t1
load data infile '../../std_data/words.dat' into table t1
load data infile '../../std_data/words.dat' into table t1
load data infile '../../std_data/words.dat' into table t1
load data infile '../../std_data/words.dat' into table t1
insert into t5 select * from `Ã¤Ã¶Ã¼Ã„Ã–Ãœ` flush logs
load data infile '../../std_data/loaddata6.dat' into table t1 CHARACTER SET latin1
load data infile '../../std_data/loaddata6.dat' into table t1
load data infile '../../std_data/loaddata6.dat' into table t1
load data infile '../../std_data/loaddata6.dat' into table t1
load data infile '../../std_data/loaddata6.dat' into table t1
load data infile '../../std_data/loaddata6.dat' into table t1
load data infile '../../std_data/loaddata6.dat' into table t1 character set koi8r
INTO TABLE patch FIELDS TERMINATED BY '' LINES STARTING BY '#'
echo shell> mysqlbinlog std_data/corrupt-relay-bin.000624 > var/tmp/bug31793.sql
error 1
exec $MYSQL_BINLOG $MYSQL_TEST_DIR/std_data/corrupt-relay-bin.000624 > $MYSQLTEST_VARDIR/tmp/bug31793.sql
SHOW GRANTS FOR untrusted@localhost
echo mysqlbinlog var/log/master_binlog_file > var/tmp/bug31611.sql
exec $MYSQL_BINLOG $MYSQLD_DATADIR/$master_binlog_file > $MYSQLTEST_VARDIR/tmp/bug31611.sql
echo mysql mysqltest1 -uuntrusted < var/tmp/bug31611.sql
error 1
exec $MYSQL mysqltest1 -uuntrusted < $MYSQLTEST_VARDIR/tmp/bug31611.sql
error ER_TABLEACCESS_DENIED_ERROR
query_vertical SELECT * FROM t1
echo >> mysqlbinlog var/log/master_binlog_file > var/tmp/bug32580.sql
exec $MYSQL_BINLOG $MYSQLD_DATADIR/$master_binlog_file > $MYSQLTEST_VARDIR/tmp/bug32580.sql
echo >> mysql test < var/tmp/bug32580.sql
exec $MYSQL test < $MYSQLTEST_VARDIR/tmp/bug32580.sql
remove_file $MYSQLTEST_VARDIR/tmp/bug32580.sql
query_vertical SELECT * FROM t1
(@a:=LOAD_FILE("$binlog_file")) IS NOT NULL AS Loaded
echo *** Unsigned server_id $s_id_max is found: $s_id_unsigned ***
disable_query_log
enable_query_log
write_file $MYSQLTEST_VARDIR/tmp/mysqlbinlog.warn.empty
diff_files $MYSQLTEST_VARDIR/tmp/mysqlbinlog.warn $MYSQLTEST_VARDIR/tmp/mysqlbinlog.warn.empty
remove_file $MYSQLTEST_VARDIR/tmp/mysqlbinlog.warn.empty
remove_file $MYSQLTEST_VARDIR/tmp/mysqlbinlog.warn
exec $MYSQL_BINLOG $MYSQLD_DATADIR/$master_binlog | $MYSQL test 2>&1
source include/show_binlog_events.inc
create procedure p1() begin prepare stmt from "select 1"; execute stmt; execute stmt; execute stmt; deallocate prepare stmt; end
create procedure p1() begin execute stmt; end
prepare stmt from "call p1()"
execute stmt
execute stmt
execute stmt
create procedure p1() begin prepare stmt from "create procedure p2() begin select 1; end"; execute stmt; deallocate prepare stmt; end
create procedure p1() begin prepare stmt from "drop procedure p2"; execute stmt; deallocate prepare stmt; end
create procedure p1() begin prepare stmt_drop from "drop table if exists t1"; execute stmt_drop; prepare stmt from "create table t1 (a int)"; execute stmt; insert into t1 (a) values (1); select * from t1; prepare stmt_alter from "alter table t1 add (b int)"; execute stmt_alter; insert into t1 (a,b) values (2,1); deallocate prepare stmt_alter; deallocate prepare stmt; deallocate prepare stmt_drop; end
create procedure p1() begin set @tab_name=concat("tab_", replace(curdate(), '-', '_')); set @drop_sql=concat("drop table if exists ", @tab_name); set @create_sql=concat("create table ", @tab_name, " (a int)"); set @insert_sql=concat("insert into ", @tab_name, " values (1), (2), (3)"); set @select_sql=concat("select * from ", @tab_name); select @tab_name; select @drop_sql; select @create_sql; select @insert_sql; select @select_sql; prepare stmt_drop from @drop_sql; execute stmt_drop; prepare stmt from @create_sql; execute stmt; prepare stmt from @insert_sql; execute stmt; prepare stmt from @select_sql; execute stmt; execute stmt_drop; deallocate prepare stmt; deallocate prepare stmt_drop; end
create procedure p1() begin prepare stmt_drop from "drop table if exists t1"; execute stmt_drop; prepare stmt from "create table t1 (a int)"; execute stmt; deallocate prepare stmt; deallocate prepare stmt_drop; end
create procedure p1() begin drop table if exists t1; create table t1 (id integer not null primary key, name varchar(20) not null); insert into t1 (id, name) values (1, 'aaa'), (2, 'bbb'), (3, 'ccc'); prepare stmt from "select name from t1"; execute stmt; select name from t1; execute stmt; prepare stmt from "select name from t1 where name=(select name from t1 where id=2)"; execute stmt; select name from t1 where name=(select name from t1 where id=2); execute stmt; end
prepare stmt from "select * from t1"
create procedure p1() begin execute stmt; deallocate prepare stmt; end
create procedure p1() begin declare a char(10); set a="sp-variable"; set @a="mysql-variable"; prepare stmt from "select 'dynamic sql:', @a, a"; execute stmt; end
create procedure p1() begin prepare stmt from 'select ? as a'; execute stmt using @a; end
create procedure p1() begin declare v_stmt_text varchar(255); declare v_id integer; declare done int default 0; declare c cursor for select id, stmt_text from t1; declare continue handler for 1295 -- ER_UNSUPPORTED_PS set @status='not supported'; declare continue handler for 1064 -- ER_SYNTAX_ERROR set @status='syntax error'; declare continue handler for sqlstate '02000' set done = 1; prepare update_stmt from "update t1 set status=? where id=?"; open c; repeat if not done then fetch c into v_id, v_stmt_text; set @id=v_id, @stmt_text=v_stmt_text; set @status="supported"; prepare stmt from @stmt_text; execute update_stmt using @status, @id; end if; until done end repeat; deallocate prepare update_stmt; end
prepare stmt from 'select 1'
create procedure p1() execute stmt
create function f1() returns int begin deallocate prepare stmt; return 1; end
create procedure p1() begin prepare stmt from 'select 1 A'; execute stmt; end
prepare stmt from 'call p1()'
execute stmt
execute stmt
create procedure p1 (a int) language sql deterministic begin declare rsql varchar(100); drop table if exists t1, t2; set @rsql= "create table t1 (a int)"; select @rsql; prepare pst from @rsql; execute pst; set @rsql= null; set @rsql= "create table t2 (a int)"; select @rsql; prepare pst from @rsql; execute pst; drop table if exists t1, t2; end
set @a:=0
INFORMATION_SCHEMA.TABLES WHERE table_schema = \'test\', COUNT, 1] = 1
INFORMATION_SCHEMA.TABLES WHERE table_schema = \'test\', COUNT, 1] = 1
CREATE TABLE t1 (f1 INT) START TRANSACTION
CREATE TABLE t1 (f1 INT) START TRANSACTION
CREATE PROCEDURE proc1() BEGIN CREATE TABLE t1 (f1 INT) START TRANSACTION; ROLLBACK; CREATE TABLE t1 (f1 INT) START TRANSACTION; COMMIT; END
PREPARE stmt FROM "CREATE TABLE t1 (f1 INT) START TRANSACTION"
CREATE TABLE t1 (f1 INT) ENGINE=MyiSAM START TRANSACTION
CREATE TABLE t1 (f1 INT) START TRANSACTION
ALTER TABLE t2 ADD f2 INT, START TRANSACTION
CREATE TEMPORARY TABLE t1 (f1 INT) START TRANSACTION
CREATE TABLE t1 START TRANSACTION as SELECT * FROM t0
create table t1 (a int not null,b int not null, primary key using HASH (a)) engine=heap comment="testing heaps" avg_row_length=100 min_rows=1 max_rows=100
alter table t1 add c int not null, add key using HASH (c,a)
create table t1 (a int not null,b int not null, primary key using HASH (a)) engine=heap comment="testing heaps"
CREATE TABLE t1 ( a int not null default 0, b int not null default 0,  key  using HASH (a),  key  using HASH (b)  ) ENGINE=HEAP
create table t1 (id int unsigned not null, primary key  using HASH (id)) engine=HEAP
create table t1 (btn char(10) not null, key using HASH (btn)) charset utf8mb4 engine=heap
alter table t1 add column new_col char(1) not null, add key using HASH (btn,new_col), drop key btn
CREATE TABLE t1 (a int not null, primary key using HASH (a)) engine=heap
CREATE TABLE t1 ( pk INT PRIMARY KEY, val INT, UNIQUE KEY USING HASH(val) ) ENGINE=MEMORY
CREATE TABLE t1( id INT AUTO_INCREMENT PRIMARY KEY, c1 INT NOT NULL, c2 INT NOT NULL, UNIQUE KEY USING HASH (c2,c1)) ENGINE = MEMORY
create procedure syntaxerror(t int)
create procedure syntaxerror(t int)
create procedure syntaxerror(t int)
create procedure bad_into(out param int) select x from t3 into param
create procedure foo() create procedure bar() set @x=3
create procedure foo() create function bar() returns double return 2.3
create procedure p(val int, out res int) begin declare x int default 0; declare continue handler for foo set x = 1; insert into test.t1 values (val); if (x) then set res = 0; else set res = 1; end if; end
create procedure p(val int, out res int) begin declare x int default 0; declare foo condition for 1146; declare continue handler for bar set x = 1; insert into test.t1 values (val); if (x) then set res = 0; else set res = 1; end if; end
create function f(val int) returns int begin declare x int; set x = val+3; end
create function f(val int) returns int begin declare x int; set x = val+3; if x < 4 then return x; end if; end
create procedure p() begin declare c cursor for insert into test.t1 values ("foo", 42); open c; close c; create procedure p() begin declare x int; declare c cursor for select * into x from test.t limit 1; open c; close c; end
create procedure p() begin declare x int; declare c cursor for select * from t1; open c; fetch c into x, y; close c; end
create procedure p() begin declare x int; declare c cursor for select * from t1; open c; fetch c into x; close c; end
create procedure p() begin declare x int; declare y float; declare z int; declare c cursor for select * from t1; open c; fetch c into x, y, z; close c; end
create function p(x int, x char(10)) begin end
create procedure p() begin declare x float; declare x int; end
create procedure u() use sptmp
create procedure p() begin declare c cursor for select * from t1; declare x int; end
create procedure p() begin declare x int; declare continue handler for sqlstate '42S99' set x = 1; declare foo condition for sqlstate '42S99'; end
create procedure p() begin declare x int; declare continue handler for sqlstate '42S99' set x = 1; declare c cursor for select * from t1; end
lock table t1 read
unlock tables
select 1 into a
create procedure bug2259() begin declare v1 int; declare c1 cursor for select s1 from t1; fetch c1 into v1; end
create procedure bug2272() begin declare v int; update t1 set v = 42; end
create procedure bug2329_1() begin declare v int; insert into t1 (v) values (5); end
create procedure bug2329_2() begin declare v int; replace t1 set v = 5; end
create function bug3287() returns int begin declare v int default null; case when v is not null then return 1; end case; return 2; end
create procedure bug3279(out y int) begin declare x int default 0; begin declare exit handler for sqlexception set x = x+1; insert into t3 values (5); end; if x < 2 then set x = x+1; insert into t3 values (6); end if; set y = x; end
create procedure bug4344() drop procedure bug4344
create procedure bug4344() drop function bug4344
create procedure bug6600() check table t1
create procedure bug6600() lock table t1 read
create procedure bug6600() unlock table t1
create procedure bug7299() begin declare v int; declare c cursor for select val from t1; declare exit handler for sqlexception select 'Error!'; open c; fetch c into v; end
create procedure bug7047() alter procedure bug7047
create function bug7047() returns int begin alter function bug7047; return 0; end
create function bug8408() returns int begin show warnings; return 0; end
create function bug8408(a int) returns int begin declare b int; select b; return b; end
create function bug8408() returns int begin declare n int default 0; select count(*) into n from t1; return n; end
create procedure bug10537() load data local infile '/tmp/somefile' into table t1
create function bug8409() returns int begin flush tables; return 5; end
create function bug8409() returns int begin reset master; return 1; end
create function bug8409() returns int begin reset slave; return 1; end
create function bug8409() returns int begin flush hosts; return 1; end
create function bug8409() returns int begin flush privileges; return 1; end
create function bug8409() returns int begin flush tables with read lock; return 1; end
create function bug8409() returns int begin flush tables; return 1; end
create function bug8409() returns int begin flush logs; return 1; end
create function bug8409() returns int begin flush status; return 1; end
create function bug8409() returns int begin flush user_resources; return 1; end
create procedure bug10969() begin declare s1 int default 0; select default(s1) from t30; end
create procedure bug10969() begin declare s1 int default 0; select default(t30.s1) from t30; end
CREATE PROCEDURE SP001() P1: BEGIN DECLARE ENDTABLE INT DEFAULT 0; DECLARE TEMP_NUM INT; DECLARE TEMP_SUM INT; DECLARE C1 CURSOR FOR SELECT F1 FROM t1; DECLARE C2 CURSOR FOR SELECT F1 FROM t2; DECLARE CONTINUE HANDLER FOR NOT FOUND SET ENDTABLE = 1; SET ENDTABLE=0; SET TEMP_SUM=0; SET TEMP_NUM=0; OPEN C1; FETCH C1 INTO TEMP_NUM; WHILE ENDTABLE = 0 DO SET TEMP_SUM=TEMP_NUM+TEMP_SUM; FETCH C1 INTO TEMP_NUM; END WHILE; SELECT TEMP_SUM; CLOSE C1; CLOSE C1; SELECT 'end of proc'; END P1
CREATE PROCEDURE BUG_12490() HELP CONTENTS
CREATE FUNCTION BUG_12490() RETURNS INT HELP CONTENTS
CREATE TRIGGER BUG_12490 BEFORE UPDATE ON t_bug_12490 FOR EACH ROW HELP CONTENTS
prepare stmt from "select bug11834_2()"
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
CREATE FUNCTION bug12953() RETURNS INT BEGIN OPTIMIZE TABLE t1; RETURN 1; END
CREATE FUNCTION bug12995() RETURNS INT BEGIN HANDLER t1 OPEN; RETURN 1; END
CREATE FUNCTION bug12995() RETURNS INT BEGIN HANDLER t1 READ FIRST; RETURN 1; END
CREATE FUNCTION bug12995() RETURNS INT BEGIN HANDLER t1 CLOSE; RETURN 1; END
create procedure bug9367() begin declare v int; declare c cursor for select s1 from t1; open c; show warnings; fetch c into v; select v; end
create procedure bug13510_1() begin declare password varchar(10); set password = 'foo1'; select password; end
create procedure bug13510_2() begin declare names varchar(10); set names = 'foo2'; select names; end
create procedure bug13510_3() begin declare password varchar(10); set `password` = 'foo3'; select password; end
create procedure bug13510_4() begin declare names varchar(10); set `names` = 'foo4'; select names; end
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN DROP TRIGGER test1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN DROP TRIGGER test1; return 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create index t1_i on t1 (a); END
CREATE FUNCTION bug_13627_f() returns int BEGIN create index t1_i on t1 (a); return 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN rename table t1 to t2; END
CREATE FUNCTION bug_13627_f() returns int BEGIN rename table t1 to t2; return 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop index t1_i on t1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN drop index t1_i on t1; return 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN unlock tables; END
CREATE FUNCTION bug_13627_f() returns int BEGIN unlock tables; return 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN LOCK TABLE t1 READ; END
CREATE FUNCTION bug_13627_f() returns int BEGIN LOCK TABLE t1 READ; return 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create database mysqltest; END
CREATE FUNCTION bug_13627_f() returns int BEGIN create database mysqltest; return 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop database mysqltest; END
CREATE FUNCTION bug_13627_f() returns int BEGIN drop database mysqltest; return 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create user 'mysqltest_1'; END
CREATE FUNCTION bug_13627_f() returns int BEGIN create user 'mysqltest_1'; return 1; END
CREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN grant select on t1 to 'mysqltest_1'; END
CREATE FUNCTION bug21975() returns int BEGIN grant select on t1 to 'mysqltest_1'; return 1; END
CREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN revoke select on t1 from 'mysqltest_1'; END
CREATE FUNCTION bug21975() returns int BEGIN revoke select on t1 from 'mysqltest_1'; return 1; END
CREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN revoke all privileges on *.* from 'mysqltest_1'; END
CREATE FUNCTION bug21975() returns int BEGIN revoke all privileges on *.* from 'mysqltest_1'; return 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop user 'mysqltest_1'; END
CREATE FUNCTION bug_13627_f() returns int BEGIN drop user 'mysqltest_1'; return 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN rename user 'mysqltest_2' to 'mysqltest_1'; END
CREATE FUNCTION bug_13627_f() returns int BEGIN rename user 'mysqltest_2' to 'mysqltest_1'; return 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create view v1 as select 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN create view v1 as select 1; return 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN alter view v1 as select 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN alter view v1 as select 1; return 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop view v1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN drop view v1; return 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create trigger tr2 before insert on t1 for each row do select 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN create trigger tr2 before insert on t1 for each row do select 1; return 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop function bug_13627_f; END
CREATE FUNCTION bug_13627_f() returns int BEGIN drop function bug_13627_f; return 1; END
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create function f2 () returns int return 1; END
CREATE FUNCTION bug_13627_f() returns int BEGIN create function f2 () returns int return 1; return 1; END
prepare stmt1 from 'select bug12329()'
execute stmt1
execute stmt1
deallocate prepare stmt1
create procedure p1(out param1 int) begin select count(*) into param1 from t3; end
CREATE FUNCTION bug13012() RETURNS INT BEGIN REPAIR TABLE t1; RETURN 1; END
CREATE PROCEDURE bug13012_1() REPAIR TABLE t1
create trigger t1_ai after insert on t1 for each row set @a:=bug11555_1()
create procedure ``() select 1
create procedure ``.bug15658() select 1
create function bug14270() returns int begin load index into cache t1; return 1; end
create function bug14270() returns int begin cache index t1 key (`primary`) in keycache1; return 1; end
create procedure bug15091() begin declare selectstr varchar(6000) default ' '; declare conditionstr varchar(5000)  default ''; set selectstr = concat(selectstr, ' and ', c.operatorid, 'in (',conditionstr, ')'); end
CREATE IF NOT EXISTS PROCEDURE bug14702() BEGIN CREATE PROCEDURE IF NOT EXISTS bug14702() BEGIN CREATE TABLE t1 (i INT)
CREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO @a
CREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO DUMPFILE "file"
CREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO OUTFILE "file"
CREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 FROM (SELECT 1) AS d1
CREATE PROCEDURE bug20953(i INT) CREATE VIEW v AS SELECT i
CREATE PROCEDURE bug20953() BEGIN DECLARE i INT; CREATE VIEW v AS SELECT i; END
PREPARE stmt FROM "CREATE VIEW v AS SELECT ?"
create function func_20713_a() returns int(11) begin declare id int; declare continue handler for sqlexception set id=null; set @in_func := 1; set id = (select id from bogus_table_20713 where id = 3); set @in_func := 2; return id; end
create function func_20713_b() returns int(11) begin declare id int; declare continue handler for sqlstate value '42S02' set id=null; set @in_func := 1; set id = (select id from bogus_table_20713 where id = 3); set @in_func := 2; return id; end
set @in_func := 0
set @in_func := 0
set @in_func := 0
set @in_func := 0
create procedure proc_25345() begin declare c1 cursor for select a from table_25345_a; declare c2 cursor for select b from table_25345_b; select 1 as result; end |
create function func_25345() returns int(11) begin call proc_25345(); return 1; end |
create function func_25345_b() returns int(11) begin declare c1 cursor for select a from table_25345_a; declare c2 cursor for select b from table_25345_b; return 1; end |
CREATE PROCEDURE p1() BEGIN DECLARE cur1 CURSOR FOR SHOW TABLES
OPEN cur1
FETCH cur1 INTO c
CLOSE cur1
END| CREATE DATABASE mysqltest
create procedure p1(a int) begin declare continue handler for 1436 -- ER_STACK_OVERRUN_NEED_MORE select 'exception'; call p1(a+1); end
SELECT very_long_db_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999.simple_func()
CALL very_long_db_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999.simple_proc()
SELECT db_name.very_long_fn_name_111111111111111111111111111111111111111111111111111111111111111111111111122222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999999999999999999()
CALL db_name.very_long_pr_name_111111111111111111111111111111111111111111111111111111111111111111111111122222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999999999999999999()
CREATE PROCEDURE p1() BEGIN DECLARE c INT DEFAULT 0; DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN SET c = c + 1; SELECT 'Warning caught!' AS Msg; END; CALL p2(); # 1 warning CALL p3(); # 1 warning CALL p4(); # No warnings CALL p5(); # 1 warning SELECT c; SELECT @@warning_count; SHOW WARNINGS; END
CREATE PROCEDURE p2() BEGIN SELECT CAST('2x' as unsigned integer); END| # 1 warning is passed to the caller CREATE PROCEDURE p3() BEGIN SELECT CAST('3x' as unsigned integer); GET DIAGNOSTICS @n = NUMBER; # does not clear the warning END| # 1 warning is passed to the caller CREATE PROCEDURE p4() BEGIN SELECT CAST('4x' as unsigned integer); INSERT INTO t1 VALUES(1); # Clears the warning END| # No warnings to pass CREATE PROCEDURE p5() BEGIN SELECT CAST('5x' as unsigned integer); CALL p2(); END
CREATE PROCEDURE p6() BEGIN SELECT CAST('6x' as unsigned integer); SHOW WARNINGS; END
CREATE PROCEDURE p7() BEGIN DECLARE c INT DEFAULT 0; DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN SET c = c + 1; SELECT 'Warning caught!' AS Msg; END; CALL p6(); SELECT c; END
CREATE PROCEDURE p1() BEGIN DECLARE c CURSOR FOR SELECT a FROM t1; OPEN c; BEGIN DECLARE v1 INT; DECLARE v2 INT; DECLARE EXIT HANDLER FOR SQLEXCEPTION SELECT "Error caught (expected)"; DECLARE EXIT HANDLER FOR NOT FOUND SELECT "End of Result Set found!"; WHILE TRUE DO FETCH c INTO v1, v2; END WHILE; END; CLOSE c; SELECT a INTO @foo FROM t1 LIMIT 1; # Clear warning stack END
CREATE PROCEDURE p1() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H2' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should be handled by H2. END
CREATE PROCEDURE p2() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H2' AS HandlerId; BEGIN SELECT 'B1' AS BlockId; BEGIN SELECT 'B2' AS BlockId; BEGIN SELECT 'B3' AS BlockId; SIGNAL SQLSTATE '01000'; # Should be handled by H2. END; END; END; END
CREATE PROCEDURE p3() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'H3' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should be handled by H3. END
CREATE PROCEDURE p4() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'H2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H3' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should be handled by H2. END
CREATE PROCEDURE p5() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'H2' AS HandlerId; BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H3' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should be handled by H3. END; END
CREATE PROCEDURE p6() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN SELECT 'H1' AS HandlerId; SIGNAL SQLSTATE 'HY000'; # Should *not* be handled by H1. END; SELECT 'S1' AS SignalId; SIGNAL SQLSTATE 'HY000'; # Should be handled by H1. END
CREATE PROCEDURE p7() BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN SELECT 'H1' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should *not* be handled by H1. END; SELECT 'S1' AS SignalId; SIGNAL SQLSTATE '01000'; # Should be handled by H1. END
CREATE PROCEDURE p8() BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN SELECT 'H2' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should *not* be handled by H1. END; SELECT 'S1' AS SignalId; SIGNAL SQLSTATE 'HY000'; # Should be handled by H2. END
CREATE PROCEDURE p9() BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H1:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H1:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H2:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H2:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H3:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H3:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H4:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H4:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H5:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H5:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H6:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H6:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN SELECT 'H2' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should *not* be handled by H1. END; SELECT 'S6' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S5' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S4' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S3' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S2' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S1' AS SignalId; SIGNAL SQLSTATE 'HY000'; # Should be handled by H2. END
CREATE PROCEDURE p10() BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H2' AS HandlerId; BEGIN BEGIN BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H1:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H1:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H2:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H2:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H3:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H3:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H4:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H4:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H5:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H5:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000' SELECT 'Wrong:H6:1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'Wrong:H6:2' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN SELECT 'H2' AS HandlerId; SIGNAL SQLSTATE '01000'; # Should be handled by H1. END; SELECT 'S6' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S5' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S4' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S3' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S2' AS SignalId; SIGNAL SQLSTATE 'HY000'; END; SELECT 'S1' AS SignalId; SIGNAL SQLSTATE 'HY000'; # Should be handled by H2. END; END; END; END
CREATE PROCEDURE p11() BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H1' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H2' AS HandlerId; BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '01000', 1249 BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'H3' AS HandlerId; DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'H4' AS HandlerId; BEGIN SELECT 'H5' AS HandlerId; SELECT 'S3' AS SignalId; SIGNAL SQLSTATE 'HY000'; # H3 SELECT 'S4' AS SignalId; SIGNAL SQLSTATE '22003'; # H3 SELECT 'S5' AS SignalId; SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1249; # H4 END; END; SELECT 'S6' AS SignalId; SIGNAL SQLSTATE 'HY000'; # H1 SELECT 'S7' AS SignalId; SIGNAL SQLSTATE '22003'; # H1 SELECT 'S8' AS SignalId; SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1249; # H5 END; SELECT 'S1' AS SignalId; SIGNAL SQLSTATE 'HY000'; # H1 SELECT 'S2' AS SignalId; SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1249; # H2 END
CREATE FUNCTION f1() RETURNS INT BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION               # handler 1 BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION             # handler 2 BEGIN INSERT INTO t1 VALUE('WRONG: Inside H2'); RETURN 2; END; INSERT INTO t1 VALUE('CORRECT: Inside H1'); RETURN 1; END; BEGIN DECLARE CONTINUE HANDLER FOR SQLWARNING               # handler 3 BEGIN INSERT INTO t1 VALUE('WRONG: Inside H3'); RETURN 3; END; INSERT INTO t1 VALUE('CORRECT: Calling f1()'); RETURN f1(); # -- exception here END; INSERT INTO t1 VALUE('WRONG: Returning 10'); RETURN 10; END
CREATE PROCEDURE p5() BEGIN DECLARE EXIT HANDLER FOR 1292 BEGIN SELECT 'Handler for 1292' AS Msg; SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1234; SHOW WARNINGS; END; INSERT INTO t2 SELECT CAST(999999 AS SIGNED INTEGER), CAST(CONCAT(CAST('2X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER), CAST(CONCAT(CAST('3X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER); END
CREATE PROCEDURE p6() BEGIN DECLARE CONTINUE HANDLER FOR 1292 BEGIN SHOW WARNINGS; SELECT 'Handler for 1292' Msg; END; INSERT INTO t2 SELECT CAST(CONCAT(CAST('1X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER), CAST(CONCAT(CAST('2X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER), CAST(CONCAT(CAST('3X' AS UNSIGNED INTEGER), '999999XX') AS SIGNED INTEGER); END
CREATE PROCEDURE p1() BEGIN DECLARE var1 INTEGER DEFAULT 'string'; DECLARE EXIT HANDLER FOR SQLWARNING SELECT 'H1'; END
CREATE FUNCTION f1() RETURNS INTEGER BEGIN DECLARE v VARCHAR(5) DEFAULT -1; SELECT b FROM t1 WHERE a = 2 INTO v; RETURN v; END
CREATE FUNCTION f2() RETURNS INTEGER BEGIN DECLARE v INTEGER; DECLARE CONTINUE HANDLER FOR NOT FOUND SET @msg = 'Handler activated.'; SELECT f1() INTO v; RETURN v; END
PREPARE s FROM 'SELECT a FROM t1 WHERE a=(SELECT MAX(a) FROM t1) AND (a="20060606155555")'
EXECUTE s
DROP PREPARE s
CREATE PROCEDURE test27759() BEGIN declare v_a date default '2007-4-10'; declare v_b date default '2007-4-11'; declare v_c datetime default '2004-4-9 0:0:0'; select v_a as a,v_b as b, least( v_a, v_b ) as a_then_b, least( v_b, v_a ) as b_then_a, least( v_c, v_a ) as c_then_a; END;
PREPARE stmt1 FROM 'SELECT * FROM t1 LEFT JOIN t1 AS t1_2 ON 1 WHERE t1_2.a IS NULL AND t1_2.b < 2'
EXECUTE stmt1
EXECUTE stmt1
DEALLOCATE PREPARE stmt1
do is_ipv4_mapped(bin(maketime(11111,exp(repeat('1',32)),'')))
do ifnull((bin_to_uuid(uuid_to_bin(date_format('7088-02-14' ,0xabbd95)))),(maketime('4678-07-20 03:51:44.174847',1,'b')))
do ucase(insert(maketime(9.565398e+307 ,'', st_longfromgeohash(('4358-04-12 03:45:08.727399'))), 0xdc0823,6756,release_all_locks()))
do soundex(maketime(cast((2530967061762658367) as decimal), exp(repeat('1',32)),((period_add(579349005,27636))xor (sha(current_user)))))
do st_mlinefromtext( maketime( now(), instr(1,pow(15270551309908264860,100)), 31 ) )
disable_query_log
disable_result_log
enable_result_log
enable_query_log
echo Assertion: mysql_errname ER_STACK_OVERRUN_NEED_MORE == $mysql_errname
insert into t1 values (repeat("1",200))
call mtr.add_suppression("Failed to set up SSL because of the following SSL library error")
call mtr.add_suppression("\\[Warning\\] .*MY-\\d+.* Changing innodb_extend_and_initialize not supported on this platform.")
call mtr.add_suppression("Failed to initialize TLS for channel: mysql_main")
send INSERT into my_db.t1 values(8) on duplicate key UPDATE id = values(id) + 80
reap
send INSERT into my_db.t1 values(6) on duplicate key UPDATE id = values(id) + 60
reap
lock tables t1 read,t2 write
unlock tables
select S.ID as xID, S.ID1 as xID1, repeat('*',count(distinct yS.ID)) as Level from t1 as S left join t1 as yS  on S.ID1 between yS.ID1 and yS.ID2 group by xID order by xID1
insert into t2 select x3.a,  -- 3 concat('val-', x3.a + 3*x4.a), -- 12 concat('val-', @a:=x3.a + 3*x4.a + 12*C.a), -- 120 concat('val-', @a + 120*D.a) from t1 x3, t1 x4, t1 C, t1 D where x3.a < 3 and x4.a < 4 and D.a < 4 order by x3.a, x4.a, C.a, D.a
create table t1 (b int4 unsigned not null)
EXPLAIN SELECT a FROM t1 IGNORE INDEX (PRIMARY,i2)
EXPLAIN SELECT a FROM t1 IGNORE INDEX FOR JOIN (PRIMARY,i2)
SELECT a FROM t1 IGNORE INDEX FOR ORDER BY (PRIMARY,i2) ORDER BY a
EXPLAIN SELECT a FROM t1 IGNORE INDEX FOR ORDER BY (PRIMARY) IGNORE INDEX FOR GROUP BY (i2) GROUP BY a
EXPLAIN SELECT a FROM t1 IGNORE INDEX (PRIMARY) IGNORE INDEX FOR ORDER BY (i2)
EXPLAIN SELECT a FROM t1 USE INDEX ()
EXPLAIN SELECT a FROM t1 USE INDEX () USE INDEX (i2)
EXPLAIN SELECT a FROM t1 FORCE INDEX (PRIMARY) IGNORE INDEX FOR GROUP BY (i2) IGNORE INDEX FOR ORDER BY (i2) USE INDEX (i2)
EXPLAIN SELECT a FROM t1 USE INDEX (i2) USE INDEX ()
EXPLAIN SELECT a FROM t1 USE INDEX FOR JOIN (i2) USE INDEX FOR GROUP BY (i2) GROUP BY a
EXPLAIN SELECT a FROM t1 FORCE INDEX FOR JOIN (i2) FORCE INDEX FOR GROUP BY (i2) GROUP BY a
EXPLAIN SELECT a FROM t1 USE INDEX () IGNORE INDEX (i2)
EXPLAIN SELECT a FROM t1 IGNORE INDEX (i2) USE INDEX ()
EXPLAIN SELECT a FROM t1 USE INDEX FOR GROUP BY (i2) USE INDEX FOR ORDER BY (i2) USE INDEX FOR JOIN (i2)
EXPLAIN SELECT a FROM t1 USE INDEX FOR JOIN (i2) USE INDEX FOR JOIN (i2) USE INDEX FOR JOIN (i2,i2)
EXPLAIN SELECT 1 FROM t1 WHERE a IN (SELECT a FROM t1 USE INDEX (i2) IGNORE INDEX (i2))
EXPLAIN SELECT 1 FROM t2 WHERE a IN (SELECT a FROM t1 USE INDEX (i2) IGNORE INDEX (i2))
INSERT INTO t1 VALUES (repeat('1', 1300),'one'), (repeat('1', 1300),'two')
query_vertical EXPLAIN SELECT SUBSTRING(a,1,10), LENGTH(a), GROUP_CONCAT(b) FROM t1 GROUP BY a
query_vertical EXPLAIN SELECT SUBSTRING(a,1,10), LENGTH(a) FROM t1 GROUP BY a
SELECT 1 FROM t1 GROUP BY TRIM(LEADING RAND() FROM '')
SELECT 1 FROM t1 GROUP BY SUBSTRING(SYSDATE() FROM 'K' FOR 'jxW<')
PREPARE stmt FROM ' SELECT 1 FROM t2 LEFT JOIN t1 ON NULL GROUP BY t2.b, t1.a HAVING a <> 2'
EXECUTE stmt
EXECUTE stmt
DEALLOCATE PREPARE stmt
FLUSH TABLE t1
FROM t1 GROUP BY field1, field2
INSERT INTO B VALUES  ('at', repeat('a',1000), 'the', -1622540288, 'as', repeat('a',1000), 'want', 1810890752, NULL, 'v', 'just')
CREATE FUNCTION f1(vlt_code_id CHAR(11)) RETURNS tinyint DETERMINISTIC BEGIN DECLARE not_installed TINYINT DEFAULT 0; select count(distinct x.id_aams) into not_installed from (select * from (select t1.id_aams, t2.* from t1 left join t2 on t2.code_id = vlt_code_id and t1.id_aams = t2.id_game where t1.id_aams = 1715000360 order by t2.id desc ) as g group by g.id_aams having g.id is null ) as x; RETURN TRUE; END
PREPARE stmt from " select count(distinct x.id_aams) from (select g.id_aams, g.id from (select t1.id_aams, t2.* from t1 left join t2 on t2.code_id='G0000000012' and t1.id_aams=t2.id_game where t1.id_aams=1715000360 order by t2.id desc ) as g group by g.id_aams having g.id is null ) as x"
EXECUTE stmt
EXECUTE stmt
DEALLOCATE PREPARE stmt
SELECT COUNT(*) FROM t1 LEFT JOIN json_table( '{}','$[0][1]' COLUMNS(a FOR ORDINALITY) ) AS t2 ON TRUE GROUP BY e*from_unixtime(0)
PREPARE stmt from 'SELECT COUNT(*), SUM(c1), AVG(c1), MIN(c1), MAX(c1) FROM t1 WHERE c1 > ?'
EXECUTE stmt USING @a
EXECUTE stmt USING @a
PREPARE stmt from 'SELECT BIT_AND(c1), BIT_OR(c1), BIT_XOR(c1) FROM t1 WHERE c1 > ?'
EXECUTE stmt USING @a
EXECUTE stmt USING @a
PREPARE stmt from "SELECT GROUP_CONCAT(c1), JSON_ARRAYAGG(c1), JSON_OBJECTAGG('key', c1) FROM t1 WHERE c1 > ?"
EXECUTE stmt USING @a
EXECUTE stmt USING @a
PREPARE stmt from 'SELECT STDDEV_POP(c1), STDDEV_SAMP(c1), VAR_POP(c1), VAR_SAMP(c1) FROM t1 WHERE c1 > ?'
EXECUTE stmt USING @a
EXECUTE stmt USING @a
CALL mtr.add_suppression("Enabling keys got errno")
CONNECT (insertConn, localhost, root,,)
CONNECTION insertConn
SEND INSERT INTO t1(id) SELECT id  FROM t2
CONNECTION default
KILL QUERY @thread_id
CONNECTION insertConn
REAP
DISCONNECT insertConn
call mtr.add_suppression("Server SSL certificate doesn't verify")
CALL mtr.add_suppression("Column count of")
CALL mtr.add_suppression("Incorrect definition of table")
CALL mtr.add_suppression("Cannot load from")
CALL mtr.add_suppression("Storage engine 'MyISAM' does not")
RENAME TABLE mysql.func TO mysql.func_bkp
RENAME TABLE mysql.func_bkp TO mysql.func
RENAME TABLE mysql.plugin TO mysql.plugin_bkp
RENAME TABLE mysql.plugin_bkp TO mysql.plugin
RENAME TABLE mysql.servers TO mysql.servers_bkp
RENAME TABLE mysql.servers_bkp TO mysql.servers
RENAME TABLE mysql.user TO mysql.user_bkp
RENAME TABLE mysql.user_bkp TO mysql.user
RENAME TABLE mysql.columns_priv TO mysql.columns_priv_bkp
RENAME TABLE mysql.columns_priv_bkp TO mysql.columns_priv
RENAME TABLE mysql.tables_priv TO mysql.tables_priv_bkp
RENAME TABLE mysql.tables_priv_bkp TO mysql.tables_priv
RENAME TABLE mysql.procs_priv TO mysql.procs_priv_bkp
RENAME TABLE mysql.procs_priv_bkp TO mysql.procs_priv
RENAME TABLE mysql.proxies_priv TO mysql.proxies_priv_bkp
GRANT PROXY ON 'user1'@'%' TO 'user2'@'%'
GRANT PROXY ON 'user1'@'%' TO 'user2'@'%'
RENAME TABLE mysql.proxies_priv_bkp TO mysql.proxies_priv
RENAME TABLE mysql.component TO mysql.component_bkp
RENAME TABLE mysql.component_bkp TO mysql.component
RENAME TABLE mysql.db TO mysql.db_bkp
RENAME TABLE mysql.db_bkp TO mysql.db
RENAME TABLE mysql.default_roles TO mysql.default_roles_bkp
RENAME TABLE mysql.default_roles_bkp TO mysql.default_roles
RENAME TABLE mysql.global_grants TO mysql.global_grants_bkp
RENAME TABLE mysql.global_grants_bkp TO mysql.global_grants
RENAME TABLE mysql.role_edges TO mysql.role_edges_bkp
RENAME TABLE mysql.role_edges_bkp TO mysql.role_edges
RENAME TABLE mysql.password_history TO mysql.password_history_bkp
RENAME TABLE mysql.password_history_bkp TO mysql.password_history
CALL mtr.add_suppression("==[0-9]*== Warning: set address range perms: large range")
SELECT ADDDATE('8112-06-20', REPEAT('1', 32))
SELECT @@global.dragnet.log_error_filter_rules
SELECT @@global.dragnet.log_error_filter_rules
create table t1 ( min_num   dec(6,6)     default .000001)
create table t1 ( min_num   dec(6,6)     default 0.000001)
create table t1 ( min_num   dec(6,6)     default .000001)
show local variables like 'SQL_MODE'
show local variables like 'SQL_MODE'
PREPARE insert_stmt FROM 'INSERT INTO test_table VALUES (?)'
PREPARE update_stmt FROM 'UPDATE test_table SET c1= ? WHERE c1= ?'
DELIMITER
CREATE FUNCTION test_function(var CHAR(50)) RETURNS CHAR(50) BEGIN DECLARE char_val CHAR(50); SELECT c1 INTO char_val FROM test_table WHERE c1=var; RETURN char_val; END
EXECUTE insert_stmt USING @var1
EXECUTE insert_stmt USING @var2
EXECUTE insert_stmt USING @var3
EXECUTE insert_stmt USING @var4
EXECUTE insert_stmt USING @var5
EXECUTE insert_stmt USING @var6
EXECUTE insert_stmt USING @var7
EXECUTE insert_stmt USING @var8
EXECUTE insert_stmt USING @var9
EXECUTE update_stmt USING @to_var1, @var1
EXECUTE update_stmt USING @to_var2, @var2
EXECUTE update_stmt USING @to_var3, @var3
EXECUTE update_stmt USING @to_var4, @var4
EXECUTE update_stmt USING @to_var5, @var5
EXECUTE update_stmt USING @to_var6, @var6
EXECUTE update_stmt USING @to_var7, @var7
EXECUTE update_stmt USING @to_var8, @var8
EXECUTE update_stmt USING @to_var9, @var9
DELIMITER
CREATE FUNCTION test_function(var CHAR(50)) RETURNS CHAR(50) BEGIN DECLARE char_val CHAR(50); SELECT c1 INTO char_val FROM test_table WHERE c1=var; RETURN char_val; END
EXECUTE insert_stmt USING @var1
EXECUTE insert_stmt USING @var2
EXECUTE insert_stmt USING @var3
EXECUTE insert_stmt USING @var4
EXECUTE insert_stmt USING @var5
EXECUTE insert_stmt USING @var6
EXECUTE insert_stmt USING @var7
EXECUTE insert_stmt USING @var8
EXECUTE insert_stmt USING @var9
EXECUTE update_stmt USING @to_var1, @var1
EXECUTE update_stmt USING @to_var2, @var2
EXECUTE update_stmt USING @to_var3, @var3
EXECUTE update_stmt USING @to_var4, @var4
EXECUTE update_stmt USING @to_var5, @var5
EXECUTE update_stmt USING @to_var6, @var6
EXECUTE update_stmt USING @to_var7, @var7
EXECUTE update_stmt USING @to_var8, @var8
EXECUTE update_stmt USING @to_var9, @var9
PREPARE stmt FROM 'UPDATE test SET count = count + 1 WHERE id = ?'
EXECUTE stmt USING @a
EXECUTE stmt USING @a
INSERT INTO t1 VALUES (REPEAT(0x1125,200000), REPEAT(0x1125,200000)), ('', ''), ('', '')
LOAD DATA INFILE '../../std_data/bug21542698.dat' INTO TABLE t1 CHARACTER SET gb18030
INSERT INTO dd_check_table(t) SELECT CONCAT(id, '-', name, '-', IFNULL(options, 'NULL'), '-', IFNULL(INSERT(se_private_data, INSTR(se_private_data, 'server_version'), 20, 'server_version=x'), 'NULL'), '-', comment, '-', engine) FROM mysql.tablespaces WHERE name = 'mysql'
< @@group_concat_max_len
FROM dd_published_schema, whole_schema WHERE dd_published_schema.checksum = whole_schema.checksum AND lctn = @@global.lower_case_file_system]" = 1
$dd_table_names, $ddse_table_names
create table t1 (s1 int) partition by list (s1) (partition c values in (1), partition Ã‡ values in (3))
LET $MYSQLD_DATADIR = `SELECT @@datadir`
FLUSH TABLE t1
SELECT mysqltest.f1()
SELECT mysqltest.f1()
SELECT mysqltest.f1()
SELECT mysqltest.f1()
SHOW GRANTS FOR mysqltest_1@'127.0.0.1/255.255.255.255'
source include/search_pattern.inc
source include/search_pattern.inc
GRANT r2 TO u1@localhost WITH ADMIN OPTION
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u2@localhost USING r1
do version_tokens_set("token1    =     def;;;;      ;invalid_token; token2= abc;;")
do version_tokens_set("token1    =     def;; token111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111=123;;      ;invalid_token; token2= abc;;")
do version_tokens_set("token1    =     none;;;;      ;invalid_token; token2= 123;;")
do version_tokens_set("token1=def;token2= abc;          ;token3=ghi")
do version_tokens_set("token1=def;token2= abc;token3=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111112")
CONNECT (vtcon1, localhost, u1, foo,)
CONNECT (vtcon2, localhost, root,,)
CONNECT (vtcon3, localhost, root,,)
CONNECTION vtcon1
CONNECTION vtcon2
CONNECTION vtcon3
WHERE info like '%select sleep%' AND state='User sleep'
source include/wait_condition.inc
CONNECTION vtcon1
LOCK TABLES t1 WRITE
echo "WL6369 Explain for Connection"
CALL mtr.add_suppression("You need to use --log-bin to make --log-replica-updates work.")
show function code signal_func
create function db() returns varchar(64) begin declare v varchar(64); select u into v from t1 limit 1; return v; end
call db1_secret.stamp(2)
select db1_secret.db()
call db1_secret.stamp(3)
select db1_secret.db()
call db1_secret.stamp(5)
select db1_secret.db()
call db1_secret.stamp(6)
select db1_secret.db()
show grants for usera@localhost
show grants for userc@localhost
call sptest.p1(1)
call sptest.p1(2)
call sptest.p1(3)
call sptest.p1(4)
show grants for userc@localhost
show grants for userb@localhost
show grants for userb@localhost
create function bug_9503 () returns int sql security invoker begin declare v int; select min(s1) into v from t1; return v; end
do 1
call mysqltest_1.p1()
call mysqltest_1.p1()
SELECT test.bug12812()
CREATE VIEW v1 AS SELECT test.bug12812()
create procedure bug14533_1() sql security definer desc db_bug14533.t1
call db_bug14533.bug14533_1()
call db_bug14533.bug14533_2()
CREATE PROCEDURE sp19857() DETERMINISTIC BEGIN DECLARE a INT; SET a=1; SELECT a; END
CREATE PROCEDURE p_suid(IN i INT) SQL SECURITY DEFINER SET @c:= 0
CREATE DEFINER=mysqltest_u1@localhost FUNCTION f_evil () RETURNS INT SQL SECURITY INVOKER BEGIN SET @a:= CURRENT_USER(); SET @b:= (SELECT COUNT(*) FROM t1); RETURN @b; END
CONNECT (con_tester,localhost,tester,,B48872)
CONNECT (con_tester_denied,localhost,Tester,,B48872)
CONNECTION con_tester
CONNECTION con_tester_denied
CONNECTION default
DISCONNECT con_tester
DISCONNECT con_tester_denied
select mysqltest_db.f_does_not_exist()
call mysqltest_db.p_does_not_exist()
select mysqltest_db.f1()
call mysqltest_db.p1()
create view bug12602983_v1 as select mysqltest_db.f_does_not_exist()
create view bug12602983_v1 as select mysqltest_db.f1()
CONNECTION default
lock tables t1 READ
lock tables t1 WRITE
unlock tables
charset(load_file('../../std_data/words.dat')), collation(load_file('../../std_data/words.dat')), coercibility(load_file('../../std_data/words.dat'))
charset(load_file('$MYSQLTEST_VARDIR/std_data/words.dat')), collation(load_file('$MYSQLTEST_VARDIR/std_data/words.dat')), coercibility(load_file('$MYSQLTEST_VARDIR/std_data/words.dat'))
INSERT INTO t (c) VALUES (REPEAT('1',65537))
INSERT INTO t (c) VALUES (REPEAT('2',65536))
INSERT INTO t (c) VALUES (REPEAT('3',65535))
create table b15776 (data blob(2147483648))
create table b15776 (data blob(4294967294))
create table b15776 (data blob(4294967295))
create table b15776 (data blob(4294967296))
CREATE TABLE b15776 (a blob(2147483647), b blob(2147483648), c blob(4294967295), a1 text(2147483647), b1 text(2147483648), c1 text(4294967295) )
CREATE TABLE b15776 (a blob(4294967296))
CREATE TABLE b15776 (a text(4294967296))
CREATE TABLE b15776 (a blob(999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999))
CREATE TABLE b15776 (a text(999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999))
CREATE TABLE b15776 (a char(2147483648))
CREATE TABLE b15776 (a char(4294967295))
CREATE TABLE b15776 (a char(4294967296))
CREATE TABLE b15776 (a year(4294967295))
CREATE TABLE b15776 (a year(4294967296))
CREATE TABLE b15776 (a int(999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999))
CREATE TABLE b15776 (a char(999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999))
CREATE TABLE b15776 (a year(999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999))
explain select cast(1 as char(4294967295))
explain select cast(1 as nchar(4294967295))
explain select cast(1 as binary(4294967295))
explain select cast(1 as char(4294967296))
explain select cast(1 as nchar(4294967296))
explain select cast(1 as binary(4294967296))
explain select cast(1 as decimal(64, 999999999999999999999999999999))
explain select cast(1 as decimal(4294967296))
explain select cast(1 as decimal(999999999999999999999999999999999999))
UPDATE t2 SET c = REPEAT('1', 70000)
UPDATE t1 LEFT JOIN t2 USING(id) SET t2.c = REPEAT('1', 70000) WHERE t1.id = 1
select @g1 between @g1 and ST_GeomFromText('POLYGON((30 30,40 40,50 50,30 50,30 40,30 30))')
LOCK TABLES t1 WRITE, t2 WRITE, t0 WRITE
RENAME TABLES t0 TO t00, t1 TO t01
UNLOCK TABLES
LOCK TABLES t0 WRITE, t1 WRITE
RENAME TABLES t0 TO mysqltest.t0, t1 TO t01
UNLOCK TABLES
select extract(DAY_MICROSECOND FROM "1999-01-02 10:11:12.000123")
select extract(HOUR_MICROSECOND FROM "1999-01-02 10:11:12.000123")
select extract(MINUTE_MICROSECOND FROM "1999-01-02 10:11:12.000123")
select extract(SECOND_MICROSECOND FROM "1999-01-02 10:11:12.000123")
create procedure p1() begin declare n int default 2; authors: while n > 0 do set n = n -1; end while authors; end
create procedure p2() begin declare n int default 2; contributors: while n > 0 do set n = n -1; end while contributors; end
create procedure p1() begin declare connection int; select max(t1.connection) into connection from t1; select concat("max=",connection) 'p1'; end
CREATE PROCEDURE p1() BEGIN DECLARE slow INT; DECLARE general INT; DECLARE ignore_server_ids INT; DECLARE master_heartbeat_period INT; SELECT max(t1.slow) INTO slow FROM t1; SELECT max(t1.general) INTO general FROM t1; SELECT max(t1.ignore_server_ids) INTO ignore_server_ids FROM t1; SELECT max(t1.master_heartbeat_period) INTO master_heartbeat_period FROM t1; SELECT slow, general, ignore_server_ids, master_heartbeat_period; END
CREATE PROCEDURE p2() BEGIN DECLARE n INT DEFAULT 2; general: WHILE n > 0 DO SET n = n -1; END WHILE general; SET n = 2; slow: WHILE n > 0 DO SET n = n -1; END WHILE slow; SET n = 2; ignore_server_ids: WHILE n > 0 DO SET n = n -1; END WHILE ignore_server_ids; SET n = 2; master_heartbeat_period: WHILE n > 0 DO SET n = n -1; END WHILE master_heartbeat_period; END
create table t (i)
load data infile '../../std_data/warnings_loaddata.dat' into table t1 fields terminated by ','
disable_query_log
enable_query_log
CREATE PROCEDURE sp1() BEGIN DECLARE x NUMERIC ZEROFILL; SELECT f1 INTO x FROM t1 LIMIT 1; END
CREATE PROCEDURE sp2() BEGIN DECLARE x NUMERIC ZEROFILL; SELECT f1 INTO x FROM t2 LIMIT 1; END
CREATE PROCEDURE sp3() BEGIN DECLARE x NUMERIC ZEROFILL; SELECT f1 INTO x FROM t3 LIMIT 1; END
CREATE PROCEDURE sp1() BEGIN declare x numeric unsigned zerofill; SELECT f1 into x from t2 limit 1; END
set @q = repeat('q', 256)
load xml infile '../../std_data/loadxml.dat' into table t1 rows identified by '<row>'
load xml infile '../../std_data/loadxml.dat' into table t1 rows identified by '<row>' ignore 4 rows
sleep 3
remove_file $MYSQLTEST_VARDIR/tmp/loadxml-dump.xml
load xml infile '../../std_data/loadxml2.dat' into table t1
LOAD XML INFILE '../../std_data/loadxml.dat' INTO TABLE t1 ROWS IDENTIFIED BY '<row>' (a,@b) SET b=concat('!',@b)
LOAD XML INFILE '../../std_data/bug16171518_1.dat' INTO TABLE t1
LOAD XML INFILE '../../std_data/bug16171518_2.dat' INTO TABLE t1
LOAD XML INFILE '../../std_data/bug16171518_2.dat' INTO TABLE t1
LOAD XML INFILE '../../std_data/bug16171518_2.dat' INTO TABLE v3
LOAD XML INFILE '../../std_data/bug16171518_2.dat' INTO TABLE t4 (col1, col2, col3) SET col4 = NULL
LOAD XML INFILE '../../std_data/bug30753708.dat' INTO TABLE t1 ROWS IDENTIFIED BY '<address>'
LOAD XML INFILE '../../std_data/bug30753708.dat' INTO TABLE t1 ROWS IDENTIFIED BY '<address>'
lock tables t2 write
send call bug9486()
unlock tables
reap
lock tables t2 read
unlock tables
lock table t1 write
send call p2()
unlock tables
reap
CREATE VIEW v1 AS SELECT id, 'a' AS name, a AS val FROM t1 UNION SELECT id, 'mn', HEX(LIKE_RANGE_MIN(a, 16)) AS min FROM t1 UNION SELECT id, 'mx', HEX(LIKE_RANGE_MAX(a, 16)) AS max FROM t1 UNION SELECT id, 'sp', REPEAT('-', 32) AS sep FROM t1 ORDER BY id, name
CALL mtr.add_suppression("Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT")
prepare s from "select ?+11.1"
prepare s from "select ?+11"
prepare s from "select ?+?"
execute s using @a,@a
execute s using @a,@a
prepare s from "select ?+?"
execute s using @a,@a
prepare s from "select ?+?"
execute s using @a,@a
prepare s from "select ?+?"
execute s using @a,@a
prepare s from "select ?+?"
execute s using @a,@a
execute s using @a,@a
execute s using @a,@a
prepare s from "select 1.0+?"
execute s using @a
prepare s from "select 1e0+?"
execute s using @a
prepare s from "select date(?)"
execute s using @a
prepare s from "select 11.1*(?+?)"
prepare s from 'select -(?)'
execute s using @a
execute s using @a
prepare s from 'select cast(? as time), ?+1'
execute s using @a,@b
execute s using @a,@b
prepare s from 'select ABS(?)'
execute s using @a
prepare s from 'select ?'
prepare s from 'select sum(1) over (order by ?)'
prepare s from 'select sum(1) over (order by ? range 2 preceding)'
prepare s from 'select sum(1) over (order by 1.1 range ? preceding)'
prepare s from 'select 1 where ? group by ? having ? order by ?'
prepare s from 'select 1 from t1 left join t2 on ?'
prepare s from 'select ?'
execute s using @a
execute s using @a
execute s using @a
prepare s from 'select 1 where ?'
execute s using @a
prepare s from 'select cast(? as unsigned)'
execute s using @y
execute s using @a
prepare s from 'select cast(? as char(10))'
execute s using @s
prepare s from 'select cast(? as binary(3))'
execute s using @s
prepare s from 'select cast(? as date)'
execute s using @d
prepare s from 'select cast(? as time(6))'
execute s using @t
prepare s from 'select cast(? as datetime(6))'
execute s using @dt
prepare s from 'select cast(? as year)'
execute s using @y
prepare s from 'select cast(? as float)'
execute s using @y
prepare s from 'select cast(? as double)'
execute s using @y
prepare s from 'select cast(? as decimal(10))'
execute s using @y
prepare s from 'select cast(? as json)'
execute s using @j
prepare s from 'select convert(?, decimal(10))'
prepare s from 'select 1 where ? and ?'
execute s using @a,@a
prepare s from 'select ?=12, ?=?, 1 BETWEEN ? AND 4.3, ? BETWEEN 1 AND 4.3, ? BETWEEN ? AND ?, ? >= 3, ? >= ?'
prepare s from 'select ifnull(?,?),ifnull(?,cast("2000" as date))'
prepare s from 'select if(?,?,?),if(?,cast("2000" as date),?)'
prepare s from 'select coalesce(?,?,?),coalesce(?,cast("2000" as date),?)'
prepare s from 'select ? in (?,?), ? in (2,?)'
prepare s from 'select ? not in (?,?), ? not in (2,?)'
prepare s from ' select case ? when 3 then 1e0 else 2e0 end, case 3 when ? then 6 else 12 end, case ? when ? then 6 else 12 end'
prepare s from ' select case 3 when 3 then ? else 2e0 end, case 3 when 3 then 1e0 else ? end, case 3 when 3 then ? else ? end, case ? when ? then ? else ? end'
prepare s from ' select case ? when ? then ? else ? end'
prepare s from ' select case when 3=2 then ? else 2e0 end, case when ? then 6 else 12 end, case when ? then ? else ? end'
prepare s from ' select ? in (select a from t1), 3 in (select ? from t1)'
prepare s from ' select ? >= ALL(select a from t1), ? = ALL (select a from t1), ? >= ANY (select a from t1), ? NOT IN (select a from t1)'
set @a=repeat("x",1000000)
set @b=repeat("y",1000000)
prepare s from 'select length(?), md5(?)'
execute s using @a,@a
prepare s from 'insert into t3 values(?)'
execute s using @a
prepare s from 'update t3 set a=?'
execute s using @b
prepare s from 'delete from t3 where a=?'
execute s using @b
prepare s from 'insert into t3 select ?'
execute s using @a
prepare s from 'insert into t3 select ? union select ?'
execute s using @a, @b
prepare s from 'insert into t3 select ? union all select ?'
execute s using @a, @b
prepare s from 'create table t4 as select ? as a from t3 limit 1'
execute s using @b
prepare s from 'create table t4 as select cast(? as binary(1000000)) as a from t3 limit 1'
execute s using @b
prepare s from 'select ~ ?'
prepare s from 'select ? IS TRUE'
prepare s from 'select ? IS FALSE'
prepare s from 'select ? IS NOT TRUE'
prepare s from 'select ? IS NOT FALSE'
prepare s from 'select ? IS NULL'
prepare s from 'select ? IS NOT NULL'
prepare s from 'select - ?'
prepare s from 'select ? - ?'
prepare s from 'select ! ?'
prepare s from 'select NOT ?'
prepare s from 'select NOT(?)'
prepare s from 'select ? DIV ?'
prepare s from 'select ? AND ?'
prepare s from 'select ? OR ?'
prepare s from 'select ? XOR ?'
prepare s from 'select ? % ?'
prepare s from 'select ? MOD ?'
prepare s from 'select + ?'
prepare s from 'select ? + ?'
prepare s from 'select - ?'
prepare s from 'select ? - ?'
prepare s from 'select ? * ?'
prepare s from 'select ? / ?'
prepare s from 'select ? = ?'
prepare s from 'select hex(? & ?)'
execute s using @a,@a
prepare s from 'select ? & 2'
execute s using @a
prepare s from 'select ? | ?'
prepare s from 'select ? ^ ?'
prepare s from 'select ? / ?'
prepare s from 'select ? = ?'
prepare s from 'select ? <=> ?'
prepare s from 'select ? > ?'
prepare s from 'select ? >= ?'
prepare s from 'select ? < ?'
prepare s from 'select ? <= ?'
prepare s from 'select ? <> ?'
prepare s from 'select ? != ?'
prepare s from 'select ? << ?'
prepare s from 'select ? >> ?'
prepare s from 'select ? LIKE ?'
prepare s from 'select ? NOT LIKE ?'
prepare s from 'select ? REGEXP ?'
prepare s from 'select ? RLIKE ?'
prepare s from 'select ? NOT REGEXP ?'
prepare s from 'select 1 from articles where MATCH (title,body) AGAINST (?)'
prepare s from 'select ? SOUNDS LIKE ?'
prepare s from 'select ABS(?)'
prepare s from 'select ACOS(?)'
prepare s from 'select ADDDATE(?,?)'
prepare s from 'select ADDDATE(?, INTERVAL ? MONTH)'
prepare s from 'select ADDDATE(?, INTERVAL ? SECOND)'
prepare s from "SELECT ADDDATE('2008-01-02', interval ? second)"
execute s using @a
prepare s from 'select ADDDATE(?, INTERVAL ? DAY_SECOND)'
prepare s from 'select ADDTIME(?,?)'
prepare s from 'select AES_DECRYPT(?,?)'
prepare s from 'select AES_DECRYPT(?,?,?)'
prepare s from 'select AES_ENCRYPT(?,?)'
prepare s from 'select AES_ENCRYPT(?,?,?)'
prepare s from 'select ANY_VALUE(?)'
prepare s from 'select ASCII(?)'
prepare s from 'select ASIN(?)'
prepare s from 'select ATAN(?)'
prepare s from 'select ATAN(?,?)'
prepare s from 'select ATAN2(?)'
prepare s from 'select ATAN2(?,?)'
prepare s from 'select AVG(?)'
prepare s from 'select BENCHMARK(?,?)'
prepare s from 'select BIN(?)'
prepare s from 'select BIN_TO_UUID(?)'
prepare s from 'select BIN_TO_UUID(?,?)'
prepare s from 'select BINARY(?)'
prepare s from 'select BIT_AND(?)'
prepare s from 'select BIT_COUNT(?)'
prepare s from 'select bit_count(?),bit_count(?)'
execute s using @a,@b
execute s using @a,@b
execute s using @a,@b
execute s using @a,@b
prepare s from 'select BIT_LENGTH(?)'
prepare s from 'select BIT_OR(?)'
prepare s from 'select BIT_XOR(?)'
prepare s from 'select CEIL(?)'
prepare s from 'select CEILING(?)'
prepare s from 'select CHAR(?)'
prepare s from 'select CHAR(?,?)'
prepare s from 'select CHAR(?,?,?)'
prepare s from 'select CHAR(?,?,?,?)'
prepare s from 'select CHAR(?,?,?,?,?)'
prepare s from 'select CHAR_LENGTH(?)'
prepare s from 'select CHARACTER_LENGTH(?)'
prepare s from 'select CHARSET(?)'
prepare s from 'select COALESCE(?)'
prepare s from 'select COALESCE(?,?)'
prepare s from 'select COALESCE(?,?,?)'
prepare s from 'select COALESCE(?,?,?,?)'
prepare s from 'select COALESCE(?,?,?,?,?)'
prepare s from 'select COERCIBILITY(?)'
prepare s from 'select COLLATION(?)'
prepare s from 'select COMPRESS(?)'
prepare s from 'select CONCAT(?)'
prepare s from 'select CONCAT(?,?)'
prepare s from 'select CONCAT(?,?,?)'
prepare s from 'select CONCAT(?,?,?,?)'
prepare s from 'select CONCAT(?,?,?,?,?)'
prepare s from 'select CONCAT_WS(?,?)'
prepare s from 'select CONCAT_WS(?,?,?)'
prepare s from 'select CONCAT_WS(?,?,?,?)'
prepare s from 'select CONCAT_WS(?,?,?,?,?)'
prepare s from 'select CONNECTION_ID()'
prepare s from 'select CONV(?,?,?)'
prepare s from 'select CONVERT_TZ(?,?,?)'
prepare s from 'select COS(?)'
prepare s from 'select COT(?)'
prepare s from 'select COUNT(?)'
prepare s from 'select COUNT(DISTINCT ?,?,?,?,?)'
prepare s from 'select CRC32(?)'
prepare s from 'select CURDATE()'
prepare s from 'select CURRENT_DATE()'
prepare s from 'select CURRENT_ROLE()'
prepare s from 'select CURRENT_TIME()'
prepare s from 'select CURRENT_TIMESTAMP()'
prepare s from 'select CURRENT_USER()'
prepare s from 'select CURTIME()'
prepare s from 'select DATABASE()'
prepare s from 'select DATE(?)'
set @a= timestamp "2001-01-02 10:11:12.345"
execute s using @a
set @a=date "2001-01-02"
execute s using @a
prepare s from 'select DATE_FORMAT(?,?)'
prepare s from 'select DATEDIFF(?,?)'
prepare s from 'select DAY(?)'
prepare s from 'select DAYNAME(?)'
prepare s from 'select DAYOFMONTH(?)'
prepare s from 'select DAYOFWEEK(?)'
prepare s from 'select DAYOFYEAR(?)'
prepare s from 'select DEGREES(?)'
prepare s from 'select ELT(?,?)'
prepare s from 'select ELT(?,?,?)'
prepare s from 'select ELT(?,?,?,?)'
prepare s from 'select ELT(?,?,?,?,?)'
prepare s from 'select EXP(?)'
prepare s from 'select EXPORT_SET(?,?,?)'
prepare s from 'select EXPORT_SET(?,?,?,?)'
prepare s from 'select EXPORT_SET(?,?,?,?,?)'
prepare s from 'select EXTRACT(YEAR FROM ?)'
prepare s from 'select ExtractValue(?,?)'
prepare s from 'select FIELD(?,?)'
prepare s from 'select FIELD(?,?,?)'
prepare s from 'select FIELD(?,?,?,?)'
prepare s from 'select FIELD(?,?,?,?,?)'
prepare s from 'select FIND_IN_SET(?,?)'
prepare s from 'select FIRST_VALUE(?) over () from t1'
prepare s from 'select FLOOR(?)'
prepare s from 'select FORMAT(?,?)'
prepare s from 'select FORMAT(?,?,?)'
prepare s from 'select FOUND_ROWS()'
prepare s from 'select FROM_BASE64(?)'
prepare s from 'select FROM_DAYS(?)'
prepare s from 'select FROM_UNIXTIME(?)'
prepare s from 'select FROM_UNIXTIME(?,?)'
prepare s from 'select GeomCollection(?, ?, ?, ?, ?)'
prepare s from 'select GET_LOCK(?,?)'
prepare s from 'select GREATEST(?,?,?,?,?)'
prepare s from 'select GROUP_CONCAT(?)'
prepare s from 'select GROUP_CONCAT(?,?)'
prepare s from 'select GROUP_CONCAT(?,?,?)'
prepare s from 'select GROUP_CONCAT(?,?,?,?)'
prepare s from 'select GROUP_CONCAT(?,?,?,?,?)'
prepare s from 'select GROUP_CONCAT(DISTINCT ?,? ORDER BY ? SEPARATOR ",")'
prepare s from 'select GTID_SUBSET(?,?)'
prepare s from 'select GTID_SUBTRACT(?,?)'
prepare s from 'select HEX(?)'
prepare s from 'select HOUR(?)'
set @a= time "10:11:12.345"
execute s using @a
set @a= timestamp "2001-01-02 10:11:12.345"
execute s using @a
prepare s from 'select ICU_VERSION()'
prepare s from 'select IF(?,?,?)'
prepare s from 'select IFNULL(?,?)'
prepare s from 'select INET_ATON(?)'
prepare s from 'select INET_NTOA(?)'
prepare s from 'select INET6_ATON(?)'
prepare s from 'select INET6_NTOA(?)'
set @a= _binary 0xFDFE0000000000005A55CAFFFEFA9089
execute s using @a
execute s using @a
prepare s from 'select INSERT(?,?,?,?)'
prepare s from 'select INSTR(?,?)'
prepare s from 'select INTERVAL(?,?)'
prepare s from 'select INTERVAL(?,?,?)'
prepare s from 'select INTERVAL(?,?,?,?)'
prepare s from 'select INTERVAL(?,?,?,?,?)'
prepare s from 'select IS_FREE_LOCK(?)'
prepare s from 'select IS_IPV4(?)'
prepare s from 'select IS_IPV4_COMPAT(?)'
prepare s from 'select IS_IPV4_MAPPED(?)'
prepare s from 'select IS_IPV6(?)'
prepare s from 'select IS_USED_LOCK(?)'
prepare s from 'select IS_UUID(?)'
prepare s from 'select ISNULL(?)'
prepare s from 'select JSON_ARRAY()'
prepare s from 'select JSON_ARRAY(?)'
prepare s from 'select JSON_ARRAY(?,?)'
prepare s from 'select JSON_ARRAY(?,?,?)'
prepare s from 'select JSON_ARRAY(?,?,?,?)'
prepare s from 'select JSON_ARRAY(?,?,?,?,?)'
prepare s from 'select JSON_ARRAY_APPEND(?,?,?)'
prepare s from 'select JSON_ARRAY_APPEND(?,?,?,?,?)'
prepare s from 'select JSON_ARRAY_INSERT(?,?,?)'
prepare s from 'select JSON_ARRAY_INSERT(?,?,?,?,?)'
prepare s from 'select JSON_ARRAYAGG(?)'
prepare s from 'select JSON_CONTAINS(?,?)'
prepare s from 'select JSON_CONTAINS(?,?,?)'
prepare s from 'select JSON_CONTAINS_PATH(?,?,?)'
prepare s from 'select JSON_CONTAINS_PATH(?,?,?,?)'
prepare s from 'select JSON_CONTAINS_PATH(?,?,?,?,?)'
prepare s from 'select JSON_DEPTH(?)'
prepare s from 'select JSON_EXTRACT(?,?)'
prepare s from 'select JSON_EXTRACT(?,?,?)'
prepare s from 'select JSON_EXTRACT(?,?,?,?)'
prepare s from 'select JSON_EXTRACT(?,?,?,?,?)'
prepare s from 'select JSON_INSERT(?,?,?)'
prepare s from 'select JSON_INSERT(?,?,?,?,?)'
prepare s from 'select JSON_KEYS(?)'
prepare s from 'select JSON_KEYS(?,?)'
prepare s from 'select JSON_LENGTH(?)'
prepare s from 'select JSON_LENGTH(?,?)'
prepare s from 'select JSON_MERGE_PATCH(?,?)'
prepare s from 'select JSON_MERGE_PATCH(?,?,?)'
prepare s from 'select JSON_MERGE_PATCH(?,?,?,?)'
prepare s from 'select JSON_MERGE_PATCH(?,?,?,?,?)'
prepare s from 'select JSON_MERGE_PRESERVE(?,?)'
prepare s from 'select JSON_MERGE_PRESERVE(?,?,?)'
prepare s from 'select JSON_MERGE_PRESERVE(?,?,?,?)'
prepare s from 'select JSON_MERGE_PRESERVE(?,?,?,?,?)'
prepare s from 'select JSON_OBJECT()'
prepare s from 'select JSON_OBJECT(?,?)'
prepare s from 'select JSON_OBJECT(?,?,?,?)'
prepare s from 'select JSON_OBJECTAGG(?,?)'
prepare s from 'select JSON_PRETTY(?)'
prepare s from 'select JSON_QUOTE(?)'
prepare s from 'select JSON_REMOVE(?,?)'
prepare s from 'select JSON_REMOVE(?,?,?)'
prepare s from 'select JSON_REMOVE(?,?,?,?)'
prepare s from 'select JSON_REMOVE(?,?,?,?,?)'
prepare s from 'select JSON_REPLACE(?,?,?)'
prepare s from 'select JSON_REPLACE(?,?,?,?,?)'
prepare s from 'select JSON_SEARCH(?,?,?)'
prepare s from 'select JSON_SEARCH(?,?,?,?)'
prepare s from 'select JSON_SEARCH(?,?,?,"x",?)'
prepare s from 'select JSON_SET(?,?,?)'
prepare s from 'select JSON_SET(?,?,?,?,?)'
prepare s from 'select JSON_STORAGE_FREE(?)'
prepare s from 'select JSON_STORAGE_SIZE(?)'
prepare s from 'SELECT * FROM JSON_TABLE( ?, "$[*]" COLUMNS( rowid FOR ORDINALITY, ac VARCHAR(100) PATH "$.a" DEFAULT ''111'' ON EMPTY DEFAULT ''999'' ON ERROR, aj JSON PATH "$.a" DEFAULT ''{"x": 333}'' ON EMPTY, bx INT EXISTS PATH "$.b" ) ) AS tt'
execute s using @a
execute s using @a
prepare s from 'SELECT * FROM JSON_TABLE( ?, ? COLUMNS( rowid FOR ORDINALITY, ac VARCHAR(100) PATH "$.a" DEFAULT ''999'' ON ERROR DEFAULT ''111'' ON EMPTY, aj JSON PATH "$.a" DEFAULT ''{"x": 333}'' ON EMPTY, bx INT EXISTS PATH "$.b" ) prepare s from 'select JSON_TYPE(?)'
prepare s from 'select JSON_UNQUOTE(?)'
prepare s from 'select JSON_VALID(?)'
prepare s from 'select LAG(?,?,?) over () from t1'
prepare s from 'select LAG(?,?,2.1) over () from t1'
prepare s from 'select LAST_DAY(?)'
prepare s from 'select LAST_INSERT_ID()'
prepare s from 'select LAST_INSERT_ID(?)'
prepare s from 'select LAST_VALUE(?) over () from t1'
prepare s from 'select LCASE(?)'
prepare s from 'select LEAD(?,?,?) over () from t1'
prepare s from 'select LEAD(?,?,2.1) over () from t1'
prepare s from 'select LEAST(?,?,?,?,?)'
prepare s from 'select LEFT(?,?)'
prepare s from 'select LENGTH(?)'
prepare s from 'select LineString(?, ?, ?, ?, ?)'
prepare s from 'select LN(?)'
prepare s from 'select LOAD_FILE(?)'
prepare s from 'select LOCALTIME()'
prepare s from 'select LOCALTIMESTAMP()'
prepare s from 'select LOCATE(?,?)'
prepare s from 'select LOCATE(?,?,?)'
prepare s from 'select LOG(?)'
prepare s from 'select LOG(?,?)'
prepare s from 'select LOG10(?)'
prepare s from 'select LOG2(?)'
prepare s from 'select LOWER(?)'
prepare s from 'select LPAD(?,?,?)'
prepare s from 'select LTRIM(?)'
prepare s from 'select MAKE_SET(?,?)'
prepare s from 'select MAKE_SET(?,?,?)'
prepare s from 'select MAKE_SET(?,?,?,?)'
prepare s from 'select MAKE_SET(?,?,?,?,?)'
prepare s from 'select MAKEDATE(?,?)'
prepare s from 'select MAKETIME(?,?,?)'
prepare s from 'select SOURCE_POS_WAIT(?,?)'
prepare s from 'select SOURCE_POS_WAIT(?,?,?)'
prepare s from 'select SOURCE_POS_WAIT(?,?,?,?)'
prepare s from 'select MAX(?)'
prepare s from 'select MBRContains(?,?)'
prepare s from 'select MBRCoveredBy(?,?)'
prepare s from 'select MBRCovers(?,?)'
prepare s from 'select MBRDisjoint(?,?)'
prepare s from 'select MBREquals(?,?)'
prepare s from 'select MBRIntersects(?,?)'
prepare s from 'select MBROverlaps(?,?)'
prepare s from 'select MBRTouches(?,?)'
prepare s from 'select MBRWithin(?,?)'
prepare s from 'select MD5(?)'
prepare s from 'select MICROSECOND(?)'
prepare s from 'select MID(?,?)'
prepare s from 'select MID(?,?,?)'
prepare s from 'select MIN(?)'
prepare s from 'select MINUTE(?)'
prepare s from 'select MOD(?,?)'
prepare s from 'select MONTH(?)'
prepare s from 'select MONTHNAME(?)'
prepare s from 'select MultiLineString(?, ?, ?, ?, ?)'
prepare s from 'select MultiPoint(?, ?, ?, ?, ?)'
prepare s from 'select MultiPolygon(?, ?, ?, ?, ?)'
prepare s from 'select NOW()'
prepare s from 'select NTH_VALUE(?,?) over () from t1'
prepare s from 'select NTILE(?) over () from t1'
prepare s from 'select NULLIF(?,?)'
prepare s from 'select NULLIF(100,?)'
prepare s from 'select NULLIF(?,100)'
prepare s from 'select 200 + NULLIF(?,?)'
prepare s from 'select 200 + NULLIF("100",?)'
prepare s from 'select 200 + NULLIF(?,"100")'
prepare s from 'select OCT(?)'
prepare s from 'select OCTET_LENGTH(?)'
prepare s from 'select ORD(?)'
prepare s from 'select PERIOD_ADD(?,?)'
prepare s from 'select PERIOD_DIFF(?,?)'
prepare s from 'select PI()'
prepare s from 'select Point(?,?)'
prepare s from 'select Polygon(?, ?, ?, ?, ?)'
prepare s from 'select POW(?,?)'
prepare s from 'select POWER(?,?)'
prepare s from 'select QUARTER(?)'
prepare s from 'select QUOTE(?)'
prepare s from 'select RADIANS(?)'
prepare s from 'select RAND()'
prepare s from 'select RAND(?)'
prepare s from 'select RANDOM_BYTES(?)'
prepare s from 'select REGEXP_INSTR(?,?)'
prepare s from 'select REGEXP_INSTR(?,?,?)'
prepare s from 'select REGEXP_INSTR(?,?,?,?)'
prepare s from 'select REGEXP_INSTR(?,?,?,?,?)'
prepare s from 'select REGEXP_LIKE(?,?)'
prepare s from 'select REGEXP_LIKE(?,?,?)'
prepare s from 'select REGEXP_REPLACE(?,?,?)'
prepare s from 'select REGEXP_REPLACE(?,?,?,?)'
prepare s from 'select REGEXP_REPLACE(?,?,?,?,?)'
prepare s from 'select REGEXP_SUBSTR(?,?)'
prepare s from 'select REGEXP_SUBSTR(?,?,?)'
prepare s from 'select REGEXP_SUBSTR(?,?,?,?)'
prepare s from 'select REGEXP_SUBSTR(?,?,?,?,?)'
prepare s from 'select RELEASE_ALL_LOCKS()'
prepare s from 'select RELEASE_LOCK(?)'
prepare s from 'select REPEAT(?,?)'
prepare s from 'select REPLACE(?,?,?)'
prepare s from 'select REVERSE(?)'
prepare s from 'select RIGHT(?,?)'
prepare s from 'select ROLES_GRAPHML()'
prepare s from 'select ROUND(?)'
prepare s from 'select ROUND(?,?)'
prepare s from 'select ROW_COUNT()'
prepare s from 'select RPAD(?,?,?)'
prepare s from 'select RTRIM(?)'
prepare s from 'select SCHEMA()'
prepare s from 'select SEC_TO_TIME(?)'
prepare s from 'select SECOND(?)'
prepare s from 'select SESSION_USER()'
prepare s from 'select SHA1(?)'
prepare s from 'select SHA2(?,?)'
prepare s from 'select SIGN(?)'
prepare s from 'select SIN(?)'
prepare s from 'select SLEEP(?)'
prepare s from 'select SOUNDEX(?)'
prepare s from 'select SPACE(?)'
prepare s from 'select SQRT(?)'
prepare s from 'select ST_Area(?)'
prepare s from 'select ST_AsBinary(?)'
prepare s from 'select ST_AsBinary(?,?)'
prepare s from 'select ST_AsGeoJSON(?)'
prepare s from 'select ST_AsGeoJSON(?,?)'
prepare s from 'select ST_AsGeoJSON(?,?,?)'
prepare s from 'select ST_AsText(?)'
prepare s from 'select ST_AsText(?,?)'
prepare s from 'select ST_Buffer(?,?)'
prepare s from 'select ST_Buffer(?,?,?)'
prepare s from 'select ST_Buffer(?,?,?,?)'
prepare s from 'select ST_Buffer(?,?,?,?,?)'
prepare s from 'select ST_Buffer_Strategy(?)'
prepare s from 'select ST_Buffer_Strategy(?,?)'
prepare s from 'select ST_Centroid(?)'
prepare s from 'select ST_Contains(?,?)'
prepare s from 'select ST_ConvexHull(?)'
prepare s from 'select ST_Crosses(?,?)'
prepare s from 'select ST_Difference(?,?)'
prepare s from 'select ST_Dimension(?)'
prepare s from 'select ST_Disjoint(?,?)'
prepare s from 'select ST_Distance(?,?)'
prepare s from 'select ST_Distance_Sphere(?,?)'
prepare s from 'select ST_Distance_Sphere(?,?,?)'
prepare s from 'select ST_EndPoint(?)'
prepare s from 'select ST_Envelope(?)'
prepare s from 'select ST_Equals(?,?)'
prepare s from 'select ST_ExteriorRing(?)'
prepare s from 'select ST_GeoHash(?,?)'
prepare s from 'select ST_GeoHash(?,?,?)'
prepare s from 'select ST_GeomCollFromText(?)'
prepare s from 'select ST_GeomCollFromText(?,?)'
prepare s from 'select ST_GeomCollFromText(?,?,?)'
prepare s from 'select ST_GeomCollFromWKB(?)'
prepare s from 'select ST_GeomCollFromWKB(?,?)'
prepare s from 'select ST_GeomCollFromWKB(?,?,?)'
prepare s from 'select ST_GeometryN(?,?)'
prepare s from 'select ST_GeometryType(?)'
prepare s from 'select ST_GeomFromGeoJSON(?)'
prepare s from 'select ST_GeomFromGeoJSON(?,?)'
prepare s from 'select ST_GeomFromGeoJSON(?,?,?)'
prepare s from 'select ST_GeomFromText(?)'
prepare s from 'select ST_GeomFromText(?,?)'
prepare s from 'select ST_GeomFromText(?,?,?)'
prepare s from 'select ST_GeomFromWKB(?)'
prepare s from 'select ST_GeomFromWKB(?,?)'
prepare s from 'select ST_GeomFromWKB(?,?,?)'
prepare s from 'select ST_InteriorRingN(?,?)'
prepare s from 'select ST_Intersection(?,?)'
prepare s from 'select ST_Intersects(?,?)'
prepare s from 'select ST_IsClosed(?)'
prepare s from 'select ST_IsEmpty(?)'
prepare s from 'select ST_IsSimple(?)'
prepare s from 'select ST_IsValid(?)'
prepare s from 'select ST_LatFromGeoHash(?)'
prepare s from 'select ST_Latitude(?)'
prepare s from 'select ST_Latitude(?,?)'
prepare s from 'select ST_Length(?)'
prepare s from 'select ST_LineFromText(?)'
prepare s from 'select ST_LineFromText(?,?)'
prepare s from 'select ST_LineFromText(?,?,?)'
prepare s from 'select ST_LineFromWKB(?)'
prepare s from 'select ST_LineFromWKB(?,?)'
prepare s from 'select ST_LineFromWKB(?,?,?)'
prepare s from 'select ST_LongFromGeoHash(?)'
prepare s from 'select ST_Longitude(?)'
prepare s from 'select ST_Longitude(?,?)'
prepare s from 'select ST_MakeEnvelope(?,?)'
prepare s from 'select ST_MLineFromText(?)'
prepare s from 'select ST_MLineFromText(?,?)'
prepare s from 'select ST_MLineFromText(?,?,?)'
prepare s from 'select ST_MLineFromWKB(?)'
prepare s from 'select ST_MLineFromWKB(?,?)'
prepare s from 'select ST_MLineFromWKB(?,?,?)'
prepare s from 'select ST_MPointFromText(?)'
prepare s from 'select ST_MPointFromText(?,?)'
prepare s from 'select ST_MPointFromText(?,?,?)'
prepare s from 'select ST_MPointFromWKB(?)'
prepare s from 'select ST_MPointFromWKB(?,?)'
prepare s from 'select ST_MPointFromWKB(?,?,?)'
prepare s from 'select ST_MPolyFromText(?)'
prepare s from 'select ST_MPolyFromText(?,?)'
prepare s from 'select ST_MPolyFromText(?,?,?)'
prepare s from 'select ST_MPolyFromWKB(?)'
prepare s from 'select ST_MPolyFromWKB(?,?)'
prepare s from 'select ST_MPolyFromWKB(?,?,?)'
prepare s from 'select ST_NumGeometries(?)'
prepare s from 'select ST_NumInteriorRing(?)'
prepare s from 'select ST_NumPoints(?)'
prepare s from 'select ST_Overlaps(?,?)'
prepare s from 'select ST_PointFromGeoHash(?,?)'
prepare s from 'select ST_PointFromText(?)'
prepare s from 'select ST_PointFromText(?,?)'
prepare s from 'select ST_PointFromText(?,?,?)'
prepare s from 'select ST_PointFromWKB(?)'
prepare s from 'select ST_PointFromWKB(?,?)'
prepare s from 'select ST_PointFromWKB(?,?,?)'
prepare s from 'select ST_PointN(?,?)'
prepare s from 'select ST_PolyFromText(?)'
prepare s from 'select ST_PolyFromText(?,?)'
prepare s from 'select ST_PolyFromText(?,?,?)'
prepare s from 'select ST_PolyFromWKB(?)'
prepare s from 'select ST_PolyFromWKB(?,?)'
prepare s from 'select ST_PolyFromWKB(?,?,?)'
prepare s from 'select ST_Simplify(?,?)'
prepare s from 'select ST_SRID(?)'
prepare s from 'select ST_SRID(?,?)'
prepare s from 'select ST_StartPoint(?)'
prepare s from 'select ST_SwapXY(?)'
prepare s from 'select ST_SymDifference(?,?)'
prepare s from 'select ST_Touches(?,?)'
prepare s from 'select ST_Union(?,?)'
prepare s from 'select ST_Validate(?)'
prepare s from 'select ST_Within(?,?)'
prepare s from 'select ST_X(?)'
prepare s from 'select ST_X(?,?)'
prepare s from 'select ST_Y(?)'
prepare s from 'select ST_Y(?,?)'
prepare s from 'select STATEMENT_DIGEST(?)'
prepare s from 'select STATEMENT_DIGEST_TEXT(?)'
prepare s from 'select STD(?)'
prepare s from 'select STDDEV(?)'
prepare s from 'select STDDEV_POP(?)'
prepare s from 'select STDDEV_SAMP(?)'
prepare s from 'select STR_TO_DATE(?,?)'
prepare s from 'select STRCMP(?,?)'
prepare s from 'select SUBDATE(?,?)'
prepare s from 'select SUBSTR(?,?)'
prepare s from 'select SUBSTR(?,?,?)'
prepare s from 'select SUBSTRING(?,?)'
prepare s from 'select SUBSTRING(?,?,?)'
prepare s from 'select SUBSTRING_INDEX(?,?,?)'
prepare s from 'select SUBTIME(?,?)'
prepare s from 'select SUM(?)'
prepare s from 'select SYSDATE()'
prepare s from 'select SYSTEM_USER()'
prepare s from 'select TAN(?)'
prepare s from 'select TIME(?)'
prepare s from 'select TIME_FORMAT(?,?)'
prepare s from 'select TIME_TO_SEC(?)'
prepare s from 'select TIMEDIFF(?,?)'
prepare s from 'select TIMEDIFF(?,"01:02:03")'
set @a= time "01:02:00"
execute s using @a
prepare s from 'select TIMEDIFF(?,"2001-01-01 01:02:03")'
set @a= timestamp "2001-01-02 01:02:00"
execute s using @a
prepare s from 'select TIMESTAMP(?)'
prepare s from 'select TIMESTAMP(?,?)'
prepare s from 'select TIMESTAMPADD(HOUR,?,?)'
prepare s from 'select TIMESTAMPDIFF(HOUR,?,?)'
prepare s from 'select TO_BASE64(?)'
prepare s from 'select TO_DAYS(?)'
set @a= date "2001-01-02"
execute s using @a
set @a= timestamp "2001-01-02 10:11:12.345"
execute s using @a
prepare s from 'select TO_SECONDS(?)'
prepare s from 'select TRIM(?)'
prepare s from 'select TRUNCATE(?,?)'
prepare s from 'select UCASE(?)'
prepare s from 'select UNCOMPRESS(?)'
prepare s from 'select UNCOMPRESSED_LENGTH(?)'
prepare s from 'select UNHEX(?)'
prepare s from 'select UNIX_TIMESTAMP()'
prepare s from 'select UNIX_TIMESTAMP(?)'
prepare s from 'select UpdateXML(?,?,?)'
prepare s from 'select UPPER(?)'
prepare s from 'select USER()'
prepare s from 'select UTC_DATE()'
prepare s from 'select UTC_TIME()'
prepare s from 'select UTC_TIMESTAMP()'
prepare s from 'select UUID()'
prepare s from 'select UUID_SHORT()'
prepare s from 'select UUID_TO_BIN(?)'
prepare s from 'select UUID_TO_BIN(?,?)'
prepare s from 'select VALIDATE_PASSWORD_STRENGTH(?)'
prepare s from 'INSERT INTO t3 VALUES(?,2.0+?)'
prepare s from 'select VAR_POP(?)'
prepare s from 'select VAR_SAMP(?)'
prepare s from 'select VARIANCE(?)'
prepare s from 'select VERSION()'
prepare s from 'select WAIT_FOR_EXECUTED_GTID_SET(?)'
prepare s from 'select WAIT_FOR_EXECUTED_GTID_SET(?,?)'
prepare s from 'select WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS(?)'
prepare s from 'select WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS(?,?)'
prepare s from 'select WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS(?,?,?)'
prepare s from 'select WEEK(?)'
prepare s from 'select WEEK(?,?)'
prepare s from 'select WEEKDAY(?)'
prepare s from 'select WEEKOFYEAR(?)'
prepare s from 'select WEIGHT_STRING(?)'
prepare s from 'select YEAR(?)'
prepare s from 'select YEARWEEK(?)'
prepare s from 'select YEARWEEK(?,?)'
PREPARE s1 FROM "SELECT i1+? FROM t1"
PREPARE s2 FROM "SELECT i2+? FROM t1"
PREPARE s3 FROM "SELECT i3+? FROM t1"
PREPARE s4 FROM "SELECT i4+? FROM t1"
PREPARE s5 FROM "SELECT i8+? FROM t1"
PREPARE s6 FROM "SELECT dc1+? FROM t1"
PREPARE s7 FROM "SELECT dc2+? FROM t1"
EXECUTE s1 USING @i1_max
EXECUTE s2 USING @i2_max
EXECUTE s3 USING @i3_max
EXECUTE s4 USING @i4_max
EXECUTE s5 USING @i8_max
EXECUTE s6 USING @dc1_max
EXECUTE s7 USING @dc2_max
EXECUTE s6 USING @dc1_ext
EXECUTE s7 USING @dc2_ext
DEALLOCATE PREPARE s1
DEALLOCATE PREPARE s2
DEALLOCATE PREPARE s3
DEALLOCATE PREPARE s4
DEALLOCATE PREPARE s5
DEALLOCATE PREPARE s6
DEALLOCATE PREPARE s7
PREPARE si FROM "INSERT INTO t1 VALUES(1,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)"
PREPARE su FROM "UPDATE t1 SET i1=?, i2=?, i3=?, i4=?, i8=?, i1u=?, i2u=?, i3u=?, i4u=?, i8u=?, dc=?, f4=?, f8=?, vc=?, fc=?, vb=?, fb=?, d=?, t=?, dt=?, ts=? WHERE pk=1"
PREPARE siu FROM "INSERT INTO t1 VALUES(1,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?) ON DUPLICATE KEY UPDATE i1=?, i2=?, i3=?, i4=?, i8=?, i1u=?, i2u=?, i3u=?, i4u=?, i8u=?, dc=?, f4=?, f8=?, vc=?, fc=?, vb=?, fb=?, d=?, t=?, dt=?, ts=?"
EXECUTE si USING @i8, @i8, @i8, @i8, @i8, @i8u, @i8u, @i8u, @i8u, @i8u, @dc, @f8, @f8, @vc, @vc, @vb, @vb, @d, @t, @dt, @dt
EXECUTE su USING @i8, @i8, @i8, @i8, @i8, @i8u, @i8u, @i8u, @i8u, @i8u, @dc, @f8, @f8, @vc, @vc, @vb, @vb, @d, @t, @dt, @dt
EXECUTE siu USING @i8, @i8, @i8, @i8, @i8, @i8u, @i8u, @i8u, @i8u, @i8u, @dc, @f8, @f8, @vc, @vc, @vb, @vb, @d, @t, @dt, @dt, @i8, @i8, @i8, @i8, @i8, @i8u, @i8u, @i8u, @i8u, @i8u, @dc, @f8, @f8, @vc, @vc, @vb, @vb, @d, @t, @dt, @dt
DEALLOCATE PREPARE si
DEALLOCATE PREPARE su
DEALLOCATE PREPARE siu
PREPARE s1 FROM "SELECT ? + ?"
EXECUTE s1 USING @r8, @r8
EXECUTE s1 USING @i8, @i8
DEALLOCATE PREPARE s1
PREPARE s1 FROM "SELECT 666 + (? + ?)"
EXECUTE s1 USING @i8, @i8
EXECUTE s1 USING @r8, @r8
DEALLOCATE PREPARE s1
PREPARE s1 FROM "SELECT -(?)"
EXECUTE s1 USING @r8
EXECUTE s1 USING @i8
DEALLOCATE PREPARE s1
PREPARE s1 FROM "SELECT 666 + -(?)"
EXECUTE s1 USING @i8
EXECUTE s1 USING @r8
DEALLOCATE PREPARE s1
PREPARE s1 FROM "SELECT GREATEST(?, ?), LEAST(?, ?)"
EXECUTE s1 USING @vc1, @vc2, @vc1, @vc2
EXECUTE s1 USING @i8, @i8, @r8, @r8
DEALLOCATE PREPARE s1
PREPARE s1 FROM "SELECT 666 + GREATEST(?, ?), 3.14e0 + LEAST(?, ?)"
EXECUTE s1 USING @i8, @i8, @r8, @r8
EXECUTE s1 USING @r8, @r8, @i8, @i8
DEALLOCATE PREPARE s1
PREPARE s1 FROM "SELECT COALESCE(?, ?)"
EXECUTE s1 USING @vc1, @vc2
EXECUTE s1 USING @i8, @i8
DEALLOCATE PREPARE s1
PREPARE s1 FROM "SELECT 666 + COALESCE(?, ?)"
EXECUTE s1 USING @i8, @i8
EXECUTE s1 USING @r8, @r8
DEALLOCATE PREPARE s1
PREPARE s1 FROM "SELECT CASE ? WHEN 1 THEN ? ELSE ? END"
EXECUTE s1 USING @i8, @vc1, @vc2
EXECUTE s1 USING @i8, @r8, @r8
DEALLOCATE PREPARE s1
PREPARE s1 FROM "SELECT 666 + CASE ? WHEN 1 THEN ? ELSE ? END"
EXECUTE s1 USING @i8, @i8, @i8
EXECUTE s1 USING @i8, @r8, @r8
DEALLOCATE PREPARE s1
PREPARE s1 FROM "SELECT IFNULL(?, ?)"
EXECUTE s1 USING @vc1, @vc2
EXECUTE s1 USING @i8, @i8
DEALLOCATE PREPARE s1
PREPARE s1 FROM "SELECT 666 + IFNULL(?, ?)"
EXECUTE s1 USING @i8, @i8
EXECUTE s1 USING @r8, @r8
DEALLOCATE PREPARE s1
PREPARE s1 FROM "SELECT NULLIF(?, ?)"
EXECUTE s1 USING @vc1, @vc2
EXECUTE s1 USING @i8, @i8
DEALLOCATE PREPARE s1
PREPARE s1 FROM "SELECT 666 + NULLIF(?, ?)"
EXECUTE s1 USING @i8, @i8
EXECUTE s1 USING @r8, @r8
DEALLOCATE PREPARE s1
PREPARE s1 FROM "SELECT IF(?, ?, ?)"
EXECUTE s1 USING @i8, @vc1, @vc2
EXECUTE s1 USING @i8, @i8, @i8
DEALLOCATE PREPARE s1
PREPARE s1 FROM "SELECT 666 + IF(?, ?, ?)"
EXECUTE s1 USING @i8, @i8, @i8
EXECUTE s1 USING @i8, @r8, @r8
DEALLOCATE PREPARE s1
PREPARE s FROM "DELETE FROM t1 WHERE (?, ?) NOT IN (SELECT 'a', 'b' FROM t2)"
EXECUTE s USING @var1, @var2
DEALLOCATE PREPARE s
PREPARE s FROM "SELECT * FROM t1 WHERE (?, ?) NOT IN (SELECT 'a', 'b' FROM t2)"
EXECUTE s USING @var1, @var2
DEALLOCATE PREPARE s
PREPARE s FROM "SELECT NULL"
EXECUTE s
PREPARE s FROM "SELECT NULL + ? "
EXECUTE s USING @iv
EXECUTE s USING @ic
DEALLOCATE PREPARE s
PREPARE s FROM 'DO ST_ENVELOPE(CEILING(?))'
PREPARE stmt1 FROM 'SELECT * FROM t1 WHERE col1 LIKE ? OR col2 LIKE ?'
DEALLOCATE PREPARE stmt1
create tablespace ndb_ts1 add datafile 'ndb_ts1.dat' use logfile group ndb_lg1 engine=myisam initial_size=32M
create tablespace ndb_ts1 add datafile 'ndb_ts1.dat' use logfile group ndb_lg1 engine=myisam
create tablespace ndb_ts1 add datafile 'ndb_ts1.dat' use logfile group ndb_lg1 engine=myisam
PREPARE ps FROM 'INSERT INTO t SELECT id+1, x FROM t a ON DUPLICATE KEY UPDATE x = a.x'
EXECUTE ps
EXECUTE ps
DEALLOCATE PREPARE ps
RENAME TABLE t1 TO t2, t3 TO t4
CREATE USER plug IDENTIFIED WITH 'test_plugin_server' AS '' CREATE USER plug_dest IDENTIFIED BY 'plug_dest_passwd' CREATE USER plug IDENTIFIED WITH 'test_plugin_server' AS 'plug_dest' CREATE USER plug IDENTIFIED WITH 'test_plugin_server' AS 'plug_dest' CREATE USER plug IDENTIFIED WITH 'test_plugin_server' AS 'plug_dest' CREATE USER plug IDENTIFIED WITH 'test_plugin_server' AS 'plug_dest'
CREATE USER plÃ¼g IDENTIFIED WITH 'test_plugin_server' AS 'plÃ¼g_dest'
DROP USER plÃ¼g
CREATE USER plÃ¼g_dest IDENTIFIED BY 'plug_dest_passwd'
DROP USER plÃ¼g_dest
CREATE USER plÃ¼g IDENTIFIED WITH 'test_pluggggin_server' AS 'plÃ¼g_dest'
CREATE USER plÃ¼g IDENTIFIED WITH test_plugin_server AS 'plÃ¼g_dest'
DROP USER plÃ¼g
CREATE USER plÃ¼g_dest IDENTIFIED BY 'plug_dest_passwd'
DROP USER plÃ¼g_dest
rename table t1 to t3
source include/show_binlog_events.inc
LOCK TABLES t1 WRITE
UNLOCK TABLES
LOCK TABLES t1 READ, t2 WRITE
UNLOCK TABLES
LOCK TABLES t1 READ, t3 WRITE, t3 AS a WRITE, t3 AS b READ
UNLOCK TABLES
LOCK TABLES t1 WRITE
UNLOCK TABLES
LOCK TABLES t1 WRITE
UNLOCK TABLES
LOCK TABLES t1 READ, t2 WRITE
UNLOCK TABLES
LOCK TABLES t1 READ, t3 WRITE, t3 AS a WRITE, t3 AS b READ
UNLOCK TABLES
LOCK TABLES t1 WRITE
UNLOCK TABLES
LOCK TABLES t1 WRITE
UNLOCK TABLES
LOCK TABLES t1 READ, t2 WRITE
UNLOCK TABLES
LOCK TABLES t1 READ, t3 WRITE, t3 AS a WRITE, t3 AS b READ
UNLOCK TABLES
LOCK TABLES t1 WRITE
UNLOCK TABLES
select case 1/0 when "a" then "true" else "false" END
select case 1/0 when "a" then "true" END
select (case 1/0 when "a" then "true" END) | 0
select (case 1/0 when "a" then "true" END) + 0.0
INSERT INTO t1 VALUES (REPEAT("a",100))
SELECT (t1.a,t1.a) IN (('a','c'),('a','b')) END FROM t1
DO GROUP_CONCAT(DISTINCT NULLIF(1, PERIOD_ADD(0x6f09c5f8 ,'7451-01-27')))
select a.id, b.category as catid, b.state as stateid, b.county as countyid from t1 a, t2 b ignore index (primary) where (a.token ='a71250b7ed780f6ef3185bfffe027983') and (a.count = b.id)
prepare stmt1 from "select * from ((t3 natural join (t1 natural join t2)) natural join t4) natural join t5"
execute stmt1
PREPARE stmt FROM 'UPDATE t2 AS A NATURAL JOIN v1 B SET B.f1 = 1'
EXECUTE stmt
EXECUTE stmt
DEALLOCATE PREPARE stmt
PREPARE stmt FROM "SELECT t2.c AS f1 FROM t1 LEFT JOIN t1 t2 ON t1.c=t2.c RIGHT JOIN t1 t3 ON t1.c=t3.c GROUP BY f1;"
EXECUTE stmt
EXECUTE stmt
DEALLOCATE PREPARE stmt
t1.c1 join t2 on t2.ref_t1 = t1.c1) on t4.ref_t1 = t1.c1
PREPARE st1 FROM " UPDATE v1 AS a NATURAL JOIN v1 AS b SET a.dummy = '', b.col_check = NULL "
EXECUTE st1
EXECUTE st1
DEALLOCATE PREPARE st1
select t1.*, dt.c from t t1, lateral (select count(*) as c from t t2 left join t t3 on t3.a>t2.a-t1.a) as dt
select t1.*, dt.c from t t1 cross join lateral (select count(*) as c from t t2 left join t t3 on t3.a>t2.a-t1.a) as dt
select t1.*, dt.c from t t1 join lateral (select count(*) as c from t t2 left join t t3 on t3.a>t2.a-t1.a) as dt on true
EXPLAIN SELECT * FROM t1 AS x3 WHERE EXISTS (SELECT * FROM t1 AS x1 JOIN t1 AS x2 ON x1.b=x2.b JOIN LATERAL (SELECT COUNT(a) AS c FROM t1 WHERE t1.b=x1.b) AS d3 ON x1.b=c)
SELECT * FROM t1, t2, LATERAL ( SELECT pk, blobfield GROUP BY pk, blobfield WITH ROLLUP ) AS d1 ORDER BY t1.f1, t2.pk
perl
my $dir = $ENV{'MYSQLTEST_VARDIR'}
open ( OUTPUT, ">$dir/tmp/mysqld_path_file.inc")
my $path = $ENV{MYSQLD}
$path =~ /^(.*)\/([^\/]*)$
print OUTPUT "let \$mysqld_path = $1;\n"
print OUTPUT "let \$mysqld_bin = $2;\n"
close (OUTPUT)
write_file $BOOTSTRAP_SQL
write_file $MYSQLTEST_VARDIR/tmp/defaultsfile.cnf
[mysqld] binlog_format=MIXED CREATE DATABASE XY
ADD CONSTRAINT C1 FOREIGN KEY (c, b) REFERENCES XY.T_1 (a, b)
ADD CONSTRAINT C2 FOREIGN KEY (b) REFERENCES XY.T_1(a)
PRIMARY KEY(a, b), UNIQUE(b)) ENGINE=InnoDB
query_vertical SHOW CREATE TABLE `Table2`
query_vertical SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_SCHEMA != 'PERFORMANCE_SCHEMA'
query_vertical SHOW CREATE TABLE Product_Order
query_vertical SHOW CREATE TABLE Product
query_vertical SHOW CREATE TABLE Customer
query_vertical SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_SCHEMA != 'PERFORMANCE_SCHEMA'
disable_query_log
enable_query_log
SELECT `B30896461`.`testFn`()
SELECT `B30896461`.`testfn`()
disable_query_log
disable_result_log
enable_query_log
enable_result_log
SELECT `B30896461`.`testFn`()
SELECT `B30896461`.`testfn`()
disable_query_log
disable_result_log
enable_query_log
enable_result_log
CREATE EVENT e_x1 ON SCHEDULE EVERY 1 SECOND DO DROP DATABASE db_x
alter event event2 on schedule every 1 year on completion preserve rename to event3 comment "new comment" do begin select 1; end_
alter event e_43 do alter event e_43 do set @a = 4
alter event e_43 do begin alter event e_43 on schedule every 5 minute; insert into test_nested values(1); end
echo '#________________________VAR_05_table_definition_cache__________________#' echo '##' SELECT COUNT(@@GLOBAL.table_definition_cache)
SELECT (184467440737095 BETWEEN 0 AND 18446744073709551500)
SELECT CAST(100 AS UNSIGNED) BETWEEN 1 AND -1
SELECT CAST(100 AS UNSIGNED) NOT BETWEEN 1 AND -1
SELECT CAST(0 AS UNSIGNED) BETWEEN 0 AND -1
SELECT CAST(0 AS UNSIGNED) NOT BETWEEN 0 AND -1
DO TRIM(-9223372036854775808) XOR '.D-'
DO OCT(-9223372036854775808)
SELECT ( 9223372036854775808 BETWEEN 9223372036854775808 AND 9223372036854775808 )
SELECT ( 9223372036854775807 BETWEEN 9223372036854775808 AND 1 )
SELECT ( -1 BETWEEN 9223372036854775808 AND 1 )
SELECT ( 0 BETWEEN 9223372036854775808 AND 1 )
SELECT ( 1 BETWEEN 9223372036854775808 AND 1 )
INSERT INTO t1 VALUES (repeat('1', 1300),'one'), (repeat('1', 1300),'two')
EXPLAIN FORMAT=tree SELECT * FROM t1 LEFT JOIN t2 USING ( a ), LATERAL ( SELECT * FROM t3 WHERE t3.a = t2.a LIMIT 1 ) t3d, LATERAL ( SELECT * FROM t3 WHERE t3.a > t1.a LIMIT 1 ) t4d
EXPLAIN FORMAT=tree SELECT * FROM t1 LEFT JOIN ( t2 LEFT JOIN t3 USING ( a ) CROSS JOIN LATERAL ( SELECT * FROM t4 WHERE t4.a = t3.a LIMIT 1 ) t4d ) ON t1.a = t4d.a
CREATE TABLE t1 ( col_int_key INTEGER, col_json JSON, KEY mv_idx ((CAST(col_json->'$[*]' AS CHAR(40) ARRAY))) )
EXPLAIN FORMAT=tree SELECT /*+ NO_BNL(t1, t2) */ * FROM t2 JOIN t1 ON 1 WHERE (CAST("1" AS JSON) MEMBER OF( t1.col_json->'$[*]'))
EXPLAIN ANALYZE FOR CONNECTION 1
EXPLAIN ANALYZE FORMAT=TRADITIONAL SELECT 1
EXPLAIN ANALYZE FORMAT=JSON SELECT 1
EXPLAIN ANALYZE FORMAT=TREE SELECT 1
EXPLAIN FORMAT=tree SELECT (1 IN (SELECT 1 FROM t1)) WHERE FALSE
EXPLAIN FORMAT=tree SELECT a IN (SELECT a FROM (table t1) AS d) FROM t1 GROUP BY (@b:=5)
EXPLAIN FORMAT=tree (SELECT 1 FROM t1) UNION ALL SELECT 1 IN (SELECT 1 FROM t1) FROM t1 WHERE 1=2
create table t1 ( dummyKey INTEGER NOT NULL AUTO_INCREMENT, a001 TINYINT, a010 TINYINT, a012 TINYINT, a015 TINYINT, a016 TINYINT, a017 TINYINT, a019 TINYINT, a029 TINYINT, a030 TINYINT, a031 TINYINT, a032 TINYINT, a042 TINYINT, a043 TINYINT, a044 TINYINT, a3001 TINYINT, a3002 TINYINT, a3003 TINYINT, a3004 TINYINT, a3005 TINYINT, a3021 TINYINT, a3022 TINYINT, a BIT(6), b BIT(6), c BIT(6), d TINYINT, e TINYINT, f TINYINT, g TINYINT, h TINYINT, i TINYINT, j TINYINT, k TINYINT, l TINYINT, m TINYINT, n TINYINT, o TINYINT, a034 TINYINT, PRIMARY KEY USING HASH (dummyKey) ) engine=archive
PREPARE stmt FROM "SELECT CAST(RAND(2) * 1000 AS UNSIGNED), CAST(RAND(?) * 1000 AS UNSIGNED) FROM t1 WHERE a = 1"
EXECUTE stmt USING @var
SET @a:=999999999999999999999999999999999999999999999999999999999999999999999999999999999
999999999999999999999999999999999999999999999999999999999999999999999999999999999
do sqrt(weight_string(_eucjpms "0E+"))
CREATE PROCEDURE test_round_fn() BEGIN DECLARE num_digits int; SET num_digits := 3; CREATE TEMPORARY TABLE tmp_test ( number double ); INSERT INTO tmp_test VALUES (1),(0); SELECT number, Round(number, num_digits) > 0, Round(number, 3) > 0 FROM tmp_test; SELECT number, Round(number, num_digits) > 0, Round(number, 3) > 0 FROM tmp_test WHERE Round(number, 3) >= 0; SELECT number, Round(number, num_digits) > 0, Round(number, 3) > 0 FROM tmp_test WHERE Round(number, num_digits) >= 0; END
DO ROUND(0xe9b1, NULL)
DO COUNT(DISTINCT ROUND(CAST(SLEEP(0) AS DECIMAL), NULL))
SELECT CRC32(INSERT('foodyear', 1, 4, 'good'))
CREATE PROCEDURE crc32_proc (IN a CHAR, OUT b BIGINT) SELECT CRC32(a) INTO b
CREATE FUNCTION crc32_func(inputvar CHAR) RETURNS BIGINT BEGIN DECLARE crcval BIGINT; SELECT CRC32(inputvar) INTO crcval; RETURN crcval; END
PREPARE stmt1 FROM 'SELECT CRC32(?)'
EXECUTE stmt1 USING @val
DEALLOCATE PREPARE stmt
LOAD DATA INFILE '../../std_data/loaddata_utf8.dat' INTO TABLE t1 CHARACTER SET utf8
do ((3273059463432352943 )* (-9223372036854775808 ))
do ((-9223372036854775808)* ( 3273059463432352943))
CREATE PROCEDURE test_round(in arg bigint) BEGIN DECLARE i int; SET i = 0; WHILE (i >= -20) DO BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '22003' SHOW ERRORS; SELECT arg, i, round(arg, i); END; SET i = i - 1; END WHILE; END
CREATE PROCEDURE test_round_unsigned(in arg bigint unsigned) BEGIN DECLARE i int; SET i = 0; WHILE (i >= -20) DO BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '22003' SHOW ERRORS; SELECT arg, i, round(arg, i); END; SET i = i - 1; END WHILE; END
PREPARE st1 FROM "INSERT INTO t VALUES (? + ?)"
EXECUTE st1 USING @a,@b
CREATE TABLE t1 SELECT 5.0 + 96 DIV 1,                     # Dividend is integer 5.0 + 96.1234 DIV 1,                # Dividend is decimal 5.0 + '96' DIV 1,                   # Dividend is string 5.0 + CAST('96' AS SIGNED) DIV 1,   # Dividend is function 5.0 + CAST('96' AS UNSIGNED) DIV 1
WHERE 1 = f1_simple_insert(f2) AND 1 = f1_simple_insert(f1)
EXPLAIN SELECT (SELECT dt.a FROM   (SELECT 1 AS a, t2.a AS b FROM t2 HAVING t1.a) dt     # <----- outer reference inside derived table. WHERE dt.b=t1.a) AS subq    # <----- normal outer reference FROM t1
(SELECT COUNT(dt1.f2) FROM (t1 AS dt1) WHERE dt1.f3 = v1.f1 ) FROM ( v1 RIGHT OUTER JOIN( t1 AS t2 STRAIGHT_JOIN t1 AS t3 ON 1) ON 1)
(SELECT SUM(dt2.f2) FROM (t1 AS dt1 STRAIGHT_JOIN t1  AS dt2 ON 1) WHERE dt1.f3 = table1.f3) AS field1, MAX(table2.f2) AS field4 FROM (view_t1 AS table1 RIGHT JOIN ((t1 AS table2 JOIN t1 AS table3 ON (table3 .f1 = table2.f2))) ON 1) WHERE table1 . f3 != 'x'
WHERE t2.f2 = ISNULL(dt.f1)) AS field1 FROM t1 AS dt GROUP BY field1
CREATE USER IF NOT EXISTS view_u2@my.oracle.com
CREATE USER IF NOT EXISTS event_u2@192.1.1.140
CREATE USER IF NOT EXISTS trig_u2@xyz.com
CREATE DEFINER=view_u2@my.oracle.com VIEW v3 AS SELECT * FROM t1
CREATE DEFINER=view_u2@my.oracle.com VIEW v4 AS SELECT * FROM t1
CREATE DEFINER=event_u2@192.1.1.140 EVENT e3 ON SCHEDULE AT '2037-01-01 00:00:00' DISABLE DO SET @a = 5
CREATE DEFINER=event_u2@192.1.1.140 EVENT e4 ON SCHEDULE AT '2037-01-01 00:00:00' DISABLE DO SET @a = 5
CREATE DEFINER=trig_u2@xyz.com TRIGGER trig3 BEFORE INSERT ON t1 FOR EACH ROW SET @sum = 1
CREATE DEFINER=trig_u2@xyz.com TRIGGER trig4 BEFORE INSERT ON t1 FOR EACH ROW SET @sum = 1
DROP USER view_u1, view_u2@my.oracle.com, event_u1, event_u2@192.1.1.140, trig_u1, trig_u2@xyz.com, proc_u1, proc_u2@localhost, func_u1, func_u2, user_not_referenced_as_definer
LOCK TABLE tbl_with_partitions READ
UNLOCK TABLES
LOAD DATA INFILE '../../std_data/wl6030.dat' INTO TABLE t1 FIELDS TERMINATED BY ',' ENCLOSED BY '"'
LOAD DATA INFILE '../../std_data/wl6030_2.dat' INTO TABLE t2 FIELDS TERMINATED BY ',' ENCLOSED BY '"'
LOAD DATA INFILE '../../std_data/wl6030_2.dat' INTO TABLE v2 FIELDS TERMINATED BY ',' ENCLOSED BY '"'
LOAD DATA INFILE '../../std_data/wl6030_2.dat' INTO TABLE t2 FIELDS TERMINATED BY ',' ENCLOSED BY '"'
LOAD DATA INFILE '../../std_data/wl6030_2.dat' INTO TABLE v2 FIELDS TERMINATED BY ',' ENCLOSED BY '"'
CREATE TRIGGER t1_trg_after_del AFTER DELETE ON t1 FOR EACH ROW SET @a := 1
create trigger t1_bi before insert on t1 for each row set new.udt:= convert_tz(new.ldt, 'Europe/Moscow', 'UTC')
LOCK TABLES t1 WRITE
UNLOCK TABLES
query_vertical SELECT CAST('2001-01-01 10:10:10.9999994' AS DATETIME) AS c1, CAST('2001-01-01 10:10:10.9999995' AS DATETIME) AS c2, CAST('2001-01-01 10:10:10.9999994' AS DATETIME(6)) AS c3, CAST('2001-01-01 10:10:10.9999995' AS DATETIME(6)) AS c4, CAST(20010101101010.9999994 AS DATETIME) AS c5, CAST(20010101101010.9999995 AS DATETIME) AS c6, CAST(20010101101010.9999994 AS DATETIME(6)) AS c7, CAST(20010101101010.9999995 AS DATETIME(6)) AS c8
query_vertical SELECT EXTRACT(MICROSECOND FROM '2001-01-01 00:00:00.9999994') AS c1, EXTRACT(MICROSECOND FROM '2001-01-01 00:00:00.9999995') AS c2, EXTRACT(MICROSECOND FROM 20010101000000.9999994) AS c3, EXTRACT(MICROSECOND FROM 20010101000000.9999995) AS c4
CALL mtr.add_suppression("==[0-9]*== Warning: set address range perms: large range")
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */
/*!40101 SET SQL_MODE=@OLD_SQL_MODE */
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */
/*!40101 SET SQL_MODE=@OLD_SQL_MODE */
call mtr.add_suppression("Invalid .* username when attempting to connect to the master server")
CHANGE REPLICATION SOURCE TO SOURCE_HOST='127.0.0.1', SOURCE_LOG_FILE='binlog-ch1.000001', SOURCE_LOG_POS=4 FOR CHANNEL 'ch1'
CHANGE REPLICATION SOURCE TO SOURCE_HOST='127.0.0.1', SOURCE_LOG_FILE='binlog-ch2.000001', SOURCE_LOG_POS=4 FOR CHANNEL 'ch2'
CHANGE REPLICATION SOURCE TO SOURCE_HOST='127.0.0.1', SOURCE_LOG_FILE="binlog-default.000001", SOURCE_LOG_POS=4 FOR CHANNEL ''
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u1@localhost USING r1
disable_query_log
enable_query_log
create procedure proc_middle_a(p1 integer) begin DECLARE l integer; DECLARE EXIT HANDLER for 1 /* not sure how to handle exceptions */ begin select "Oops ... now what ?"; end; select "In prod_middle()"; create temporary table t1(a integer, b integer); select GET_LOCK("user_mutex", 10) into l; insert into t1 set a = p1, b = p1; call proc_bottom_a(p1); select RELEASE_LOCK("user_mutex") into l; drop temporary table t1; end
create procedure proc_middle_b(p1 integer) begin DECLARE l integer; DECLARE EXIT HANDLER for SQLEXCEPTION, NOT FOUND begin begin DECLARE CONTINUE HANDLER for SQLEXCEPTION, NOT FOUND begin /* Ignore errors from the cleanup code */ end; select "Doing cleanup !"; select RELEASE_LOCK("user_mutex") into l; drop temporary table t1; end; RESIGNAL; end; select "In prod_middle()"; create temporary table t1(a integer, b integer); select GET_LOCK("user_mutex", 10) into l; insert into t1 set a = p1, b = p1; call proc_bottom_b(p1); select RELEASE_LOCK("user_mutex") into l; drop temporary table t1; end
load data infile '../../std_data/inconsistent_scan.csv' into table bureau columns terminated by "," ignore 1 lines
KILL QUERY @thread_id
PREPARE p FROM "SELECT sex, AVG(id), MIN(AVG(id)) OVER w min, MAX(AVG(id)) OVER w max, NTILE(2) OVER w FROM t1 GROUP BY sex HAVING sex=(SELECT c FROM ss LIMIT 1) OR sex='F' OR sex IS NULL WINDOW w AS (ORDER BY sex ROWS UNBOUNDED PRECEDING) ORDER BY sex DESC"
EXECUTE p
EXECUTE p
DROP PREPARE p
SELECT t.*, MIN(t.rank) OVER (ROWS UNBOUNDED PRECEDING) min, MAX(t.rank) OVER (ROWS UNBOUNDED PRECEDING) max FROM (SELECT sex, id, date, ROW_NUMBER() OVER w AS row_no, RANK() OVER w AS `rank` FROM t1,t2 WHERE t1.id=t2.user_id WINDOW w AS (PARTITION BY date ORDER BY id) ) AS t
prepare st_1180 from 'SELECT * FROM t1 WHERE ?="1111" and session_id = "abc"'
execute st_1180 using @arg1
execute st_1180 using @arg1
execute st_1180 using @arg1
prepare st_1644 from 'insert into t1 values ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
execute st_1644 using @arg01, @arg02, @arg03, @arg04, @arg05, @arg06, @arg07, @arg08, @arg09, @arg10, @arg11, @arg12, @arg13, @arg14, @arg15, @arg16, @arg17, @arg18, @arg19, @arg20
execute st_1644 using @arg01, @arg02, @arg03, @arg04, @arg05, @arg06, @arg07, @arg08, @arg09, @arg10, @arg11, @arg12, @arg13, @arg14, @arg15, @arg16, @arg17, @arg18, @arg19, @arg20
execute st_1644 using @arg01, @arg02, @arg03, @arg04, @arg05, @arg06, @arg07, @arg08, @arg09, @arg10, @arg11, @arg12, @arg13, @arg14, @arg15, @arg16, @arg17, @arg18, @arg19, @arg20
prepare st_1676 from 'select a.cola, a.colb, a.cold from t1 a, t2 b where a.cola = ? and a.colb = ? and a.cold = ? and b.cola = a.cola and b.colb = a.colb and b.colc = a.cold'
execute st_1676 using @arg0, @arg1, @arg2
prepare st_18492 from 'select * from t1 where 3 in (select (1+1) union select 1)'
execute st_18492
prepare stmt1 from 'insert into t1 (a, b) values (?, ?)'
prepare stmt2 from 'insert into t2 (a, b) values (?, ?)'
execute stmt1 using @intarg, @varchararg
execute stmt2 using @intarg, @varchararg
execute stmt1 using @intarg, @UNDEFINED
execute stmt2 using @intarg, @UNDEFINED
execute stmt1 using @UNDEFINED, @varchararg
execute stmt2 using @UNDEFINED, @varchararg
execute stmt1 using @UNDEFINED, @nullarg
execute stmt2 using @nullarg, @varchararg
PREPARE stmt FROM 'select 1 from `t1` where `a` = any (select (@@tmpdir))'
EXECUTE stmt
DEALLOCATE PREPARE stmt
PREPARE stmt FROM "SET PASSWORD FOR test_user1@'localhost' = 'SoSecret'"
EXECUTE stmt
DEALLOCATE PREPARE stmt
PREPARE stmt FROM "SET PASSWORD FOR test_user2@'localhost' = 'SoSecret'"
EXECUTE stmt
DEALLOCATE PREPARE stmt
prepare s from 'select a<cast(? as signed) from t6'
execute s using @a
execute s using @a
PREPARE stmt FROM "SELECT * FROM mysql.user LIMIT 0"
EXECUTE stmt
DEALLOCATE PREPARE stmt
PREPARE stmt FROM "CREATE TABLE t1 AS SELECT * FROM mysql.user LIMIT 0"
EXECUTE stmt
DEALLOCATE PREPARE stmt
PREPARE stmt FROM "INSERT INTO t1 SELECT * FROM mysql.user LIMIT 1"
EXECUTE stmt
DEALLOCATE PREPARE stmt
PREPARE stmt FROM "UPDATE t1 SET user='mno' WHERE EXISTS (SELECT * FROM mysql.user LIMIT 1)"
EXECUTE stmt
DEALLOCATE PREPARE stmt
PREPARE stmt FROM "DELETE FROM t1 WHERE EXISTS (SELECT * FROM mysql.user LIMIT 1)"
EXECUTE stmt
DEALLOCATE PREPARE stmt
PREPARE stmt FROM "SELECT * FROM mysql.user LIMIT 0 LOCK IN SHARE MODE"
EXECUTE stmt
DEALLOCATE PREPARE stmt
create table t1 ( a int not null references t2, b int not null references t2 (c), primary key (a,b), foreign key (a) references t3 match full, foreign key (a) references t3 match partial, foreign key (a,b) references t3 (c,d) on delete no action on update no action, foreign key (a,b) references t3 (c,d) on update cascade, foreign key (a,b) references t3 (c,d) on delete set default, foreign key (a,b) references t3 (c,d) on update set null) engine=myisam
RENAME TABLE parent0 TO parent
RENAME TABLE parent0 TO parent
LOCK TABLES parent WRITE
UNLOCK TABLES
LOCK TABLES child READ, parent WRITE
UNLOCK TABLES
LOCK TABLES child WRITE, parent WRITE
UNLOCK TABLES
call mtr.add_suppression("Dictionary file not specified")
PREPARE stmt1 FROM 'UPDATE mysql.user SET authentication_string=(?) where USER = ?'
SET @a = REPEAT('a',2147483647)
EXECUTE stmt1 USING @a,@b
DEALLOCATE PREPARE stmt1
PREPARE stmt1 FROM 'UPDATE mysql.user SET authentication_string=(?) where USER = ?'
SET @a = REPEAT('a',1048576)
EXECUTE stmt1 USING @a,@b
DEALLOCATE PREPARE stmt1
password validate password validate monkey CREATE USER 'user1'@'localhost' IDENTIFIED BY 'passWORD123#'
remove_file $MYSQLTEST_VARDIR/tmp/dictionary.txt
remove_file $MYSQLTEST_VARDIR/tmp/dictionary2.txt
CREATE TABLE t1 (c1 YEAR(4294967295))
CREATE TABLE t1 (c1 YEAR(4294967296))
c1 int(10) unsigned NOT NULL AUTO_INCREMENT, c2 varchar(30) NOT NULL, c3 smallint(5) unsigned DEFAULT NULL, PRIMARY KEY (c1)) ENGINE = archive $data_directory $index_directory
source $passwd_file
remove_file $PASSWD_FILE
remove_file $MYSQLD_LOG
exec unset SUDO_USER && $MYSQL test -e "SELECT COUNT(*) AS zero_sudo_count FROM performance_schema.session_connect_attrs WHERE attr_name = 'os_sudouser' AND PROCESSLIST_ID=CONNECTION_ID()"
exec SUDO_USER=gizmo $MYSQL test -e "SELECT attr_value AS must_be_gizmo FROM performance_schema.session_connect_attrs WHERE ATTR_NAME = 'os_sudouser'"
HANDLER t1 OPEN
HANDLER t1 READ a FIRST
HANDLER t1 READ a NEXT
HANDLER t1 READ a PREV
HANDLER t1 READ a LAST
HANDLER t1 CLOSE
HANDLER t1 OPEN
HANDLER t1 READ a FIRST
HANDLER t1 READ a NEXT
HANDLER t1 CLOSE
rename table t0 to t1
rename table t3 to t4, t2 to t3, t1 to t2, t4 to t1
rename table t3 to t4, t2 to t3, t1 to t2, t4 to t1
rename table t3 to t4, t2 to t3, t1 to t2, t4 to t1
rename table t1 to t2
rename table t1 to t1
rename table t3 to t4, t2 to t3, t1 to t2, t4 to t2
rename table t3 to t1, t2 to t3, t1 to t2, t4 to t1
rename table t3 to t4, t5 to t3, t1 to t2, t4 to t1
send RENAME TABLE t1 TO t2, t3 to t4
UNLOCK TABLES
reap
source include/wait_for_query_to_succeed.inc
rename table test.t1 to nonexistingdb.t2
LOCK TABLES t1 READ
RENAME TABLE t2 TO t3
RENAME TABLE t1 TO t3
UNLOCK TABLES
LOCK TABLE t1 WRITE
RENAME TABLE t1 TO t3
RENAME TABLE t3 TO t4, t4 TO t5
UNLOCK TABLES
LOCK TABLES t0 WRITE
RENAME TABLE t0 TO t3
UNLOCK TABLES
LOCK TABLES t1 READ, t0 WRITE
RENAME TABLE t0 TO t3
UNLOCK TABLES
LOCK TABLES t1 WRITE, t0 WRITE
RENAME TABLE t0 TO t3
UNLOCK TABLES
LOCK TABLES t5 WRITE
RENAME TABLE t5 TO t4
UNLOCK TABLES
LOCK TABLES t2 READ, t4 WRITE
RENAME TABLE t4 TO t5
UNLOCK TABLES
LOCK TABLES t2 READ, t5 WRITE, t5 AS a WRITE, t5 AS b READ
RENAME TABLE t5 TO t4
UNLOCK TABLES
LOCK TABLES t2 WRITE, t4 WRITE
RENAME TABLES t2 TO t0, t4 TO t2, t0 TO t4
UNLOCK TABLES
LOCK TABLE t2 WRITE
RENAME TABLES t2 TO t1, t1 TO t3, t3 TO t5
UNLOCK TABLES
LOCK TABLES t4 WRITE, t5 WRITE, t6 WRITE
RENAME TABLES t4 TO t1, t5 TO t2
UNLOCK TABLES
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE
RENAME TABLES t1 TO t0, t2 TO t4
UNLOCK TABLES
LOCK TABLES t1 WRITE
RENAME TABLE v1 TO v2
UNLOCK TABLES
LOCK TABLES v1 READ
RENAME TABLE v1 TO v2
UNLOCK TABLES
LOCK TABLES v1 WRITE
RENAME TABLE v1 TO v3
UNLOCK TABLES
LOCK TABLES v2 WRITE, v3 WRITE
RENAME TABLE v2 TO v0, v3 TO v2, v0 TO v3
UNLOCK TABLES
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE, t4 WRITE
RENAME TABLES t2 TO t0, t3 TO t2, t0 TO t3
RENAME TABLE t1 TO t0, t4 TO t1, t0 TO t4
UNLOCK TABLES
LOCK TABLES t1 WRITE, t3 WRITE
RENAME TABLE t1 TO t4
UNLOCK TABLES
select default(str), default(strnull), default(intg), default(rel) from t1
explain select default(str), default(strnull), default(intg), default(rel) from t1
select * from t1 where str <> default(str)
explain select * from t1 where str <> default(str)
SELECT s, 32 AS mi FROM t1 GROUP BY s HAVING DEFAULT(mi) IS NULL
IMPORT TABLE FROM 't1_*.sdi'
lock table t1 write
lock table t2 write
unlock tables
send set global read_only=1
unlock tables
reap
lock table t1 read
lock table t2 read
unlock tables
unlock tables
unlock tables
unlock tables
RENAME TABLE t1 to t3
UNLOCK TABLES
FOR EACH ROW BEGIN END
ADD DATAFILE 'ts1.ibd' ENGINE=INNODB
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1.ibd' ENGINE=INNODB
EVERY 10 HOUR DO SELECT 1
UNLOCK TABLES
UNLOCK TABLES
call mtr.add_suppression(".*Password salt for user.*")
call mtr.add_suppression("Found invalid password for user:*")
SHOW CREATE USER 'kristofer'@'localhost'
change_user kristofer2,secret2
SHOW CREATE USER 'kristofer'@'localhost'
INSERT INTO t1 SELECT REPEAT('1', 2*1024*1024)
remove_file $outfile
remove_file $outfile
echo '#________________________VAR_06_Host_Cache_Size__________________#' echo '##' SELECT COUNT(@@GLOBAL.Host_Cache_Size)
insert into t1 values (repeat('b',20))
select c cb20 from t1 where c=repeat('b',20)
DROP TABLE Ã¥Ã¤Ã¶, æ—¥æœ¬èªž,  ð©¸½
CREATE FUNCTION f1() RETURNS longblob BEGIN DECLARE ret longblob; SELECT statement_digest_text( "DROP TABLE t" ) INTO ret; RETURN ret; END;
prepare s from "DO SHA1(DATABASE());"
execute s
replace_regex /version.*/VERSION/ /created.*/CREATED/ /last_altered.*/LAST_ALTERED/ /id.*/ID/ /\/\//\//
replace_regex /version.*/VERSION/ /created.*/CREATED/ /last_altered.*/LAST_ALTERED/ /id.*/ID/ /\/\//\//
replace_regex /version.*/VERSION/ /created.*/CREATED/ /last_altered.*/LAST_ALTERED/ /id.*/ID/ /\/\//\//
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES dst_t1 WRITE
UNLOCK TABLES
LOCK TABLES dst_t2 WRITE
UNLOCK TABLES
LOCK TABLES dst.dst_t2 WRITE
UNLOCK TABLES
replace_regex /version.*/VERSION/ /created.*/CREATED/ /last_altered.*/LAST_ALTERED/ /id.*/ID/ /\/\//\//
replace_regex /version.*/VERSION/ /created.*/CREATED/ /last_altered.*/LAST_ALTERED/ /id.*/ID/ /\/\//\//
replace_regex /version.*/VERSION/ /created.*/CREATED/ /last_altered.*/LAST_ALTERED/ /id.*/ID/ /\/\//\//
replace_regex /version.*/VERSION/ /created.*/CREATED/ /last_altered.*/LAST_ALTERED/ /id.*/ID/ /\/\//\//
SELECT TRACE RLIKE 'minmax_keypart_in_disjunctive_query' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
SELECT @trace RLIKE "keypart_reference_from_where_clause"
SET @a:=5
set @select=2,@t5=1.23456
set @test_int=10,@test_double=1e-10,@test_string="abcdeghi",@test_string2="abcdefghij",@select=NULL
select @test_int,@test_double,@test_string,@test_string2,@select
show local variables like 'default_storage_engine'
show local variables like 'default_storage_engine'
set global sql_mode=repeat('a',80)
SET @@myisam_mmap_size= 500M
SELECT UTC_DATE()
call mtr.add_suppression("\\[Warning\\] .*MY-\\d+.* You need to use --log-bin to make --binlog-format work.")
CONNECT (con1,localhost,root,,test)
CONNECTION default
DISCONNECT con1
PREPARE s FROM "set character_set_client = ?"
EXECUTE s USING @x
DEALLOCATE PREPARE s
create table t1 (c national character varying(10))
call mtr.add_suppression("Failed to set up SSL because of the following SSL library error")
call mtr.add_suppression("\\[Warning\\] \\[[^]]*\\] \\[[^]]*\\] You need to use --log-bin to make --binlog-format work.")
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR u1@localhost USING r1
SELECT INSERT('ðŒ†ãƒ†Ã€a', 2, 2, 'ãƒ†b')
call mtr.add_suppression(".*Out of memory *")
INSERT INTO t1 VALUES (REPEAT(0x1125,200000), REPEAT(0x1125,200000)), ('', ''), ('', '')
source $passwd_file
remove_file $PASSWD_FILE
remove_file $MYSQLD_LOG
remove_file $MYSQLD_LOG
mkdir $DDIR
remove_file $MYSQLD_LOG
lock tables t1 write
unlock tables
lock tables t1 write, t1 as t0 read
unlock tables
lock tables t1 write, t1 as t0 read, t1 as t2 read
unlock tables
lock tables t1 write, t1 as t0 write, t1 as t2 read
unlock tables
lock tables t1 write, t1 as t0 write, t1 as t2 read, t1 as t3 read
unlock tables
lock tables t1 write, t1 as t0 write, t1 as t2 write
unlock tables
lock tables t1 write,t1 as b write, t2 write, t2 as c read
lock tables t1 write,t1 as b write, t2 write, t2 as c read
unlock tables
lock tables t1 write
unlock tables
CREATE PROCEDURE p1() CREATE VIEW v1 AS SELECT * FROM t1
LOCK TABLES t1 WRITE
UNLOCK TABLES
LOCK TABLES t1 WRITE
UNLOCK TABLES
CREATE PROCEDURE p1() RENAME TABLE t2 TO t3
DELIMITER
load data infile '../../std_data/loaddata3.dat' into table v1 fields terminated by '' enclosed by '' ignore 1 lines
load data infile '../../std_data/loaddata3.dat' ignore into table v1 fields terminated by '' enclosed by '' ignore 1 lines
prepare stmt1 from "insert into v3(a) values (?);"
execute stmt1 using @a
execute stmt1 using @a
deallocate prepare stmt1
prepare stmt1 from "insert into v3(a) select ?;"
execute stmt1 using @a
execute stmt1 using @a
deallocate prepare stmt1
RENAME TABLES t1 TO t5, v1 TO v2
RENAME TABLES t5 TO t1, v2 TO v1, t3 TO t4
CREATE TABLE innodb_table1 (m INT, n INT, FOREIGN KEY (n) REFERENCES t0(f1)) START TRANSACTION
create procedure p3 () reads sql data begin set profiling = ON; select 'This p3 should show up in profiling'; show profile; end
lock table t1 write
unlock table
PREPARE s FROM 'DO 1'
EXECUTE s
DEALLOCATE PREPARE s
call mtr.add_suppression("Can't create thread to")
call mtr.add_suppression("Out of memory")
RENAME TABLE T1 TO T2
select mysqltest.t1.* from MYSQLTEST.t1
select MYSQLTEST.t1.* from MYSQLTEST.t1
select MYSQLTEST.T1.* from MYSQLTEST.T1
select MYSQLTEST.T1.* from T1
select MYSQLTEST.t1.* from MYSQLTEST.t1
drop table if exists Ä°,Ä°Ä°
create table Ä° (s1 int)
show create table Ä°
drop table Ä°
create table Ä°Ä° (s1 int)
show create table Ä°Ä°
drop table Ä°Ä°
show create database mysql_TEST
perl
my $dir = $ENV{'MYSQLTEST_VARDIR'}
open ( OUTPUT, ">$dir/tmp/mysqld_path_file.inc")
my $path = $ENV{MYSQLD}
$path =~ /^(.*)\/([^\/]*)$
print OUTPUT "let \$mysqld_path = $1;\n"
print OUTPUT "let \$mysqld_bin = $2;\n"
close (OUTPUT)
SELECT @@global.validate_password.check_user_name
create table `about:text` ( _id int not null auto_increment, `about:text` varchar(255) not null default '', primary key (_id) )
INSERT INTO t1 SELECT CONCAT(REPEAT('1', 1024*1024 - 27), "\'\r dummydb dummyhost")
remove_file $outfile
remove_file $outfile
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u1@localhost USING r1
SHOW GRANTS FOR u1@localhost USING r1
UNLOCK TABLES
enable_info
disable_info
INSERT INTO t0 SET a=1, b=20 AS n ON DUPLICATE KEY UPDATE b= n.b
INSERT INTO t1 SET b='11', a=0 AS n ON DUPLICATE KEY UPDATE b= n.a, a= n.b
INSERT INTO t1 SET b='11', a=0 AS n ON DUPLICATE KEY UPDATE b= n.a, a= n.b
source $passwd_file
remove_file $PASSWD_FILE
remove_file $MYSQLD_LOG
write_file $BOOTSTRAP_SQL
remove_file $MYSQLD_LOG
remove_file $BOOTSTRAP_SQL
remove_file $MYSQLD_LOG
remove_file $MYSQLD_LOG
remove_file $MYSQLD_LOG
remove_file $MYSQL_TMP_DIR/keyring
remove_file $MYSQLD_LOG
write_file $BOOTSTRAP_SQL
create table t1 (a int not null,b int not null, primary key using BTREE (a)) engine=heap comment="testing heaps"
source include/force_binlog_format_statement.inc
SHOW GRANTS FOR 'kristofer'@'localhost'
change_user kristofer2,secret2
SHOW GRANTS FOR 'kristofer'@'localhost'
SHOW GRANTS FOR 'kristofer'@'localhost'
send INSERT INTO t1 VALUES (1)
reap
reap
DELIMITER
PREPARE drop_constraint_stmt FROM 'ALTER TABLE t1 DROP CONSTRAINT `primary`, DROP CONSTRAINT f2_unique, DROP CONSTRAINT fk, DROP CONSTRAINT f2_check'
EXECUTE drop_constraint_stmt
EXECUTE drop_constraint_stmt
DROP PREPARE drop_constraint_stmt
DELIMITER
PREPARE drop_constraint_stmt FROM 'ALTER TABLE t1 DROP CONSTRAINT `primary`, DROP CONSTRAINT f2_unique, DROP CONSTRAINT fk, DROP CONSTRAINT f2_check'
PREPARE alter_constraint_stmt FROM 'ALTER TABLE t1 ALTER CONSTRAINT f2_check NOT ENFORCED'
EXECUTE alter_constraint_stmt
EXECUTE drop_constraint_stmt
EXECUTE alter_constraint_stmt
EXECUTE drop_constraint_stmt
DROP PREPARE alter_constraint_stmt
DROP PREPARE drop_constraint_stmt
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
MfmqTBMBAAAALgAAAN0AAAAAACgAAAAAAAEABHRlc3QAB3QxX2Jhc2UAAQMAAQ== MfmqTBcBAAAAIgAAAP8AAAAAACgAAAAAAAEAAf/+AQAAAA== '
prepare stmt1 from 'select * from t1_base'
deallocate prepare stmt1
call mtr.add_suppression("Slave SQL.*Can.t execute the query because you have a conflicting read lock., Error_code: MY-001223")
prepare stmt1 from 'insert into t1_base values (1)'
execute stmt1
unlock tables
unlock tables
unlock tables
deallocate prepare stmt1
prepare stmt1 from 'insert into t1_base values (1)'
deallocate prepare stmt1
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
handler t1_base open
handler t1_base read first
handler t1_base close
unlock tables
handler t1_base open
handler t1_base read first
handler t1_base close
unlock tables
set @id:= connection_id()
kill query @id
unlock tables
kill query @id
unlock tables
unlock tables
lock tables t1_base read
unlock tables
lock tables t1_base read
unlock tables
unlock tables
lock tables t1_base write
unlock tables
unlock tables
unlock tables
lock tables t1_temp write
unlock tables
lock tables t1_temp write
unlock tables
unlock tables
unlock tables
unlock tables
release savepoint sv1
unlock tables
unlock tables
unlock tables
release savepoint sv1
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
insert into t1 (a) select b from t2 on duplicate key update a=default(b)
create table BIT_XOR (a int)
drop table BIT_XOR
select abs(3 AS three)
select abs(3 three)
select abs(3 AS "three")
select abs(3 "three")
select instr("foobar" AS p1, "bar")
select instr("foobar" p1, "bar")
select instr("foobar" AS "p1", "bar")
select instr("foobar" "p1", "bar")
select instr(@foobar "p1", "bar")
select instr("foobar", "bar" AS p2)
select instr("foobar", "bar" p2)
select instr("foobar", "bar" AS "p2")
select instr("foobar", "bar" "p2")
select instr("foobar", @bar "p2")
select instr("foobar" AS p1, "bar" AS p2)
select conv(255 AS p1, 10, 16)
select conv(255 p1, 10, 16)
select conv(255 AS "p1", 10, 16)
select conv(255 "p1", 10, 16)
select conv(255, 10 AS p2, 16)
select conv(255, 10 p2, 16)
select conv(255, 10 AS "p2", 16)
select conv(255, 10 "p2", 16)
select conv(255, 10, 16 AS p3)
select conv(255, 10, 16 p3)
select conv(255, 10, 16 AS "p3")
select conv(255, 10, 16 "p3")
select conv(255 AS p1, 10 AS p2, 16 AS p3)
select atan(10 AS p1)
select atan(10 p1)
select atan(10 AS "p1")
select atan(10 "p1")
select atan(10 AS p1, 20)
select atan(10 p1, 20)
select atan(10 AS "p1", 20)
select atan(10 "p1", 20)
select atan(10, 20 AS p2)
select atan(10, 20 p2)
select atan(10, 20 AS "p2")
select atan(10, 20 "p2")
select atan(10 AS p1, 20 AS p2)
create table t1 (a int not null,b int not null, primary key using HASH (a)) engine=heap comment="testing heaps"
LOCK INSTANCE FOR BACKUP
UNLOCK INSTANCE
LOCK INSTANCE FOR BACKUP
LOCK INSTANCE FOR BACKUP
UNLOCK INSTANCE
UNLOCK INSTANCE
LOCK INSTANCE FOR BACKUP
create function bug17615() returns varchar(256) unicode begin declare tmp_res varchar(256) unicode; set tmp_res= 'foo string'; return tmp_res; end
CREATE FUNCTION f(f1 VARCHAR(64) CHARACTER SET ucs2 COLLATE ucs2_unicode_ci) RETURNS VARCHAR(64) CHARACTER SET ucs2 COLLATE ucs2_danish_ci BEGIN DECLARE f2 VARCHAR(64) CHARACTER SET ucs2 COLLATE ucs2_swedish_ci; DECLARE f3 VARCHAR(64) CHARACTER SET ucs2 COLLATE ucs2_bin; SET f1= concat(collation(f1), ' ', collation(f2), ' ', collation(f3)); RETURN f1; END
CREATE FUNCTION f1() RETURNS VARCHAR(64) CHARACTER SET ucs2 BEGIN DECLARE f1 VARCHAR(64) CHARACTER SET ucs2; DECLARE f2 VARCHAR(64) CHARACTER SET ucs2; SET f1='str'; CALL p1(f1, f2); RETURN f2; END
CREATE FUNCTION f(f1 VARCHAR(64) COLLATE ucs2_unicode_ci) RETURNS VARCHAR(64) CHARACTER SET ucs2 BEGIN RETURN 'str'; END
CREATE FUNCTION f(f1 VARCHAR(64) CHARACTER SET ucs2) RETURNS VARCHAR(64) COLLATE ucs2_unicode_ci BEGIN RETURN 'str'; END
CREATE FUNCTION f(f1 VARCHAR(64) CHARACTER SET ucs2) RETURNS VARCHAR(64) CHARACTER SET ucs2 BEGIN DECLARE f2 VARCHAR(64) COLLATE ucs2_unicode_ci; RETURN 'str'; END
source include/show_binlog_events.inc
GRANT `admin-db1t1` TO `admin-db1` WITH ADMIN OPTION
GRANT r1 TO `app-middleware-db1`@`localhost` WITH ADMIN OPTION
SHOW GRANTS FOR CURRENT_USER() USING `admin-db1`
GRANT `admin-db1t1` TO `app`@`localhost` WITH ADMIN OPTION
GRANT r1 TO u1@localhost WITH ADMIN OPTION
GRANT r1 TO u2@localhost WITH ADMIN OPTION
GRANT r2 TO u2@localhost WITH ADMIN OPTION
GRANT r3 TO r2 WITH ADMIN OPTION
GRANT r3 TO u1 WITH ADMIN OPTION
GRANT r3 TO u2 WITH ADMIN OPTION
cat_file $MYSQLD_DATADIR/test_string_service.log
remove_file $MYSQLD_DATADIR/test_string_service.log
call mtr.add_suppression("Failed to set up SSL because of the following SSL library error")
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
enable_query_log
disable_query_log
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' FROM information_schema.schemata LIMIT 0, 5
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' FROM schemata LIMIT 0, 5
enable_query_log
into outfile "../../tmp/outfile-test.4" fields terminated by ',' optionally enclosed by '"' lines terminated by '\n' from information_schema.schemata where schema_name like 'mysqltest'
into outfile "../../tmp/outfile-test.4" fields terminated by ',' optionally enclosed by '"' lines terminated by '\n' from information_schema.schemata where schema_name like 'mysqltest'
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr2_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=2
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=2
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr2_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=2
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr3_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=3
CREATE TRIGGER tr2_bi BEFORE INSERT ON t1 FOR EACH ROW FOLLOWS tr0_bi SET @a:=2
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr3_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=3
CREATE TRIGGER tr2_bi BEFORE INSERT ON t1 FOR EACH ROW PRECEDES tr0_bi SET @a:=2
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr2_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=2
CREATE TRIGGER tr1_bu BEFORE UPDATE ON t1 FOR EACH ROW SET @a:=3
CREATE TRIGGER tr3_bi BEFORE INSERT ON t1 FOR EACH ROW FOLLOWS tr2_bi SET @a:=3
CREATE TRIGGER tr2_bu BEFORE UPDATE ON t1 FOR EACH ROW FOLLOWS tr1_bu SET @a:=3
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr1_bu BEFORE UPDATE ON t1 FOR EACH ROW SET @a:=3
CREATE TRIGGER tr2_bu BEFORE UPDATE ON t1 FOR EACH ROW FOLLOWS tr1_bi SET @a:=3
CREATE TRIGGER tr2_au AFTER UPDATE ON t1 FOR EACH ROW FOLLOWS tr1_bi SET @a:=3
CREATE TRIGGER tr1_au AFTER UPDATE ON t1 FOR EACH ROW FOLLOWS tr1_bu SET @a:=3
CREATE TRIGGER tr1_ai AFTER INSERT ON t1 FOR EACH ROW FOLLOWS tr1_bi SET @a:=3
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr2_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=2
CREATE TRIGGER tr1_bu BEFORE UPDATE ON t1 FOR EACH ROW SET @a:=3
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr2_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=2
CREATE TRIGGER tr0_bi BEFORE INSERT ON t1 FOR EACH ROW PRECEDES tr1_bi SET @a:=0
CREATE TRIGGER tr1_1_bi BEFORE INSERT ON t1 FOR EACH ROW FOLLOWS tr1_bi SET @a:=0
CREATE TRIGGER tr1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=1
CREATE TRIGGER tr2_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:=2
CREATE TRIGGER tr1_bu BEFORE UPDATE ON t1 FOR EACH ROW SET @a:=3
unlock tables
unlock tables
VALUES ROW(1, 10)
VALUES ROW(1, 10), ROW(2, 20)
SELECT * FROM (VALUES ROW(1, 10)) AS dt
SELECT * FROM (VALUES ROW(1, 10), ROW(2, 20)) AS dt
VALUES ROW(1, 10), ROW(2)
VALUES ROW(1), ROW(2, 20)
TABLE t0
SELECT * FROM (TABLE t0) AS dt
SELECT * FROM t0 JOIN (VALUES ROW(2, 20)) AS dt
SELECT * FROM t0 JOIN (VALUES ROW(2, 20), ROW(3, 30)) AS dt
SELECT * FROM t0 LEFT JOIN (VALUES ROW(2, 20), ROW(3, 30)) AS dt ON t0.a = dt.column_0
SELECT * FROM t0 LEFT JOIN (VALUES ROW(1, 20), ROW(1, 30)) AS dt ON t0.a = dt.column_0
SELECT * FROM t0 RIGHT JOIN (VALUES ROW(2, 20), ROW(3, 30)) AS dt ON t0.a = dt.column_0
SELECT * FROM t0 RIGHT JOIN (VALUES ROW(1, 20), ROW(1, 30)) AS dt ON t0.a = dt.column_0
SELECT * FROM (VALUES ROW(1), ROW(2)) AS dt0 NATURAL JOIN (VALUES ROW(1, 10), ROW(2, 20)) AS dt1
SELECT * FROM (VALUES ROW(1), ROW(2)) AS dt0 NATURAL JOIN (VALUES ROW(1, 10), ROW(1, 20)) AS dt1
VALUES ROW(1) UNION SELECT 2
VALUES ROW(1, 10) UNION SELECT 2, 20
VALUES ROW((SELECT 1), 10)
VALUES ROW(1, 10), ROW(2, "20")
SELECT * FROM (VALUES ROW(1, 10), ROW(2, "20") UNION SELECT 3, 30) AS dt
SELECT * FROM (SELECT 1, 10 UNION VALUES ROW(2, 20), ROW(3, "30")) AS dt
VALUES ROW((SELECT a FROM t0), 10)
SELECT * FROM t0 WHERE a IN (VALUES ROW(1))
SELECT * FROM t0 WHERE a IN (VALUES ROW(1), ROW(2))
SELECT * FROM t0 WHERE (a, b) IN (VALUES ROW(1, 10))
SELECT * FROM t0 WHERE (a, b) IN (VALUES ROW(1, 10), ROW(2, 20))
SELECT * FROM t0 WHERE a NOT IN (VALUES ROW(1))
SELECT * FROM t0 WHERE a NOT IN (VALUES ROW(1), ROW(2))
SELECT * FROM t0 WHERE (a, b) NOT IN (VALUES ROW(1, 10))
SELECT * FROM t0 WHERE (a, b) NOT IN (VALUES ROW(1, 10), ROW(2, 20))
SELECT * FROM t0 WHERE a >ALL (VALUES ROW(1))
SELECT * FROM t0 WHERE a >ALL (VALUES ROW(1), ROW(2))
SELECT * FROM t0 WHERE a <ANY (VALUES ROW(1))
SELECT * FROM t0 WHERE a <ANY (VALUES ROW(1), ROW(2))
VALUES ROW()
VALUES ROW(RAND(0), RAND(1))
SELECT * FROM t0 WHERE b IN (VALUES ROW(a*10))
VALUES ROW(1, NULL)
VALUES ROW(1, 10), ROW(2, NULL)
SELECT * FROM t0 WHERE (a, b) IN (VALUES ROW(1, NULL))
INSERT INTO t SELECT * FROM (VALUES ROW(1, 11), ROW(2, 20)) AS n(a, b) ON DUPLICATE KEY UPDATE b= n.b
VALUES ROW(DEFAULT)
SELECT * FROM (VALUES ROW(DEFAULT)) AS dt
INSERT INTO t VALUES ROW(DEFAULT(a), 20)
INSERT INTO t VALUES ROW(DEFAULT(a) + 1, 30)
VALUES ROW(1, 1.0, 1.0E0, '1', DATE'2000-01-01', TIME'00:00:01', TIMESTAMP'2000-01-01 00:00:01', CAST('{"j":"1"}' AS JSON)), ROW(2, 2.0, 2.0E0, '2', DATE'2000-01-02', TIME'00:00:02', TIMESTAMP'2000-01-01 00:00:01', CAST('{"j":"2"}' AS JSON))
CREATE VIEW v AS VALUES ROW(1)
CREATE VIEW v(x) AS VALUES ROW(1)
CREATE VIEW v AS SELECT * FROM (VALUES ROW(1)) AS t1
CREATE VIEW v AS SELECT * FROM (VALUES ROW(1)) AS t1(x)
CREATE VIEW v(x) AS SELECT * FROM (VALUES ROW(1)) AS t1(z)
CREATE VIEW v(x, y) AS VALUES ROW(1,2), ROW(2,4), ROW(3,6)
SELECT DISTINCT SQL_BIG_RESULT col_json, col_char FROM ( VALUES ROW( 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx', NULL, NULL ), ROW( NULL, NULL, '"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"' ) ) AS t1 ( col_char, col_time, col_json ) GROUP BY col_time ORDER BY col_json
SELECT t1.col FROM (TABLE t) AS t1, (SELECT * FROM (VALUES ROW('Y')) AS sq_t1, t) AS t2
SELECT 1 FROM (TABLE t1) AS table1 JOIN t2 AS table2 ON table1.x = table2.y WHERE table1.x IN (VALUES ROW('B'))
SELECT 1 FROM (TABLE t1) AS table1 JOIN t2 AS table2 ON table1.x = table2.y WHERE table1.x IN (VALUES ROW(NULL))
SELECT 1 FROM (TABLE t1) AS table1 JOIN t2 AS table2 ON table1.x = table2.y WHERE table1.x IN (VALUES ROW(NULL), ROW('B'))
VALUES ROW(1), ROW(2) LIMIT 1
(VALUES ROW(1), ROW(2), ROW(3), ROW(4), ROW(5)) LIMIT 2 OFFSET 3
TABLE t1 LIMIT 5 OFFSET 5
VALUES ROW(1) ORDER BY 1
VALUES ROW(1) ORDER BY 1 DESC
(VALUES ROW(1)) ORDER BY 1
(VALUES ROW(1)) ORDER BY 1 DESC
VALUES ROW(1),ROW(2) ORDER BY 1
VALUES ROW(1),ROW(2) ORDER BY 1 DESC
(VALUES ROW(1),ROW(2)) ORDER BY 1
(VALUES ROW(1),ROW(2)) ORDER BY 1 DESC
VALUES ROW(1,9),ROW(2,4) ORDER BY 2
VALUES ROW(1,9),ROW(2,4) ORDER BY 2 DESC
(VALUES ROW(1,9),ROW(2,4)) ORDER BY 2
(VALUES ROW(1,9),ROW(2,4)) ORDER BY 2 DESC
VALUES ROW(1) ORDER BY '1'
VALUES ROW(1) ORDER BY '1' DESC
(VALUES ROW(1)) ORDER BY '1'
(VALUES ROW(1)) ORDER BY '1' DESC
VALUES ROW(1),ROW(2) ORDER BY '1'
VALUES ROW(1),ROW(2) ORDER BY '1' DESC
(VALUES ROW(1),ROW(2)) ORDER BY '1'
(VALUES ROW(1),ROW(2)) ORDER BY '1' DESC
VALUES ROW(1,9),ROW(2,4) ORDER BY '2'
VALUES ROW(1,9),ROW(2,4) ORDER BY '2' DESC
(VALUES ROW(1,9),ROW(2,4)) ORDER BY '2'
(VALUES ROW(1,9),ROW(2,4)) ORDER BY '2' DESC
VALUES ROW(1),ROW(2) ORDER BY 1
VALUES ROW(1),ROW(2) ORDER BY 1 DESC
VALUES ROW(1) ORDER BY (SELECT 1)
VALUES ROW(1) ORDER BY (SELECT 1) DESC
(VALUES ROW(1)) ORDER BY (SELECT 1)
(VALUES ROW(1)) ORDER BY (SELECT 1) DESC
VALUES ROW(1),ROW(2) ORDER BY (SELECT 1)
VALUES ROW(1),ROW(2) ORDER BY (SELECT 1) DESC
(VALUES ROW(1),ROW(2)) ORDER BY (SELECT 1)
(VALUES ROW(1),ROW(2)) ORDER BY (SELECT 1) DESC
VALUES ROW(1,9),ROW(2,4) ORDER BY (SELECT 2)
VALUES ROW(1,9),ROW(2,4) ORDER BY (SELECT 2) DESC
(VALUES ROW(1,9),ROW(2,4)) ORDER BY (SELECT 2)
(VALUES ROW(1,9),ROW(2,4)) ORDER BY (SELECT 2) DESC
VALUES ROW(1) ORDER BY column_0
VALUES ROW(1) ORDER BY column_0 DESC
(VALUES ROW(1),ROW(2)) ORDER BY column_0
(VALUES ROW(1),ROW(2)) ORDER BY column_0 DESC
VALUES ROW(1),ROW(2) ORDER BY column_0
VALUES ROW(1),ROW(2) ORDER BY column_0 DESC
(VALUES ROW(1),ROW(2)) ORDER BY column_0
(VALUES ROW(1),ROW(2)) ORDER BY column_0 DESC
VALUES ROW(1,9),ROW(2,4) ORDER BY column_1
VALUES ROW(1,9),ROW(2,4) ORDER BY column_1 DESC
(VALUES ROW(1,9),ROW(2,4)) ORDER BY column_1
(VALUES ROW(1,9),ROW(2,4)) ORDER BY column_1 DESC
VALUES ROW(1) ORDER BY (SELECT column_0)
VALUES ROW(1) ORDER BY (SELECT column_0) DESC
(VALUES ROW(1),ROW(2)) ORDER BY (SELECT column_0)
(VALUES ROW(1),ROW(2)) ORDER BY (SELECT column_0) DESC
VALUES ROW(1),ROW(2) ORDER BY (SELECT column_0)
VALUES ROW(1),ROW(2) ORDER BY (SELECT column_0) DESC
(VALUES ROW(1),ROW(2)) ORDER BY (SELECT column_0)
(VALUES ROW(1),ROW(2)) ORDER BY (SELECT column_0) DESC
VALUES ROW(1,9),ROW(2,4) ORDER BY (SELECT column_1)
VALUES ROW(1,9),ROW(2,4) ORDER BY (SELECT column_1) DESC
(VALUES ROW(1,9),ROW(2,4)) ORDER BY (SELECT column_1)
(VALUES ROW(1,9),ROW(2,4)) ORDER BY (SELECT column_1) DESC
SELECT (VALUES ROW(1) ORDER BY t) AS a FROM t
SELECT (VALUES ROW(1) ORDER BY w) AS a FROM t
WHERE USER != 'event_scheduler'`
HANDLER s1.t1 OPEN
HANDLER s1.t1 OPEN AS t1
HANDLER t1 READ k1 FIRST
HANDLER t1 READ k1=(1,10)
unlock tables
unlock tables
unlock tables
lock tables t1 read
unlock tables
lock table t1 read
unlock tables
lock tables t1 read
lock tables t2 read
unlock tables
create table `#mysql50#abc``def` ( id int )
LOCK TABLE t1 WRITE
UNLOCK TABLES
CREATE TRIGGER trg1 AFTER INSERT ON table1 FOR EACH ROW INSERT INTO table2 SELECT t.notable.*
UNLOCK TABLES
help 'function_of_my_dream'
help '%possible_f%'
help 'impossible_func%'
help 'impossible_category%'
help 'impossible_%'
help '%function_1'
help '%function_2'
help '%function_3'
help '%function_4'
help '%function_5'
help '%function_6'
help '%function_7'
help '%category_2'
help 'impossible_function_1'
help 'impossible_category_1'
LOCK TABLES t1 WRITE
HELP no_such_topic
UNLOCK TABLES
SELECT cast(TIMESTAMP'2019-10-10 10:11:12' AT TIME ZONE 'UTC' AS DATETIME)
SELECT cast(TIMESTAMP'2019-10-10 10:11:12' AT TIME ZONE '+00:00' AS DATETIME)
SELECT cast(TIMESTAMP'2019-10-10 10:11:12+00:00' AT TIME ZONE '+00:00' AS DATETIME)
SELECT cast( TIME'10:10' AT TIME ZONE 'UTC' AS DATETIME )
SELECT cast( '2019-10-10' AT TIME ZONE 'UTC' AS DATETIME )
SELECT cast( 123 AT TIME ZONE 'UTC' AS DATETIME )
SELECT cast( a AT TIME ZONE '+00:00' AS DATETIME ) FROM t1
SELECT cast( b AT TIME ZONE '+00:00' AS DATETIME ) FROM t1
SELECT cast( a AT TIME ZONE '+00:00' AS DATETIME ) FROM t1
SELECT cast( b AT TIME ZONE '+00:00' AS DATETIME ) FROM t1
SELECT cast( '2019-10-10 10:11' AT TIME ZONE 'UTC' AS DATETIME )
RENAME TABLE mysql.time_zone TO time_zone_backup
RENAME TABLE time_zone_backup TO mysql.time_zone
CREATE PROCEDURE p1 () DROP TRIGGER tr1
CREATE PROCEDURE p1 () DROP TRIGGER tr1
SELECT db1.f1(1)
DELIMITER
DELIMITER
CREATE PROCEDURE f1(IN arg TINYINT UNSIGNED) BEGIN DECLARE arg1 TINYINT; select abs('1abcd') into arg; END
CREATE PROCEDURE sp2() BEGIN DECLARE v1 TINYINT DEFAULT 450000; END
CREATE FUNCTION fn2() RETURNS tinyint BEGIN DECLARE v1 TINYINT DEFAULT 450000; RETURN v1; END
CREATE PROCEDURE proc_c() BEGIN DECLARE div_zero INTEGER; SET SQL_MODE='TRADITIONAL'; SELECT 1/0; END
CREATE FUNCTION crc(_text TEXT) RETURNS BIGINT(20) UNSIGNED DETERMINISTIC RETURN CONV(LEFT(MD5(_text),16),16,10)
CREATE PROCEDURE Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_e() BEGIN END
CREATE PROCEDURE Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_Ã©() BEGIN END
CREATE PROCEDURE Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_E() BEGIN END
SHOW CREATE PROCEDURE Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_Ã©
DROP PROCEDURE Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_Ã©
CREATE FUNCTION Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_e() RETURNS INT return 15081947
CREATE FUNCTION Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_Ã©() RETURNS INT return 15081947
CREATE FUNCTION Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_E() RETURNS INT return 15081947
SHOW CREATE FUNCTION Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_Ã©
DROP FUNCTION Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_Ã©
CREATE FUNCTION myfunc(dt VARCHAR(50)) RETURNS VARCHAR(32) DETERMINISTIC BEGIN DECLARE dt_local TIMESTAMP(0); SET dt_local = dt; RETURN CONCAT(UNIX_TIMESTAMP(dt_local)); END;
PREPARE stmt FROM 'SELECT CONCAT(UNIX_TIMESTAMP(?))'
EXECUTE stmt USING @var
EXECUTE stmt USING @var
EXECUTE stmt USING @var
DEALLOCATE PREPARE stmt
DELIMITER
query_vertical SELECT * FROM information_schema.columns WHERE table_schema = 'information_schema' AND table_name   = 'PARAMETERS' ORDER BY ordinal_position
CREATE FUNCTION test_func1 (s char(20) RETURNS CHAR(50) SELECT * FROM INFORMATION_SCHEMA.PARAMETERS WHERE SPECIFIC_SCHEMA = 'i_s_parameters_test' AND SPECIFIC_NAME = 'test_func1'
delimiter \
CREATE TABLE t2 AS SELECT INSERT(1133,3,0,22) FROM t1
CREATE TABLE t2 AS SELECT REPEAT(1,2) FROM t1
insert into t1 values (repeat(0x201f, 10))
insert into t1 values (repeat(0x2020, 10))
insert into t1 values (repeat(0x2021, 10))
send INSERT INTO t1 VALUES(1)
FLUSH TABLE t1
reap
create function bug23333() RETURNS int(11) DETERMINISTIC begin insert into t1 values (null)
return @a
end| reset master
CALL mtr.add_suppression("ACL table mysql.role_edges missing. Some operations may fail.")
CALL mtr.add_suppression("ACL table mysql.default_roles missing. Some operations may fail.")
KILL @id
WHERE state= 'Waiting for table metadata lock' AND info='UPDATE t1 SET a=NULL'
WHERE state= 'Waiting for table metadata lock' AND info='UPDATE t1 SET a=NULL'
WHERE INFO='DELETE FROM t1 WHERE f1 = 1' and STATE='Waiting for table metadata lock'
WHERE INFO='DELETE FROM t1 WHERE f1 = 1' and STATE='Waiting for table metadata lock'
WHERE INFO='DELETE FROM t1 WHERE f1 = 1' and STATE='Waiting for table metadata lock'
WHERE INFO='DELETE FROM t1 WHERE f1 = 1' and STATE='Waiting for table metadata lock'
LOCK TABLES t2 WRITE
WHERE INFO='DELETE FROM t1 WHERE f1 = 1' and STATE='Waiting for table metadata lock'
UNLOCK TABLES
LOCK TABLES t2 WRITE
WHERE INFO='DELETE FROM t1 WHERE f1 = 1' and STATE='Waiting for table metadata lock'
UNLOCK TABLES
CREATE DEFINER=baz@localhost PROCEDURE my_db.baz_proc() BEGIN set ROLE all; INSERT into my_db.t1 values(4) on duplicate key UPDATE id = values(id) + 400; END
CALL my_db.foo_proc()
CALL my_db.baz_proc()
CALL my_db.baz_proc()
CALL my_db.foo_proc()
GRANT r2 TO r1 WITH ADMIN OPTION
GRANT r1 TO u1 WITH ADMIN OPTION
GRANT r1 TO u1 WITH ADMIN OPTION
SHOW GRANTS FOR `r_verifier`@`localhost`
SHOW GRANTS FOR `TestUserFails`@`localhost`
PREPARE stmt FROM ' select * from t1 where a = ? '
EXECUTE stmt USING @var
DEALLOCATE PREPARE stmt
prepare stmt1 from ' select 1 as my_col '
prepare stmt1 from ' select ? as my_col '
prepare stmt1 from @arg00
prepare stmt1 from @arg00
prepare stmt1 from ' select * from t1 where a <= 2 '
prepare stmt1 from ' select * from t1 where x <= 2 '
prepare stmt1 from ' insert into t1(a,x) values(?,?) '
prepare stmt1 from ' insert into t1(x,a) values(?,?) '
prepare stmt1 from ' select * from not_exist where a <= 2 '
prepare stmt1 from ' select a, b from t1 execute never_prepared
prepare stmt1 from ' select * from t1 where a <= 2 '
prepare stmt1 from ' select * from not_exist where a <= 2 '
execute stmt1
prepare stmt2 from ' select * from t5 '
execute stmt2
execute stmt2
execute stmt2
execute stmt2
execute stmt2
execute stmt2
execute stmt2
execute stmt2
prepare stmt1 from ' select * from t1 where a <= 2 '
execute stmt1
prepare stmt1 from ' select * from t1 where a <= ? '
execute stmt1 using @arg00
execute stmt1
execute stmt1 using @arg00, @arg01
execute stmt1 using @not_set
deallocate prepare never_prepared
prepare stmt1 from ' select * from t1 where a <= 2 '
prepare stmt1 from ' select * from not_exist where a <= 2 '
deallocate prepare stmt1
prepare stmt2 from ' select a,b from t5 where a <= 2 '
deallocate prepare stmt2
prepare stmt1 from ' select a from t1 where a <= 2 '
prepare stmt2 from ' select b from t1 where a <= 2 '
execute stmt2
execute stmt1
prepare stmt1 from ' select a from t1 where a <= 2 '
prepare stmt2 from ' select a from t1 where a <= 2 '
execute stmt2
execute stmt1
deallocate prepare stmt1
execute stmt2
prepare stmt4 from ' show databases like ''mysql'' '
execute stmt4
prepare stmt4 from ' show tables from test like ''t2%'' '
execute stmt4
prepare stmt4 from ' show columns from t2 where field in (select ?) '
execute stmt4 using @arg00
execute stmt4 using @arg00
execute stmt4 using @arg00
prepare stmt4 from ' show columns from t2 from test like ''a%'' '
execute stmt4
prepare stmt4 from ' show index from t2 from test '
execute stmt4
prepare stmt4 from ' show table status from test like ''t2%'' '
execute stmt4
prepare stmt4 from ' show table status from test like ''t9%'' '
execute stmt4
prepare stmt4 from ' show status like ''Threads_running'' '
execute stmt4
prepare stmt4 from ' show variables like ''sql_mode'' '
execute stmt4
prepare stmt4 from ' show engine myisam logs '
execute stmt4
prepare stmt4 from ' show grants for user '
prepare stmt4 from ' show create table t2 '
prepare stmt4 from ' show master status '
prepare stmt4 from ' show master logs '
prepare stmt4 from ' show slave status '
prepare stmt4 from ' show warnings limit 20 '
prepare stmt4 from ' show errors limit 20 '
prepare stmt4 from ' show storage engines '
execute stmt4
prepare stmt1 from ' drop table if exists t5 '
execute stmt1
prepare stmt1 from ' drop table t5 '
execute stmt1
prepare stmt1 from ' SELECT @@version '
execute stmt1
prepare stmt_do from ' do @var:=  (1 in (select a from t1)) '
prepare stmt_set from ' set @var= (1 in (select a from t1)) '
prepare stmt_do from ' do @var:=  (1 in (select a from t5)) '
prepare stmt_set from ' set @var= (1 in (select a from t5)) '
deallocate prepare stmt_do
deallocate prepare stmt_set
prepare stmt1 from ' prepare stmt2 from '' select 1 ''  '
prepare stmt1 from ' execute stmt2 '
prepare stmt1 from ' deallocate prepare never_prepared '
prepare stmt1 from 'alter view v1 as select 2'
prepare stmt4 from ' use test '
prepare stmt3 from ' create database mysqltest '
prepare stmt3 from ' drop database mysqltest '
prepare stmt3 from ' describe t2 '
execute stmt3
execute stmt3
prepare stmt3 from ' lock tables t1 read '
prepare stmt3 from ' unlock tables '
into table t1 fields terminated by ''\t'' '
execute stmt1
prepare stmt1 from ' optimize table t1 '
prepare stmt1 from ' analyze table t1 '
prepare stmt1 from ' checksum table t1 '
prepare stmt1 from ' repair table t1 '
prepare stmt1 from ' handler t1 open '
prepare stmt3 from ' commit '
prepare stmt3 from ' rollback '
prepare stmt4 from ' SET sql_mode=ansi '
execute stmt4
prepare stmt4 from ' SET sql_mode="" '
execute stmt4
prepare stmt5 from ' select ''2'' || ''3'' '
execute stmt5
execute stmt5
prepare stmt1 from ' flush local privileges '
prepare stmt1 from ' KILL 0 '
prepare stmt1 from ' explain select a from t1 order by b '
execute stmt1
prepare stmt1 from ' explain select a from t1 where a > ? order by b '
execute stmt1 using @arg00
prepare stmt1 from ' insert into t2 values(?, ?) '
prepare stmt1 from ' select * from t2 where id= ? and name= ? '
execute stmt1 using @id, @arg00
execute stmt1 using @id, @arg01
execute stmt1 using @id, @arg02
execute stmt1 using @id, @arg03
execute stmt1 using @id, @arg04
prepare stmt_drop from ' drop table if exists t2 '
execute stmt_drop
prepare stmt_create from ' create table t2 ( a int primary key, b char(10)) '
execute stmt_create
prepare stmt3 from ' create table t3 like t2 '
execute stmt3
prepare stmt3 from ' create table t3 (m int) select ? as m '
execute stmt3 using @arg00
prepare stmt3 from ' create index t2_idx on t2(b) '
prepare stmt3 from ' drop index t2_idx on t2 '
prepare stmt3 from ' alter table t2 drop primary key '
prepare stmt3 from ' rename table t2 to new_t2 '
execute stmt3
execute stmt3
rename table new_t2 to t2
prepare stmt1 from ' rename table t5 to t6, t7 to t8 '
execute stmt1
execute stmt1
execute stmt1
rename table t6 to t5, t8 to t7
execute stmt1
1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1 AND 1 = 1
execute stmt1
execute stmt1
'1234567890123456789012345678901234567890123456789012345678901234567890' = '1234567890123456789012345678901234567890123456789012345678901234567890' AND '1234567890123456789012345678901234567890123456789012345678901234567890' = '1234567890123456789012345678901234567890123456789012345678901234567890' AND '1234567890123456789012345678901234567890123456789012345678901234567890' = '1234567890123456789012345678901234567890123456789012345678901234567890' AND '1234567890123456789012345678901234567890123456789012345678901234567890' = '1234567890123456789012345678901234567890123456789012345678901234567890' AND '1234567890123456789012345678901234567890123456789012345678901234567890' = '1234567890123456789012345678901234567890123456789012345678901234567890' AND '1234567890123456789012345678901234567890123456789012345678901234567890' = '1234567890123456789012345678901234567890123456789012345678901234567890' AND '1234567890123456789012345678901234567890123456789012345678901234567890' = '1234567890123456789012345678901234567890123456789012345678901234567890' AND '1234567890123456789012345678901234567890123456789012345678901234567890' = '1234567890123456789012345678901234567890123456789012345678901234567890' AND '1234567890123456789012345678901234567890123456789012345678901234567890' = '1234567890123456789012345678901234567890123456789012345678901234567890'
execute stmt1
execute stmt1
prepare stmt1 from ' select ''ABC'' as my_const_col FROM t1 WHERE ? = ?  and  ? = ?  and  ? = ?  and  ? = ?  and ? = ?  and  ? = ?  and  ? = ?  and  ? = ?  and ? = ?  and  ? = ?  and  ? = ?  and  ? = ?  and ? = ?  and  ? = ?  and  ? = ?  and  ? = ?  and ? = ?  and  ? = ?  and  ? = ?  and  ? = ?  and ? = ?  and  ? = ?  and  ? = ?  and  ? = ?  and ? = ?  '
execute stmt1 using @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00, @arg00
execute stmt1 using @arg00, @arg01, @arg02, @arg03, @arg04, @arg05, @arg06, @arg07, @arg10, @arg11, @arg12, @arg13, @arg14, @arg15, @arg16, @arg17, @arg20, @arg21, @arg22, @arg23, @arg24, @arg25, @arg26, @arg27, @arg30, @arg31, @arg32, @arg33, @arg34, @arg35, @arg36, @arg37, @arg40, @arg41, @arg42, @arg43, @arg44, @arg45, @arg46, @arg47, @arg50, @arg51, @arg52, @arg53, @arg54, @arg55, @arg56, @arg57, @arg60, @arg61
prepare stmt1 from @string
execute stmt1
prepare stmt1 from @string
execute stmt1
prepare stmt1 from ' select * from t5 '
execute stmt1
prepare stmt1 from "select 1 from t1 where 1=(select 1 from t1 having c1)"
execute stmt1
drop prepare stmt1
SHOW GRANTS FOR root@localhost
SHOW GRANTS for "mysql.session"@localhost
HANDLER tbl_18335504 OPEN
HANDLER tbl_18335504 READ FIRST WHERE b = 2 AND 1 > sleep(2)
HANDLER tbl_18335504 READ i1 FIRST WHERE a = 20 AND 1 > sleep(2)
HANDLER tbl_18335504 READ i1 FIRST WHERE a > 10 AND 1 > sleep(2) LIMIT 5
HANDLER tbl_18335504 READ FIRST WHERE b > 1 AND 1 > sleep(2) LIMIT 5
HANDLER tbl_18335504 CLOSE
create trigger ai after insert on t1 for each row set @a:= new.at
create trigger au after update on t1 for each row set @a:= new.at
create trigger ad after delete on t1 for each row set @a:= old.at
load data infile '../../std_data/loaddata5.dat' into table t1 fields terminated by '' enclosed by '' (i, k)
CONNECT (rl_holder,    localhost, root,,)
CONNECT (rl_acquirer,  localhost, root,,)
CONNECT (wl_acquirer,  localhost, root,,)
CONNECT (rl_contender, localhost, root,,)
CONNECTION rl_holder
CONNECTION rl_acquirer
CONNECTION wl_acquirer
sleep 2
CONNECTION rl_contender
CONNECTION rl_holder
sleep 2
CONNECTION rl_acquirer
CONNECTION wl_acquirer
CONNECTION rl_contender
CONNECTION default
DISCONNECT rl_acquirer
DISCONNECT wl_acquirer
DISCONNECT rl_contender
DISCONNECT rl_holder
write_file $BOOTSTRAP_SQL
source $passwd_file
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR u3@localhost
remove_file $PASSWD_FILE
remove_file $MYSQLD_LOG
remove_file $BOOTSTRAP_SQL
CREATE TABLE t1(x INT, KEY `` ((x + 1)))
CREATE TEMPORARY TABLE issue_functional_key_part ( sold_on DATETIME NOT NULL DEFAULT NOW(), INDEX sold_on_date ((DATE(sold_on))) ) SELECT NOW() `sold_on`
LOAD DATA INFILE '$MYSQLTEST_VARDIR/tmp/bug30838749' INTO TABLE t2 LINES STARTING BY 'EXPLAIN' TERMINATED BY 'EOL'
SELECT TRACE NOT RLIKE '"final_filtering_effect": 1' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
CREATE FUNCTION testQuestion() RETURNS INTEGER BEGIN DECLARE foo INTEGER; DECLARE bar INTEGER; SET foo=1; SET bar=2; RETURN foo; END
CALL mtr.add_suppression("\\[ERROR\\].* Operating system error number")
CALL mtr.add_suppression("\\[ERROR\\].* The error means mysqld does not have the access")
CALL mtr.add_suppression("\\[ERROR\\].* Cannot create a tablespace for table .* because the directory is not a valid location. The DATA DIRECTORY location must be in a known directory")
CALL mtr.add_suppression("\\[ERROR\\].* Error number 30 means 'Read-only file system'")
CALL mtr.add_suppression("\\[ERROR\\].* 'mkdir' returned OS error 130")
ON t3.col_time_key > t2.col_datetime_key
ON t3.col_time_key > t2.col_datetime_key
perl
open(FILE, ">", "$ENV{MYSQL_TMP_DIR}/perror_syslocale.inc") or die $!
else {print FILE "let \$non_eng_sys= 1;\n";} close FILE
source $MYSQL_TMP_DIR/perror_syslocale.inc
remove_file $MYSQL_TMP_DIR/perror_syslocale.inc
LOCK TABLE t1 WRITE
send INSERT INTO t1 VALUES (1)
WHERE ID = $con1_id AND STATE = 'Waiting for table metadata lock'
WHERE ID = $con1_id AND STATE = 'Waiting for table metadata lock'
UNLOCK TABLES
reap
send FLUSH TABLES WITH READ LOCK
KILL CONNECTION @id
reap
call mtr.add_suppression("You need to use --log-bin to make --log-replica-updates work.")
call mtr.add_suppression("You need to use --log-bin to make --binlog-format work.")
(SELECT LOCATE('IS_version=', properties) AS pos1,         # find the start of "IS_version=..." substring (SELECT SUBSTR(properties, pos1)) AS tail,         # extract the "IS_version=..." substring (SELECT LOCATE(';', tail)) AS pos2,                # find the 1st ";" delimiter inside "IS_version=..." (SELECT SUBSTR(tail, 12, pos2 - 12)) AS is_version # extract the result ("12" is for the length of "IS_version=") FROM mysql.dd_properties) AS a`
(SELECT LOCATE('.', @@version) AS dot1, (SELECT SUBSTR(@@version, dot1 + 1)) AS tail1, (SELECT LOCATE('.', tail1)) AS dot2, (SELECT SUBSTR(tail1, dot2 + 1)) AS tail2, (SELECT LOCATE('-', tail2)) AS dash1, (SELECT SUBSTR(@@version, 1, dot1 - 1)) AS v1, (SELECT SUBSTR(tail1, 1, dot2 - 1)) AS v2, (SELECT SUBSTR(tail2, 1, dash1 - 1)) AS v3) a`
CONNECT (con1, localhost, root)
CONNECT (con2, localhost, root)
CONNECTION con1
CONNECTION default
CONNECTION con1
CONNECTION con2
CONNECTION con1
CONNECTION default
CONNECTION con1
CONNECTION con2
CONNECTION con1
CONNECTION default
CONNECTION con1
CONNECTION con2
CONNECTION con1
CONNECTION default
CONNECTION con1
CONNECTION con2
CONNECTION con1
CONNECTION default
CONNECTION default
CONNECTION con1
CONNECTION default
CONNECTION default
DISCONNECT con1
DISCONNECT con2
LOCK INSTANCE FOR BACKUP
UNLOCK INSTANCE
LOCK INSTANCE FOR BACKUP
LOCK INSTANCE FOR BACKUP
UNLOCK INSTANCE
UNLOCK INSTANCE
LOCK INSTANCE FOR BACKUP
UNLOCK INSTANCE
UNLOCK TABLES
LOCK INSTANCE FOR BACKUP
UNLOCK TABLES
UNLOCK INSTANCE
LOCK INSTANCE FOR BACKUP
LOCK INSTANCE FOR BACKUP
UNLOCK TABLES
UNLOCK INSTANCE
LOCK INSTANCE FOR BACKUP
UNLOCK TABLES
UNLOCK INSTANCE
insert into t1 values (repeat(0x0000201f, 10))
insert into t1 values (repeat(0x00002020, 10))
insert into t1 values (repeat(0x00002021, 10))
PREPARE stmt FROM 'UPDATE t2 INNER JOIN (t1 JOIN t3 USING(a)) USING(a) SET a = NULL WHERE t1.b <> t2.b'
PREPARE stmt1 FROM "select 'a' rlike ?"
DEALLOCATE PREPARE stmt1
CREATE DEFINER=root@localhost PROCEDURE p1() BEGIN UPDATE t1, t2 SET a = 1 WHERE regexp_like(t1.subject, t2.pattern); END|
PREPARE stmt1 FROM "SELECT regexp_like( 'a', ? )"
PREPARE stmt2 FROM "SELECT regexp_like( ?, 'a' )"
PREPARE stmt3 FROM "SELECT regexp_like( ?, ? )"
EXECUTE stmt1 USING @pattern
EXECUTE stmt2 USING @subject
EXECUTE stmt3 USING @subject, @pattern
EXECUTE stmt1 USING @pattern
EXECUTE stmt2 USING @subject
EXECUTE stmt3 USING @subject, @pattern
DEALLOCATE PREPARE stmt1
DEALLOCATE PREPARE stmt2
DEALLOCATE PREPARE stmt3
DO 1 rlike multilinestring(point(1, 1))
SELECT length(regexp_replace( repeat('a', @buf_sz_utf16), 'a', 'b' ))
SELECT length(regexp_replace( repeat('a', @buf_sz_utf16 + 1), 'a', 'b' ))
SELECT length(regexp_replace( repeat('a', @buf_sz_utf16), 'a', 'bb' ))
INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) )
DO '1' regexp repeat('$', 50000000)
DO ( (@b) regexp (cot (unhex ( 1 )) ) )
DO ( (@c) rlike (cot ( (!( @f )) )) )
DO ( ('') rlike (cot ( ' %' )) )
DO ( (-28277) regexp (period_add ( -10966, 1381205734 )) )
DO ( (( @f )) rlike (json_depth ( 'key4' )) )
DO ( ('-  ') regexp (cot ( right (':#.', 33) )) )
DO ( (1) regexp (exp ( 64826 )) )
DO ( (@g) regexp (cot ( @f )) )
DO ( (@b) regexp (exp ( 0x1fc5574c )) )
DO ( (25091) rlike (exp ( 14373 )) )
enable_connect_log
send SELECT regexp_instr('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC', '(A+)+B')
replace_result $conn1_id <conn1_id>
reap
source include/wait_until_disconnected.inc
disable_connect_log
SELECT regexp_like( repeat(@v1, 'abc'), 'abc' )
SET @s := "SELECT regexp_like( '', '', ? / '' )"
PREPARE stmt FROM @s
EXECUTE stmt
EXECUTE stmt
CREATE TABLE t1 AS SELECT regexp_instr( 'a', 'a' ) AS a, regexp_like( 'a', 'a' ) AS b, regexp_replace( 'abc', 'b', 'x' ) AS c, regexp_substr( 'a', 'a' ) AS d, regexp_substr( repeat('a', 512), 'a' ) AS e, regexp_substr( repeat('a', 513), 'a' ) AS f
do regexp_like(0, "^{18446744073709551616")
do regexp_instr(0, "^{18446744073709551616")
DO INSERT(regexp_like(1, '['), 0, 1, '')
DO INSERT(regexp_instr(1, '['), 0, 1, '')
DO INSERT(regexp_replace(1, '[', 42), 0, 1, '')
call mtr.add_suppression("\\[Warning\\] \\[[^]]*\\] \\[[^]]*\\] You need to use --log-bin to make --binlog-format work.")
lock tables t1 write, t2 write, t3 write
lock tables t1 write, t2 write, t3 write, t1 as t4 read
lock tables t1 write, t2 read
unlock tables
lock table t1 write
unlock tables
LOCK TABLES mysql.time_zone READ, mysql.time_zone_name READ, t1 READ
UNLOCK TABLES
LOCK TABLES mysql.time_zone READ, mysql.time_zone_name READ, t1 WRITE
UNLOCK TABLES
LOCK TABLES mysql.time_zone READ, mysql.time_zone_name READ
UNLOCK TABLES
LOCK TABLES mysql.time_zone WRITE, mysql.time_zone_name WRITE
UNLOCK TABLES
LOCK TABLES mysql.time_zone READ, mysql.time_zone_name WRITE, t1 READ
LOCK TABLES mysql.time_zone WRITE, mysql.time_zone_name WRITE, t1 READ
LOCK TABLES mysql.time_zone WRITE, mysql.time_zone_name WRITE, t1 WRITE
LOCK TABLES mysql.time_zone READ, mysql.time_zone_name WRITE
lock table v_bug5719 write
unlock tables
lock tables v_bug5719 write
unlock tables
lock tables t1 write, v_bug5719 write
unlock tables
LOCK TABLES t1 WRITE, t2 READ
UNLOCK TABLES
lock table t1 write, t2 write
flush table t1
unlock tables
lock tables t1 write, v1 write
flush table t1
flush table t1
unlock tables
lock table t1 write
lock tables t1 write, v1 write
flush table t2
create trigger t2_bi before insert on t2 for each row set @a:=1
unlock tables
lock tables v1 read
flush table t2
create trigger t2_bi before insert on t2 for each row set @a:=1
unlock tables
lock tables t1 write
create trigger t2_bi before insert on t2 for each row set @a:=1
flush table t2
unlock tables
lock tables t1 write, t1 as a read, t1 as b read
unlock tables
lock tables t1 write, t1 as a read, t1 as b read
unlock tables
LOCK TABLE t1 WRITE
HANDLER t1 OPEN
HANDLER t1 READ FIRST
HANDLER t1 CLOSE
UNLOCK TABLES
LOCK TABLE t1 READ
LOCK TABLE t1 WRITE
LOCK TABLE t1 READ
LOCK TABLE t1 WRITE
UNLOCK TABLES
LOCK TABLE t1 WRITE
LOCK TABLE t2 WRITE
FLUSH TABLE t2
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t1 LOW_PRIORITY WRITE
UNLOCK TABLES
call mtr.add_suppression("Can't open and lock privilege tables: Table 'user' was not locked with LOCK TABLES")
LOCK TABLES t1 READ
UNLOCK TABLES
LOCK TABLE t1 WRITE
UNLOCK TABLES
LOCK TABLE t1 READ
UNLOCK TABLES
LOCK TABLE t2 WRITE
UNLOCK TABLES
LOCK TABLE t1 WRITE
UNLOCK TABLES
LOCK TABLE t1 WRITE, t2 WRITE
UNLOCK TABLES
LOCK TABLE v1 WRITE
UNLOCK TABLES
LOCK TABLE t1 WRITE, t2 WRITE, v1 WRITE
UNLOCK TABLES
HANDLER t1 OPEN
HANDLER t1 READ FIRST
LOCK TABLE s1.v1 WRITE
UNLOCK TABLES
LOCK TABLES t1 WRITE
UNLOCK TABLES
create table tm (k int, index using btree (k)) charset utf8mb4 engine=myisam
alter table tm add column l int, add index using btree (l)
alter table t1 drop key k, add index using btree (k), algorithm=inplace
alter table t1 drop key k, add index using hash (k), algorithm=inplace
alter table t1 drop key k, add index using btree (k), algorithm=inplace
alter table t1 drop key k, add index using btree (k), algorithm=copy
disable_query_log
call mtr.add_suppression("Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT")
enable_query_log
create table ```a` (i int)
drop table ```a`
CREATE TABLE `t1` ( `a b` INT, `c"d` INT, `e``f` INT, PRIMARY KEY (`a b`, `c"d`, `e``f`) ) ENGINE=MyISAM DEFAULT CHARSET=latin1
create trigger trg1 before insert on t1 for each row begin if new.a > 10 then set new.a := 10; set new.a := 11; end if; end
create trigger trg2 before update on t1 for each row begin if old.a % 2 = 0 then set new.b := 12; end if; end
create trigger trg3 after update on t1 for each row begin if new.a = -1 then set @fired:= "Yes"; end if; end
create trigger trg4 before insert on t2 for each row begin if new.a > 10 then set @fired:= "No"; end if; end
[mysqltest1] port=1234 DROP TABLE IF EXISTS `test1`
CREATE PROCEDURE `bug9056_proc1`(IN a INT, IN b INT, OUT c INT) BEGIN SELECT a+b INTO c; end
CREATE PROCEDURE bug9056_proc2(OUT a INT) BEGIN select sum(id) from t1 into a; END
/*!50003 CREATE FUNCTION `f`() RETURNS bigint(20) return 42 */
/*!50003 CREATE PROCEDURE `p`() select 42 */
create view v3 as select bug23491_original.f1()
INSERT INTO t1 SET c1=11, c2=REPEAT('q',509)
CREATE PROCEDURE simpleproc1 (OUT param1 INT) BEGIN SELECT COUNT(*) INTO param1 FROM t1; END
CREATE PROCEDURE simpleproc2 (OUT param1 INT) BEGIN SELECT COUNT(*) INTO param1 FROM t2; END
CREATE EVENT e1 ON SCHEDULE EVERY 1 SECOND DO DROP DATABASE BUG52792
CREATE EVENT e2 ON SCHEDULE EVERY 1 SECOND DO DROP DATABASE BUG52792
CREATE TABLE t1(f1 INT INVISIBLE, f2 INT, f3 INT AS (f1 + 10), f4 INT AS (f2 + 10) INVISIBLE, f5 INT AS (f2 + 10) STORED INVISIBLE)
CREATE TABLE t2(f1 INT, f2 INT INVISIBLE)
remove_file $MYSQLTEST_VARDIR/tmp/test1.sql
remove_file $MYSQLTEST_VARDIR/tmp/t2.txt
remove_file $MYSQLTEST_VARDIR/tmp/t2.sql
remove_file $MYSQLTEST_VARDIR/tmp/test_t2.log
remove_file $MYSQLTEST_VARDIR/tmp/tmp1.xml
remove_file $MYSQLTEST_VARDIR/tmp/tmp2.xml
send with recursive q (num, mark) as ( select 1, "a" union all select 1+num, "b" from q where mark="a" union all select 1+num, "a" from q where mark="b" ) select num from q
KILL QUERY @id
reap
create procedure check_pk_person(in person_type char, in id integer) begin declare x integer; declare msg varchar(128); /* Test integrity constraints for an 'arc' relationship. Based on 'person_type', 'id' points to either a physical person, or a moral person. */ case person_type when 'P' then begin select count(person_id) from ab_physical_person where ab_physical_person.person_id = id into x; if (x != 1) then set msg= concat('No such physical person, PK:', id); SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = msg, MYSQL_ERRNO = 10000; end if; end; when 'M' then begin select count(company_id) from ab_moral_person where ab_moral_person.company_id = id into x; if (x != 1) then set msg= concat('No such moral person, PK:', id); SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = msg, MYSQL_ERRNO = 10000; end if; end; else begin set msg= concat('No such person type:', person_type); SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = msg, MYSQL_ERRNO = 50000; end; end case; end
create procedure check_pk_inventory(in id integer) begin declare x integer; declare msg varchar(128); select count(item_id) from in_inventory where in_inventory.item_id = id into x; if (x != 1) then set msg= concat('Failed integrity constraint, table in_inventory, PK:', id); SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = msg, MYSQL_ERRNO = 10000; end if; end
create procedure check_pk_order(in id integer) begin declare x integer; declare msg varchar(128); select count(po_id) from po_order where po_order.po_id = id into x; if (x != 1) then set msg= concat('Failed integrity constraint, table po_order, PK:', id); SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = msg, MYSQL_ERRNO = 10000; end if; end
SELECT REPEAT('T', 16777211)
{ Version" : 1 , "mysql_server" : { "max_connections" : { "Value" : "23" , "Metadata" : { "Timestamp" : 1573471430265110 , "User" : "root" , "Host" : "localhost" } } } } SET PERSIST_ONLY replica_exec_mode = DEFAULT
FLUSH TABLE ta, tb
LET $wait_condition= SELECT COUNT(*) = 1 FROM performance_schema.events_waits_current WHERE event_name LIKE '%COND_open'
LET $wait_condition= SELECT event_id != @first_wait_id FROM performance_schema.events_waits_current WHERE event_name LIKE '%COND_open'
FLUSH TABLE ta, tb
LET $wait_condition= SELECT COUNT(*) = 1 FROM performance_schema.events_waits_current WHERE event_name LIKE '%COND_open'
FLUSH TABLE tb
LET $wait_condition= SELECT COUNT(*) = 1 FROM performance_schema.events_waits_current WHERE event_name LIKE '%COND_open'
FLUSH TABLE tb
LET $wait_condition= SELECT COUNT(*) = 1 FROM information_schema.processlist WHERE state LIKE 'Waiting for table flush' AND info LIKE 'FLUSH TABLES'
FLUSH TABLE tb
LET $wait_condition= SELECT COUNT(*) = 1 FROM information_schema.processlist WHERE state LIKE 'Waiting for table flush' AND info LIKE 'FLUSH TABLES tb'
FLUSH TABLE tb
LET $wait_condition= SELECT COUNT(*) = 1 FROM information_schema.processlist WHERE state LIKE 'Waiting for table flush' AND info LIKE 'FLUSH TABLES'
LET $wait_condition= SELECT COUNT(*) = 1 FROM performance_schema.events_waits_current WHERE event_name LIKE '%COND_open'
LET $wait_condition= SELECT COUNT(*) = 0 FROM information_schema.processlist WHERE state LIKE 'Waiting for table flush' AND info LIKE 'FLUSH TABLES'
LET $wait_condition= SELECT COUNT(*) = 1 FROM information_schema.processlist WHERE state LIKE 'Waiting for table metadata lock' AND info LIKE 'CREATE TABLE tb%'
FLUSH TABLE tb
LET $wait_condition= SELECT COUNT(*) = 1 FROM information_schema.processlist WHERE state LIKE 'Waiting for tablespace metadata lock' AND info LIKE 'ALTER TABLESPACE%'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
CREATE TABLESPACE ts2 ADD DATAFILE 'ts2_1.ibd'
LET $wait_condition= SELECT COUNT(*) = 2 FROM information_schema.processlist WHERE state LIKE 'Waiting for tablespace metadata lock' AND info LIKE '%TABLESPACE%'
LET $wait_condition= SELECT COUNT(*) = 1 FROM information_schema.processlist WHERE state LIKE 'Waiting for tablespace metadata lock' AND info LIKE 'ALTER TABLESPACE%'
LET $wait_condition= SELECT COUNT(*) = 0 FROM information_schema.processlist WHERE state LIKE 'Waiting for tablespace metadata lock' AND info LIKE 'ALTER TABLESPACE%'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1.ibd'
CREATE TABLESPACE ts2 ADD DATAFILE 'ts2.ibd'
LET $wait_condition= SELECT COUNT(*) = 2 FROM information_schema.processlist WHERE state LIKE 'Waiting for tablespace metadata lock' AND info LIKE 'DROP TABLESPACE%'
LET $wait_condition= SELECT COUNT(*) = 0 FROM information_schema.processlist WHERE state LIKE 'Waiting for tablespace metadata lock' AND info LIKE 'DROP TABLESPACE%'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
CREATE TABLESPACE ts2 ADD DATAFILE 'ts2_1.ibd'
CREATE TABLESPACE ts3 ADD DATAFILE 'ts3_1.ibd'
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
CREATE TABLESPACE ts2 ADD DATAFILE 'ts2_1.ibd'
CREATE TABLESPACE ts3 ADD DATAFILE 'ts3_1.ibd'
FLUSH TABLE t1 WITH READ LOCK
UNLOCK TABLES
FLUSH TABLE t2 FOR EXPORT
UNLOCK TABLES
LOCK TABLE t3 READ
UNLOCK TABLES
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
UNLOCK TABLES
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
DEALLOCATE PREPARE stmt1
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
LET $wait_condition= SELECT COUNT(*) = 1 FROM information_schema.processlist WHERE state LIKE 'Waiting for tablespace metadata lock' AND info LIKE 'DROP TABLESPACE%'
LET $wait_condition= SELECT COUNT(*) = 0 FROM information_schema.processlist WHERE state LIKE 'Waiting for tablespace metadata lock' AND info LIKE 'DROP TABLESPACE%'
CREATE TABLESPACE `` ADD DATAFILE 'x.ibd'
CREATE TABLESPACE xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ADD DATAFILE 'x.ibd'
CREATE TABLESPACE xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ADD DATAFILE 'x.ibd'
CREATE TABLESPACE `Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥` ADD DATAFILE 'x.ibd'
CREATE TABLESPACE `Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥Â¥` ADD DATAFILE 'x.ibd'
CREATE TABLESPACE `â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬` ADD DATAFILE 'x.ibd'
CREATE TABLESPACE `â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬â‚¬` ADD DATAFILE 'x.ibd'
CREATE TABLESPACE `aðˆ` ADD DATAFILE 'x.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
LOCK TABLE t1 READ
UNLOCK TABLES
UNLOCK TABLES
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1_1.ibd'
ALTER TABLE t1 TABLESPACE ``
CREATE TABLE t2 (pk INTEGER PRIMARY KEY) TABLESPACE ``
LET $wait_condition= SELECT COUNT(*) = 1 FROM information_schema.processlist WHERE state LIKE 'Waiting for tablespace metadata lock' AND info LIKE 'ALTER TABLESPACE%'
LET $wait_condition= SELECT COUNT(*) = 2 FROM performance_schema.metadata_locks WHERE object_type LIKE 'TABLESPACE'
LET $wait_condition= SELECT COUNT(*) = 1 FROM performance_schema.events_waits_current WHERE object_type LIKE 'TABLESPACE'
CALL sys.ps_setup_disable_instrument('wait')
CALL sys.ps_setup_enable_instrument('wait/lock/metadata/sql/mdl')
LET $wait_condition= SELECT COUNT(*) = 0 FROM information_schema.processlist WHERE state LIKE 'Waiting for tablespace metadata lock' AND info LIKE 'ALTER TABLESPACE%'
LET $wait_condition= SELECT COUNT(*) = 0 FROM performance_schema.metadata_locks WHERE object_type LIKE 'TABLESPACE'
LET $wait_condition= SELECT COUNT(*) = 1 FROM performance_schema.events_waits_history_long WHERE object_type LIKE 'TABLESPACE' AND object_name LIKE 'ts1'
CALL sys.ps_setup_enable_instrument('wait')
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1.ibd'
LET $wait_condition= SELECT COUNT(*) = 1 FROM performance_schema.metadata_locks WHERE object_type LIKE 'TABLESPACE' AND object_name LIKE 'ts1'
LET $wait_condition= SELECT COUNT(*) = 1 FROM performance_schema.metadata_locks WHERE object_type LIKE 'TABLESPACE' AND object_name LIKE 'ts1'
LET $wait_condition= SELECT COUNT(*) = 1 FROM performance_schema.metadata_locks WHERE object_type LIKE 'TABLESPACE' AND object_name LIKE 'ts1'
LET $wait_condition= SELECT COUNT(*) = 1 FROM performance_schema.metadata_locks WHERE object_type LIKE 'TABLESPACE' AND object_name LIKE 'ts1'
LET $wait_condition= SELECT COUNT(*) = 1 FROM performance_schema.metadata_locks WHERE object_type LIKE 'TABLESPACE' AND object_name LIKE 'ts1'
LET $wait_condition= SELECT COUNT(*) = 1 FROM performance_schema.metadata_locks WHERE object_type LIKE 'TABLESPACE' AND object_name LIKE 'ts2'
UNLOCK TABLES
CREATE TABLESPACE ts1 ADD DATAFILE 'df1.ibd'
ALTER TABLESPACE ts1 RENAME TO ts2
ALTER TABLESPACE ts2 RENAME TO ts1
ALTER TABLESPACE ts1 RENAME TO ts2
ALTER TABLESPACE ts1 RENAME TO ts2
ALTER TABLESPACE ts2 RENAME TO ts3
ALTER TABLESPACE ts2 RENAME TO ts3
ALTER TABLESPACE ts3 RENAME TO ts4
ALTER TABLESPACE ts3 RENAME TO ts4
CREATE TABLESPACE ts1 ADD DATAFILE 'df1.ibd'
ALTER TABLESPACE ts1 RENAME TO ts2
UNLOCK TABLES
LOCK TABLES t1 READ
ALTER TABLESPACE ts1 RENAME TO ts2
UNLOCK TABLES
CREATE TABLESPACE ts1 ADD DATAFILE 'df1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'df1.ibd'
ALTER TABLESPACE ts1 RENAME TO t1
CREATE TABLESPACE s1 ADD DATAFILE 's1.ibd'
LOCK TABLE t1 WRITE
UNLOCK TABLE
LOCK TABLES test1 WRITE
UNLOCK TABLES
LOCK TABLES part1 WRITE
UNLOCK TABLES
CREATE FUNCTION MY_KILL(tid INT) RETURNS INT BEGIN DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN END; KILL tid; RETURN (SELECT COUNT(*) = 0 FROM INFORMATION_SCHEMA.PROCESSLIST WHERE ID = tid); END
KILL (SELECT COUNT(*) FROM mysql.user)
disable_reconnect
enable_reconnect
send SELECT id FROM t1 WHERE id IN (SELECT /*+ NO_BNL(a,b,c,d) */ DISTINCT a.id FROM t2 a, t2 b, t2 c, t2 d GROUP BY ACOS(1/a.id), b.id, c.id, d.id HAVING a.id BETWEEN 10 AND 20)
KILL @id
reap
send SELECT ACOS(0)
KILL QUERY @id
reap
send EXECUTE stmt
KILL QUERY @id
reap
KILL @id
disable_query_log
enable_query_log
create procedure p_verify_reprepare_count(expected int) begin declare old_reprepare_count int default @reprepare_count; select variable_value from performance_schema.session_status where variable_name='com_stmt_reprepare' into @reprepare_count; if old_reprepare_count + expected <> @reprepare_count then select concat("Expected: ", expected, ", actual: ", @reprepare_count - old_reprepare_count) as "ERROR"; else select '' as "SUCCESS"; end if; end
prepare stmt from "select * from t1"
prepare stmt from "select * from t1"
execute stmt
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select * from t1"
execute stmt
execute stmt
rename table t1 to t2
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select a from t1"
execute stmt
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "insert into t1 (a) value (?)"
execute stmt using @val
execute stmt using @val
execute stmt using @val
prepare stmt from "insert into t1 (a) value (?)"
execute stmt using @val
execute stmt using @val
execute stmt using @val
prepare stmt from "insert into t1 (a) value (?)"
execute stmt using @val
execute stmt using @val
execute stmt using @val
prepare stmt from "insert into t1 (a) value (?)"
execute stmt using @val
execute stmt using @val
execute stmt using @val
execute stmt using @val
prepare stmt from "insert into t1 (a) value (?)"
execute stmt using @val
deallocate prepare stmt
prepare stmt from "insert into t1 (a) values (?)"
execute stmt using @var
execute stmt using @var
prepare stmt from "insert into t1(a) values (?)"
execute stmt using @var
execute stmt using @var
deallocate prepare stmt
prepare stmt from "insert into t1 (a) values (?)"
execute stmt using @var
execute stmt using @var
prepare stmt from "insert into t1 (a) values (?)"
execute stmt using @var
execute stmt using @var
prepare stmt from "insert into t1 (a) values (?)"
execute stmt using @var
execute stmt using @var
deallocate prepare stmt
prepare stmt from "select * from t1"
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from 'select count(*) from t1'
execute stmt
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select * from t1"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select * from t1"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select * from t1"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select count(*) from t1"
execute stmt
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select a from t1"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select * from t1"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select * from t1"
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select * from t1"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select * from t1"
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select * from t1"
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select * from t1"
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select * from t1"
execute stmt
execute stmt
flush table t2
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
lock tables t1 read, t2 read
execute stmt
execute stmt
execute stmt
unlock tables
lock tables t1 read, t2 read
execute stmt
execute stmt
execute stmt
unlock tables
lock tables t1 read, t2 read
execute stmt
execute stmt
execute stmt
unlock tables
deallocate prepare stmt
lock tables t1 read, v1 read
prepare stmt from 'select * from v1'
execute stmt
execute stmt
unlock tables
lock tables t1 read
execute stmt
unlock tables
deallocate prepare stmt
lock tables t1 read, v1 read
prepare stmt from 'select * from v1'
execute stmt
execute stmt
unlock tables
lock tables t1 read
execute stmt
unlock tables
deallocate prepare stmt
prepare stmt from "select * from v1"
execute stmt
execute stmt
execute stmt
execute stmt
create function f1() returns int begin declare x int; call p1(x); return x; end
create procedure p1(out x int) select max(a) from t1 into x
prepare stmt from "select * from v1"
execute stmt
execute stmt
create procedure p1(out x int) select max(a) from t2 into x
execute stmt
flush table t1
execute stmt
execute stmt
prepare stmt from "select * from v1"
execute stmt
execute stmt
execute stmt
execute stmt
flush table t1
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
prepare stmt from "insert into v1 (a) values (?)"
execute stmt using @var
execute stmt using @var
execute stmt using @var
execute stmt using @var
deallocate prepare stmt
prepare stmt from "select ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE from INFORMATION_SCHEMA.ROUTINES where routine_name='p1'"
execute stmt
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select * from mysql.general_log where argument='IMPOSSIBLE QUERY STRING'"
execute stmt
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select database_name, table_name, n_rows, sum_of_other_index_sizes from mysql.innodb_table_stats where table_name='t1'"
execute stmt
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select * from v1"
execute stmt
execute stmt
execute stmt
execute stmt
prepare stmt from "alter table t1 add column b int"
execute stmt
execute stmt
execute stmt
execute stmt
prepare stmt from "show create procedure p1"
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
prepare stmt from "show create function f1"
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
prepare stmt from "show create trigger t1_bi"
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select a from t1"
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select * from v_27420"
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select oref, a, a in (select a from t_27430_1 where oref=t_27430_2.oref) Z from t_27430_2"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select * from v_27690_1, v_27690_2"
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select f1()"
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
deallocate prepare stmt_sf
deallocate prepare stmt_sp
prepare stmt from "select 1 as res from dual where (1) in (select * from t1)"
execute stmt
deallocate prepare stmt
prepare stmt from 'create table t2 as select * from t1'
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "create temporary table if not exists t2 as select * from t1"
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "create table t2 like t1"
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "update t2 set a=a+1 where (1) in (select * from t1)"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "insert into t2 set a=((1) in (select * from t1))"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "insert into t2 select * from t1"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "replace t2 set a=((1) in (select * from t1))"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "replace t2 select * from t1"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "delete from t2 where (1) in (select * from t1)"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "delete t2, t3 from t2, t3 where (1) in (select * from t1)"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "update t2, t3 set t3.a=t2.a, t2.a=null where (1) in (select * from t1)"
execute stmt
deallocate prepare stmt
prepare stmt from "load data infile '../std_data_ln/words.dat' into table t1"
prepare stmt from "show databases where (1) in (select * from t1)"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "show tables where (1) in (select * from t1)"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "show fields from t1 where (1) in (select * from t1)"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "show keys from t1 where (1) in (select * from t1)"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "show variables where (1) in (select * from t1)"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "show status where (1) in (select * from t1)"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "show charset where (1) in (select * from t1)"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "show collation where (1) in (select * from t1)"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "show table status where (1) in (select * from t1)"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "show triggers where (1) in (select * from t1)"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "show open tables where (1) in (select * from t1)"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "show procedure status where (1) in (select * from t1)"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "show function status where (1) in (select * from t1)"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "show events where (1) in (select * from t1)"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "set @a=((1) in (select * from t1))"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "do ((1) in (select * from t1))"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "call p1((1) in (select * from t1))"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "create view v1 as select * from t1"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "alter view v1 as select 2"
CREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW SET @a:= (SELECT COUNT(*) FROM t1)
PREPARE stmt1 FROM 'INSERT INTO t1 VALUES (1)'
EXECUTE stmt1
EXECUTE stmt1
DEALLOCATE PREPARE stmt1
PREPARE stmt2 FROM 'CREATE TEMPORARY TABLE tm (i INT) ENGINE=InnoDB UNION=(t1)'
EXECUTE stmt2
EXECUTE stmt2
DEALLOCATE PREPARE stmt2
PREPARE stmt3 FROM 'ALTER TABLE tm UNION=(t1)'
EXECUTE stmt3
EXECUTE stmt3
DEALLOCATE PREPARE stmt3
call mtr.add_suppression("Got an error from thread_id=.*ha_myisam.cc:")
call mtr.add_suppression("MySQL thread id .*, query id .* localhost.*mysqltest_u1 Checking table")
flush table mysqltest_db1.t1
CALL mtr.add_suppression("Cannot create temporary merge file")
create table t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by range (a) subpartition by hash (a+b) ( partition x1 values less than (1) ( subpartition x11 nodegroup 0, subpartition x12 nodegroup 1), partition x2 values less than (5) ( subpartition x21 nodegroup 0, subpartition x22 nodegroup 1), partition x3 values less than (10) ( subpartition x31 max_rows=50, subpartition x32 nodegroup 1) )
CREATE TABLE t1 (f1 INT NOT NULL AUTO_INCREMENT, f2 INT NOT NULL, PRIMARY KEY (f1,f2)) ENGINE=InnoDB PARTITION BY RANGE (f2) (PARTITION p0 VALUES LESS THAN (100), PARTITION p1 VALUES LESS THAN (200), PARTITION p2 VALUES LESS THAN (300), PARTITION p3 VALUES LESS THAN (MAXVALUE))
INSERT INTO t VALUES (REPEAT('a', 128)), (REPEAT('b', 128)), (REPEAT('c', 128)), (REPEAT('d', 128))
CALL mtr.add_suppression("Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT")
SET @save_filters= @@global.dragnet.log_error_filter_rules
disable_warnings
SET @save_filters= @@global.dragnet.log_error_filter_rules
SELECT @@global.dragnet.log_error_filter_rules
SELECT @@global.dragnet.log_error_filter_rules
SELECT @@session.dragnet.log_error_filter_rules
disable_warnings
SET @@global.dragnet.log_error_filter_rules= REPEAT("IF prio>9 THEN drop. ", 1025)
SET @rules= CONCAT("IF ", REPEAT("x", 20000), ">9 THEN drop.")
call mtr.add_suppression("\\[ERROR\\] \\[MY\\-010000\\] \\[Server\\] Errors should not be suppressed")
enable_warnings
disable_warnings
perl
use File::stat
my $file= $ENV{'GREP_FILE'} or die("grep file not set")
my $pattern="^20"
my $stime= $ENV{'GREP_START'}
open(FILE, "$file") or die("Unable to open $file: $!")
while (<FILE>) { my $line = $_
my $ts = 0
if ($stime == 0) { print "$line"
} elsif ($line =~ /$pattern/) { $line =~ /([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])T([0-9][0-9]):([0-9][0-9]):([0-9][0-9])\.([0-9][0-9][0-9][0-9][0-9][0-9])[-+Z][0-9:]* *[0-9]* *?(\[.*)
$ts=$1.$2.$3.$4.$5.$6.$7
if ($ts >= $stime) { $stime= 0
} } } close(FILE)
select HEX(0x19c9bbcce9e0a88f5212572b0c5b9e6d0 | _binary 0x13c19e5cfdf03b19518cbe3d65faf10d2), HEX(0x19c9bbcce9e0a88f5212572b0c5b9e6d0 ^ _binary 0x13c19e5cfdf03b19518cbe3d65faf10d2), HEX(0x19c9bbcce9e0a88f5212572b0c5b9e6d0 & _binary 0x13c19e5cfdf03b19518cbe3d65faf10d2), HEX(~ _binary 0x19c9bbcce9e0a88f5212572b0c5b9e6d0), HEX(~ _binary 0x13c19e5cfdf03b19518cbe3d65faf10d2)
PREPARE s1 FROM "SELECT HEX(vbin1 & vbin2), HEX(vbin1 | vbin2), HEX(vbin1 ^ vbin2), HEX(~vbin1), HEX(vbin1 << 3), HEX(vbin2 >> 3), BIT_COUNT(vbin1) FROM t WHERE id in(1, 2, 3, 4, 5, 6)"
EXECUTE s1
EXECUTE s1
PREPARE s2 FROM "SELECT HEX(vbin1 & vbin2), HEX(vbin1 | vbin2), HEX(vbin1 ^ vbin2), HEX(~vbin1), HEX(vbin1 << 3), HEX(vbin2 >> 3), BIT_COUNT(vbin1) FROM t WHERE id in(7)"
EXECUTE s2
EXECUTE s2
CREATE TABLE at(_bit bit(64), _tin tinyint(8), _boo bool, _sms smallint signed, _smu smallint unsigned, _mes mediumint signed, _meu mediumint unsigned, _ins int signed, _inu int unsigned, _bis bigint signed, _biu bigint unsigned, _dec decimal (5,2), _flo float, _dou double, _yea year, _jsn json, _chr char(12), _vch varchar(12), _bin binary(255), _vbn varbinary(255), _tbl tinyblob, _ttx tinytext, _blb blob, _txt text, _mbb mediumblob, _mtx mediumtext, _lbb longblob, _ltx longtext, _pnt point, _dat date default '1988-12-15', _dtt datetime default '2015-10-24 12:00:00', _smp timestamp default '2015-10-24 14:00:00', _tim time default' 07:08:09', _enu enum('a', 'b', 'c'), _set set('a', 'b', 'c') )
INSERT INTO at ( _bit, _tin, _boo, _sms, _smu, _mes, _meu, _ins, _inu, _bis, _biu, _dec, _flo, _dou, _yea, _jsn, _chr, _vch, _bin, _vbn, _tbl, _ttx, _blb, _txt, _mbb, _mtx, _lbb, _ltx, _pnt, _enu, _set ) VALUES ( 64, 64, true, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 2005, cast('{"a": 3}' as json), "abcdefghijkl", "abcdefghijkl", x'CAFEBABE000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CAFEBABE11111111', x'CAFEBABE00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111CAFEBABE', x'CAFEBABE000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CAFE1111CAFE1111', "abcdefg", x'cafebabe', "abcdefg", x'cafebabe', "abcdefg", x'cafebabe', "abcdefg", st_geomfromtext('point(1 1)'), 1, 1 )
SELECT _bit | 2147483647 FROM at
SELECT _tin | 2147483647 FROM at
SELECT _boo | 2147483647 FROM at
SELECT _sms | 2147483647 FROM at
SELECT _smu | 2147483647 FROM at
SELECT _mes | 2147483647 FROM at
SELECT _meu | 2147483647 FROM at
SELECT _ins | 2147483647 FROM at
SELECT _inu | 2147483647 FROM at
SELECT _bis | 2147483647 FROM at
SELECT _biu | 2147483647 FROM at
SELECT _dec | 2147483647 FROM at
SELECT _flo | 2147483647 FROM at
SELECT _dou | 2147483647 FROM at
SELECT _yea | 2147483647 FROM at
SELECT _jsn | 2147483647 FROM at
SELECT _chr | 2147483647 FROM at
SELECT _vch | 2147483647 FROM at
SELECT _bin | 2147483647 FROM at
SELECT _vbn | 2147483647 FROM at
SELECT _tbl | 2147483647 FROM at
SELECT _ttx | 2147483647 FROM at
SELECT _blb | 2147483647 FROM at
SELECT _txt | 2147483647 FROM at
SELECT _mbb | 2147483647 FROM at
SELECT _mtx | 2147483647 FROM at
SELECT _lbb | 2147483647 FROM at
SELECT _ltx | 2147483647 FROM at
SELECT _pnt | 2147483647 FROM at
SELECT _dat | 2147483647 FROM at
SELECT _dtt | 2147483647 FROM at
SELECT _smp | 2147483647 FROM at
SELECT _tim | 2147483647 FROM at
SELECT _enu | 2147483647 FROM at
SELECT _set | 2147483647 FROM at
SELECT _bit & 2147483647 FROM at
SELECT _tin & 2147483647 FROM at
SELECT _boo & 2147483647 FROM at
SELECT _sms & 2147483647 FROM at
SELECT _smu & 2147483647 FROM at
SELECT _mes & 2147483647 FROM at
SELECT _meu & 2147483647 FROM at
SELECT _ins & 2147483647 FROM at
SELECT _inu & 2147483647 FROM at
SELECT _bis & 2147483647 FROM at
SELECT _biu & 2147483647 FROM at
SELECT _dec & 2147483647 FROM at
SELECT _flo & 2147483647 FROM at
SELECT _dou & 2147483647 FROM at
SELECT _yea & 2147483647 FROM at
SELECT _jsn & 2147483647 FROM at
SELECT _chr & 2147483647 FROM at
SELECT _vch & 2147483647 FROM at
SELECT _bin & 2147483647 FROM at
SELECT _vbn & 2147483647 FROM at
SELECT _tbl & 2147483647 FROM at
SELECT _ttx & 2147483647 FROM at
SELECT _blb & 2147483647 FROM at
SELECT _txt & 2147483647 FROM at
SELECT _mbb & 2147483647 FROM at
SELECT _mtx & 2147483647 FROM at
SELECT _lbb & 2147483647 FROM at
SELECT _ltx & 2147483647 FROM at
SELECT _pnt & 2147483647 FROM at
SELECT _dat & 2147483647 FROM at
SELECT _dtt & 2147483647 FROM at
SELECT _smp & 2147483647 FROM at
SELECT _tim & 2147483647 FROM at
SELECT _enu & 2147483647 FROM at
SELECT _set & 2147483647 FROM at
SELECT _bit ^ 2147483647 FROM at
SELECT _tin ^ 2147483647 FROM at
SELECT _boo ^ 2147483647 FROM at
SELECT _sms ^ 2147483647 FROM at
SELECT _smu ^ 2147483647 FROM at
SELECT _mes ^ 2147483647 FROM at
SELECT _meu ^ 2147483647 FROM at
SELECT _ins ^ 2147483647 FROM at
SELECT _inu ^ 2147483647 FROM at
SELECT _bis ^ 2147483647 FROM at
SELECT _biu ^ 2147483647 FROM at
SELECT _dec ^ 2147483647 FROM at
SELECT _flo ^ 2147483647 FROM at
SELECT _dou ^ 2147483647 FROM at
SELECT _yea ^ 2147483647 FROM at
SELECT _jsn ^ 2147483647 FROM at
SELECT _chr ^ 2147483647 FROM at
SELECT _vch ^ 2147483647 FROM at
SELECT _bin ^ 2147483647 FROM at
SELECT _vbn ^ 2147483647 FROM at
SELECT _tbl ^ 2147483647 FROM at
SELECT _ttx ^ 2147483647 FROM at
SELECT _blb ^ 2147483647 FROM at
SELECT _txt ^ 2147483647 FROM at
SELECT _mbb ^ 2147483647 FROM at
SELECT _mtx ^ 2147483647 FROM at
SELECT _lbb ^ 2147483647 FROM at
SELECT _ltx ^ 2147483647 FROM at
SELECT _pnt ^ 2147483647 FROM at
SELECT _dat ^ 2147483647 FROM at
SELECT _dtt ^ 2147483647 FROM at
SELECT _smp ^ 2147483647 FROM at
SELECT _tim ^ 2147483647 FROM at
SELECT _enu ^ 2147483647 FROM at
SELECT _set ^ 2147483647 FROM at
SELECT _bit | x'cafebabe' FROM at
SELECT _tin | x'cafebabe' FROM at
SELECT _boo | x'cafebabe' FROM at
SELECT _sms | x'cafebabe' FROM at
SELECT _smu | x'cafebabe' FROM at
SELECT _mes | x'cafebabe' FROM at
SELECT _meu | x'cafebabe' FROM at
SELECT _ins | x'cafebabe' FROM at
SELECT _inu | x'cafebabe' FROM at
SELECT _bis | x'cafebabe' FROM at
SELECT _biu | x'cafebabe' FROM at
SELECT _dec | x'cafebabe' FROM at
SELECT _flo | x'cafebabe' FROM at
SELECT _dou | x'cafebabe' FROM at
SELECT _yea | x'cafebabe' FROM at
SELECT _jsn | x'cafebabe' FROM at
SELECT _chr | x'cafebabe' FROM at
SELECT _vch | x'cafebabe' FROM at
SELECT hex(_bin | x'CAFEBABE000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CAFE1111CAFE1111') FROM at
SELECT _bin | x'cafebabe' FROM at
SELECT hex(_vbn | x'CAFEBABE000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CAFE1111CAFE1111') FROM at
SELECT _vbn | x'cafebabe' FROM at
SELECT hex(_tbl | x'CAFEBABE000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CAFE1111CAFE1111') FROM at
SELECT _tbl | x'cafebabe' FROM at
SELECT _ttx | x'cafebabe' FROM at
SELECT hex(_blb | x'cafebabe') FROM at
SELECT _txt | x'cafebabe' FROM at
SELECT hex(_mbb | x'cafebabe') FROM at
SELECT _mtx | x'cafebabe' FROM at
SELECT hex(_lbb | x'cafebabe') FROM at
SELECT _ltx | x'cafebabe' FROM at
SELECT _pnt | x'cafebabe' FROM at
SELECT _dat | x'cafebabe' FROM at
SELECT _dtt | x'cafebabe' FROM at
SELECT _smp | x'cafebabe' FROM at
SELECT _tim | x'cafebabe' FROM at
SELECT _enu | x'cafebabe' FROM at
SELECT _set | x'cafebabe' FROM at
SELECT _bit & x'cafebabe' FROM at
SELECT _tin & x'cafebabe' FROM at
SELECT _boo & x'cafebabe' FROM at
SELECT _sms & x'cafebabe' FROM at
SELECT _smu & x'cafebabe' FROM at
SELECT _mes & x'cafebabe' FROM at
SELECT _meu & x'cafebabe' FROM at
SELECT _ins & x'cafebabe' FROM at
SELECT _inu & x'cafebabe' FROM at
SELECT _bis & x'cafebabe' FROM at
SELECT _biu & x'cafebabe' FROM at
SELECT _dec & x'cafebabe' FROM at
SELECT _flo & x'cafebabe' FROM at
SELECT _dou & x'cafebabe' FROM at
SELECT _yea & x'cafebabe' FROM at
SELECT _jsn & x'cafebabe' FROM at
SELECT _chr & x'cafebabe' FROM at
SELECT _vch & x'cafebabe' FROM at
SELECT hex(_bin & x'CAFEBABE000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CAFE1111CAFE1111') FROM at
SELECT _bin & x'cafebabe' FROM at
SELECT hex(_vbn & x'CAFEBABE000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CAFE1111CAFE1111') FROM at
SELECT _vbn & x'cafebabe' FROM at
SELECT hex(_tbl & x'CAFEBABE000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CAFE1111CAFE1111') FROM at
SELECT _tbl & x'cafebabe' FROM at
SELECT _ttx & x'cafebabe' FROM at
SELECT hex(_blb & x'cafebabe') FROM at
SELECT _txt & x'cafebabe' FROM at
SELECT hex(_mbb & x'cafebabe') FROM at
SELECT _mtx & x'cafebabe' FROM at
SELECT hex(_lbb & x'cafebabe') FROM at
SELECT _ltx & x'cafebabe' FROM at
SELECT _pnt & x'cafebabe' FROM at
SELECT _dat & x'cafebabe' FROM at
SELECT _dtt & x'cafebabe' FROM at
SELECT _smp & x'cafebabe' FROM at
SELECT _tim & x'cafebabe' FROM at
SELECT _enu & x'cafebabe' FROM at
SELECT _set & x'cafebabe' FROM at
SELECT _bit ^ x'cafebabe' FROM at
SELECT _tin ^ x'cafebabe' FROM at
SELECT _boo ^ x'cafebabe' FROM at
SELECT _sms ^ x'cafebabe' FROM at
SELECT _smu ^ x'cafebabe' FROM at
SELECT _mes ^ x'cafebabe' FROM at
SELECT _meu ^ x'cafebabe' FROM at
SELECT _ins ^ x'cafebabe' FROM at
SELECT _inu ^ x'cafebabe' FROM at
SELECT _bis ^ x'cafebabe' FROM at
SELECT _biu ^ x'cafebabe' FROM at
SELECT _dec ^ x'cafebabe' FROM at
SELECT _flo ^ x'cafebabe' FROM at
SELECT _dou ^ x'cafebabe' FROM at
SELECT _yea ^ x'cafebabe' FROM at
SELECT _jsn ^ x'cafebabe' FROM at
SELECT _chr ^ x'cafebabe' FROM at
SELECT _vch ^ x'cafebabe' FROM at
SELECT hex(_bin ^ x'CAFEBABE000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CAFE1111CAFE1111') FROM at
SELECT _bin ^ x'cafebabe' FROM at
SELECT hex(_vbn ^ x'CAFEBABE000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CAFE1111CAFE1111') FROM at
SELECT _vbn ^ x'cafebabe' FROM at
SELECT hex(_tbl ^ x'CAFEBABE000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CAFE1111CAFE1111') FROM at
SELECT _tbl ^ x'cafebabe' FROM at
SELECT _ttx ^ x'cafebabe' FROM at
SELECT hex(_blb ^ x'cafebabe') FROM at
SELECT _txt ^ x'cafebabe' FROM at
SELECT hex(_mbb ^ x'cafebabe') FROM at
SELECT _mtx ^ x'cafebabe' FROM at
SELECT hex(_lbb ^ x'cafebabe') FROM at
SELECT _ltx ^ x'cafebabe' FROM at
SELECT _pnt ^ x'cafebabe' FROM at
SELECT _dat ^ x'cafebabe' FROM at
SELECT _dtt ^ x'cafebabe' FROM at
SELECT _smp ^ x'cafebabe' FROM at
SELECT _tim ^ x'cafebabe' FROM at
SELECT _enu ^ x'cafebabe' FROM at
SELECT _set ^ x'cafebabe' FROM at
SELECT HEX(_bin & _bin), HEX(_bin & _vbn), HEX(_vbn & _bin), HEX(_vbn & _vbn) FROM at
SELECT HEX(_bin | _bin), HEX(_bin | _vbn), HEX(_vbn | _bin), HEX(_vbn | _vbn) FROM at
SELECT HEX(_bin ^ _bin), HEX(_bin ^ _vbn), HEX(_vbn ^ _bin), HEX(_vbn ^ _vbn) FROM at
PREPARE s1 FROM "SELECT group_id, HEX(BIT_AND(a)) FROM t GROUP BY group_id"
EXECUTE s1
PREPARE s2 FROM "SELECT group_id, HEX(BIT_OR(a)) FROM t GROUP BY group_id"
EXECUTE s2
PREPARE s3 FROM "SELECT group_id, HEX(BIT_XOR(a)) FROM t GROUP BY group_id"
EXECUTE s3
PREPARE s4 FROM "SELECT HEX(BIT_AND(a)) FROM t"
EXECUTE s4
PREPARE s5 FROM "SELECT HEX(BIT_OR(a)) FROM t"
EXECUTE s5
PREPARE s6 FROM "SELECT HEX(BIT_XOR(a)) FROM t"
EXECUTE s6
PREPARE s1 FROM "SELECT group_id, HEX(BIT_AND(a)) FROM t GROUP BY group_id"
EXECUTE s1
PREPARE s2 FROM "SELECT group_id, HEX(BIT_OR(a)) FROM t GROUP BY group_id"
EXECUTE s2
PREPARE s3 FROM "SELECT group_id, HEX(BIT_XOR(a)) FROM t GROUP BY group_id"
EXECUTE s3
PREPARE s4 FROM "SELECT HEX(BIT_AND(a)) FROM t"
EXECUTE s4
PREPARE s5 FROM "SELECT HEX(BIT_OR(a)) FROM t"
EXECUTE s5
PREPARE s6 FROM "SELECT HEX(BIT_XOR(a)) FROM t"
EXECUTE s6
PREPARE s1 FROM "SELECT HEX(BIT_AND(a)),HEX(BIT_OR(a)),HEX(BIT_XOR(a)) FROM t WHERE group_id = 5"
EXECUTE s1
EXECUTE s1
PREPARE s2 FROM "SELECT group_id, HEX(BIT_AND(a)), HEX(BIT_OR(a)), HEX (BIT_XOR(a)) FROM t GROUP BY group_id"
EXECUTE s2
EXECUTE s2
SELECT HEX(_binary 0x0003 << (_binary 0x38 | 0x38))
SELECT HEX(_binary 0x0003 << (_binary 0x40 | 0x40))
LET $have_debug= `SELECT (version() LIKE '%debug%')`
IF ($have_debug) { disable_query_log
disable_result_log
enable_result_log
enable_query_log
} DROP table t
SET @a:= b'1010010001000010000010000001000000010000000010000000001000000000010000000000010000000000001'
SELECT BIT_COUNT(_binary 0x221040808040100200200100)
INSERT INTO t VALUES(REPEAT(x'0a',1000))
SET @a:= b'1010010001000010000010000001000000010000000010000000001000000000010000000000010000000000001'
LET $c = 96
WHILE ($c) { EVAL INSERT INTO r SELECT $c, HEX(@a << $c), HEX(@a >> $c)
DEC $c
} SELECT * FROM r ORDER by c
INSERT INTO t VALUES(1, REPEAT('2', 257)), (1, REPEAT('1', 257))
INSERT INTO t VALUES(1, REPEAT('2', 255)), (1, REPEAT('1', 255))
INSERT INTO t VALUES(1, REPEAT('2', 32750), REPEAT('1', 32750))
SELECT 1 FROM t WHERE insert(a & 0x111111,'','','')
SELECT 1 FROM t WHERE insert(a & NULL,'','','')
PREPARE s FROM 'do json_array(1, database(), bit_or(@c:=0xe9))'
EXECUTE s
EXECUTE s
DEALLOCATE PREPARE s
SET @s:="do field('1',monthname(now()),bit_and(export_set(1,'',1,0x29,186)))"
PREPARE s FROM @s
EXECUTE s
EXECUTE s
DEALLOCATE PREPARE s
SET @s1:='do length(concat(1,bit_xor(aes_encrypt(1,1,1))));'
PREPARE s FROM @s
EXECUTE s
EXECUTE s
DEALLOCATE PREPARE s
write_file $BOOTSTRAP_SQL
mkdir $DDIR
remove_file $MYSQLD_LOG
remove_file $BOOTSTRAP_SQL
mkdir $DDIR
write_file $AFILE
some text perl
my $mysqldir="$ENV{'DDIR'}/mysql"
if (opendir(my $dh, $mysqldir)) { print "Data directory $mysqldir not empty\n"
closedir($dh)
} remove_file $MYSQLD_LOG
write_file $DDIR
some text remove_file $MYSQLD_LOG
CALL mtr.add_suppression("Dictionary file not specified")
perl
my $logf= $ENV{'LOGF'} or die "LOGF not set"
open(FILE, "$logf") or die("Unable to open $logf: $!\n")
my $count_warnings= grep(/\[Warning\] \[[^]]*\] \[[^]]*\] The syntax 'plugin-validate-password-length' is deprecated and will be removed in a future release\. Please use validate-password-length instead\./gi,<FILE>)
my $count_warnings= $count_warnings
print "Deprecation warning count : $count_warnings\n"
close(FILE)
open(FILE,">$logf") or die("Unable to open $logf for truncation $!\n")
close(FILE)
CALL mtr.add_suppression("Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT")
CREATE TABLE t4 (s1 CHAR(50) CHARACTER SET latin1, s2 CHAR(50) CHARACTER SET cp932, d DECIMAL(10,2))| CREATE PROCEDURE bug18293 (IN ins1 CHAR(50), IN ins2 CHAR(50) CHARACTER SET cp932, IN ind DECIMAL(10,2)) BEGIN INSERT INTO t4 VALUES (ins1, ins2, ind)
END| CALL bug18293("Foo's a Bar", _cp932 0xED40ED41ED42, 47.93)
INSERT INTO t1 VALUES (REPEAT(_ucs2 0x201f, 10))
INSERT INTO t1 VALUES (REPEAT(_ucs2 0x2020, 10))
INSERT INTO t1 VALUES (REPEAT(_ucs2 0x2021, 10))
PREPARE stmt FROM "SELECT /*+ SET_VAR(big_tables=on) */ VARIABLE_VALUE FROM performance_schema.session_variables where VARIABLE_NAME = 'big_tables'"
EXECUTE stmt
EXECUTE stmt
DEALLOCATE PREPARE stmt
DELIMITER \
CREATE PROCEDURE test_hint (hint_str VARCHAR(255), var_str VARCHAR(64)) BEGIN SET @orig_q= CONCAT("SELECT VARIABLE_VALUE FROM performance_schema.session_variables where VARIABLE_NAME = '",  var_str, "'"); SET @hint_q= CONCAT("SELECT /*+ ", hint_str, "*/ VARIABLE_VALUE" , " FROM performance_schema.session_variables where VARIABLE_NAME = '",  var_str, "'"); PREPARE orig_stmt FROM @orig_q; PREPARE hint_stmt FROM @hint_q; EXECUTE orig_stmt; EXECUTE hint_stmt; EXECUTE orig_stmt; DEALLOCATE PREPARE orig_stmt; DEALLOCATE PREPARE hint_stmt; END
INSERT INTO t1 VALUES ( repeat( 'a', 10 ), 1), ( repeat( 'b', 10 ), 2)
LOCK TABLES t1 WRITE
UNLOCK TABLES
SELECT TIMEDIFF(NOW(), UTC_TIMESTAMP)
SELECT /*+ SET_VAR(time_zone = '+04:00') */ TIMEDIFF(NOW(), UTC_TIMESTAMP)
SELECT /*+ SET_VAR(time_zone = 'UTC') */ TIMEDIFF(NOW(), UTC_TIMESTAMP)
UPDATE /*+ SET_VAR(time_zone = 'UTC') */ t1 SET f1 = TIMEDIFF(NOW(), UTC_TIMESTAMP)
INSERT /*+ SET_VAR(time_zone = 'UTC') */ t1 VALUES (TIMEDIFF(NOW(), UTC_TIMESTAMP))
DELETE /*+ SET_VAR(time_zone = 'UTC') */ FROM t1 WHERE f1 = TIMEDIFF(NOW(), UTC_TIMESTAMP)
set @a := foo
set @a := connection_id() + 3
set @b := 1
set session @honk=99
SET @a := (SELECT afield FROM bigfailure)
SET @a := (select afield from (SELECT afield FROM bigfailure) as b)
SET @a := (select * from bigfailure where afield = (SELECT afield FROM bigfailure))
insert into city 'blah'
set @rownum := 0
set @rank := 0
set @prev_score := NULL
select @rownum := @rownum + 1 as `row`, @rank := IF(@prev_score!=a, @rownum, @rank) as `rank`, @prev_score := a as score from t1 order by score desc
set @var := 0
set @``= "illegal"
select @``
SELECT 1 NOT IN (SELECT 1 FROM t1 as t1 GROUP BY 1 LIKE (SELECT 1 FROM t1 as t2)) AS col
SELECT 1 NOT IN (SELECT 1 FROM t1 as t1 ORDER BY 1 LIKE (SELECT 1 FROM t1 as t2)) AS col
SET @c := FROM_UNIXTIME(1537002029)
DO ((@c := (_utf32' -'))) SOUNDS LIKE(@c)
PREPARE s1 FROM 'SELECT * FROM numbers WHERE ui=?'
PREPARE s2 FROM 'SELECT * FROM numbers WHERE si=?'
EXECUTE s1 USING @ui_min
EXECUTE s1 USING @ui_max
EXECUTE s1 USING @si_min
EXECUTE s1 USING @si_max
EXECUTE s2 USING @ui_min
EXECUTE s2 USING @ui_max
EXECUTE s2 USING @si_min
EXECUTE s2 USING @si_max
DEALLOCATE PREPARE s1
DEALLOCATE PREPARE s2
SET @str_ascii=_ASCII'abcxyz'
PREPARE s1 FROM 'SELECT HEX(vc_utf8mb4) FROM strings WHERE vc_ascii = ?'
PREPARE s2 FROM 'SELECT HEX(vc_utf8mb4) FROM strings WHERE vc_latin1 = ?'
PREPARE s3 FROM 'SELECT HEX(vc_utf8mb4) FROM strings WHERE vc_utf8mb4 = ?'
PREPARE s4 FROM 'SELECT HEX(vc_utf8mb4) FROM strings WHERE vc_utf16 = ?'
PREPARE s5 FROM 'SELECT HEX(vc_utf8mb4) FROM strings WHERE vc_utf32 = ?'
EXECUTE s1 USING @str_ascii
EXECUTE s1 USING @str_latin1
EXECUTE s1 USING @str_utf8mb4
EXECUTE s1 USING @str_utf16
EXECUTE s1 USING @str_utf32
EXECUTE s2 USING @str_ascii
EXECUTE s2 USING @str_latin1
EXECUTE s2 USING @str_utf8mb4
EXECUTE s2 USING @str_utf16
EXECUTE s2 USING @str_utf32
EXECUTE s3 USING @str_ascii
EXECUTE s3 USING @str_latin1
EXECUTE s3 USING @str_utf8mb4
EXECUTE s3 USING @str_utf16
EXECUTE s3 USING @str_utf32
EXECUTE s4 USING @str_ascii
EXECUTE s4 USING @str_latin1
EXECUTE s4 USING @str_utf8mb4
EXECUTE s4 USING @str_utf16
EXECUTE s4 USING @str_utf32
EXECUTE s5 USING @str_ascii
EXECUTE s5 USING @str_latin1
EXECUTE s5 USING @str_utf8mb4
EXECUTE s5 USING @str_utf16
EXECUTE s5 USING @str_utf32
DEALLOCATE PREPARE s1
DEALLOCATE PREPARE s2
DEALLOCATE PREPARE s3
DEALLOCATE PREPARE s4
DEALLOCATE PREPARE s5
PREPARE s FROM 'SELECT 0e0 + ?'
EXECUTE s USING @maxint
DEALLOCATE PREPARE s
PREPARE s FROM 'SELECT 0.0 + ?'
EXECUTE s USING @maxint
DEALLOCATE PREPARE s
PREPARE s FROM 'SELECT 0 + ?'
EXECUTE s USING @maxint
DEALLOCATE PREPARE s
PREPARE s FROM 'SELECT concat(?,"")'
EXECUTE s USING @maxint
DEALLOCATE PREPARE s
do null not between 1 and @undefined_var
do null not between @undefined_var and 1
CREATE FUNCTION bug27563() RETURNS INT(11) DETERMINISTIC BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '70100' SET @a:= 'killed'; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET @a:= 'exception'; SET DEBUG_SYNC= 'now SIGNAL in_sync WAIT_FOR kill'; RETURN 1; END
send INSERT INTO t1 VALUES (bug27563())
KILL QUERY @id
reap
send UPDATE t1 SET f1= bug27563()
KILL QUERY @id
reap
send DELETE FROM t1 WHERE bug27563() IS NULL
KILL QUERY @id
reap
send SELECT * FROM t1 WHERE f1= bug27563()
KILL QUERY @id
reap
CREATE TRIGGER trg27563 BEFORE INSERT ON t1 FOR EACH ROW BEGIN DECLARE CONTINUE HANDLER FOR SQLSTATE '70100' SET @a:= 'killed'; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET @a:= 'exception'; INSERT INTO t2 VALUES(0); SET DEBUG_SYNC= 'now SIGNAL in_sync WAIT_FOR kill'; INSERT INTO t2 VALUES(1); END
send INSERT INTO t1 VALUES(2),(3)
KILL QUERY @id
reap
lock table t1 read
unlock tables
lock tables t2 read
unlock tables
lock tables t1 read
unlock tables
lock tables t1 read
unlock tables
show grants for test@localhost
show grants for test@localhost
create function f2 () returns int begin declare v int; select s1 from t2 into v; return v; end
create function f2 () returns int begin declare v int; select s1 from t2 into v; return v; end
LOCK TABLES v1 READ
UNLOCK TABLES
create definer=some_user@`` sql security invoker view v1 as select 1
CREATE FUNCTION f2() RETURNS VARCHAR(77) SQL SECURITY INVOKER BEGIN DECLARE cu VARCHAR(77); CALL p1(cu); RETURN cu; END
PREPARE stmt1 FROM "SELECT * FROM mysqltest_db1.t2"
EXECUTE stmt1
PREPARE stmt2 FROM "SELECT * FROM mysqltest_db1.v1, mysqltest_db1.t2"
EXECUTE stmt2
EXECUTE stmt1
EXECUTE stmt2
PREPARE stmt_v1     FROM "SELECT * FROM mysqltest1.v1"
PREPARE stmt_v2 FROM "SELECT * FROM mysqltest1.v2"
EXECUTE stmt_v1
EXECUTE stmt_v2
PREPARE stmt FROM "SELECT a FROM v3"
EXECUTE stmt
CREATE VIEW v_mysqluser1_f1 AS SELECT mysqltest1.f1() AS a
LOCK TABLES v1 READ
SHOW GRANTS FOR user1@localhost
PREPARE stmt FROM 'SELECT * FROM v1'
EXECUTE stmt
DROP PREPARE stmt
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' LINES TERMINATED BY '\n' FROM v1
cat_file $OUTFILE
remove_file $OUTFILE
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' LINES TERMINATED BY '\n' FROM v1
call mtr.add_suppression("Failed to set up SSL because of the following SSL library error")
call mtr.add_suppression("Found 1 prepared XA transactions")
ALTER TABLE t1 ADD PARTITION (PARTITION p2 VALUES IN ((71),(72),(73),(74),(75),(76),(77),(78),(79),(80), ALTER TABLE t1 ADD PARTITION (PARTITION p2 VALUES IN (21,22,23,24,25,26,27,28,29,30, 31,32,33,34,35,36,37,38,39,40))
ALTER TABLE t1 ADD PARTITION ALTER TABLE t1 ADD PARTITION (PARTITION p3_a VALUES IN (1 + 1 + 1, "a0"))
ALTER TABLE t1 ADD PARTITION (PARTITION part_2 VALUES IN ((21 ,22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ,32, 33, 34, 35, 36, 37, 38, 39, 40), (41 ,42, 43, 44, 45, 46, 47, 48, 49, 50, ALTER TABLE t1 ADD PARTITION (PARTITION part_2 VALUES IN (21 ,22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ,32, 33, 34, 35, 36, 37, 38, 39, 40))
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by list (a) subpartition by hash (a+b) ( partition x1 values in (1,2,3) ( subpartition x11 nodegroup 0, subpartition x12 nodegroup 1), partition x2 values in (4,5,6) ( subpartition x21 nodegroup 0, subpartition x22 nodegroup 1) )
mkdir $MYSQLTEST_VARDIR/tmp/tc_partition_list_directory
mkdir $MYSQLTEST_VARDIR/tmp/tc_partition_list_directory/p1999
mkdir $MYSQLTEST_VARDIR/tmp/tc_partition_list_directory/p1999/data
mkdir $MYSQLTEST_VARDIR/tmp/tc_partition_list_directory/p1999/idx
mkdir $MYSQLTEST_VARDIR/tmp/tc_partition_list_directory/p2000
mkdir $MYSQLTEST_VARDIR/tmp/tc_partition_list_directory/p2000/data
mkdir $MYSQLTEST_VARDIR/tmp/tc_partition_list_directory/p2000/idx
mkdir $MYSQLTEST_VARDIR/tmp/tc_partition_list_directory/p2001
mkdir $MYSQLTEST_VARDIR/tmp/tc_partition_list_directory/p2001/data
mkdir $MYSQLTEST_VARDIR/tmp/tc_partition_list_directory/p2001/idx
PARTITION BY LIST(YEAR(adate)) ( PARTITION p1999 VALUES IN (1995, 1999, 2003) DATA DIRECTORY = '$MYSQLTEST_VARDIR/tmp/tc_partition_list_directory/p1999/data' INDEX DIRECTORY = '$MYSQLTEST_VARDIR/tmp/tc_partition_list_directory/p1999/idx', PARTITION p2000 VALUES IN (1996, 2000, 2004) DATA DIRECTORY = '$MYSQLTEST_VARDIR/tmp/tc_partition_list_directory/p2000/data' INDEX DIRECTORY = '$MYSQLTEST_VARDIR/tmp/tc_partition_list_directory/p2000/idx', PARTITION p2001 VALUES IN (1997, 2001, 2005) DATA DIRECTORY = '$MYSQLTEST_VARDIR/tmp/tc_partition_list_directory/p2001/data' INDEX DIRECTORY = '$MYSQLTEST_VARDIR/tmp/tc_partition_list_directory/p2001/idx' )
RENAME TABLE t to t_2
RENAME TABLE t_2 to t
echo completed
CALL mtr.add_suppression('You need to use --log-bin to make --binlog-format work.')
LOCK TABLES t2 READ
UNLOCK TABLES
LOCK TABLES t2 WRITE
UNLOCK TABLES

/* line with only comment */
prepare bar from "DELETE FROM table_28779 WHERE a = 7 OR 1=1/*' AND b = 'bar';"
prepare bar from "DELETE FROM table_28779 WHERE a = 7 OR 1=1/*' AND b = 'bar';*"
prepare bar from "DELETE FROM table_28779 WHERE a = 7 OR 1=1/*! AND 2=2;"
prepare bar from "DELETE FROM table_28779 WHERE a = 7 OR 1=1/*! AND 2=2;*"
prepare bar from "DELETE FROM table_28779 WHERE a = 7 OR 1=1/*!98765' AND b = 'bar';"
prepare bar from "DELETE FROM table_28779 WHERE a = 7 OR 1=1/*!98765' AND b = 'bar';*"
SELECT 1 /*!99999 /* */ */
SELECT 2 /*!12345 /* */ */
SELECT 3 /*! /* */ */
CREATE PROCEDURE p2 () BEGIN DECLARE p LONGTEXT CHARACTER SET UTF8 DEFAULT '<Ã‘><r>A</r></Ã‘>'; SELECT EXTRACTVALUE(p,'/Ã‘/r'); END
CREATE PROCEDURE spxml(xml VARCHAR(128)) BEGIN DECLARE c INT; DECLARE i INT DEFAULT 1; SET c= ExtractValue(xml,'count(/a/b)'); SET @i= c; WHILE i <= c DO BEGIN SELECT i, @i, ExtractValue(xml,'/a/b[$i]'), ExtractValue(xml,'/a/b[$@i]'); SET i= i + 1; SET @i= @i - 1; END; END WHILE; END
select UpdateXML('<a>a</a>',repeat('a b ',1000),'')
do weight_string(extractvalue('','/*/a'))
do char((weight_string(extractvalue((''),('tX')))) using cp852)
RENAME TABLE t1 TO t2
insert ignore t1 values (1, repeat('a',210), repeat('b', 310))
insert ignore t1 values (2, repeat(0xD0B1,215), repeat(0xD0B1, 310))
select i from t1 where a=repeat(_utf8 'a',200)
select i from t1 where a=repeat(_utf8 0xD0B1,200)
select i from t1 where b=repeat(_utf8 'b',310)
create table ti (k int, index using btree (k)) charset utf8mb4 engine=innodb
create table th (k int, index using btree (k)) charset utf8mb4 engine=heap
alter table ti add column l int, add index using btree (l)
alter table th add column l int, add index using hash (l)
create table ti (k int, index using hash (k)) charset utf8mb4 engine=innodb
alter table ti add column l int, add index using hash (l)
create table t1 (k int, index using btree (k)) charset utf8mb4 engine=innodb
create table t1 (k int, index using hash (k)) charset utf8mb4 engine=heap
create table t1 (k int, index using btree (k), index using hash (k)) engine=heap
create table t1 (k int, index (k), index using hash (k)) engine=heap
create table t1 (k int, index using btree (k), index (k)) engine=innodb
create table t1 (k int, index using btree (k), index using hash (k)) engine=innodb
WHERE info LIKE 'ALTER EVENT%' AND state='Waiting for event metadata lock'
source include/wait_condition.inc
WHERE info LIKE 'SHOW CREATE EVENT%' AND state='Waiting for event metadata lock'
source include/wait_condition.inc
DISCONNECT con1
DISCONNECT con2
CREATE PROCEDURE p1() BEGIN DECLARE v1 BIT; DECLARE v2 BIT(1); DECLARE v3 BIT(3) DEFAULT b'101'; DECLARE v4 BIT(64) DEFAULT 0x5555555555555555; DECLARE v5 BIT(3); DECLARE v6 BIT(64); DECLARE v7 BIT(8) DEFAULT 128; DECLARE v8 BIT(8) DEFAULT '128'; DECLARE v9 BIT(8) DEFAULT ' 128'; DECLARE v10 BIT(8) DEFAULT 'x 128'; SET v1 = v4; SET v2 = 0; SET v5 = v4; # check overflow SHOW WARNINGS; SET v6 = v3; # check padding SELECT HEX(v1); SELECT HEX(v2); SELECT HEX(v3); SELECT HEX(v4); SELECT HEX(v5); SELECT HEX(v6); SELECT HEX(v7); SELECT HEX(v8); SELECT HEX(v9); SELECT HEX(v10); END
CREATE PROCEDURE p1(arg VARCHAR(255)) BEGIN INSERT INTO t1 VALUES('p1: step1'); CASE arg * 10 WHEN 10 * 10 THEN INSERT INTO t1 VALUES('p1: case1: on 10'); WHEN 10 * 10 + 10 * 10 THEN BEGIN CASE arg / 10 WHEN 1 THEN INSERT INTO t1 VALUES('p1: case1: case2: on 1'); WHEN 2 THEN BEGIN DECLARE i TINYINT DEFAULT 10; WHILE i > 0 DO INSERT INTO t1 VALUES(CONCAT('p1: case1: case2: loop: i: ', i)); CASE MOD(i, 2) WHEN 0 THEN INSERT INTO t1 VALUES('p1: case1: case2: loop: i is even'); WHEN 1 THEN INSERT INTO t1 VALUES('p1: case1: case2: loop: i is odd'); ELSE INSERT INTO t1 VALUES('p1: case1: case2: loop: ERROR'); END CASE; SET i = i - 1; END WHILE; END; ELSE INSERT INTO t1 VALUES('p1: case1: case2: ERROR'); END CASE; CASE arg WHEN 10 THEN INSERT INTO t1 VALUES('p1: case1: case3: on 10'); WHEN 20 THEN INSERT INTO t1 VALUES('p1: case1: case3: on 20'); ELSE INSERT INTO t1 VALUES('p1: case1: case3: ERROR'); END CASE; END; ELSE INSERT INTO t1 VALUES('p1: case1: ERROR'); END CASE; CASE arg * 10 WHEN 10 * 10 THEN INSERT INTO t1 VALUES('p1: case4: on 10'); WHEN 10 * 10 + 10 * 10 THEN BEGIN CASE arg / 10 WHEN 1 THEN INSERT INTO t1 VALUES('p1: case4: case5: on 1'); WHEN 2 THEN BEGIN DECLARE i TINYINT DEFAULT 10; WHILE i > 0 DO INSERT INTO t1 VALUES(CONCAT('p1: case4: case5: loop: i: ', i)); CASE MOD(i, 2) WHEN 0 THEN INSERT INTO t1 VALUES('p1: case4: case5: loop: i is even'); WHEN 1 THEN INSERT INTO t1 VALUES('p1: case4: case5: loop: i is odd'); ELSE INSERT INTO t1 VALUES('p1: case4: case5: loop: ERROR'); END CASE; SET i = i - 1; END WHILE; END; ELSE INSERT INTO t1 VALUES('p1: case4: case5: ERROR'); END CASE; CASE arg WHEN 10 THEN INSERT INTO t1 VALUES('p1: case4: case6: on 10'); WHEN 20 THEN INSERT INTO t1 VALUES('p1: case4: case6: on 20'); ELSE INSERT INTO t1 VALUES('p1: case4: case6: ERROR'); END CASE; END; ELSE INSERT INTO t1 VALUES('p1: case4: ERROR'); END CASE; END
CREATE PROCEDURE p2() BEGIN DECLARE i TINYINT DEFAULT 3; WHILE i > 0 DO IF MOD(i, 2) = 0 THEN SET @_test_session_var = 10; ELSE SET @_test_session_var = 'test'; END IF; CASE @_test_session_var WHEN 10 THEN INSERT INTO t1 VALUES('p2: case: numerical type'); WHEN 'test' THEN INSERT INTO t1 VALUES('p2: case: string type'); ELSE INSERT INTO t1 VALUES('p2: case: ERROR'); END CASE; SET i = i - 1; END WHILE; END
CREATE PROCEDURE p1(x DATETIME) BEGIN CREATE TABLE t1 SELECT x; SHOW CREATE TABLE t1; DROP TABLE t1; END
CREATE PROCEDURE p2() BEGIN DECLARE vb BIT(1); SELECT b INTO vb FROM t1 WHERE b = 0; SELECT HEX(vb), vb = 0, vb = FALSE, vb IS FALSE, vb = 1, vb = TRUE, vb IS TRUE; SELECT b INTO vb FROM t1 WHERE b = 1; SELECT HEX(vb), vb = 0, vb = FALSE, vb IS FALSE, vb = 1, vb = TRUE, vb IS TRUE; END
CREATE PROCEDURE proc_12976_a() BEGIN declare localvar bit(1); SELECT val INTO localvar FROM table_12976_a; SELECT coalesce(localvar, 1)+1, coalesce(val, 1)+1 FROM table_12976_a; END|
CREATE PROCEDURE proc_12976_b( name varchar(15), out ep bit, out msg varchar(10)) BEGIN SELECT emailperm into ep FROM table_12976_b where (appname = name); IF ep is true THEN SET msg = 'True'; ELSE SET msg = 'False'; END IF; END|
CREATE PROCEDURE p1() BEGIN DECLARE v TINYINT DEFAULT 1e200; SELECT v; END
CREATE PROCEDURE p2() BEGIN DECLARE v DECIMAL(5) DEFAULT 1e200; SELECT v; END
CREATE PROCEDURE p3() BEGIN DECLARE v CHAR(5) DEFAULT 'abcdef'; SELECT v LIKE 'abc___'; END
CREATE PROCEDURE p4(arg VARCHAR(2)) BEGIN DECLARE var VARCHAR(1); SET var := arg; SELECT arg, var; END
CREATE PROCEDURE p5(arg CHAR(2)) BEGIN DECLARE var CHAR(1); SET var := arg; SELECT arg, var; END
CREATE PROCEDURE p6(arg DECIMAL(2)) BEGIN DECLARE var DECIMAL(1); SET var := arg; SELECT arg, var; END
CREATE PROCEDURE p1 (arg DECIMAL(64,2)) BEGIN DECLARE var DECIMAL(64,2); SET var = arg; SELECT var; END
CREATE PROCEDURE p1() BEGIN DECLARE sp_var INTEGER; SELECT col INTO sp_var FROM t1 LIMIT 1; SHOW WARNINGS; SET @user_var = sp_var; SELECT sp_var; SELECT @user_var; END
CREATE FUNCTION f1(arg VARCHAR(255)) RETURNS VARCHAR(255) BEGIN DECLARE v1 VARCHAR(255); DECLARE v2 VARCHAR(255); SET v1 = CONCAT(LOWER(arg), UPPER(arg)); SET v2 = CONCAT(LOWER(v1), UPPER(v1)); INSERT INTO t1 VALUES(v1), (v2); RETURN CONCAT(LOWER(arg), UPPER(arg)); END
CREATE PROCEDURE p2(arg ENUM('a', 'b')) BEGIN DECLARE var ENUM('c', 'd') DEFAULT arg; SHOW WARNINGS; SELECT arg, var; END
CALL p1(_UTF8 't')
CALL p2(_LATIN1 't')
CREATE PROCEDURE p1(arg1 BINARY(2), arg2 VARBINARY(2)) BEGIN DECLARE var1 BINARY(2) DEFAULT 0x41; DECLARE var2 VARBINARY(2) DEFAULT 0x42; SELECT HEX(arg1), HEX(arg2); SELECT HEX(var1), HEX(var2); END
CREATE FUNCTION f1() RETURNS VARCHAR(2000) BEGIN DECLARE var VARCHAR(2000); SET var = ''; SET var = CONCAT(var, 'abc'); SET var = CONCAT(var, ''); RETURN var; END
CREATE PROCEDURE p1() BEGIN DECLARE v_char VARCHAR(255); DECLARE v_text TEXT DEFAULT ''; SET v_char = 'abc'; SET v_text = v_char; SET v_char = 'def'; SET v_text = concat(v_text, '|', v_char); SELECT v_text; END
CREATE PROCEDURE bug27415_text_test(entity_id_str_in text) BEGIN DECLARE str_remainder text; SET str_remainder = entity_id_str_in; select 'before substr', str_remainder; SET str_remainder = SUBSTRING(str_remainder, 3); select 'after substr', str_remainder; END
CREATE PROCEDURE bug27415_text_test2(entity_id_str_in text) BEGIN DECLARE str_remainder text; DECLARE str_remainder2 text; SET str_remainder2 = entity_id_str_in; select 'before substr', str_remainder2; SET str_remainder = SUBSTRING(str_remainder2, 3); select 'after substr', str_remainder; END
set @b:='test'
CREATE PROCEDURE ctest() BEGIN DECLARE i CHAR(16); DECLARE j INT; SET i= 'string'; SET j= 1 + i; END
CREATE PROCEDURE vctest() BEGIN DECLARE i VARCHAR(16); DECLARE j INT; SET i= 'string'; SET j= 1 + i; END
select group_concat('3') over ()
PREPARE p FROM "SELECT sex, AVG(id), ROW_NUMBER() OVER w FROM t1 GROUP BY sex HAVING sex='M' OR sex IS NULL WINDOW w AS () ORDER BY sex DESC"
EXECUTE p
EXECUTE p
DROP PREPARE p
PREPARE p FROM "SELECT sex, AVG(id), SUM(AVG(id)) OVER w, NTILE(2) OVER w FROM t1 GROUP BY sex HAVING sex=(SELECT c FROM ss LIMIT 1) OR sex='F' OR sex IS NULL WINDOW w AS (ORDER BY sex ROWS UNBOUNDED PRECEDING) ORDER BY sex DESC"
EXECUTE p
EXECUTE p; # The second execute used to fail DROP PREPARE p
SELECT sex, AVG(id) FROM t1 GROUP BY sex WITH ROLLUP HAVING (sex='M' OR sex IS NULL) AND AVG(id)=3.0 ORDER BY GROUPING(sex), sex
PREPARE p FROM "SELECT sex, COUNT(id) OVER (ORDER BY id ROWS BETWEEN ? PRECEDING and ? PRECEDING) FROM t1"
EXECUTE p USING @p1, @p2
EXECUTE p USING @p2, @p1
DROP PREPARE p
PREPARE p FROM "SELECT sex, COUNT(id) OVER (ORDER BY id ROWS BETWEEN ? FOLLOWING and ? FOLLOWING) FROM t1"
EXECUTE p USING @p2, @p1
EXECUTE p USING @p1, @p2
DROP PREPARE p
PREPARE p FROM "SELECT sex, COUNT(id) OVER (ORDER BY id ROWS BETWEEN ? FOLLOWING and ? FOLLOWING) FROM t1"
EXECUTE p USING @p2, @p1
EXECUTE p USING @p1, @p2
DROP PREPARE p
PREPARE p FROM "SELECT sex, COUNT(id) OVER (ORDER BY id ROWS ? PRECEDING) FROM t1"
EXECUTE p USING @p1
DROP PREPARE p
PREPARE p FROM "SELECT sex, COUNT(id) OVER (ORDER BY id RANGE ? PRECEDING) FROM t1"
EXECUTE p USING @p1
DROP PREPARE p
PREPARE p FROM "SELECT sex, COUNT(id) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND ? FOLLOWING) FROM t1"
EXECUTE p USING @p1
DROP PREPARE p
PREPARE p FROM "SELECT t, FIRST_VALUE(t) OVER (ORDER BY t RANGE INTERVAL ? HOUR PRECEDING) FROM t_time"
EXECUTE p USING @p1
PREPARE p FROM "SELECT t, FIRST_VALUE(t) OVER (ORDER BY t RANGE BETWEEN INTERVAL ? HOUR PRECEDING AND INTERVAL ? HOUR PRECEDING) FROM t_time"
EXECUTE p USING @p1, @p2
EXECUTE p USING @p2, @p1
EXECUTE p USING @p2, @p1
PREPARE p FROM "SELECT t, FIRST_VALUE(t) OVER (ORDER BY t RANGE BETWEEN INTERVAL ? HOUR PRECEDING AND INTERVAL ? HOUR_MINUTE PRECEDING) FROM t_time"
EXECUTE p USING @p2, @p1
EXECUTE p USING @p2, @p1
SELECT SUM(1) OVER w FROM (SELECT * FROM t1,t2 WHERE t1.id=t2.user_id) t SELECT  SUM(id) OVER (PARTITION BY sex ORDER BY id ROWS UNBOUNDED PRECEDING) summ, sex FROM t1
PREPARE s FROM 'SELECT id, NTILE(?) OVER w FROM t1 WINDOW w AS (ORDER BY id)'
EXECUTE s USING @a
PREPARE p FROM "SELECT id, NTILE(?) OVER w FROM t1 WINDOW w AS (ORDER BY id)"
EXECUTE p USING @p1
EXECUTE p USING @p1
EXECUTE p USING @p1
DROP PREPARE p
SELECT SUM(b) OVER (ORDER by a GROUPS 2 PRECEDING) FROM t
SELECT SUM(b) OVER (ORDER by a ROWS 2 PRECEDING EXCLUDE CURRENT ROW) FROM t
SELECT SUM(b) OVER (ORDER by a ROWS 2 PRECEDING EXCLUDE TIES) FROM t
SELECT SUM(b) OVER (ORDER by a ROWS 2 PRECEDING EXCLUDE GROUP) FROM t
SELECT SUM(b) OVER (ORDER by a ROWS 2 PRECEDING EXCLUDE NO OTHERS) FROM t
PREPARE p from 'SELECT sex, PERCENT_RANK() OVER (ORDER BY AVG(id) DESC) FROM t1 GROUP BY sex ORDER BY sex'
EXECUTE p
PREPARE ps FROM "SELECT RANK() OVER ( PARTITION BY pk ORDER BY col_int, col_varchar, pk) AS rnk, CUME_DIST() OVER ( PARTITION BY col_int ORDER BY pk ) AS c_dist FROM t"
EXECUTE ps
DROP PREPARE ps
PREPARE ps FROM " SELECT ROW_NUMBER() OVER ( ORDER BY d ) AS rn FROM t1 WINDOW  w1 AS ( ORDER BY d ), w2 AS ( ORDER BY a RANGE 5 PRECEDING )"
EXECUTE ps
DROP PREPARE ps
CREATE VIEW v1 AS SELECT STDDEV_SAMP(a) OVER ( ORDER BY a ROWS CURRENT ROW) AS std_dev_samp FROM t
SELECT STDDEV_SAMP(a) OVER ( ORDER BY a ROWS CURRENT ROW ) AS std_dev_samp FROM t
PREPARE ps FROM "SELECT  AVG(c2)  OVER ( ) AS res FROM  te2"
EXECUTE ps
EXECUTE ps
EXECUTE ps
CREATE FUNCTION f1() RETURNS char(255) BEGIN DECLARE ret char(255); SELECT  AVG(c2)  OVER ( ) AS res FROM  te2 INTO ret; RETURN ret; END
PREPARE ps FROM  "SELECT AVG(col_int_key) OVER () FROM t WHERE pk=3 GROUP BY col_int_key"
EXECUTE ps
EXECUTE ps
PREPARE ps FROM "SELECT AVG(12) OVER () FROM dual"
EXECUTE ps
EXECUTE ps
DROP PREPARE ps
CREATE TABLE E ( col_int int(11) DEFAULT NULL, col_varchar_10_utf8 varchar(10) CHARACTER SET utf8 DEFAULT NULL, pk int(11) NOT NULL AUTO_INCREMENT, col_varchar_10_latin1 varchar(10) DEFAULT NULL, col_varchar_255_utf8 varchar(255) CHARACTER SET utf8 DEFAULT NULL, col_varchar_255_latin1 varchar(255) DEFAULT NULL, col_int_key int(11) GENERATED ALWAYS AS ((col_int + col_int)) VIRTUAL, col_varchar_255_utf8_key varchar(255) CHARACTER SET utf8 GENERATED ALWAYS AS (concat(repeat(col_varchar_10_utf8,3),repeat(col_varchar_10_utf8,3))) VIRTUAL, col_varchar_255_latin1_key varchar(255) GENERATED ALWAYS AS (concat(repeat(col_varchar_10_latin1,3),repeat(col_varchar_10_latin1,3))) VIRTUAL, col_varchar_10_utf8_key varchar(10) CHARACTER SET utf8 GENERATED ALWAYS AS (repeat(substr(col_varchar_10_utf8,-(1)),5)) VIRTUAL, col_varchar_10_latin1_key varchar(10) GENERATED ALWAYS AS (repeat(substr(col_varchar_10_latin1,-(1)),7)) VIRTUAL, PRIMARY KEY (pk DESC), UNIQUE KEY ucover_key1 (pk DESC, col_int_key DESC, col_varchar_255_utf8_key DESC, col_varchar_255_latin1_key DESC, col_varchar_10_utf8_key DESC, col_varchar_10_latin1_key DESC), UNIQUE KEY ucover_key2 (pk, col_int_key, col_varchar_255_utf8_key, col_varchar_255_latin1_key, col_varchar_10_utf8_key, col_varchar_10_latin1_key), KEY col_int_key (col_int_key DESC), KEY col_varchar_255_utf8_key (col_varchar_255_utf8_key DESC), KEY col_varchar_255_latin1_key (col_varchar_255_latin1_key DESC), KEY col_varchar_10_utf8_key (col_varchar_10_utf8_key DESC), KEY col_varchar_10_latin1_key (col_varchar_10_latin1_key), KEY multi_key1 (col_int_key DESC, col_varchar_10_latin1_key), KEY multi_key1a (col_int_key DESC, col_varchar_10_latin1_key DESC), KEY multi_key2 (col_int_key,col_int DESC), KEY multi_key3 (col_varchar_255_utf8_key DESC, col_varchar_255_utf8), KEY multi_key4 (col_varchar_255_latin1_key, col_varchar_255_latin1), KEY multi_key5 (pk DESC,col_int_key DESC, col_varchar_10_latin1_key), KEY cover_key1 (pk DESC,col_int_key DESC, col_varchar_255_utf8_key, col_varchar_255_latin1_key DESC, col_varchar_10_utf8_key DESC, col_varchar_10_latin1_key) )
CREATE TABLE C ( col_int int(11) DEFAULT NULL, col_varchar_10_utf8 varchar(10) CHARACTER SET utf8 DEFAULT NULL, pk int(11) NOT NULL AUTO_INCREMENT, col_varchar_10_latin1 varchar(10) DEFAULT NULL, col_varchar_255_utf8 varchar(255) CHARACTER SET utf8 DEFAULT NULL, col_varchar_255_latin1 varchar(255) DEFAULT NULL, col_int_key int(11) GENERATED ALWAYS AS ((col_int + col_int)) VIRTUAL, col_varchar_255_utf8_key varchar(255) CHARACTER SET utf8 GENERATED ALWAYS AS (concat(repeat(col_varchar_10_utf8,3),repeat(col_varchar_10_utf8,3))) VIRTUAL, col_varchar_255_latin1_key varchar(255) GENERATED ALWAYS AS (concat(repeat(col_varchar_10_latin1,3),repeat(col_varchar_10_latin1,3))) VIRTUAL, col_varchar_10_utf8_key varchar(10) CHARACTER SET utf8 GENERATED ALWAYS AS (repeat(substr(col_varchar_10_utf8,-(1)),5)) VIRTUAL, col_varchar_10_latin1_key varchar(10) GENERATED ALWAYS AS (repeat(substr(col_varchar_10_latin1,-(1)),7)) VIRTUAL, PRIMARY KEY (pk DESC), UNIQUE KEY ucover_key1 (pk DESC, col_int_key DESC, col_varchar_255_utf8_key DESC, col_varchar_255_latin1_key DESC, col_varchar_10_utf8_key DESC, col_varchar_10_latin1_key DESC), UNIQUE KEY ucover_key2 (pk, col_int_key, col_varchar_255_utf8_key, col_varchar_255_latin1_key, col_varchar_10_utf8_key, col_varchar_10_latin1_key), KEY col_int_key (col_int_key DESC), KEY col_varchar_255_utf8_key (col_varchar_255_utf8_key DESC), KEY col_varchar_255_latin1_key (col_varchar_255_latin1_key DESC), KEY col_varchar_10_utf8_key (col_varchar_10_utf8_key DESC), KEY col_varchar_10_latin1_key (col_varchar_10_latin1_key), KEY multi_key1 (col_int_key DESC, col_varchar_10_latin1_key), KEY multi_key1a (col_int_key DESC, col_varchar_10_latin1_key DESC), KEY multi_key2 (col_int_key, col_int DESC), KEY multi_key3 (col_varchar_255_utf8_key DESC, col_varchar_255_utf8), KEY multi_key4 (col_varchar_255_latin1_key, col_varchar_255_latin1), KEY multi_key5 (pk DESC, col_int_key DESC, col_varchar_10_latin1_key), KEY cover_key1 (pk DESC, col_int_key DESC, col_varchar_255_utf8_key, col_varchar_255_latin1_key DESC, col_varchar_10_utf8_key DESC, col_varchar_10_latin1_key) )
PREPARE stmt FROM "SELECT w, SUM(w) OVER (ROWS 3.14 PRECEDING) FROM t"
EXECUTE stmt
PREPARE stmt FROM "SELECT w, SUM(w) OVER (ROWS ? PRECEDING) FROM t"
EXECUTE stmt USING @p1
EXECUTE stmt USING @p1
DROP PREPARE stmt
PREPARE s FROM 'DO (SELECT a FROM t WINDOW w2 AS (w1), w1 AS (ORDER BY a, a));'
EXECUTE s
EXECUTE s
SELECT FROM_UNIXTIME(FIRST_VALUE(@b)RESPECT NULLS OVER(), REPEAT('1',32))IS NOT FALSE
DO ST_WITHIN(ST_ASWKB(ST_ASBINARY(1,'axis-order=srid-defined')), ST_ASWKT( ST_ASBINARY(LAST_VALUE(4732)OVER()),'axis-order=srid-defined'))
DO ST_OVERLAPS(ST_ASWKB(ST_ASBINARY(1,'axis-order=lat-long'), 'axis-order=srid-defined'), ST_ASWKT(LAST_VALUE('*7') OVER()))
DO ST_POINTN(ST_ASWKT(ST_ASWKT(ST_ASWKB(6565))), ST_ASBINARY(LAST_VALUE(0xfd8b9af2bedb16c0d7f1cca63b5c9e) OVER()))
DO POW(-8714,REPEAT('1',32)) OR VALIDATE_PASSWORD_STRENGTH(LAST_VALUE(1) OVER())
DO SUBSTRING_INDEX(((((RADIANS(0xBD)) && (ST_SRID(1, 4326)))) OR (COT(UUID_SHORT()))), FIRST_VALUE(ROW_COUNT())RESPECT NULLS OVER(), 171)
DO ((JSON_TYPE('4:8')) AND (((ROLES_GRAPHML()) LIKE (FIRST_VALUE(31543) RESPECT NULLS OVER()))))
DO CONCAT_WS( JSON_OBJECTAGG( ROW_COUNT(), BIT_COUNT(-23163)), DEGREES((1.595545e+308)), REPEAT(FIRST_VALUE('%0') OVER(), 30))
DO REPLACE((( RELEASE_LOCK( ACOS(0x41))) OR (1)), LAST_VALUE(9.750062e+306) RESPECT NULLS OVER(), UUID_SHORT())
DO LAG(1, 9223372036854775807) OVER()
DO LEAD(1, 9223372036854775807) OVER()
DO NTILE(9223372036854775807) OVER()
DO LAG(1, 18446744073709551615) OVER()
DO LEAD(1, 18446744073709551615) OVER()
DO NTILE(18446744073709551615) OVER()
CREATE PROCEDURE p1(n INT) DO NTILE(n) OVER()
PREPARE stmt FROM 'DO NTILE(?) OVER()'
EXECUTE stmt USING @v
EXECUTE stmt USING @undefined
DO NTILE(@v) OVER()
DO NTILE(@undefined) OVER()
CREATE PROCEDURE p2(n INT) DO LEAD(1, n) OVER()
CREATE PROCEDURE p3(n INT) DO LAG(1, n) OVER()
PREPARE stmt FROM 'DO LAG(1, ?) OVER()'
EXECUTE stmt USING @v
PREPARE stmt FROM 'DO LEAD(1, ?) OVER()'
EXECUTE stmt USING @v
DO LAG(1, @v) OVER()
DO LEAD(1, @v) OVER()
DO LAG(1, @v) OVER()
DO LEAD(1, @v) OVER()
DO NTILE(@v) OVER()
DO LAG(1, @v) OVER()
DO LEAD(1, @v) OVER()
DO NTILE(@v) OVER()
DO LAG(1, @v) OVER()
DO LAG(1, @v) OVER(), @v:=20
DO LEAD(1, @v) OVER()
DO LEAD(1, @v) OVER(), @v:=20
DO NTILE(@v) OVER()
DO NTILE(@v) OVER(), @v:=20
LOAD DATA INFILE '../../tmp/data1.tmp' INTO TABLE t2
LOAD DATA INFILE '../../tmp/data2.tmp' INTO TABLE t2
WHERE f1 < 3 and f2 > 11
WHERE f1 > 2 and f2 < 25 and f3 > 200
WHERE f1 > 3 and f2 < 50 or f3 > 200
(SELECT f1, f2, f3 FROM t1) as dt WHERE (dt.f1 = 6) or( t1.f2 = 50 and dt.f3 = 200)
(SELECT f1, f2, f3 FROM t1) as dt, t0 WHERE f1 > 3 and f2 < 50 and i0 > 3
WHERE f1 > 3 and f2 < 50 and f3 > 200
WHERE (f1 > 2 and f2 < 35) and (f1+f3) > 300
WHERE (f1 > 2 and f2 < 35) or (f1+f3) > 300 or (f1 < 2)
(SELECT f3 FROM t1) as dt2 WHERE (f1 > 2 and f2 < 35) and (f1+f3) > 300 and (f3 < 400)
(SELECT f3 FROM t1) as dt2) as dt3 WHERE (f1 > 2 and f2 < 35) and (f1+f3) > 200 and (f3 < 300)
WHERE i > 1 and i+j > 40
FROM (SELECT l as i, m as j, n as k FROM (SELECT f1 as l, f2 as m, f3 as n FROM t1) as dt1 ) as dt2 WHERE i > 1 and i+j > 40
FROM (SELECT f1 as i, f2 as j FROM t1 ) as dt1 , (SELECT f1 as l, f2 as m, f3 as n FROM t1) as dt2 WHERE i > 1 and i+j > 40 and m < 20 and m+i > 20
(SELECT (i+j) AS g, f1 FROM (SELECT (f1+f2) AS i, (f1-f2) AS j FROM (SELECT f1+10 AS f1, f2+10 AS f2 FROM t1) AS dt0) AS dt1, (SELECT f1, f2 FROM t1) AS dt2) AS dt3 WHERE g > 26 and g+f1 > 31
(SELECT (f1+f2) as i, (f3+10) as j FROM t1) as dt1) as dt2 WHERE l > 20 and l+m > 10
FROM (SELECT f1+f2 as j FROM t1) as dt1(k)) as dt(m) WHERE m > 30
WHERE f1 > 3
WHERE f1+f2 > 30
FROM (SELECT f1, SUM(f2) FROM t1 GROUP BY f1 WITH ROLLUP) as dt WHERE f1 IS NULL
FROM (SELECT f1 as j, SUM(f2) as sum FROM t1 GROUP BY f1 WITH ROLLUP) as dt WHERE j+sum > 50 OR j IS NULL
FROM (SELECT f1 as j, SUM(f2) as sum FROM t1 GROUP BY f1 WITH ROLLUP HAVING AVG(f2) > 1) AS dt WHERE j+sum > 50 OR j IS NULL
WHERE f1 > 3
WHERE f1 > 0
WHERE f1 > 2
FROM (SELECT f1, SUM(f2) OVER(PARTITION BY f1) FROM t1 GROUP BY f1) as dt WHERE f1 > 2
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f2) FROM t1 GROUP BY f1) as dt WHERE f2 > 30
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f1) FROM t1 GROUP BY f1) as dt WHERE f1 > 2 and f2 > 30 and (f1+f2) > 40
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f1,f2) FROM t1 GROUP BY f1) as dt WHERE f1 > 2 and f2 > 30 and (f1+f2) > 40
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f1,f2), AVG(f3) OVER (PARTITION BY f1) FROM t1 GROUP BY f1) as dt WHERE f1 > 2 and f2 > 30 and (f1+f2) > 40
FROM (SELECT f1, SUM(f2) as SUM, AVG(f3) OVER (PARTITION BY SUM(f2)) FROM t1 GROUP BY f1) as dt WHERE SUM > 40
FROM (SELECT f1, SUM(f2) OVER (PARTITION by f1,f2), AVG(f3) OVER (PARTITION BY f2,f1), FIRST_VALUE(f3) OVER (PARTITION by f1) FROM t1) as dt WHERE f1 > 2
FROM (SELECT f1, SUM(f1) OVER (PARTITION by f2), AVG(f2) OVER (PARTITION BY f1) FROM t1) as dt WHERE f1 > 2
FROM (SELECT f1 FROM t1) as dt WHERE f1 > ?
DROP PREPARE p
(SELECT (f1+f2) as i, (f3+?) as j FROM t1) as dt1) as dt2 WHERE l > 20 and l+m > 10
WHERE a > 0.5
WHERE f1 > 3*RAND() AND f1 < 10
(SELECT f1, SUM(f2) OVER(PARTITION BY f1) FROM t1) as dt WHERE f1 > 3*RAND() AND f1 < 10
(SELECT f1 FROM t1) as dt WHERE f1 > 3*RAND() AND f1<10
FROM (SELECT f1 FROM t1 UNION SELECT f2 FROM t1) as dt WHERE f1 > 2
(SELECT (SELECT 1 FROM t1 LIMIT 1) as f1 FROM t1) as dt WHERE f1 = 1
CREATE FUNCTION p() RETURNS INTEGER BEGIN DECLARE retn INTEGER; SELECT count(f1) FROM t1 INTO retn; RETURN retn; END
WHERE p() = 1
CREATE FUNCTION p() RETURNS INTEGER DETERMINISTIC BEGIN DECLARE retn INTEGER; SELECT count(f1) FROM t1 INTO retn; RETURN retn; END
CREATE PROCEDURE p() BEGIN DECLARE val INTEGER; SET val = 2; EXPLAIN FORMAT=tree SELECT AVG(f1) FROM (SELECT * FROM t1) as dt WHERE f2 > val; SELECT AVG(f1) FROM (SELECT * FROM t1) as dt WHERE f2 > val; END
qn2 AS (SELECT 3*f1 AS f2 FROM qn) SELECT * from qn2)) as dt WHERE f2 > 1
qn2 AS (SELECT 3*f1 AS f2 FROM qn) SELECT * from qn,qn2)) as dt WHERE f1 < 10 and f2 > 1
WHERE dt.f1 > 31 and t1.f2  > 40
WHERE dt.f1 is null
WHERE dt.f1 > 3
LEFT JOIN t1 AS t2 ON TRUE) AS dt ON dt.f1 > 3
FROM t1 GROUP BY f1) as dt1 WHERE f1 > 10) dt2 WHERE sum > 10
FROM (SELECT f1, f2 FROM t1 WHERE f1 > 10) as dt1 GROUP BY f1) dt2 WHERE sum > 10
((SELECT f1, f2 FROM t1) as dt, (SELECT f1, f2 FROM t1) as dt1) WHERE FALSE
(SELECT * FROM (SELECT * FROM t1) as dt1) as dt2 WHERE f1 > 3
(SELECT * FROM (SELECT * FROM t1) as dt1) as dt2 WHERE f1 > 3
(SELECT /*+ NO_DERIVED_CONDITION_PUSHDOWN(dt1) */ * FROM (SELECT * FROM t1) as dt1) as dt2 WHERE f1 > 3
SELECT NULL IN(SELECT (f1 between 0 and 1) FROM (SELECT f1 FROM t WHERE  (@b:=NULL) - f2)as dt )
select sum(all a),count(all a),avg(all a),std(all a),variance(all a),bit_or(all a),bit_and(all a),min(all a),max(all a),min(all c),max(all c) from t1
prepare stmt1 from 'SELECT COUNT(*) FROM t1'
execute stmt1
execute stmt1
execute stmt1
deallocate prepare stmt1
prepare stmt1 from 'SELECT max(a) FROM t1'
execute stmt1
execute stmt1
execute stmt1
deallocate prepare stmt1
INSERT INTO t1 VALUES (1,CONCAT(REPEAT('_', 250), "qq")), (1,CONCAT(REPEAT('_', 250), "zz")), (1,CONCAT(REPEAT('_', 250), "aa")), (1,CONCAT(REPEAT('_', 250), "ff"))
INSERT INTO D VALUES (39,40,4,repeat('  X', 42)), (43,56,4,repeat('  X', 42)), (47,12,4,repeat('  X', 42)), (71,28,4,repeat('  X', 42)), (76,54,4,repeat('  X', 42)), (83,45,4,repeat('  X', 42)), (105,53,12,NULL)
PREPARE si8 FROM 'SELECT MAX(i8) FROM t1 WHERE i8 > ?'
PREPARE ei8 FROM 'EXPLAIN SELECT MAX(i8) FROM t1 WHERE i8 > ?'
PREPARE sdc FROM 'SELECT MAX(dc) FROM t1 WHERE dc > ?'
PREPARE edc FROM 'EXPLAIN SELECT MAX(dc) FROM t1 WHERE dc > ?'
PREPARE sf8 FROM 'SELECT MAX(f8) FROM t1 WHERE f8 > ?'
PREPARE ef8 FROM 'EXPLAIN SELECT MAX(f8) FROM t1 WHERE f8 > ?'
PREPARE svc FROM 'SELECT MAX(vc) FROM t1 WHERE vc > ?'
PREPARE evc FROM 'EXPLAIN SELECT MAX(vc) FROM t1 WHERE vc > ?'
EXECUTE si8 USING @i8
EXECUTE ei8 USING @i8
EXECUTE sdc USING @dc
EXECUTE edc USING @dc
EXECUTE sf8 USING @f8
EXECUTE ef8 USING @f8
EXECUTE svc USING @vc
EXECUTE evc USING @vc
CREATE FUNCTION seq_1_to_2() RETURNS INT BEGIN DECLARE limit_value, return_value INT; SET limit_value = 2; SELECT c1 INTO return_value FROM tr; IF (return_value < limit_value) THEN UPDATE tr SET c1 = c1 + 1; ELSE UPDATE tr SET c1 = 1; END IF; RETURN (return_value); END
/*!99999 SET @@SESSION.non_supported_session_variable = 1*/
/*!99999 SET @@SESSION.non_supported_session_variable = 1*/
/*!99999 SET @@SESSION.non_supported_session_variable = 1*/
/*!99999 SET @@SESSION.non_supported_session_variable = 1*/
CREATE TABLE t2 AS SELECT INSERT(1133,3,0,22) FROM t1
CREATE TABLE t2 AS SELECT REPEAT(1,2) FROM t1
call mtr.add_suppression("Server SSL certificate doesn't verify")
SHOW GRANTS FOR u1@localhost USING r1
CALL db1.sp1()
CALL db1.sp3()
SHOW GRANTS FOR u1@localhost USING r1
CALL db1.sp1()
SHOW GRANTS FOR u1@localhost USING r1
CALL db1.sp1()
CALL db1.sp2()
CALL db2.sp1()
CALL db1.sp3()
CALL db1.sp1()
CALL db1.sp2()
CALL db2.sp1()
CALL db1.sp3()
CALL db1.sp3()
SHOW GRANTS FOR u_worldrou@localhost USING r_worldrou
CALL world.proc_empty()
SELECT world.func_plusone(1)
SELECT world.func_plustwo(1)
send insert into t1 (c) values (2)
reap
SELECT 'c373e9f5ad0791a0dab5444553544200' IN(SELECT t1.FOLDERID FROM t1 WHERE t1.PARENTID='2f6161e879db43c1a5b82c21ddc49089' AND t1.FOLDERNAME = 'Level1')
PREPARE my_stmt FROM "SELECT t1.b, count(*) FROM t1 group by t1.b having count(*) > ALL (SELECT COUNT(*) FROM t2 WHERE t2.a=1 GROUP By t2.b)"
EXECUTE my_stmt
EXECUTE my_stmt
deallocate prepare my_stmt
create procedure p1() begin declare done int default 3; repeat select (SELECT rs.t2_id FROM t2 rs WHERE rs.t1_id= (SELECT lt.t1_id FROM t1 lt WHERE lt.t3_id=a.t3_id) ORDER BY b DESC LIMIT 1) as x from t3 AS a; set done= done-1; until done <= 0 end repeat; end
prepare st1 from "select * from t1 where (a1, a2) in (select b1, min(b2) from t2 where b1 > '0' group by b1)"
execute st1
execute st1
prepare st1 from "select * from t1 where (a1, a2) in (select b1, min(b2) from t2 where b1 > '0' group by b1)"
execute st1
execute st1
CREATE PROCEDURE run_n_times(x int) BEGIN DECLARE c int; WHILE x DO SET x = x-1; SELECT COUNT(expr_key) INTO c FROM ot WHERE expr_key IN (SELECT expr_nokey FROM it) AND ot.expr_key<100000000; END WHILE; END
source include/have_profiling.inc
LET $OLD_DB= `SELECT DATABASE()`
CREATE PROCEDURE test_if_commit() BEGIN ROLLBACK; SELECT IF (COUNT(*) > 0, "YES", "NO") AS "IMPLICIT COMMIT" FROM trans; DELETE FROM trans; COMMIT; END
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
load data infile '../../std_data/words.dat' into table t4
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
show engine all mutex
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
show engine all logs
source include/implicit_commit_helper.inc
show engine all status
source include/implicit_commit_helper.inc
show charset where (1) in (select * from t1)
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
do ((1) in (select * from t1))
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
lock tables t1 write, trans write
source include/implicit_commit_helper.inc
unlock tables
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
show create database db2
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
rename table t3 to t4
source include/implicit_commit_helper.inc
rename table t4 to t3
source include/implicit_commit_helper.inc
handler t1 open as ha1
source include/implicit_commit_helper.inc
handler ha1 read a first
source include/implicit_commit_helper.inc
handler ha1 close
source include/implicit_commit_helper.inc
show slave hosts
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
help 'foo'
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
show function code f1
source include/implicit_commit_helper.inc
prepare stmt1 from "insert into t1 values (5)"
source include/implicit_commit_helper.inc
execute stmt1
source include/implicit_commit_helper.inc
deallocate prepare stmt1
source include/implicit_commit_helper.inc
create trigger trg1 before insert on t1 for each row set @a:=1
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
CREATE TABLESPACE ts1 ADD DATAFILE './ts1.ibd' ENGINE=INNODB
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
source include/implicit_commit_helper.inc
echo ok
write_file $BOOTSTRAP_SQL
select test.a(), test.st_x(), test.st_y()
CALL mtr.add_suppression("Failed to initialize TLS for channel: mysql_admin")
CALL mtr.add_suppression("Failed to set up SSL because of the following SSL library error")
create procedure test_invalid() begin SIGNAL; create procedure test_invalid() begin SIGNAL foo; end
SIGNAL SQLSTATE '00000'
SIGNAL SQLSTATE '00001'
create procedure test_invalid() begin SIGNAL SQLSTATE '12345' SET bla_bla = 'foo'; create procedure test_invalid() begin SIGNAL SQLSTATE '12345' SET CONDITION_IDENTIFIER = 'foo'; create procedure test_invalid() begin SIGNAL SQLSTATE '12345' SET CONDITION_NUMBER = 'foo'; create procedure test_invalid() begin SIGNAL SQLSTATE '12345' SET CONNECTION_NAME = 'foo'; create procedure test_invalid() begin SIGNAL SQLSTATE '12345' SET MESSAGE_LENGTH = 'foo'; create procedure test_invalid() begin SIGNAL SQLSTATE '12345' SET MESSAGE_OCTET_LENGTH = 'foo'; create procedure test_invalid() begin SIGNAL SQLSTATE '12345' SET PARAMETER_MODE = 'foo'; create procedure test_invalid() begin SIGNAL SQLSTATE '12345' SET PARAMETER_NAME = 'foo'; create procedure test_invalid() begin SIGNAL SQLSTATE '12345' SET PARAMETER_ORDINAL_POSITION = 'foo'; create procedure test_invalid() begin SIGNAL SQLSTATE '12345' SET RETURNED_SQLSTATE = 'foo'; create procedure test_invalid() begin SIGNAL SQLSTATE '12345' SET ROUTINE_CATALOG = 'foo'; create procedure test_invalid() begin SIGNAL SQLSTATE '12345' SET ROUTINE_NAME = 'foo'; create procedure test_invalid() begin SIGNAL SQLSTATE '12345' SET ROUTINE_SCHEMA = 'foo'; create procedure test_invalid() begin SIGNAL SQLSTATE '12345' SET SERVER_NAME = 'foo'; create procedure test_invalid() begin SIGNAL SQLSTATE '12345' SET SPECIFIC_NAME = 'foo'; create procedure test_invalid() begin SIGNAL SQLSTATE '12345' SET TRIGGER_CATALOG = 'foo'; create procedure test_invalid() begin SIGNAL SQLSTATE '12345' SET TRIGGER_NAME = 'foo'; create procedure test_invalid() begin SIGNAL SQLSTATE '12345' SET TRIGGER_SCHEMA = 'foo'; delimiter ;
prepare stmt from 'SIGNAL SQLSTATE \'23000\''
prepare stmt from 'RESIGNAL SQLSTATE \'23000\''
SIGNAL foo
SIGNAL SQLSTATE '01000'
SIGNAL SQLSTATE '02000'
SIGNAL SQLSTATE '23000'
SIGNAL SQLSTATE VALUE '23000'
SIGNAL SQLSTATE 'HY000' SET MYSQL_ERRNO = 65536
SIGNAL SQLSTATE 'HY000' SET MYSQL_ERRNO = 99999
SIGNAL SQLSTATE 'HY000' SET MYSQL_ERRNO = 4294967295
SIGNAL SQLSTATE 'HY000' SET MYSQL_ERRNO = 0
SIGNAL SQLSTATE 'HY000' SET MYSQL_ERRNO = 65535
RESIGNAL
RESIGNAL foo
RESIGNAL SQLSTATE '12345'
RESIGNAL SQLSTATE VALUE '12345'
SIGNAL SQLSTATE '77777' SET MESSAGE_TEXT=''
create procedure test_signal() begin DECLARE something CONDITION FOR SQLSTATE '99999'; DECLARE message_text VARCHAR(64) DEFAULT "Local string variable"; DECLARE sqlcode INTEGER DEFAULT 1234; SIGNAL something SET MESSAGE_TEXT = message_text, MYSQL_ERRNO = sqlcode; end
create procedure test_invalid() begin DECLARE something CONDITION FOR SQLSTATE "AABBB"; SIGNAL something SET MESSAGE_TEXT = @message_text := 'illegal', MYSQL_ERRNO = @sqlcode := 1234; create procedure test_signal() begin DECLARE aaa VARCHAR(64); DECLARE bbb VARCHAR(64); DECLARE ccc VARCHAR(64); DECLARE ddd VARCHAR(64); DECLARE eee VARCHAR(64); DECLARE fff VARCHAR(64); DECLARE ggg VARCHAR(64); DECLARE hhh VARCHAR(64); DECLARE iii VARCHAR(64); DECLARE jjj VARCHAR(64); DECLARE kkk VARCHAR(64); DECLARE warn CONDITION FOR SQLSTATE "01234"; set aaa= repeat("A", 64); set bbb= repeat("B", 64); set ccc= repeat("C", 64); set ddd= repeat("D", 64); set eee= repeat("E", 64); set fff= repeat("F", 64); set ggg= repeat("G", 64); set hhh= repeat("H", 64); set iii= repeat("I", 64); set jjj= repeat("J", 64); set kkk= repeat("K", 64); SIGNAL warn SET CLASS_ORIGIN = aaa, SUBCLASS_ORIGIN = bbb, CONSTRAINT_CATALOG = ccc, CONSTRAINT_SCHEMA = ddd, CONSTRAINT_NAME = eee, CATALOG_NAME = fff, SCHEMA_NAME = ggg, TABLE_NAME = hhh, COLUMN_NAME = iii, CURSOR_NAME = jjj, MESSAGE_TEXT = kkk, MYSQL_ERRNO = 65535; end
create function test_signal_func() returns integer begin DECLARE v INT; DECLARE warn CONDITION FOR SQLSTATE "01XXX"; SIGNAL warn SET MESSAGE_TEXT = "This function SIGNAL a warning", MYSQL_ERRNO = 1012; SELECT @@warning_count INTO v; return v; end
create trigger t1_ai after insert on t1 for each row begin DECLARE msg VARCHAR(128); DECLARE warn CONDITION FOR SQLSTATE "01XXX"; set msg= concat("This trigger SIGNAL a warning, a=", NEW.a); SIGNAL warn SET MESSAGE_TEXT = msg, MYSQL_ERRNO = 1012; end
create trigger t1_ai after insert on t1 for each row begin DECLARE msg VARCHAR(128); DECLARE not_found CONDITION FOR SQLSTATE "02XXX"; set msg= concat("This trigger SIGNAL a not found, a=", NEW.a); SIGNAL not_found SET MESSAGE_TEXT = msg, MYSQL_ERRNO = 1012; end
create trigger t1_ai after insert on t1 for each row begin DECLARE msg VARCHAR(128); DECLARE error CONDITION FOR SQLSTATE "03XXX"; set msg= concat("This trigger SIGNAL an error, a=", NEW.a); SIGNAL error SET MESSAGE_TEXT = msg, MYSQL_ERRNO = 1012; end
create procedure p1() begin declare a int; declare c cursor for select f1() from t1; declare continue handler for sqlstate '03000' select "caught 03000"; declare continue handler for 1326 select "caught cursor is not open"; select "Before open"; open c; select "Before fetch"; fetch c into a; select "Before close"; close c; end
create procedure test_resignal() begin DECLARE x integer; DECLARE c cursor for select * from t_cursor; DECLARE CONTINUE HANDLER for not found begin select "before RESIGNAL"; RESIGNAL SQLSTATE "02444" SET MESSAGE_TEXT = "RESIGNAL to a not found", MYSQL_ERRNO = 55555 ; select "after RESIGNAL"; end; open c; fetch c into x; close c; end
create procedure test_resignal() begin DECLARE x integer; DECLARE c cursor for select * from t_cursor; DECLARE CONTINUE HANDLER for not found begin select "before RESIGNAL"; RESIGNAL SQLSTATE "44444" SET MESSAGE_TEXT = "RESIGNAL to an error", MYSQL_ERRNO = 55555 ; select "after RESIGNAL"; end; open c; fetch c into x; close c; end
CREATE PROCEDURE peter_p1 () BEGIN DECLARE x CONDITION FOR SQLSTATE '42000'; DECLARE EXIT HANDLER FOR x BEGIN SHOW WARNINGS; RESIGNAL x SET MYSQL_ERRNO = 9999; END; BEGIN DECLARE EXIT HANDLER FOR x BEGIN SHOW WARNINGS; RESIGNAL x SET SCHEMA_NAME = 'test', MYSQL_ERRNO= 1232; END; /* Raises ER_WRONG_VALUE_FOR_VAR : 1231, SQLSTATE 42000 */ SET @@sql_mode=NULL; END; END
CREATE PROCEDURE peter_p2 () BEGIN DECLARE x CONDITION for SQLSTATE '42000'; DECLARE EXIT HANDLER FOR x BEGIN SHOW WARNINGS; RESIGNAL x SET MESSAGE_TEXT = 'Hi, I am a useless error message', MYSQL_ERRNO = 9999; END; CALL peter_p1(); END
create procedure test_signal() begin DECLARE cÃ©Ã¨Ã§Ã  foo CONDITION FOR SQLSTATE '12345'; SIGNAL cÃ©Ã¨Ã§Ã  SET MYSQL_ERRNO = 1000; end
create procedure test_signal() begin DECLARE 'cÃ©Ã¨Ã§Ã ' CONDITION FOR SQLSTATE '12345'; SIGNAL 'cÃ©Ã¨Ã§Ã ' SET MYSQL_ERRNO = 1000; end
CREATE PROCEDURE p1() BEGIN DECLARE CONTINUE HANDLER FOR 1051 BEGIN DROP DATABASE none;  # Error 1008 END; DROP TABLE none;  # Error 1051 END
FROM mysql.innodb_index_stats WHERE table_name = 't1' AND index_name = 'latest_key' AND stat_name = 'n_diff_pfx01'
HANDLER information_schema.COLUMNS OPEN
PREPARE ps1 FROM 'SHOW TABLES FROM no_such_schema'
PREPARE ps2 FROM 'SHOW TABLES FROM mysql LIKE \'%tables%\''
EXECUTE ps1
EXECUTE ps2
DEALLOCATE PREPARE ps1
DEALLOCATE PREPARE ps2
call mtr.add_suppression('Skipped updating resource group metadata in InnoDB read only mode.')
LOCK TABLE t1 write
UNLOCK TABLES
call mtr.add_suppression("option 'thread_stack':")
CALL mtr.add_suppression("Could not increase number of max_open_files to more than *")
CALL mtr.add_suppression("Plugin audit_log reported *")
DROP TABLE IF EXISTS t1, `t``1`, `t 1`
SET @create = IF(@have_ndb = 0, @create_cmd, 'SET @dummy = 0')
SET @drop = IF(@have_ndb = 0, @drop_cmd, 'SET @dummy = 0')
PREPARE create_stmt FROM @create
PREPARE drop_stmt FROM @drop
EXECUTE create_stmt
DROP PREPARE create_stmt
EXECUTE drop_stmt
DROP PREPARE drop_stmt
SELECT j, i, f, JSON_ARRAYAGG(i) OVER w jarray_i, JSON_ARRAYAGG(f) OVER w jarray_f FROM t1 WINDOW w AS (ORDER BY j)
SELECT j, s, JSON_ARRAYAGG(s) OVER w jarray_s, JSON_ARRAYAGG(j) OVER w jarray_j FROM t1 WINDOW w AS (ORDER BY j)
SELECT i, JSON_ARRAYAGG(i) OVER() FROM t1
SELECT s, j, JSON_ARRAYAGG(s) OVER w jarray_s, JSON_ARRAYAGG(j) OVER w jarray_j FROM t1 WINDOW w AS (ORDER BY j) ORDER BY j DESC
SELECT j, i, f, JSON_ARRAYAGG(i) OVER w jarray_i, JSON_ARRAYAGG(f) OVER w jarray_f FROM t1 WINDOW w AS (ORDER BY j DESC)
CREATE VIEW v AS SELECT i, j, JSON_ARRAYAGG(j) OVER (ORDER BY i DESC ROWS UNBOUNDED PRECEDING) jarray_j FROM t1
SELECT s, j, JSON_ARRAYAGG(s) OVER w jarray_s, JSON_ARRAYAGG(j) OVER w jarray_j FROM t1 GROUP BY s,j WINDOW w AS (ORDER BY j)
SELECT i, f, JSON_ARRAYAGG(i) OVER w jarray_i, JSON_ARRAYAGG(f) OVER w jarray_f FROM t1 GROUP BY i,f WITH ROLLUP HAVING GROUPING(f)=1 WINDOW w AS (ORDER BY f)
SELECT i, f, RANK() OVER w rank1, NTH_VALUE(i,3) OVER w nth, LEAD(f, 2) OVER w lead1, LAG(f,2) OVER w lag1, JSON_ARRAYAGG(i) OVER w jarray_i FROM t1 WINDOW w AS (ORDER BY f)
SELECT i, PERCENT_RANK() OVER (ORDER BY f) p_rank, JSON_ARRAYAGG(j) OVER (ORDER BY i,j ROWS UNBOUNDED PRECEDING) jarray_j FROM t1
SELECT i, f, MIN(i) OVER w min, JSON_ARRAYAGG(i) OVER w jarray_i FROM t1 WINDOW w AS (PARTITION BY f)
SELECT i, f, MAX(i) OVER w max, JSON_ARRAYAGG(i) OVER w jarray_i FROM t1 WINDOW w AS (PARTITION BY i ROWS UNBOUNDED PRECEDING)
SELECT i, j, f, RANK() OVER w rank1, JSON_ARRAYAGG(i) OVER w jarray_i FROM t1 WINDOW w AS (PARTITION BY i ORDER BY j ROWS BETWEEN 2 PRECEDING AND 1 PRECEDING)
SELECT i, j, f, CUME_DIST() OVER w c_dist, JSON_ARRAYAGG(i) OVER w jarray_i FROM t1 WINDOW w AS (PARTITION BY i ORDER BY j ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING)
SELECT i, f, PERCENT_RANK() OVER w p_rank, JSON_ARRAYAGG(i) OVER w jarray_i FROM t1 WINDOW w AS (PARTITION BY i ORDER BY f RANGE BETWEEN 2.1 FOLLOWING AND 4.5 FOLLOWING)
SELECT i, f, j, CUME_DIST() OVER w c_dist, JSON_ARRAYAGG(j) OVER w jarray_j FROM t1 WINDOW w AS (PARTITION BY i ORDER BY f RANGE BETWEEN 1 PRECEDING AND 10 FOLLOWING)
SELECT j, s, f, JSON_OBJECTAGG(j,f) OVER w jobject_f, JSON_OBJECTAGG(j,s) OVER w jobject_s FROM t1 WINDOW w AS (ORDER BY j)
SELECT i, JSON_OBJECTAGG(i,j) OVER() FROM t1
SELECT j, s, JSON_OBJECTAGG(j,s) OVER w jobject_s, JSON_OBJECTAGG(f,j) OVER w jobject_j FROM t1 WINDOW w AS (ORDER BY j) ORDER BY j DESC
SELECT j, i, JSON_OBJECTAGG(j,i) OVER w jobject_i, JSON_OBJECTAGG(j,f) OVER w jobject_f FROM t1 WINDOW w AS (ORDER BY j DESC)
SELECT i, j, JSON_OBJECTAGG(j,f) OVER w jobject_i, JSON_OBJECTAGG(j,s) OVER w jobject_f FROM t1 WINDOW w AS (PARTITION BY i ORDER BY j)
SELECT j, s, f, JSON_OBJECTAGG(j,s) OVER w jobject_s, JSON_OBJECTAGG(f,j) OVER w jobject_j FROM t1 WINDOW w AS (PARTITION BY i ORDER BY s)
SELECT i, JSON_OBJECTAGG(i,j) OVER(PARTITION BY i) FROM t1
CREATE VIEW v AS SELECT i, j, JSON_OBJECTAGG(i,j) OVER (ORDER BY i DESC ROWS UNBOUNDED PRECEDING) jobject_j FROM t1
SELECT j, s, JSON_OBJECTAGG(j, s) OVER w jobject_s FROM t1 GROUP BY j,s WINDOW w AS (ORDER BY j)
SELECT i, JSON_OBJECTAGG(i,f) OVER w jobject_f FROM t1 GROUP BY i,f WITH ROLLUP HAVING GROUPING(f)=1  WINDOW w AS (ORDER BY f)
SELECT i, j, f, JSON_OBJECTAGG(j,f) OVER w jobject_f, RANK() OVER w rank1 FROM t1 WINDOW w AS (PARTITION BY i ORDER BY i)
SELECT i, j, f, JSON_OBJECTAGG(i,j) OVER w jobject_i, RANK() OVER w rank1, NTH_VALUE(i,2) OVER w nth, LEAD(f, 1) OVER w lead1, LAG(f,1) OVER w lag1 FROM t1 WINDOW w AS (PARTITION BY i ORDER BY j)
SELECT i, f, PERCENT_RANK() OVER (ORDER BY f) p_rank, JSON_OBJECTAGG(i,j) OVER (ORDER BY i,j ROWS UNBOUNDED PRECEDING) jobject_j FROM t1
SELECT i, j, f, JSON_OBJECTAGG(i,j) OVER w jobject_i, MIN(i) OVER w min FROM t1 WINDOW w AS (PARTITION BY i)
SELECT i, j, f, JSON_OBJECTAGG(j,f) OVER w jobject_j, MAX(i) OVER w max FROM t1 WINDOW w AS (PARTITION BY f ROWS UNBOUNDED PRECEDING)
SELECT i, j, f, JSON_OBJECTAGG(j,f) OVER w jobject_j, RANK() OVER w rank1 FROM t1 WINDOW w AS (PARTITION BY f ORDER BY j ROWS BETWEEN 2 PRECEDING AND 1 PRECEDING)
SELECT i, j, f, JSON_OBJECTAGG(j,f) OVER w jobject_j, RANK() OVER w rank1 FROM t1 WINDOW w AS (PARTITION BY f ORDER BY j ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)
SELECT i, j, f, JSON_OBJECTAGG(j,f) OVER w jobject_j, CUME_DIST() OVER w c_dist FROM t1 WINDOW w AS (PARTITION BY i ORDER BY j ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING)
SELECT i, j, f, JSON_OBJECTAGG(f,j) OVER w jobject_i FROM t1 WINDOW w AS (PARTITION BY i ORDER BY f RANGE BETWEEN 2.1 FOLLOWING AND 4.5 FOLLOWING)
SELECT i, j, f, JSON_OBJECTAGG(j,f) OVER w jobject_j, CUME_DIST() OVER w c_dist FROM t1 WINDOW w AS (PARTITION BY i ORDER BY j,f ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING)
SELECT i, j, f, JSON_OBJECTAGG(i,j) OVER w jobject_i, MAX(i) OVER w max FROM t1 WINDOW w AS (PARTITION BY f ROWS UNBOUNDED PRECEDING)
SELECT i, j, f, JSON_OBJECTAGG(i,j) OVER w jobject_i, RANK() OVER w rank1 FROM t1 WINDOW w AS (PARTITION BY f ORDER BY j ROWS BETWEEN 2 PRECEDING AND 1 PRECEDING)
SELECT i, j, f, JSON_OBJECTAGG(i,j) OVER w jobject_i, RANK() OVER w rank1 FROM t1 WINDOW w AS (PARTITION BY f ORDER BY j ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)
SELECT i, j, f, JSON_OBJECTAGG(i,j) OVER w jobject_i FROM t1 WINDOW w AS (PARTITION BY i ORDER BY j ROWS BETWEEN 1 FOLLOWING AND 5 FOLLOWING)
SELECT i, j, f, JSON_OBJECTAGG(j,f) OVER w jobject_j FROM t1 WINDOW w AS (PARTITION BY i ROWS BETWEEN 1 FOLLOWING AND UNBOUNDED FOLLOWING)
SELECT i, j, f, JSON_OBJECTAGG(j,f) OVER w jobject_j FROM t1 WINDOW w AS (PARTITION BY i ROWS BETWEEN 2 PRECEDING AND 4 FOLLOWING)
SELECT i, j, f, JSON_OBJECTAGG(i,f) OVER w jobject_i FROM t1 WINDOW w AS (PARTITION BY i ORDER BY f RANGE BETWEEN 2.1 FOLLOWING AND 4.5 FOLLOWING)
SELECT 0 & (JSON_ARRAYAGG(1) OVER w) FROM (select 1) as dt  WINDOW w as ()
SELECT MAKETIME(((1)<=> (JSON_OBJECTAGG('1',1)OVER())),'1',1)
SELECT MAKETIME(((1)<=> (2*JSON_OBJECTAGG('1',1)OVER())),'1',1)
SELECT (1 + CAST(JSON_OBJECTAGG(1,2) OVER () AS DECIMAL))
SELECT JSON_OBJECTAGG(`key`, i) OVER w AS agg FROM t WINDOW w AS (ORDER BY `key` ROWS CURRENT ROW)
SELECT JSON_OBJECTAGG(`key`, i) OVER w AS agg FROM t WINDOW w AS (ORDER BY i ROWS CURRENT ROW)
SHOW GRANTS FOR "mysql.session"@localhost
SHOW GRANTS FOR "mysql.session"@localhost
SHOW GRANTS FOR u1
SHOW GRANTS FOR u2
SHOW GRANTS FOR u1
SHOW GRANTS FOR u2
SHOW GRANTS FOR root@localhost
SELECT * FROM json_table('[]', '$[*]' COLUMNS (p CHAR(1) CHARACTER SET utf8 PATH '$.a')) AS t
SELECT * FROM json_table('[]', '$[*]' COLUMNS (p CHAR(1) CHARACTER SET "utf8" PATH '$.a')) AS t
SELECT * FROM json_table('[]', '$[*]' COLUMNS (p CHAR(1) CHARACTER SET 'utf8' PATH '$.a')) AS t
SELECT * FROM json_table('[]', '$[*]' COLUMNS (p CHAR(1) CHARACTER SET `utf8` PATH '$.a')) AS t
SELECT * FROM json_table('[]', '$[*]' COLUMNS (p NATIONAL CHAR(1) PATH '$.a')) AS t
SELECT * FROM json_table('[]', '$[*]' COLUMNS (p NCHAR(1) PATH '$.a')) AS t
SELECT * FROM json_table('[]', '$[*]' COLUMNS (p NCHAR PATH '$.a')) AS t
SELECT * FROM json_table('[]', '$[*]' COLUMNS (p NVARCHAR(1) PATH '$.a')) AS t
create event Ð·Ð°Ð´Ð°Ñ‡ÐºÐ° on schedule every 123 minute starts now() ends now() + interval 1 month do select 1
drop event Ð·Ð°Ð´Ð°Ñ‡ÐºÐ°
create event Ð·Ð°ÐºÐ°Ñ‡ÐºÐ° on schedule every 10 hour do select get_lock("test_lock1", 20)
drop event Ð·Ð°ÐºÐ°Ñ‡ÐºÐ°
create event Ð·Ð°ÐºÐ°Ñ‡ÐºÐ° on schedule every 10 hour do select get_lock("test_lock2", 20)
where ( (state like 'User lock%' AND info like 'select get_lock%') OR (command='Daemon' AND user='event_scheduler' AND state = 'Waiting for next activation'))
drop event Ð·Ð°ÐºÐ°Ñ‡ÐºÐ°
where (state like 'User lock%' AND info like 'select get_lock%')
create event Ð·Ð°ÐºÐ°Ñ‡ÐºÐ°21 on schedule every 10 hour do select get_lock("test_lock2_1", 20)
where ( (state like 'User lock%' AND info like 'select get_lock%') OR (command='Daemon' AND user='event_scheduler' AND state = 'Waiting for next activation'))
where (info like "select get_lock%" OR user='event_scheduler')
drop event Ð·Ð°ÐºÐ°Ñ‡ÐºÐ°21
create trigger t_16_bi before insert on t_16 for each row create event  e_16 on schedule every 1 second do set @a=5
create trigger t1_ai after insert on t1 for each row show create event e1
SHOW EVENTS FROM ``
lock table t1 read
unlock tables
create function f1() returns int begin show create event e1; return 1; end
create trigger trg before insert on t1 for each row begin show create event e1; end
create trigger trg before insert on t1 for each row begin select event_name from information_schema.events; end|                                                                                                                                                    --error ER_EVENT_RECURSION_FORBIDDEN create function f1() returns int begin create event e2 on schedule every 10 hour do select 1; return 1; end
create function f1() returns int begin alter event e1 rename to e2; return 1; end
create function f1() returns int begin drop event e2; return 1; end
create procedure p1() begin alter event e1 rename to e2; end
create procedure p1() begin drop event e1; end
create event Ð¸Ð¼Ñ_ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_48 on schedule every 2 year do select 1
drop event Ð¸Ð¼Ñ_ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ_Ð²_ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²ÐºÐµ_ÑƒÑ‚Ñ„8_Ð´Ð»Ð¸Ð½Ð¾Ð¹_Ð±Ð¾Ð»ÑŒÑˆÐµ_Ñ‡ÐµÐ¼_48
create event Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_66 on schedule every 2 year do select 1
echo The following SELECTs should all give 1
select (NOT FALSE) OR TRUE, NOT (FALSE OR TRUE), NOT FALSE OR TRUE
select (NOT FALSE) XOR FALSE, NOT (FALSE XOR FALSE), NOT FALSE XOR FALSE
select (NOT FALSE) AND FALSE, NOT (FALSE AND FALSE), NOT FALSE AND FALSE
select NOT NOT TRUE, NOT NOT NOT FALSE
select (NOT NULL) IS TRUE, NOT (NULL IS TRUE), NOT NULL IS TRUE
select (NOT NULL) IS NOT TRUE, NOT (NULL IS NOT TRUE), NOT NULL IS NOT TRUE
select (NOT NULL) IS FALSE, NOT (NULL IS FALSE), NOT NULL IS FALSE
select (NOT NULL) IS NOT FALSE, NOT (NULL IS NOT FALSE), NOT NULL IS NOT FALSE
select (NOT TRUE) IS UNKNOWN, NOT (TRUE IS UNKNOWN), NOT TRUE IS UNKNOWN
select (NOT TRUE) IS NOT UNKNOWN, NOT (TRUE IS NOT UNKNOWN), NOT TRUE IS NOT UNKNOWN
select (NOT TRUE) IS NULL, NOT (TRUE IS NULL), NOT TRUE IS NULL
select (NOT TRUE) IS NOT NULL, NOT (TRUE IS NOT NULL), NOT TRUE IS NOT NULL
WHERE state= 'Waiting for stored function metadata lock' AND info='SHOW OPEN TABLES WHERE f1()=0'
LOCK TABLES t0 WRITE, t1 WRITE
UNLOCK TABLES
WHERE info LIKE 'DROP FUNCTION mixedcase' AND state='Waiting for stored function metadata lock'
source include/wait_condition.inc
WHERE info LIKE 'SHOW CREATE FUNCTION%' AND state='Waiting for stored function metadata lock'
source include/wait_condition.inc
WHERE info LIKE 'ALTER FUNCTION mixedcase%' AND state='Waiting for stored function metadata lock'
source include/wait_condition.inc
WHERE info LIKE 'SHOW CREATE PROCEDURE%' AND state='Waiting for stored procedure metadata lock'
source include/wait_condition.inc
WHERE info LIKE 'ALTER PROCEDURE mixedcase%' AND state='Waiting for stored procedure metadata lock'
source include/wait_condition.inc
DISCONNECT con1
DISCONNECT con2
create table t1 (a int) partition by range (a) ( partition p0 values less than (NULL), partition p1 values less than (MAXVALUE))
create table t1 (a int) partition by range (a) ( partition p0 values less than (maxvalue))
LOCK TABLES t1 WRITE
UNLOCK TABLES
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by range (a) subpartition by hash (a+b) ( partition x1 values less than (1) ( subpartition x11 engine innodb nodegroup 0, subpartition x12 engine innodb nodegroup 1), partition x2 values less than (5) ( subpartition x21 engine innodb nodegroup 0, subpartition x22 engine innodb nodegroup 1) )
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by range (a) subpartition by hash (a+b) ( partition x1 values less than (1) ( subpartition x11 nodegroup 0, subpartition x12 nodegroup 1), partition x2 values less than (5) ( subpartition x21 nodegroup 0, subpartition x22 nodegroup 1) )
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by range (a) subpartition by hash (a+b) ( partition x1 values less than (1) ( subpartition x11 engine innodb nodegroup 0, subpartition x12 engine innodb nodegroup 1), partition x2 values less than (5) ( subpartition x21 engine innodb nodegroup 0, subpartition x22 engine innodb nodegroup 1) )
ALTER TABLE t1 partition by range (a) subpartition by hash (a+b) ( partition x1 values less than (1) ( subpartition x11 engine innodb nodegroup 0, subpartition x12 engine innodb nodegroup 1), partition x2 values less than (5) ( subpartition x21 engine innodb nodegroup 0, subpartition x22 engine innodb nodegroup 1) )
DEALLOCATE PREPARE s1
DEALLOCATE PREPARE s2
DEALLOCATE PREPARE s3
DEALLOCATE PREPARE s4
DEALLOCATE PREPARE s5
DEALLOCATE PREPARE s6
DEALLOCATE PREPARE s1
DEALLOCATE PREPARE s2
DEALLOCATE PREPARE s3
DEALLOCATE PREPARE s4
DEALLOCATE PREPARE s5
DEALLOCATE PREPARE s6
DEALLOCATE PREPARE s1
DEALLOCATE PREPARE s2
DEALLOCATE PREPARE s3
DEALLOCATE PREPARE s4
DEALLOCATE PREPARE s5
DEALLOCATE PREPARE s6
DEALLOCATE PREPARE s1
DEALLOCATE PREPARE s2
DEALLOCATE PREPARE s3
DEALLOCATE PREPARE s4
DEALLOCATE PREPARE s5
DEALLOCATE PREPARE s6
execute s1 using @iv
execute s1 using @sv
DEALLOCATE PREPARE s1
DEALLOCATE PREPARE s2
DEALLOCATE PREPARE s3
DEALLOCATE PREPARE s4
DEALLOCATE PREPARE s5
DEALLOCATE PREPARE s6
DEALLOCATE PREPARE s1
DEALLOCATE PREPARE s2
DEALLOCATE PREPARE s3
DEALLOCATE PREPARE s4
DEALLOCATE PREPARE s5
DEALLOCATE PREPARE s6
DEALLOCATE PREPARE s1
DEALLOCATE PREPARE s2
DEALLOCATE PREPARE s3
DEALLOCATE PREPARE s4
DEALLOCATE PREPARE s5
DEALLOCATE PREPARE s6
create function f1() returns int begin declare j int; select i from t1 where i = 1 into j; return j; end
create function f2() returns int begin declare k int; select i from t1 where i = 1 into k; insert into t2 values (k + 5); return 0; end
create function f6() returns int begin declare k int; select i from v1 where i = 1 into k; return k; end
create function f7() returns int begin declare k int; select j from v2 where j = 1 into k; return k; end
create function f8() returns int begin declare k int; select i from v1 where i = 1 into k; insert into t2 values (k+5); return k; end
create function f11() returns int begin declare k int; set k= f1(); insert into t2 values (k+5); return k; end
create procedure p2(inout p int) begin select i from t1 where i = 1 into p; end
create function f14() returns int begin declare k int; call p2(k); insert into t2 values (k+5); return k; end
create function f15() returns int begin declare k int; call p2(k); return k; end
create function f17() returns int begin declare j int; select i from t1 where i = 1 into j; call p3; return 1; end
create trigger t4_bi before insert on t4 for each row begin declare k int; select i from t1 where i=1 into k; set new.l= k+1; end
create trigger t5_bu before update on t5 for each row begin declare j int; call p2(j); set new.l= j + 1; end
lock table t1 write
unlock tables
lock table t1 write
unlock tables
call mtr.add_suppression("Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT")
WHERE state= 'Waiting for table flush' AND info= 'FLUSH TABLES'
UNLOCK TABLES
delimiter
create procedure solver(initial_leftm varchar(200), initial_rightm varchar(200)) begin declare initial_leftm_j  json; declare initial_rightm_j json; set initial_leftm_j  = cast(initial_leftm as json), initial_rightm_j = cast(initial_rightm as json); with recursive number_of_lines (value) as (select json_length(initial_rightm_j)), number_of_columns (value) as (select json_length(json_extract(initial_leftm_j,"$[0]"))), line_numbers (n) as ( select 0 union all select n+1 from line_numbers, number_of_lines where n<(value-1) ), column_numbers (n) as ( select 0 union all select n+1 from line_numbers, number_of_columns where n<(value-1) ), equations (null_if_done, leftm, rightm, pivot_lines, pivot_columns) as ( select 0, initial_leftm_j, initial_rightm_j, cast("" as char(200)), cast("" as char(200)) union all select cur_pivot.cur_pivot_line , ( select "[" || group_concat( ( select "[" || group_concat( json_extract(json_extract(eq.leftm, "$[" || ln.n || "]"), "$[" || cn.n || "]") - (case when find_in_set(ln.n,eq.pivot_lines)=0 and ln.n<>cur_pivot.cur_pivot_line then json_extract(json_extract(eq.leftm, "$[" || ln.n || "]"), "$[" || cur_pivot.cur_pivot_column || "]") * json_extract(json_extract(eq.leftm, "$[" || cur_pivot.cur_pivot_line || "]"), "$[" || cn.n || "]") / cur_pivot.cur_pivot_value else 0 end) order by cn.n separator ',') || "]" from column_numbers cn ) order by ln.n separator ',') || "]" from line_numbers ln ), ( select "[" || group_concat( json_extract(eq.rightm, "$[" || ln.n || "]") - (case when find_in_set(ln.n,eq.pivot_lines)=0 and ln.n<>cur_pivot.cur_pivot_line then json_extract(json_extract(eq.leftm, "$[" || ln.n || "]"), "$[" || cur_pivot.cur_pivot_column || "]") * json_extract(eq.rightm, "$[" || cur_pivot.cur_pivot_line || "]") / cur_pivot.cur_pivot_value else 0 end) order by ln.n separator ',') || "]" from line_numbers ln ), coalesce(cur_pivot.cur_pivot_line, "") || "," || eq.pivot_lines, coalesce(cur_pivot.cur_pivot_column, "") || "," || eq.pivot_columns from equations eq left join lateral ( select ln.n as cur_pivot_line, cn.n as cur_pivot_column, ( json_extract(json_extract(eq.leftm, "$[" || ln.n || "]"), "$[" || cn.n || "]") ) as cur_pivot_value from line_numbers ln join column_numbers cn where find_in_set(ln.n,eq.pivot_lines)=0 and json_extract(json_extract(eq.leftm, "$[" || ln.n || "]"), "$[" || cn.n || "]") <> 0 order by cur_pivot_line,cur_pivot_column limit 1 ) as cur_pivot on 1 where eq.null_if_done is not null ), final_equations as ( select * from equations where null_if_done is null ) select json_extract(eq.leftm, "$[" || ln.n || "]")  as left_member, json_extract(eq.rightm, "$[" || ln.n || "]") as right_member, free.value as list_of_free_unknowns from final_equations eq, line_numbers ln, ( select group_concat(cn.n+1) as value from final_equations eq, column_numbers cn where find_in_set(cn.n,eq.pivot_columns)=0 ) as free order by find_in_set(ln.n,eq.pivot_lines), ln.n; end
CALL mtr.add_suppression("Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT")
rename table t3 to t4
FLUSH TABLE t1
FLUSH TABLE t1
copy_file std_data/bug46565.ARZ $MYSQLD_DATADIR/test/t1.ARZ
CALL mtr.add_suppression("Found wrong key definition in #sql.* Please do \"ALTER TABLE `#sql.*` FORCE \" to fix it!")
FLUSH TABLE t1
FLUSH TABLE t1
PREPARE stmt1 FROM "INSERT INTO t1( a ) VALUES ( ? )"
EXECUTE stmt1 USING @a
LOCK INSTANCE FOR BACKUP
CREATE TABLESPACE testtablespace ADD DATAFILE 'ts.ibd' ENGINE=InnoDB
CREATE TRIGGER testtrigger_1 BEFORE INSERT ON testtable_1 FOR EACH ROW SET @a:=1
UNLOCK INSTANCE
CREATE TABLESPACE testtablespace ADD DATAFILE 'ts.ibd' ENGINE=InnoDB
CREATE TRIGGER testtrigger_1 BEFORE INSERT ON testtable_1 FOR EACH ROW SET @a:=1
LOCK INSTANCE FOR BACKUP
LOCK INSTANCE FOR BACKUP
UNLOCK INSTANCE
UNLOCK INSTANCE
LOCK INSTANCE FOR BACKUP
CALL mtr.add_suppression("Failed to set up SSL because of the following *")
CALL mtr.add_suppression("One can only use the --user switch.*")
[mysqld] innodb_fast_shutdown=1 innodb_default_row_format=REDUNDANT sql_mode=REAL_AS_FLOAT innodb_flush_log_at_trx_commit=2 max_digest_length=2024 SELECT @@global.innodb_fast_shutdown
GRANT PROXY ON 'internal_proxied'@'%' TO 'external_u1'@'%','external_u2'@'%'
[mysqld] sort_buffer_size=314156 [mysqld] innodb_fast_shutdown=1 innodb_default_row_format=REDUNDANT innodb_flush_log_at_trx_commit=2 SELECT VARIABLE_NAME, VARIABLE_SOURCE FROM performance_schema.variables_info WHERE VARIABLE_NAME IN ('sort_buffer_size', 'max_connections', 'max_digest_length', 'innodb_fast_shutdown', 'innodb_default_row_format', 'innodb_flush_log_at_trx_commit')
[mysqld] innodb_fast_shutdown=1 { "mysql_server": { "event_scheduler": OFF , "mysql_server_static_options": {"binlog_gtid_simple_recovery": "0" , "ft_query_expansion_limit": "200" } } } { "mysql_server": { "event_scheduler": "OFF" , "mysql_server_static_options": {"binlog_gtid_simple_recovery": 0 , "ft_query_expansion_limit": "200" } } } { "mysql_server": { "event_scheduler": OFF , "mysql_server_static_options": {"binlog_gtid_simple_recovery": "0"  "ft_query_expansion_limit": "200" } } } { "mysql_server": { "event_scheduler": OFF , "mysql_xxxx_static_options": {"binlog_gtid_simple_recovery": "0" , "ft_query_expansion_limit": "200" } } } { "xxxx_server": { "event_scheduler": OFF , "mysql_server_static_options": {"binlog_gtid_simple_recovery": "0" , "ft_query_expansion_limit": "200" } } } set @a=repeat('A',2000)
set @b=repeat('A',24000)
RENAME TABLE mysql.procs_priv TO mysql.procs_priv_backup
FLUSH TABLE mysql.procs_priv
RENAME TABLE mysql.procs_priv_backup TO mysql.procs_priv
FLUSH TABLE mysql.procs_priv
ALTER USER u1 COMMENT 'free form text'
ALTER USER u1 COMMENT 'changed the free form text'
ALTER USER u1 ATTRIBUTE '{"uid" : "34234"}'
ALTER USER u1 ATTRIBUTE '{"speed" : "9000"}'
ALTER USER u1 ATTRIBUTE '{"speed" : null }'
ALTER USER foo@localhost COMMENT 'password lock time'
ALTER USER foo@localhost ATTRIBUTE '{"flag":"red"}'
ALTER USER foo@localhost ATTRIBUTE '{"flag":null}'
ALTER USER foo@localhost COMMENT 'zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz'
ALTER USER foo@localhost COMMENT 'xxx'
ALTER USER foo@localhost ATTRIBUTE 'not a valid object'
ALTER USER u4@sdasd ATTRIBUTE '{}'
ALTER USER fff@asdasd COMMENT ''
CREATE USER foo2@localhost IDENTIFIED BY 'foo' COMMENT 'xxx'
CREATE USER foo3 PASSWORD EXPIRE DEFAULT COMMENT 'abc'
CREATE USER foo4 ACCOUNT LOCK ATTRIBUTE '{"stuff":"ffuts"}'
ALTER USER foo4 ACCOUNT UNLOCK ATTRIBUTE '{"stuff":"unlocked"}'
ALTER USER foo@localhost ATTRIBUTE '{"key":"value"}'
ALTER USER foo@localhost COMMENT 'Added key/value pair'
ALTER USER redqueen@localhost DISCARD OLD PASSWORD COMMENT 'Dropped old password'
CREATE USER u1 COMMENT 'Hello "Smith"'
CREATE USER u1 COMMENT 'Hello "Smith"'
CREATE USER u1@localhost IDENTIFIED BY 'foo' COMMENT 'Not permitted to change this'
ALTER USER u1@localhost COMMENT 'I comment what I want'
ALTER USER u1@localhost ATTRIBUTE '{"key": "value"}'
CREATE USER u1@localhost IDENTIFIED BY 'foo',u2@localhost IDENTIFIED BY 'foo' COMMENT "Works with partial restrictions"
ALTER USER CURRENT_USER() COMMENT 'test'
ALTER USER CURRENT_USER() ATTRIBUTE '{ "comment" : null }'
SHOW GRANTS FOR u1@localhost
ALTER USER u1@localhost ATTRIBUTE '{"Restrictions": [{"Database":"mysql","Privileges": [ "CREATE" ]}]}'
SHOW GRANTS FOR u1@localhost
CREATE USER u1@localhost ATTRIBUTE "this is a string"
echo "WL6369 Explain for Connection"
show grants for second_user@localhost
show grants for second_user@localhost
prepare s_t9 from 'select c1 as my_col from t9 where c1= 1'
execute s_t9
show grants for second_user@localhost
show grants for second_user@localhost
show grants for second_user@localhost
prepare s_t1 from 'select a as my_col from t1'
execute s_t1
execute s_t9
deallocate prepare s_t9
show grants for second_user@localhost
show grants for second_user@localhost
execute s_t1
show grants for second_user@localhost
show grants for second_user@localhost
prepare stmt3 from ' grant all on test.t1 to drop_user@localhost '
prepare stmt3 from ' revoke all privileges on test.t1 from drop_user@localhost '
prepare stmt3 from ' drop user drop_user@localhost '
PREPARE stmt FROM 'INSERT INTO t1 VALUES (1)'
EXECUTE stmt
GET DIAGNOSTICS CONDITION 1 @varErrorMessage = message_text, @varErrorNo = mysql_errno
EXECUTE stmt
GET DIAGNOSTICS CONDITION 1 @varErrorMessage = message_text, @varErrorNo = mysql_errno
DROP PREPARE stmt
(SELECT * FROM mysql.tables WHERE schema_id IN (SELECT id FROM mysql.schemata WHERE name='mysql')) AS tables1 LEFT JOIN mysql.tablespaces ON tables1.tablespace_id = tablespaces.id WHERE tables1.name NOT IN ('ndb_binlog_index') ORDER BY tables1.name
tablespace_id IN (SELECT id FROM mysql.tablespaces WHERE name='mysql') AND name NOT IN ('ndb_binlog_index') ORDER BY name ASC
call mtr.add_suppression("Resizing redo log from")
call mtr.add_suppression("Upgrading redo log")
call mtr.add_suppression("Starting to delete and rewrite log files")
call mtr.add_suppression("New log files created")
call mtr.add_suppression("You need to use --log-bin to make --binlog-format work")
call mtr.add_suppression("Creating routine without parsing routine body")
call mtr.add_suppression("Storage engine '.*' does not support system tables. \\[mysql.*\\]")
call mtr.add_suppression("Table 'mysql.component' doesn't exist")
call mtr.add_suppression("is expected to be transactional")
call mtr.add_suppression("table is missing or has an incorrect definition")
call mtr.add_suppression("ACL DDLs will not work unless mysql_upgrade is executed")
call mtr.add_suppression(".* Native table .* has the wrong structure")
call mtr.add_suppression("Column count of mysql.* is wrong")
call mtr.add_suppression("The privilege system failed to initialize correctly.*")
call mtr.add_suppression(".*The system table mysql.global_grants is missing.*")
call mtr.add_suppression("ACL table mysql.[a-z_]* missing. Some operations may fail.")
call mtr.add_suppression("Info table is not ready to be used. Table 'mysql.slave_master_info' cannot be opened")
call mtr.add_suppression("Error in checking mysql.slave_master_info repository info type of TABLE")
call mtr.add_suppression("Error creating master info: Error checking repositories.")
call mtr.add_suppression("Slave: Failed to initialize the master info structure for channel")
call mtr.add_suppression("Failed to create or recover replication info repositories.")
call mtr.add_suppression("Plugin mysqlx reported: 'Unable to use user mysql.session")
call mtr.add_suppression("Plugin mysqlx reported: 'Unable to switch context")
(SELECT * FROM mysql.tables WHERE schema_id IN (SELECT id FROM mysql.schemata WHERE name='mysql')) AS tables1 LEFT JOIN mysql.tablespaces ON tables1.tablespace_id = tablespaces.id WHERE tables1.name NOT IN ('ndb_binlog_index') ORDER BY tables1.name
tablespace_id IN (SELECT id FROM mysql.tablespaces WHERE name='mysql') AND name NOT IN ('ndb_binlog_index') ORDER BY name ASC
ALTER USER pwd_history_plugin@localhost IDENTIFIED WITH 'test_plugin_server' PASSWORD REUSE INTERVAL 1 DAY
ALTER USER mohit@localhost IDENTIFIED WITH 'test_plugin_server' AS 'haha'
PREPARE q FROM 'EXPLAIN FORMAT=tree SELECT * FROM t1 WHERE pk = ?'
EXECUTE q USING @v
engine=myisam data directory="$MYSQLTEST_VARDIR/tmp" index directory="$MYSQLTEST_VARDIR/run"
rename table t7 to t9
engine=myisam index directory="$MYSQLTEST_VARDIR/run"
engine=myisam data directory="$MYSQLTEST_VARDIR/tmp"
DATA DIRECTORY='$MYSQLTEST_VARDIR/tmp' INDEX DIRECTORY='$MYSQLTEST_VARDIR/tmp'
DATA DIRECTORY='$MYSQLTEST_VARDIR/tmp' INDEX DIRECTORY='$MYSQLTEST_VARDIR/tmp'
RENAME TABLE t2 TO t1
INDEX DIRECTORY='$MYSQLD_DATADIR/mysql'
DATA DIRECTORY='$MYSQLD_DATADIR/test'
DATA DIRECTORY='$MYSQLD_DATADIR/'
INDEX DIRECTORY='$MYSQLD_DATADIR'
INDEX DIRECTORY='$MYSQLTEST_VARDIR/master-data_var'
INDEX DIRECTORY='$MYSQL_TMP_DIR/mysql'
FLUSH TABLE t1
FLUSH TABLE schema1.t1
FLUSH TABLE schema1.t1
data directory="$MYSQLTEST_VARDIR/tmp" index directory="$MYSQLTEST_VARDIR/run"
DATA DIRECTORY "$MYSQLTEST_VARDIR/tmp"
SET @sav_big= (SELECT COALESCE(@session.big_tables, 0))
WHERE USER != 'event_scheduler'`
FLUSH TABLE t1
FLUSH TABLE mysql_db1.t1
FLUSH TABLE t1
FLUSH TABLE t1
FLUSH TABLE t1
FLUSH TABLE t1
FLUSH TABLE t1
write_file $BOOTSTRAP_SQL
perl
my $log= $ENV{'MYSQLD_LOG'} or die
open(FILE, "$log") or die
my $c_e= grep(/\[Warning\] \[[^]]*\] \[[^]]*\] Can\'t open and lock time zone table/gi,<FILE>)
print "#     Time zone table warning found $c_e times.\n"
close(FILE)
remove_file $BOOTSTRAP_SQL
remove_file $MYSQLD_LOG
remove_file $DDIR/mysql.ibd
perl
my $log= $ENV{'MYSQLD_LOG'} or die
open(FILE, "$log") or die
my $c_e= grep(/Failed to find valid data directory./gi,<FILE>)
print "#     DD initialization error found $c_e times.\n"
close(FILE)
remove_file $MYSQLD_LOG
perl
my $log= $ENV{'MYSQLD_LOG'} or die
open(FILE, "$log") or die
my $c_e= grep(/\[ERROR\] \[[^]]*\] \[[^]]*\] failed to set datadir/gi,<FILE>)
print "#     Datadir error found $c_e times.\n"
close(FILE)
remove_file $MYSQLD_LOG
perl
my $log= $ENV{'MYSQLD_LOG'} or die
open(FILE, "$log") or die
my $c_e= grep(/Failed to find valid data directory/gi,<FILE>)
print "#     DD initialization error found $c_e times.\n"
close(FILE)
remove_file $MYSQLD_LOG
perl
my $log= $ENV{'MYSQLD_LOG'} or die
open(FILE, "$log") or die
my $c_e= grep(/Failed to find valid data directory/gi,<FILE>)
print "#     DD initialization error found $c_e times.\n"
close(FILE)
remove_file $MYSQLD_LOG
SET @old_sql_mode := @@sql_mode
create function func1(x int) returns int deterministic begin declare z1, z2 int; set z1 = x; set z2 = z1+2; return z2; end
explain format=json select distinct concat(c1, repeat('xx', 250)) as cc from t2
select distinct concat(c1, repeat('xx', 250)) as cc from t2 order by 1
explain format=json select concat(c1, repeat('xx', 250)) as cc from t2 group by cc
select concat(c1, repeat('xx', 250)) as cc from t2 group by cc order by 1
explain format=json select count(distinct concat(c1, repeat('xx', 250))) as cc from t2
select count(distinct concat(c1, repeat('xx', 250))) as cc from t2 order by 1
INSERT INTO N VALUES (1,3,repeat('a',1000)),(0,4,'tell'),(7,6,'o'),(6,7,'g'),(8,8,'can'), (9,15,repeat('a',1020)),(4,16,repeat('a',1020)),(6,18,'his'),(NULL,19,'going'), (7,22,'mean'),(8,23,'here')
SELECT alias2 . `col_int_nokey` AS field1 FROM ( CC AS alias1 INNER JOIN ( ( BB AS alias2 INNER JOIN (  SELECT   SQ1_alias1 . * FROM C AS SQ1_alias1  ) AS alias3 ON (alias3 . `col_int_key` = alias2 . `col_int_nokey`  ) ) ) ON (alias3 . `col_varchar_nokey` = alias2 . `col_varchar_key`  ) ) WHERE (  ( alias2 . `pk` , alias3 . `col_int_nokey` ) IN ( SELECT 4 , 7  UNION  SELECT 137, 6 ) ) AND alias1 . `pk` > 149 AND alias1 . `pk` < ( 149 + 7 ) OR alias3 . `col_varchar_key` < 'o'
INSERT INTO t2 VALUES ('MFDLE',1,'no',1358168064), ('v',2,'really',154664960), (repeat('mcrxjxxfpo',100),3,repeat('mcrxjxxfpo',100),1), ('o',4,'CEJHM',3), ('j',5,'CRDLM',174915584), ('m',6,'that\'s',7), ('YVMBM',7,'is',4), ('h',8,'as',8), ('y',9,'not',686096384), ('m',10,repeat('mcrxjxxfpo',100),8), (repeat('mcrxjxxfpo',100),11,'v',2), ('and', 12,'b',6), ('from',13,'OJSUT',9), ('you',14,repeat('mcrxjxxfpo',100),1), ('mr',15,'ZMJFI',9), ('TYZOE',16,'I\'ll',-363069440), ('HLKEJ',17,'v',-767492096), ('OINER',18,repeat('mcrxjxxfpo',100),-102170624), (repeat('mcrxjxxfpo',100),19,'i',7), ('one',20,'CPIUQ',469303296), (repeat('mcrxjxxfpo',100),21,'IGLXO',1140391936), ('ERRUY',22,'WKQHJ',1), ('q',23,repeat('mcrxjxxfpo',100),1694564352), ('CYGKG',24,'o',7), ('BIWWF',25,'good',-1532035072)
mkdir $test_dir
mkdir $wrong_test_dir
1,a 2,b 1,a 2,b 1,a 2,b CREATE TABLE test.wl13168(id INT PRIMARY KEY, data VARCHAR(50))
remove_file $MYSQLTEST_VARDIR/tmp/wl13168_log.txt
remove_file $MYSQLTEST_VARDIR/tmp/wl13168_log.txt
remove_file $MYSQLTEST_VARDIR/tmp/wl13168_log.txt
force-rmdir $test_dir
force-rmdir $wrong_test_dir
reap
UNLOCK TABLES
CONNECT (con1, localhost, root)
CONNECT (con2, localhost, root)
WHERE info LIKE 'DROP TRIGGER%' AND state LIKE 'Waiting for % metadata lock'
source include/wait_condition.inc
WHERE info LIKE 'SHOW CREATE TRIGGER%' AND state LIKE 'Waiting for % metadata lock'
source include/wait_condition.inc
DISCONNECT con1
DISCONNECT con2
call mtr.add_suppression(".* Failed to activate default role .*")
GRANT sys_role TO peter@clickhost.net
GRANT role1 TO peter@clickhost.net
GRANT wp_administrators TO joe@localhost WITH ADMIN OPTION
SHOW GRANTS FOR current_user() USING `engineering`@`%`,`role`@`%`
SHOW GRANTS FOR `wp_administrators`
SHOW GRANTS FOR `joe`@`localhost`
SHOW GRANTS FOR `joe`@`localhost` USING wp_administrators
SHOW GRANTS FOR `joe`@`localhost` USING role1
SHOW GRANTS FOR `joe`@`localhost` USING engineering
SHOW GRANTS FOR `joe`@`localhost`
GRANT consultants TO engineering WITH ADMIN OPTION
SHOW GRANTS FOR `joe`@`localhost` USING engineering
SHOW GRANTS FOR sally USING engineering, consultants
SHOW GRANTS FOR sally USING engineering, consultants
SHOW GRANTS FOR sally USING consultants
SHOW GRANTS FOR sally USING engineering
SHOW GRANTS FOR sally USING consultants
SHOW GRANTS FOR sally USING engineering
GRANT consultants TO engineering WITH ADMIN OPTION
GRANT consultants TO sally WITH ADMIN OPTION
SHOW GRANTS FOR sally USING engineering
SHOW GRANTS FOR current_user() USING `replication`
SHOW GRANTS FOR `joe`@`localhost` USING `replication`
SHOW GRANTS FOR `root`@`localhost` USING `replication`
SHOW GRANTS FOR 'joe_schema_designer'@'localhost' USING 'schema_designer'
SHOW GRANTS FOR 'joe_schema_designer'@'localhost' USING 'db_admin'
SHOW GRANTS FOR CURRENT_USER() USING `db_admin`
CALL db1.sp1()
CALL test.sp1()
SHOW GRANTS FOR CURRENT_USER() USING db_admin
CALL db1.sp1()
CALL test.sp1()
CALL db1.sp2()
SHOW GRANTS FOR u1@`%`
SHOW GRANTS FOR u1@`%` USING r1
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR u1@localhost USING u1234567890123456789012345678901
DISCONNECT con_base
DISCONNECT con_admin1
DISCONNECT con_admin2
CONNECTION default
LOCK TABLE t1 write
UNLOCK TABLES
CREATE TRIGGER tr1 AFTER DELETE ON t1 FOR EACH ROW BEGIN INSERT INTO t1 SELECT * FROM t1 AS A
END | DELETE IGNORE FROM t1
PREPARE stm FROM 'CALL p1()'
EXECUTE stm
DEALLOCATE PREPARE stm
PREPARE s FROM 'DELETE t1 FROM t1, (SELECT 1 FROM DUAL) AS dt'
EXECUTE s
EXECUTE s
DEALLOCATE PREPARE s
call mtr.add_suppression("Could not use")
create user test@127.0.0.1 identified by "gambling"
grant ALL on *.* to test@127.0.0.1
drop user test@127.0.0.1
set @id := 1
ALTER USER b22551523@localhost IDENTIFIED with 'test_plugin_server'
ALTER USER b22551523@localhost IDENTIFIED with 'mysql_native_password'
CALL mtr.add_suppression("option 'log_error_verbosity'")
CALL mtr.add_suppression("--verbose is for use with")
CREATE TABLE t1 (d ENUM("YES","NO")) PARTITION BY RANGE COLUMNS(d) (PARTITION p0 VALUES LESS THAN ("NO"), PARTITION p1 VALUES LESS THAN (MAXVALUE))
CREATE TABLE t1 (d SET("Car","MC")) PARTITION BY RANGE COLUMNS(d) (PARTITION p0 VALUES LESS THAN ("MC"), PARTITION p1 VALUES LESS THAN (MAXVALUE))
create table t1 (a int, b int) partition by range columns (a,b) ( partition p0 values less than (maxvalue, 10), partition p1 values less than (maxvalue, maxvalue))
create table t1 (a int, b int, c int) partition by range columns (a,b,c) ( partition p0 values less than (1, maxvalue, 10), partition p1 values less than (1, maxvalue, maxvalue))
create table t1 (a int, b char(10), c varchar(25), d datetime) partition by range columns(a,b,c,d) subpartition by hash (to_seconds(d)) subpartitions 4 ( partition p0 values less than (1, 0, MAXVALUE, '1900-01-01'), partition p1 values less than (1, 'a', MAXVALUE, '1999-01-01'), partition p2 values less than (1, 'a', MAXVALUE, MAXVALUE), partition p3 values less than (1, MAXVALUE, MAXVALUE, MAXVALUE))
create table t1 (a int, b char(10), c varchar(25), d datetime) partition by range columns(a,b,c,d) subpartition by hash (to_seconds(d)) subpartitions 4 ( partition p0 values less than (1, '0', MAXVALUE, '1900-01-01'), partition p1 values less than (1, 'a', MAXVALUE, '1999-01-01'), partition p2 values less than (1, 'b', MAXVALUE, MAXVALUE), partition p3 values less than (1, MAXVALUE, MAXVALUE, MAXVALUE))
create table t1 (a int, b int) partition by range columns (a,b) (partition p0 values less than (NULL, maxvalue))
create table t1 (a int, b int) partition by list columns(a,b) ( partition p0 values in ((maxvalue, 0)))
alter table t1 add partition (partition p1 values in (maxvalue, maxvalue))
create table t1 (a int) partition by list columns(a) ( partition p0 values in (2, 1), create table t1 (a int) partition by list columns(a) ( partition p0 values in (2, 1), partition p1 values in (4, NULL, 3))
create table t1 (a int, b int) partition by range columns(a,b) (partition p0 values less than (maxvalue, 10))
create table t1 (a int, b int) partition by list columns(a,b) create table t1 (a int, b int) partition by range columns(a,b) (partition p0 values less than (maxvalue,maxvalue))
create table t1 (a int, b int) partition by range columns(a,b) (partition p0 values less than (1, 0), partition p1 values less than (2, maxvalue), partition p2 values less than (3, 3), partition p3 values less than (10, maxvalue))
CREATE PROCEDURE a(x INT) BEGIN DECLARE rnd INT; DECLARE cnt INT; WHILE x > 0 DO SET rnd= x % 100; SET cnt = (SELECT COUNT(*) FROM t1 WHERE a = rnd); INSERT INTO t1(a,b) VALUES (rnd, CAST(cnt AS CHAR)); SET x= x - 1; END WHILE; END
SELECT TRACE RLIKE 'have_both_agg_distinct_and_min_max' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
SELECT TRACE RLIKE 'have_both_agg_distinct_and_min_max' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
SELECT TRACE RLIKE 'have_both_agg_distinct_and_min_max' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
SELECT TRACE RLIKE 'have_both_agg_distinct_and_min_max' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
SELECT TRACE RLIKE 'have_both_agg_distinct_and_min_max' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
GROUP BY a
AND out1.pk<>3 AND out1.nk = (SELECT MAX(out1.k) FROM t1)
AND out1.pk = (SELECT MAX(out1.k) FROM t1)
AND out1.pk = (SELECT MAX(k) FROM t1)
AND out1.pk = (SELECT 2*MIN(k) FROM t1)
AND out1.pk = (SELECT SUM(k) - COUNT(k) FROM t1)
AND out1.pk = (SELECT MIN(out1.k + k) - 1 FROM t1)
AND out1.pk = (SELECT out1.k + MIN(k) - 1 FROM t1)
AND out1.pk = (SELECT MIN(out1.k) + MIN(k) - 1 FROM t1)
AND out1.pk = (SELECT SUM(out1.k) / COUNT(k) FROM t1)
AND out1.pk = (SELECT SUM(out1.k) / COUNT(*) FROM t1)
AND out1.pk = (SELECT AVG(out1.k) FROM t1)
SELECT TRACE RLIKE 'disjuntive_predicate_present' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
SELECT TRACE RLIKE 'disjuntive_predicate_present' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
SELECT TRACE RLIKE 'minmax_keypart_in_disjunctive_query' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
SELECT TRACE RLIKE 'minmax_keypart_in_disjunctive_query' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
SELECT TRACE RLIKE 'minmax_keypart_in_disjunctive_query' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
SELECT TRACE RLIKE 'minmax_keypart_in_disjunctive_query' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
SELECT TRACE RLIKE 'minmax_keypart_in_disjunctive_query' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
SELECT TRACE RLIKE 'minmax_keypart_in_disjunctive_query' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
SELECT TRACE RLIKE 'minmax_keypart_in_disjunctive_query' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
SELECT TRACE RLIKE 'minmax_keypart_in_disjunctive_query' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
SELECT TRACE RLIKE 'minmax_keypart_in_disjunctive_query' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
SELECT TRACE RLIKE 'minmax_keypart_in_disjunctive_query' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
SELECT TRACE RLIKE 'minmax_keypart_in_disjunctive_query' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
SELECT TRACE RLIKE 'minmax_keypart_in_disjunctive_query' AS OK FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE
SELECT a, MAX(TRIM('1' FROM ~1)) FROM t GROUP BY a
RENAME TABLE t1 TO tt1
RENAME TABLE tt1 TO tt1tt1
RENAME TABLE tt1tt1 TO ttt1ttt1ttt1ttt1_xyz
RENAME TABLE ttt1ttt1ttt1ttt1_xyz TO tttttttttttttttt1_abc
RENAME TABLE tttttttttttttttt1_abc TO t1
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE, t0 WRITE
RENAME TABLES t0 TO t00, t1 TO t01, t2 TO t4
UNLOCK TABLES
LOCK TABLES t1 WRITE
RENAME TABLE t1 TO mysqltest.t1
UNLOCK TABLES
LOCK TABLES t1 WRITE, t2 WRITE
RENAME TABLES t1 TO mysqltest.t1, t2 TO t3
UNLOCK TABLES
LOCK TABLES t4 WRITE, t1 WRITE
RENAME TABLES t4 TO mysqltest.t4, t1 TO t3
UNLOCK TABLES
SELECT product, country_id , SUM(profit) FROM t1 GROUP BY product, country_id WITH ROLLUP ORDER BY product DESC, GROUPING (country_id), country_id
SELECT product, country_id , year, SUM(profit) FROM t1 EXPLAIN SELECT product, country_id , year, SUM(profit) FROM t1 SELECT product, country_id , year, SUM(profit) FROM t1 GROUP BY product, country_id, year WITH CUBE UNION ALL SELECT product, country_id , year, SUM(profit) FROM t1 drop table t1,t2
SELECT a, b, c, GROUPING(a) FROM t1 GROUP BY a,b,c WITH ROLLUP
SELECT a, b, c, GROUPING(a, b) FROM t1 GROUP BY a,b,c WITH ROLLUP
SELECT a, b, c, GROUPING(a, b, c) FROM t1 GROUP BY a,b,c WITH ROLLUP
SELECT a, b FROM t1 GROUP BY a,b WITH ROLLUP HAVING GROUPING(b) = 1
SELECT a, b, GROUPING(c) FROM t1 GROUP BY a,b WITH ROLLUP
SELECT a, b, c, GROUPING(a, b, c) FROM t1 GROUP BY a,b WITH ROLLUP
SELECT a, GROUPING(SUM(a)) FROM t1 GROUP BY (a) WITH ROLLUP
SELECT a, b, GROUPING(a) FROM t1 GROUP BY a,b
SELECT a, b, GROUPING(a) FROM t1
SELECT a, b FROM t1 WHERE GROUPING(a)=1 GROUP BY a,b WITH ROLLUP
SELECT a, b FROM t1 GROUP BY GROUPING(a),GROUPING(b) WITH ROLLUP
SELECT a, b, c, GROUPING(1) FROM t1 GROUP BY a,b,c WITH ROLLUP
SELECT a, GROUPING(1) FROM t1 GROUP BY 1 WITH ROLLUP
SELECT GROUPING(1) FROM t1 GROUP BY 1 WITH ROLLUP
SELECT a, b, GROUPING(c + c) FROM t1 GROUP BY a,b WITH ROLLUP
SELECT a, b, GROUPING(c + c) FROM t1 GROUP BY a,b,(c + c) WITH ROLLUP
SELECT GROUPING((SELECT MAX(b) FROM t1)) FROM t1 GROUP BY (SELECT MAX(b) FROM t1) WITH ROLLUP
SELECT (SELECT MAX(b) FROM t1) FROM t1 GROUP BY (SELECT MAX(b) FROM t1) WITH ROLLUP HAVING GROUPING((SELECT 1 FROM DUAL))=0
SELECT (SELECT MAX(b) FROM t1) FROM t1 GROUP BY (SELECT MAX(b) FROM t1) WITH ROLLUP HAVING GROUPING((SELECT MAX(b) FROM t1))=0
SELECT 1 WHERE 2 > ALL (SELECT GROUPING(a) FROM t1 GROUP BY a WITH ROLLUP)
SELECT 1 WHERE 1 = ANY (SELECT GROUPING(a) FROM t1 GROUP BY a WITH ROLLUP)
PREPARE ps FROM "SELECT a FROM t1 GROUP BY a WITH ROLLUP HAVING GROUPING(a)=0"
EXECUTE ps
PREPARE ps FROM "SELECT a FROM t1 GROUP BY a WITH ROLLUP HAVING GROUPING(a)=1"
EXECUTE ps
PREPARE ps FROM "SELECT GROUPING(a) FROM v GROUP BY a WITH ROLLUP"
EXECUTE ps
SELECT  MAX(a) FROM t1 WHERE (b) IN (SELECT MIN(t2.b) FROM t1 AS t2 GROUP BY t2.b WITH ROLLUP HAVING GROUPING (t2.b)=0)
SELECT  MAX(a) FROM t1 WHERE (b) IN (SELECT MIN(t2.b) FROM (SELECT b from t1) AS t2 GROUP BY t2.b WITH ROLLUP HAVING GROUPING (t2.b)=0)
WITH qn AS (SELECT a, b, c, GROUPING(a) as grouping_a FROM t1 GROUP BY a,b,c WITH ROLLUP) SELECT * FROM qn
WITH qn AS (SELECT (SELECT  MAX(a) FROM t1) as field1 FROM t1 GROUP BY field1 WITH ROLLUP HAVING GROUPING(field1)=0) SELECT * FROM qn
with qn as (SELECT  MAX(a) FROM t1 WHERE (b) IN ( SELECT MIN(t2.b) FROM (SELECT b from t1) AS t2 GROUP BY t2.b WITH ROLLUP HAVING GROUPING (t2.b)=0)) SELECT * FROM qn
WITH qn AS(SELECT GROUPING((SELECT MAX(b) FROM t1)) as field1 FROM t1 GROUP BY (SELECT MAX(b) FROM t1) WITH ROLLUP) SELECT qn.field1 FROM qn
SELECT a as Department,b as Employees, SUM(c), GROUPING(a) as GP_A, GROUPING(b) as GP_B FROM t1 GROUP BY a,b WITH ROLLUP
SELECT a as Department,b as Employees, SUM(c), GROUPING(a) as GP_A, GROUPING(b) as GP_B FROM t1 GROUP BY a,b WITH ROLLUP HAVING GP_A=1 OR GP_B=1
SELECT IF(GROUPING(a)=1,'All Departments', a) as Department, IF(GROUPING(b)=1, 'All Employees', b) as Employees, SUM(c) as SUM FROM t1 GROUP BY a,b WITH ROLLUP
SELECT a as Department, b as Employees, SUM(c), GROUPING(a) as GP_A, GROUPING(b) as GP_B FROM t1 GROUP BY a,b WITH ROLLUP
SELECT a as Department, b as Employees, SUM(c), GROUPING(a) as GP_A, GROUPING(b) as GP_B FROM t1 GROUP BY a,b WITH ROLLUP HAVING (GP_A =1 AND GP_B=1) OR (GP_B=1)
PREPARE ps FROM "SELECT COALESCE(a,'rollup_null') FROM v GROUP BY a WITH ROLLUP"
EXECUTE ps
DROP PREPARE ps
SELECT i, GROUPING(i+j), AVG(k) from t1 GROUP BY i,i+j WITH ROLLUP HAVING i is NOT NULL ORDER BY i+j
SELECT i, GROUPING(i+j), AVG(k) from t1 GROUP BY i,i+j WITH ROLLUP HAVING AVG(k) > 10 ORDER BY i
SELECT i, GROUPING(i+j), AVG(k) from t1 GROUP BY i,i+j WITH ROLLUP HAVING AVG(k) + 20 < 35 ORDER BY i
SELECT DISTINCT i, i+j, GROUPING(i+j), AVG(k) from t1 GROUP BY i,i+j WITH ROLLUP HAVING i is NOT NULL ORDER BY i+j
SELECT DISTINCT i, GROUPING(i+j), AVG(k) from t1 GROUP BY i,i+j WITH ROLLUP HAVING AVG(k) > 10 ORDER BY i
SELECT DISTINCT i, GROUPING(i+j), AVG(k) from t1 GROUP BY i,i+j WITH ROLLUP HAVING AVG(k) + 20 < 35 ORDER BY i
SELECT i, j, AVG(k) FROM t1 GROUP BY i,j WITH ROLLUP ORDER BY GROUPING(i),i,GROUPING(j),j
SELECT i, j, AVG(k) FROM t1 GROUP BY i,j WITH ROLLUP ORDER BY GROUPING(i),i,GROUPING(j),j LIMIT 5
SELECT i, j, SUM(k) FROM t1 GROUP BY i,j WITH ROLLUP HAVING i > 10 and j < 1000 ORDER BY GROUPING(i),i,GROUPING(j),j
SELECT CONCAT(i,':',j) as ij, CONCAT(j,':',i) as ji FROM t1 GROUP BY ij, ji WITH ROLLUP ORDER BY GROUPING(ij),ij,GROUPING(ji),ji
SELECT i, 'sum' FROM (SELECT i, SUM(j) AS 'sum' FROM t1 GROUP BY i WITH ROLLUP ORDER BY GROUPING(i),i) AS tmp WHERE i is NULL
SELECT i FROM t1 WHERE EXISTS (SELECT i, j, SUM(k) FROM t1 AS t2 WHERE t1.i=t2.i GROUP BY i,j WITH ROLLUP HAVING SUM(k) > 40 ORDER BY GROUPING(i),i, GROUPING(j),j)
SELECT a, SUM(a), SUM(a)+1, CONCAT(SUM(a),'x'), SUM(a)+SUM(a), SUM(a) FROM (SELECT 1 a, 2 b UNION SELECT 2,3 UNION SELECT 5,6 ) d GROUP BY a WITH ROLLUP ORDER BY GROUPING(a),a
SELECT i, j, i AS k, COUNT(*) AS count FROM t1 GROUP BY i, j, k WITH ROLLUP ORDER BY GROUPING(i),i, GROUPING(j),j, GROUPING(k),k
SELECT * FROM (SELECT i, j, SUM(k) FROM t1 GROUP BY i, j WITH ROLLUP ORDER BY GROUPING(i),i, GROUPING(j),j) as tmp
SELECT i, j, i+j, AVG(j) over () from t1 GROUP BY i,j WITH ROLLUP HAVING i+j is NULL ORDER BY GROUPING(i)
SELECT i, j, i+j, FIRST_VALUE(i) over () from t1 GROUP BY i,j WITH ROLLUP HAVING i+j is NULL ORDER BY GROUPING(i)
SELECT i, j, i+j, FIRST_VALUE(i) over () from t1 GROUP BY i,j WITH ROLLUP HAVING GROUPING(i) = 1 ORDER BY GROUPING(i)
SELECT i, j, i+j, FIRST_VALUE(i) over () from t1 GROUP BY i,j WITH ROLLUP HAVING 1 + 2 - GROUPING(i) = 2 ORDER BY GROUPING(i)
SELECT i, j, i+j, AVG(j), AVG(j) over () from t1 GROUP BY i,j WITH ROLLUP HAVING GROUPING(j)+AVG(j) > 11 ORDER BY GROUPING(i)
SELECT i,j, SUM(k), GROUPING(i), GROUPING(j) FROM t1 GROUP BY i,j WITH ROLLUP HAVING GROUPING(i) = 1 OR GROUPING (j) = 1 ORDER BY GROUPING(i),i,GROUPING(j),j
SELECT DISTINCT GROUPING(i), GROUPING(j) FROM t1 GROUP BY i,j WITH ROLLUP
SELECT DISTINCT GROUPING(i), GROUPING(j) FROM t1 GROUP BY i,j WITH ROLLUP ORDER BY GROUPING(i), GROUPING(j)
SELECT DISTINCT j, GROUPING(j) FROM t1 GROUP BY i,j WITH ROLLUP
SELECT i, j, AVG(k) FROM t1 GROUP BY i,j+GROUPING(i) WITH ROLLUP
SELECT GROUPING(table2.col_time) AS field1 FROM t1 AS table1,t1 as table2 WHERE table2.pk = 1 GROUP BY table2.col_time WITH ROLLUP ORDER BY GROUPING(table2.col_time)
SELECT (((@e:=`b`)) NOT BETWEEN 0x0b5f09 AND (CHAR(md5(@pub1), (CONNECTION_ID()+LEAD(5225.750000,110) RESPECT NULLS OVER(ORDER BY b, a))))) FROM t GROUP BY b,a WITH ROLLUP
SELECT (a+1) IS NULL, GROUPING(a+1) FROM t1 GROUP BY a+1 WITH ROLLUP
SELECT a AS f1, 'w' AS f2 FROM t GROUP BY f1, f2 WITH ROLLUP HAVING GROUPING(f2)=1
SELECT a AS f1, 'w' AS f2 FROM t GROUP BY f1, f2 WITH ROLLUP HAVING GROUPING(f2)=0
SELECT a AS f1, 'w' AS f2 FROM t GROUP BY f1, f2 WITH ROLLUP HAVING GROUPING(f1)=0
PREPARE ps FROM "SELECT RANK() OVER (ORDER BY a) FROM t1 GROUP BY a WITH ROLLUP"
CREATE PROCEDURE p1() BEGIN DECLARE v1 DOUBLE(10,3); SET v1= 100; SET @s = CONCAT('########################################', 40 , v1); SELECT @s; END;
hoho huhu$nl$nl)
, foo )
echo "WL6369 Explain for Connection"
WHERE i<100 AND j<10 ORDER BY i LIMIT 5
EXECUTE pse USING @client_id
EXECUTE ps USING @client_id
DEALLOCATE PREPARE ps
DEALLOCATE PREPARE pse
EXECUTE pse USING @client_id
EXECUTE ps USING @client_id
DEALLOCATE PREPARE ps
DEALLOCATE PREPARE pse
ALTER DEFINER=s@1 VIEW v1 AS SELECT * FROM t1
CALL mtr.add_suppression("Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT")
create function f1() returns int begin declare j int; select i from t1 where i = 1 into j; return j; end
create function f2() returns int begin declare k int; select i from t1 where i = 1 into k; insert into t2 values (k + 5); return 0; end
create function f6() returns int begin declare k int; select i from v1 where i = 1 into k; return k; end
create function f7() returns int begin declare k int; select j from v2 where j = 1 into k; return k; end
create function f8() returns int begin declare k int; select i from v1 where i = 1 into k; insert into t2 values (k+5); return k; end
create function f11() returns int begin declare k int; set k= f1(); insert into t2 values (k+5); return k; end
create procedure p2(inout p int) begin select i from t1 where i = 1 into p; end
create function f14() returns int begin declare k int; call p2(k); insert into t2 values (k+5); return k; end
create function f15() returns int begin declare k int; call p2(k); return k; end
create trigger t4_bi before insert on t4 for each row begin declare k int; select i from t1 where i=1 into k; set new.l= k+1; end
create trigger t5_bu before update on t5 for each row begin declare j int; call p2(j); set new.l= j + 1; end
select insert(_utf32 0x000000610000006200000063,10,2,_utf32 0x000000640000006500000066)
select insert(_utf32 0x000000610000006200000063,1,2,_utf32 0x000000640000006500000066)
prepare stmt1 from @str2
execute stmt1 using @ivar
prepare stmt from 'select utext from t1 where utext like ?'
execute stmt using @param1
execute stmt using @param1
deallocate prepare stmt
prepare stmt from 'select utext from t1 where utext like ?'
execute stmt using @param1
execute stmt using @param1
deallocate prepare stmt
insert into t1 values (repeat('a',333)), (repeat('b',333))
CREATE TABLE t1 AS SELECT repeat('a',2) as s1 LIMIT 0
SELECT id, CHAR_LENGTH(GROUP_CONCAT(body)) AS l FROM (SELECT 'a' AS id, REPEAT('foo bar', 100) AS body UNION ALL SELECT 'a' AS id, REPEAT('bla bla', 100) AS body) t1 GROUP BY id ORDER BY l DESC
DO REPLACE(CONVERT(1 USING utf32),BIT_XOR(1),SHA1(@d))
do lcase(ltrim(from_unixtime(0,' %T ')))
do _cp852 "" <= lcase(trim(leading 1 from 12222)) not between '1' and '2'
do upper(substring(1.111111111111111111 from '2n'))
do nullif(1,'-' between lcase(right(11111111," 7,]" ))and '1')
do upper(right(198039009115594390000000000000000000000.000000,35))
do concat('111','11111111111111111111111111', substring_index(uuid(),0,1.111111e+308))
do replace(ltrim(from_unixtime(0,' %T ')), '0', '1')
do insert(ltrim(from_unixtime(0,' %T ')), 2, 1, 'hi')
do replace(ltrim(from_unixtime(0,' %T ')), '0', '1')
SHOW GRANTS FOR 'kristofer'@'localhost'
change_user kristofer2,secret2
SHOW GRANTS FOR 'kristofer'@'localhost'
SHOW GRANTS FOR 'kristofer'@'localhost'
RENAME TABLE t1 TO `t2_............................end`
RENAME TABLE `t2_............................end` to t1
LOCK TABLES test_concurrent_insert READ LOCAL
UNLOCK TABLES
LOCK TABLES test_concurrent_insert WRITE
UNLOCK TABLES
"1" "4" "3 CHECK TABLE test_repair_table3
"1","101","IBM" CHECK TABLE test_repair_table5
"1","101","IBM" FLUSH TABLES
"1","101","IBM" FLUSH TABLES
1,"string" 2","string" 3,"string" 1,"string" "2",string" 3,"string" check table bug22080_2
1, 1E-2 -2E2, .9 -10E-1, -.9 -1, -100.1 1a, -2b repair table t1
lock tables t1 read
unlock tables
1,"integer sans quotes" 1,string sans quotes 1,quotes"in between" strings "1",Integer with quote and string with no quote 1,"escape sequence \n \" \\ \r \a within quotes" 1,escape sequence \n \" \\ \r \a without quotes SELECT * FROM t1
1,"string only at the beginning quotes SELECT * FROM t1
1,string with only ending quotes" SELECT * FROM t1
create procedure p_verify_reprepare_count(expected int) begin declare old_reprepare_count int default @reprepare_count; select variable_value from performance_schema.session_status where variable_name='com_stmt_reprepare' into @reprepare_count; if old_reprepare_count + expected <> @reprepare_count then select concat("Expected: ", expected, ", actual: ", @reprepare_count - old_reprepare_count) as "ERROR"; else select '' as "SUCCESS"; end if; end
prepare stmt from "select a from t1"
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt1 from "truncate t1"
prepare stmt2 from "select 1 as my_column from t1"
prepare stmt3 from "select 1 as my_column from (select * from t1) as t2"
prepare stmt4 from "select 1 as my_column from (select 1) as t2 where exists (select 1 from t1)"
prepare stmt5 from "select * from (select 1 as b) as t2, t1"
prepare stmt6 from "select * from t1 union all select 1.5"
prepare stmt7 from "select 1 as my_column union all select 1 from t1"
prepare stmt8 from "insert into t1 values(1),(2)"
prepare stmt9 from "update t1 set a = 3 where a = 2"
prepare stmt10 from "delete from t1 where a = 1"
prepare stmt1 from "select a,b from t1"
prepare stmt2 from "select a,b from (select * from t1) as t1"
prepare stmt3 from "select * from t1 where a = 2 and b = 2"
prepare stmt4 from "select * from t2 where (a,b) in (select * from t1)"
prepare stmt5 from "select * from t1 union select * from t2"
prepare stmt6 from "select * from t1 union all select * from t2"
prepare stmt7 from "insert into t1 set a = 4, b = 4"
prepare stmt8 from "insert into t1 select * from t2"
query_get_value(explain select avg(a) from t1, possible_keys, 1)
query_get_value(explain select avg(a) from t1, Extra, 1)
prepare stmt from "select avg(a) from t1"
execute stmt
execute stmt
query_get_value(explain select avg(a) from t1, possible_keys, 1)
query_get_value(explain select avg(a) from t1, Extra, 1)
execute stmt
execute stmt
query_get_value(explain select avg(a) from t1, possible_keys, 1)
query_get_value(explain select avg(a) from t1, Extra, 1)
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "insert into t1 values(1)"
execute stmt
execute stmt
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select f1() as my_column, a from t1"
execute stmt
prepare stmt from "select a, f1() as my_column from t1"
execute stmt
prepare stmt from "select f1() as my_column, count(*) from t1"
execute stmt
prepare stmt from "select count(*), f1() as my_column from t1"
execute stmt
prepare stmt from "select 1 as my_column from (select 1) as t2 where exists (select f1() from t1)"
execute stmt
execute stmt
prepare stmt from "select f1()"
execute stmt
execute stmt
deallocate prepare stmt
prepare stmt from "select count(*), f1() as my_column from t1"
execute stmt
deallocate prepare stmt
prepare stmt from "call p1"
execute stmt
create procedure mysqltest.p1() begin drop schema mysqltest; create schema mysqltest; end
execute stmt
execute stmt
deallocate prepare stmt
remove_file $MYSQLD_LOG
remove_file $BOOTSTRAP_SQL
select position(binary 'll' in 'hello'),position('a' in binary 'hello')
SELECT POSITION(x'44' IN _utf8mb4'abcdef')
SELECT POSITION(x'64' IN _utf8mb4'abcdef')
SELECT POSITION(x'ff' IN _utf8mb4'abcdef')
SELECT CONCAT('"',CONCAT_WS('";"',repeat('a',60),repeat('b',60),repeat('c',60),repeat('d',100)), '"')
select insert('txs',2,1,'hi'),insert('is ',4,0,'a'),insert('txxxxt',2,4,'es')
select repeat('monty',5),concat('*',space(5),'*')
select insert("aa",100,1,"b"),insert("aa",1,3,"b"),left("aa",-1),substring("a",1,2)
select length(repeat("a",100000000)),length(repeat("a",1000*64))
select position("0" in "baaa" in (1)),position("0" in "1" in (1,2,3)),position("sql" in ("mysql"))
select position(("1" in (1,2,3)) in "01")
select length(repeat("a",65500)),length(concat(repeat("a",32000),repeat("a",32000))),length(replace("aaaaa","a",concat(repeat("a",10000)))),length(insert(repeat("a",40000),1,30000,repeat("b",50000)))
select length(repeat("a",1000000)),length(concat(repeat("a",32000),repeat("a",32000),repeat("a",32000))),length(replace("aaaaa","a",concat(repeat("a",32000)))),length(insert(repeat("a",48000),1,1000,repeat("a",48000)))
select domain from t1 where concat('@', trim(leading '.' from concat('.', domain))) = '@hello.de'
select domain from t1 where concat('@', trim(leading '.' from concat('.', domain))) = '@test.de'
select POSITION(_latin1'B' IN _latin1'abcd' COLLATE latin1_bin)
select POSITION(_latin1'B' COLLATE latin1_bin IN _latin1'abcd')
select POSITION(_latin1'B' COLLATE latin1_general_ci IN _latin1'abcd' COLLATE latin1_bin)
select _latin1'B' between _latin1'a' and _latin1'c'
select _latin1'B' collate latin1_bin between _latin1'a' and _latin1'c'
select _latin1'B' between _latin1'a' collate latin1_bin and _latin1'c'
select _latin1'B' between _latin1'a' and _latin1'c' collate latin1_bin
select _latin2'B' between _latin1'a' and _latin1'b'
select _latin1'B' between _latin2'a' and _latin1'b'
select _latin1'B' between _latin1'a' and _latin2'b'
select _latin1'B' collate latin1_general_ci between _latin1'a' collate latin1_bin and _latin1'b'
select _latin1'B' in (_latin1'a',_latin1'b')
select _latin1'B' collate latin1_bin in (_latin1'a',_latin1'b')
select _latin1'B' in (_latin1'a' collate latin1_bin,_latin1'b')
select _latin1'B' in (_latin1'a',_latin1'b' collate latin1_bin)
select _latin2'B' in (_latin1'a',_latin1'b')
select _latin1'B' in (_latin2'a',_latin1'b')
select _latin1'B' in (_latin1'a',_latin2'b')
select _latin1'B' COLLATE latin1_general_ci in (_latin1'a' COLLATE latin1_bin,_latin1'b')
select _latin1'B' COLLATE latin1_general_ci in (_latin1'a',_latin1'b' COLLATE latin1_bin)
select collation(trim(LEADING _latin2' ' FROM _latin2'a')), coercibility(trim(LEADING _latin2'a' FROM _latin2'a'))
select collation(trim(TRAILING _latin2' ' FROM _latin2'a')), coercibility(trim(TRAILING _latin2'a' FROM _latin2'a'))
select collation(trim(BOTH _latin2' ' FROM _latin2'a')), coercibility(trim(BOTH _latin2'a' FROM _latin2'a'))
select collation(repeat(_latin2'a',10)), coercibility(repeat(_latin2'a',10))
select collation(insert(_latin2'abcd',2,3,_latin2'ef')), coercibility(insert(_latin2'abcd',2,3,_latin2'ef'))
create table t1 charset latin1 select bin(130), oct(130), conv(130,16,10), hex(130), char(130), format(130,10), left(_latin2'a',1), right(_latin2'a',1), lcase(_latin2'a'), ucase(_latin2'a'), substring(_latin2'a',1,1), concat(_latin2'a',_latin2'b'), lpad(_latin2'a',4,_latin2'b'), rpad(_latin2'a',4,_latin2'b'), concat_ws(_latin2'a',_latin2'b'), make_set(255,_latin2'a',_latin2'b',_latin2'c'), export_set(255,_latin2'y',_latin2'n',_latin2' '), trim(_latin2' a '), ltrim(_latin2' a '), rtrim(_latin2' a '), trim(LEADING _latin2' ' FROM _latin2' a '), trim(TRAILING _latin2' ' FROM _latin2' a '), trim(BOTH _latin2' ' FROM _latin2' a '), repeat(_latin2'a',10), reverse(_latin2'ab'), quote(_latin2'ab'), soundex(_latin2'ab'), substring(_latin2'ab',1), insert(_latin2'abcd',2,3,_latin2'ef'), replace(_latin2'abcd',_latin2'b',_latin2'B')
explain select insert('txs',2,1,'hi')
select trim(null from 'kate') as "must_be_null"
select trim('xyz' from null) as "must_be_null"
select trim(leading NULL from 'kate') as "must_be_null"
select trim(trailing NULL from 'xyz') as "must_be_null"
EXPLAIN SELECT s FROM t1 WHERE TRIM('y' FROM s) > 'ab'
EXPLAIN SELECT s FROM t1 WHERE TRIM(LEADING 'y' FROM s) > 'ab'
EXPLAIN SELECT s FROM t1 WHERE TRIM(TRAILING 'y' FROM s) > 'ab'
EXPLAIN SELECT s FROM t1 WHERE TRIM(BOTH 'y' FROM s) > 'ab'
set @dec=5
select format(pi(), @dec)
select insert('hello', -1, 1, 'hi')
select insert('hello', -4294967295, 1, 'hi')
select insert('hello', 4294967295, 1, 'hi')
select insert('hello', -4294967296, 1, 'hi')
select insert('hello', 4294967296, 1, 'hi')
select insert('hello', -4294967297, 1, 'hi')
select insert('hello', 4294967297, 1, 'hi')
select insert('hello', -18446744073709551615, 1, 'hi')
select insert('hello', 18446744073709551615, 1, 'hi')
select insert('hello', -18446744073709551616, 1, 'hi')
select insert('hello', 18446744073709551616, 1, 'hi')
select insert('hello', -18446744073709551617, 1, 'hi')
select insert('hello', 18446744073709551617, 1, 'hi')
select insert('hello', 1, -1, 'hi')
select insert('hello', 1, -4294967295, 'hi')
select insert('hello', 1, 4294967295, 'hi')
select insert('hello', 1, -4294967296, 'hi')
select insert('hello', 1, 4294967296, 'hi')
select insert('hello', 1, -4294967297, 'hi')
select insert('hello', 1, 4294967297, 'hi')
select insert('hello', 1, -18446744073709551615, 'hi')
select insert('hello', 1, 18446744073709551615, 'hi')
select insert('hello', 1, -18446744073709551616, 'hi')
select insert('hello', 1, 18446744073709551616, 'hi')
select insert('hello', 1, -18446744073709551617, 'hi')
select insert('hello', 1, 18446744073709551617, 'hi')
select insert('hello', -1, -1, 'hi')
select insert('hello', -4294967295, -4294967295, 'hi')
select insert('hello', 4294967295, 4294967295, 'hi')
select insert('hello', -4294967296, -4294967296, 'hi')
select insert('hello', 4294967296, 4294967296, 'hi')
select insert('hello', -4294967297, -4294967297, 'hi')
select insert('hello', 4294967297, 4294967297, 'hi')
select insert('hello', -18446744073709551615, -18446744073709551615, 'hi')
select insert('hello', 18446744073709551615, 18446744073709551615, 'hi')
select insert('hello', -18446744073709551616, -18446744073709551616, 'hi')
select insert('hello', 18446744073709551616, 18446744073709551616, 'hi')
select insert('hello', -18446744073709551617, -18446744073709551617, 'hi')
select insert('hello', 18446744073709551617, 18446744073709551617, 'hi')
select repeat('hello', -1)
select repeat('hello', -4294967295)
select repeat('hello', 4294967295)
select repeat('hello', -4294967296)
select repeat('hello', 4294967296)
select repeat('hello', -4294967297)
select repeat('hello', 4294967297)
select repeat('hello', -18446744073709551615)
select repeat('hello', 18446744073709551615)
select repeat('hello', -18446744073709551616)
select repeat('hello', 18446744073709551616)
select repeat('hello', -18446744073709551617)
select repeat('hello', 18446744073709551617)
select repeat('a', cast(2 as unsigned int))
SELECT REPEAT( '#', tire ) AS A, REPEAT( '#', tire % 999 ) AS B, tire FROM `t1`
SELECT REPEAT('0', CAST(0 AS UNSIGNED))
SELECT REPEAT('0', -2)
SELECT REPEAT('0', 2)
DO UNHEX(-1)
DO UNHEX(-182680438)
DO UNHEX(-2251799813685249)
SELECT INSERT('abc', 3, 3, '1234')
SELECT INSERT('abc', 4, 3, '1234')
SELECT INSERT('abc', 5, 3, '1234')
SELECT INSERT('abc', 6, 3, '1234')
SELECT '1' IN ('1', SUBSTRING(-9223372036854775809, 1))
SELECT insert( substring_index( 'a', 'a', 'b' ), 1, 0, 'x' )
SELECT REPEAT('1', DAY(FROM_UNIXTIME(-1)))
CREATE TABLE t1 charset utf8mb4 SELECT SUBSTRING('1', DAY(FROM_UNIXTIME(-1))) AS f1, LEFT('1', DAY(FROM_UNIXTIME(-1))) AS f2, RIGHT('1', DAY(FROM_UNIXTIME(-1))) AS f3, REPEAT('1', DAY(FROM_UNIXTIME(-1))) AS f4, RPAD('hi', DAY(FROM_UNIXTIME(-1)),'?') AS f5, LPAD('hi', DAY(FROM_UNIXTIME(-1)),'?') AS f6
SELECT ((+0) IN ((0b111111111111111111111111111111111111111111111111111),(rpad(1.0,2048,1)), (32767.1)))
SELECT ((127.1) not in ((rpad(1.0,2048,1)),(''),(-1.1)))
do format(rpad('111111111.1', 1111111, '999999999999999999999999999999999999999999'),0,'be_BY')
DO round( concat( ( coalesce( ( ST_linefromwkb('2147483648', -b'1111111111111111111111111111111111111111111')), ( convert('[.DC2.]',decimal(30,30)) ), bit_count('') ) ), ( lpad( ( elt('01','}:K5')), sha1('P'), ( ( select '-9223372036854775808.1' > all (select ''))) ) ) ) )
SET @@global.max_allowed_packet:= @tmp_max
SELECT LENGTH(TO_BASE64(REPEAT('a', @@max_allowed_packet-10)))
SELECT CHAR_LENGTH(EXPORT_SET(1,1,1,REPEAT(1,100000000)))
SET @@global.max_allowed_packet:= @tmp_max
PREPARE stmt FROM "SELECT COLLATION(space(2))"
EXECUTE stmt
EXECUTE stmt
select t1.a as str, length(t1.a) as str_length, t2.a as pos, t2.a + 10 as length, insert(t1.a, t2.a, t2.a + 10, '1234567') as 'insert' from t1, t2
SELECT 1 FROM t1 GROUP BY insert(a,'1','11','1')
SELECT insert(a,1,1,1) FROM t1
do concat('a',concat_ws('a', 0x2859, 'a' , trim(period_add('a',1) from (1&'')) ) )
select length(repeat("",1)) as a
select length(repeat("",1024*1024*1024)) as a
select length(repeat("1",1024*1024)) as a
select length(repeat("1",1024*1024*1024)) as a
SET @@global.max_allowed_packet:= DEFAULT
do rpad(_utf16"33",1073741826,_latin1"44")
SELECT length(repeat(_utf8mb4 0xE29883, 21844)) AS data
SELECT length(data) AS len FROM ( SELECT repeat(_utf8mb4 0xE29883, 21844) AS data ) AS sub
SELECT length(repeat(_utf8mb4 0xE29883, 21846)) AS data
SELECT length(data) AS len FROM ( SELECT repeat(_utf8mb4 0xE29883, 21846) AS data ) AS sub
SELECT COUNTRY FROM t1 WHERE trim(leading 'A' FROM  COUNTRY) = 'ustralia'
SELECT  COUNTRY  FROM t1 WHERE  trim(trailing 'a' FROM COUNTRY)= 'Australi'
SELECT COUNTRY FROM t1 WHERE trim(leading  'A' FROM COUNTRY) = 'ustralia' AND trim(trailing 'a' FROM COUNTRY) = 'Australi'
SELECT c1 <=  REPEAT( SUBSTR( UPPER('Rdlpikti') , 1 , 2 ), 8 ) FROM t1
SELECT * FROM t1 WHERE c1 <=  REPEAT( SUBSTR( UPPER('Rdlpikti') , 1 , 2 ), 8)
SELECT * FROM t1 WHERE c1 <=  REPEAT( SUBSTR( UPPER('Rdlpikti') , 1 , 2 ), 8)
SELECT BIN(MID(REPEAT('b',64),21,229))
SELECT BIN(RIGHT(REPEAT('b',64),30))
SELECT BIN(SUBSTRING(REPEAT('b',64),9))
SELECT OCT(LEFT(REPEAT('b',64),15))
do from_base64(aes_encrypt(right(cast((0x5d44f4d736397d92c8267c12)as decimal),1), rand(to_days('2028-12-04 15:50:01.284969'))))
do from_base64(cast(right(11,1)as binary(24)))
do convert(inet_aton(cast(left(-1,1)as binary(30))) using utf8)
do from_base64(cast((left(collation(4097),((repeat('1',32))or((-18772))))) as binary(40)))
do from_base64(cast((mid(17653,row('-688:20:12.162697',(null)) >= row(('*.)$'),(0xc254b6)),1))as binary(34)))
do from_base64(cast((mid(uuid(),20,64)) as binary(55)))
set @e:=_latin1'77'
do inet_aton(aes_encrypt(left(@e,1),5))
CREATE PROCEDURE sub1(id CHAR(10) CHARACTER SET utf8) BEGIN SELECT * FROM view1 WHERE table_name=id COLLATE utf8_tolower_ci; EXPLAIN SELECT * FROM view1 WHERE table_name=id COLLATE utf8_tolower_ci; SELECT * FROM view2 WHERE table_name=id; EXPLAIN SELECT * FROM view2 WHERE table_name=id; SELECT * FROM dd_table WHERE name COLLATE utf8_tolower_ci = id; EXPLAIN SELECT * FROM dd_table WHERE name COLLATE utf8_tolower_ci = id; SELECT * FROM view1 WHERE id COLLATE utf8_tolower_ci=table_name; EXPLAIN SELECT * FROM view1 WHERE id COLLATE utf8_tolower_ci=table_name; SELECT * FROM view2 WHERE id=table_name; EXPLAIN SELECT * FROM view2 WHERE id=table_name; SELECT * FROM dd_table WHERE id = name COLLATE utf8_tolower_ci; EXPLAIN SELECT * FROM dd_table WHERE id = name COLLATE utf8_tolower_ci; SELECT * FROM view1 WHERE table_name COLLATE utf8_tolower_ci = id; EXPLAIN SELECT * FROM view1 WHERE table_name COLLATE utf8_tolower_ci = id; END
select insert(null,2,1,'hi'),insert('txs',null,1,'hi')
select insert('txs',2,null,'hi'),insert('txs',2,1,null)
select insert('txs',null,null,'hi'),insert(null,null,null,null)
SELECT REPEAT(0x1111, 40000000) >> 1
SELECT (~(REPEAT(0xb822, 0x5C9C380)))
do concat(export_set(1,1,repeat('a',31),' $',213))
CREATE PROCEDURE proc (ofs INT, count INT) BEGIN DECLARE i INT DEFAULT ofs; WHILE i < count DO SELECT i AS i; IF LOWER(CHAR(i USING utf8) COLLATE utf8_tolower_ci) != LOWER(CHAR(i USING utf8mb4) COLLATE utf8mb4_0900_as_ci) THEN SELECT i AS 'found funny character'; END IF; SET i = i + 1; END WHILE; END
SELECT CONCAT('"',CONCAT('";"',repeat('a',60), repeat('b',60), repeat('c',60), repeat ('d',100)),'"')
SELECT CONCAT('"',CONCAT_WS('";"',repeat('a',60), repeat('b',60), repeat('c',60), repeat ('d',100)),'"')
SELECT CONCAT_WS('"',CONCAT_WS('";"',repeat('a',60), repeat('b',60), repeat('c',60), repeat ('d',100)),'"')
SELECT CONCAT('"',CONCAT('";"',repeat('a',60), repeat('b',60), repeat('c',60), repeat ('d',100)),'"')
SELECT CONCAT('"',CONCAT_WS('";"',repeat('a',60), repeat('b',60), repeat('c',60), repeat ('d',100)),'"')
SELECT CONCAT_WS('"',CONCAT_WS('";"',repeat('a',60), repeat('b',60), repeat('c',60), repeat ('d',100)),'"')
do repeat(row_count()  ,((-9223372036854775808 )<<('{ }'  ))  )
do ((repeat(1,9223372036854775808))or(convert((0x6d5b5d8d)using dec8)))
SELECT HEX(LPAD('', 42, TRIM(BOTH c1 FROM x'ff'))) FROM t1
SELECT HEX(LPAD('', 42, TRIM(x'ffff' FROM c1))) FROM t1
SELECT TRIM(BOTH x'f0' FROM _utf8mb4 x'F09F8DA3F09F8DA3')
SELECT TRIM(BOTH x'F09F8DA3' FROM _utf8mb4 x'F09F8DA3F09F8DA3')
SELECT TRIM(_latin2 x'a3' from _latin1 "hello")
SELECT TRIM(leading _utf8mb4 x'F09F8DA3' from _gb18030 x'9439B9376181308B33')
DO INSERT(1, 1, 1, CAST(1 AS DECIMAL(1,3)))
DO CONVERT( NULLIF( @a , 'c' ) USING BINARY)
SELECT INSERT(1, 1, 2, _utf8mb4 x'E4B8ADE69687')
remove_file $file
do crc32(char(1.134475e+308))
SELECT INSERT(a, 1, 1, x'ff') FROM t1
SELECT INSERT('a', 1, 1, YEAR(UNHEX('w')))
DO USER() in (COERCIBILITY(@c), CONVERT(LAST_VALUE(FROM_UNIXTIME(1536999169)) OVER() USING utf32))
DO ST_ISVALID(INSTR(9223372036854775806 ,0x46bc299f))
DO ST_SRID(LOCATE(0x58ed0b8e,8,135))
DO NOT CAST(UTC_TIME AS CHAR(2877246026) CHARACTER SET ujis)
DO REPEAT(LAST_INSERT_ID(''), 4294967295)
DO REPEAT(LAST_INSERT_ID(''), 0x96e4ed7e70a7fec7f11572c8980a)
CREATE VIEW v AS SELECT REPEAT('x', 1 NOT IN (0)) AS c
CREATE TABLE at(_bin binary(16), _vbn varbinary(16), _tbl tinyblob, _ttx tinytext, _blb blob)
SELECT bin_to_uuid(_bin), bin_to_uuid(_vbn), bin_to_uuid(_tbl), bin_to_uuid(_ttx), bin_to_uuid(_blb) FROM at
EVAL $query
EVAL CREATE TABLE t3 AS $query
INSERT into at(_bin,_blb) VALUES('c8eb4b15cb0948bb','c8eb4b15cb0948bb')
CREATE TABLE t3 AS SELECT hex('c8eb4b15cb0948bb'),hex(_bin),hex(_blb) FROM at
CREATE TABLE t3 AS SELECT unhex(_bin) FROM at
SELECT bin_to_uuid(x'')
SELECT bin_to_uuid(x'', true)
PREPARE s FROM "SELECT bin_to_uuid(x'7f9d04ae61b34468ac798ffcc984ab68',true)"
EXECUTE s
EXECUTE s
PREPARE s2 FROM "SELECT bin_to_uuid(uuid_to_bin('{12345678-1234-5678-1234-567812345678}', true), true)"
EXECUTE s2
EXECUTE s2
exec $MYSQL test -e "SELECT length(attr_value) > 0 AS must_be_non_zero FROM performance_schema.session_connect_attrs WHERE attr_name = 'os_user' AND PROCESSLIST_ID=CONNECTION_ID()"
SET @KEYS=REPEAT('c', 16)
SET @ENCSTR=REPEAT('d', 256)
SELECT AES_DECRYPT(AES_ENCRYPT(@ENCSTR, @KEYS), @KEYS)=@ENCSTR
SELECT AES_DECRYPT(AES_ENCRYPT(@ENCSTR, @KEYS, @IV), @KEYS, @IV)=@ENCSTR
SELECT AES_DECRYPT(AES_ENCRYPT(@ENCSTR, @KEYS), @KEYS)=@ENCSTR FROM t1
SELECT AES_DECRYPT(AES_ENCRYPT(@ENCSTR, @KEYS, @IV), @KEYS, @IV)=@ENCSTR FROM t1
SELECT AES_DECRYPT(AES_ENCRYPT(@ENCSTR, @KEYS), @KEYS)=@ENCSTR FROM t1
SELECT AES_DECRYPT(AES_ENCRYPT(@ENCSTR, @KEYS, @IV), @KEYS, @IV)=@ENCSTR FROM t1
SELECT AES_DECRYPT(AES_ENCRYPT(@ENCSTR, @KEYS), @KEYS)=@ENCSTR
SELECT AES_DECRYPT(AES_ENCRYPT(@ENCSTR, @KEYS, @IV), @KEYS, @IV)=@ENCSTR
SELECT AES_DECRYPT(AES_ENCRYPT(@ENCSTR, @KEYS), @KEYS)=@ENCSTR FROM t1
SELECT AES_DECRYPT(AES_ENCRYPT(@ENCSTR, @KEYS, @IV), @KEYS, @IV)=@ENCSTR FROM t1
SELECT AES_DECRYPT(AES_ENCRYPT(@ENCSTR, @KEYS), @KEYS)=@ENCSTR FROM t1
SELECT AES_DECRYPT(AES_ENCRYPT(@ENCSTR, @KEYS, @IV), @KEYS, @IV)=@ENCSTR FROM t1
SELECT AES_DECRYPT(AES_ENCRYPT(@ENCSTR, @KEYS), @KEYS)=@ENCSTR
SELECT AES_DECRYPT(AES_ENCRYPT(@ENCSTR, @KEYS, @IV), @KEYS, @IV)=@ENCSTR
SELECT AES_DECRYPT(AES_ENCRYPT(@ENCSTR, @KEYS), @KEYS)=@ENCSTR FROM t1
SELECT AES_DECRYPT(AES_ENCRYPT(@ENCSTR, @KEYS, @IV), @KEYS, @IV)=@ENCSTR FROM t1
SELECT AES_DECRYPT(AES_ENCRYPT(@ENCSTR, @KEYS), @KEYS)=@ENCSTR FROM t1
SELECT AES_DECRYPT(AES_ENCRYPT(@ENCSTR, @KEYS, @IV), @KEYS, @IV)=@ENCSTR FROM t1
SET @KEYS=RANDOM_BYTES(1)
SET @KEYS=RANDOM_BYTES(1024)
SET @KEYS='helloworld'
SET @ENCSTR=REPEAT('K',100)
select AES_ENCRYPT(@ENCSTR, @KEYS, @IV)=AES_ENCRYPT(@ENCSTR, @KEYS, @IV1)
SET @KEYS='helloworld1234567890'
SET @ENCSTR=REPEAT('J',255)
INSERT INTO t1 values(AES_ENCRYPT(@ENCSTR, @KEYS, @IV))
SELECT AES_DECRYPT(f1, @KEYS, @IV)=@ENCSTR FROM t1
SELECT AES_DECRYPT(f1, @KEYS, @IV)=@ENCSTR FROM t1
SELECT COALESCE (AES_DECRYPT(f1, @KEYS, @IV)=@ENCSTR,0) FROM t1
SELECT AES_DECRYPT(f1, @KEYS, @IV)=@ENCSTR FROM t1
SELECT AES_DECRYPT(f1, @KEYS, @IV)=@ENCSTR FROM t1
SELECT AES_DECRYPT(f1, @KEYS, @IV)=@ENCSTR FROM t1
SHOW GRANTS FOR 'kristofer'@'localhost'
SHOW GRANTS FOR 'kristofer'@'localhost'
call mtr.add_suppression("The table 't1' is full")
INSERT INTO t1 SET b=repeat('a',600)
UPDATE t1 SET b=repeat('a', 800) where a=10
INSERT INTO t1 SET b=repeat('a',400)
UPDATE t1 SET b=repeat('a', 600) where a=11
call mtr.add_suppression("The plugin .* used to authenticate user .* is not loaded. Nobody can currently login using this account")
call mtr.add_suppression("User entry .* has an empty plugin value. The user will be ignored and no one can login with this user anymore.")
call mtr.add_suppression("Some of the user accounts with SUPER privileges were disabled because of empty mysql.user.plugin value.")
call mtr.add_suppression("Found an entry in the 'role_edges' table with unknown authorization ID '`r3`@`%`'")
SHOW GRANTS FOR ''@''
SONAME "$TESTUDFSERVICES"
show function code almost_empty
create procedure code_sample(x int, out err int, out nulls int) begin declare count int default 0; set nulls = 0; begin declare c cursor for select name from t1; declare exit handler for not found close c; open c; loop begin declare n varchar(20); declare continue handler for sqlexception set err=1; fetch c into n; if isnull(n) then set nulls = nulls + 1; else set count = count + 1; update t2 set idx = count where name=n; end if; end; end loop; end; select t.name, t.idx from t2 t order by idx asc; end
create procedure sudoku_solve(p_naive boolean, p_all boolean) deterministic modifies sql data begin drop temporary table if exists sudoku_work, sudoku_schedule; create temporary table sudoku_work ( `row` smallint not null, col smallint not null, dig smallint not null, cnt smallint, key using btree (cnt), key using btree (`row`), key using btree (col), unique key using hash (`row`,col) ); create temporary table sudoku_schedule ( idx int not null auto_increment primary key, `row` smallint not null, col smallint not null ); call sudoku_init(); if p_naive then update sudoku_work set cnt = 0 where dig = 0; else call sudoku_count(); end if; insert into sudoku_schedule (`row`,col) select `row`,col from sudoku_work where cnt is not null order by cnt desc; begin declare v_scounter bigint default 0; declare v_i smallint default 1; declare v_dig smallint; declare v_schedmax smallint; select count(*) into v_schedmax from sudoku_schedule; more: loop begin declare v_tcounter bigint default 0; sched: while v_i <= v_schedmax do begin declare v_row, v_col smallint; select `row`,col into v_row,v_col from sudoku_schedule where v_i = idx; select dig into v_dig from sudoku_work where v_row = `row` and v_col = col; case v_dig when 0 then set v_dig = 1; update sudoku_work set dig = 1 where v_row = `row` and v_col = col; when 9 then if v_i > 0 then update sudoku_work set dig = 0 where v_row = `row` and v_col = col; set v_i = v_i - 1; iterate sched; else select v_scounter as 'Solutions'; leave more; end if; else set v_dig = v_dig + 1; update sudoku_work set dig = v_dig where v_row = `row` and v_col = col; end case; set v_tcounter = v_tcounter + 1; if not sudoku_digit_ok(v_row, v_col, v_dig) then iterate sched; end if; set v_i = v_i + 1; end; end while sched; select dig from sudoku_work; select v_tcounter as 'Tests'; set v_scounter = v_scounter + 1; if p_all and v_i > 0 then set v_i = v_i - 1; else leave more; end if; end; end loop more; end; drop temporary table sudoku_work, sudoku_schedule; end
CREATE PROCEDURE proc_19194_simple(i int) BEGIN DECLARE str CHAR(10); CASE i WHEN 1 THEN SET str="1"; WHEN 2 THEN SET str="2"; WHEN 3 THEN SET str="3"; ELSE SET str="unknown"; END CASE; SELECT str; END
CREATE PROCEDURE proc_19194_searched(i int) BEGIN DECLARE str CHAR(10); CASE WHEN i=1 THEN SET str="1"; WHEN i=2 THEN SET str="2"; WHEN i=3 THEN SET str="3"; ELSE SET str="unknown"; END CASE; SELECT str; END
CREATE PROCEDURE proc_19194_nested_1(i int, j int) BEGIN DECLARE str_i CHAR(10); DECLARE str_j CHAR(10); CASE i WHEN 10 THEN SET str_i="10"; WHEN 20 THEN BEGIN set str_i="20"; CASE WHEN j=1 THEN SET str_j="1"; WHEN j=2 THEN SET str_j="2"; WHEN j=3 THEN SET str_j="3"; ELSE SET str_j="unknown"; END CASE; select "i was 20"; END; WHEN 30 THEN SET str_i="30"; WHEN 40 THEN SET str_i="40"; ELSE SET str_i="unknown"; END CASE; SELECT str_i, str_j; END
CREATE PROCEDURE proc_19194_nested_2(i int, j int) BEGIN DECLARE str_i CHAR(10); DECLARE str_j CHAR(10); CASE WHEN i=10 THEN SET str_i="10"; WHEN i=20 THEN BEGIN set str_i="20"; CASE j WHEN 1 THEN SET str_j="1"; WHEN 2 THEN SET str_j="2"; WHEN 3 THEN SET str_j="3"; ELSE SET str_j="unknown"; END CASE; select "i was 20"; END; WHEN i=30 THEN SET str_i="30"; WHEN i=40 THEN SET str_i="40"; ELSE SET str_i="unknown"; END CASE; SELECT str_i, str_j; END
CREATE PROCEDURE proc_19194_nested_3(i int, j int) BEGIN DECLARE str_i CHAR(10); DECLARE str_j CHAR(10); CASE i WHEN 10 THEN SET str_i="10"; WHEN 20 THEN BEGIN set str_i="20"; CASE j WHEN 1 THEN SET str_j="1"; WHEN 2 THEN SET str_j="2"; WHEN 3 THEN SET str_j="3"; ELSE SET str_j="unknown"; END CASE; select "i was 20"; END; WHEN 30 THEN SET str_i="30"; WHEN 40 THEN SET str_i="40"; ELSE SET str_i="unknown"; END CASE; SELECT str_i, str_j; END
CREATE PROCEDURE proc_19194_nested_4(i int, j int) BEGIN DECLARE str_i CHAR(10); DECLARE str_j CHAR(10); CASE WHEN i=10 THEN SET str_i="10"; WHEN i=20 THEN BEGIN set str_i="20"; CASE WHEN j=1 THEN SET str_j="1"; WHEN j=2 THEN SET str_j="2"; WHEN j=3 THEN SET str_j="3"; ELSE SET str_j="unknown"; END CASE; select "i was 20"; END; WHEN i=30 THEN SET str_i="30"; WHEN i=40 THEN SET str_i="40"; ELSE SET str_i="unknown"; END CASE; SELECT str_i, str_j; END
CREATE PROCEDURE p1() CREATE INDEX idx ON t1 (c1)
create procedure proc_26977_broken(v int) begin declare i int default 5; declare continue handler for sqlexception begin select 'caught something'; retry: while i > 0 do begin set i = i - 1; select 'looping', i; end; end while retry; end; select 'do something'; insert into t1 values (v); select 'do something again'; insert into t1 values (v); end
create procedure proc_26977_works(v int) begin declare i int default 5; declare continue handler for sqlexception begin select 'caught something'; retry: while i > 0 do begin set i = i - 1; select 'looping', i; end; end while retry; select 'optimizer: keep hreturn'; end; select 'do something'; insert into t1 values (v); select 'do something again'; insert into t1 values (v); end
create procedure proc_33618_h(num int) begin declare count1 int default '0'; declare vb varchar(30); declare last_row int; while(num>=1) do set num=num-1; begin declare cur1 cursor for select `a` from t_33618; declare continue handler for not found set last_row = 1; set last_row:=0; open cur1; rep1: repeat begin declare exit handler for 1062 begin end; fetch cur1 into vb; if (last_row = 1) then leave rep1; end if; end; until last_row=1 end repeat; close cur1; end; end while; end
create procedure proc_33618_c(num int) begin declare count1 int default '0'; declare vb varchar(30); declare last_row int; while(num>=1) do set num=num-1; begin declare cur1 cursor for select `a` from t_33618; declare continue handler for not found set last_row = 1; set last_row:=0; open cur1; rep1: repeat begin declare cur2 cursor for select `b` from t_33618; fetch cur1 into vb; if (last_row = 1) then leave rep1; end if; end; until last_row=1 end repeat; close cur1; end; end while; end
CREATE PROCEDURE p1() BEGIN DECLARE dummy int default 0; CASE 12 WHEN 12 THEN SET dummy = 0; END CASE; END
CREATE PROCEDURE p1() BEGIN DECLARE c CURSOR FOR SELECT a FROM t1; OPEN c; BEGIN DECLARE v INT; DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN GET DIAGNOSTICS @n = NUMBER; GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT; SELECT "Warning found!"; SELECT @err_no, @err_txt; END; DECLARE EXIT HANDLER FOR NOT FOUND BEGIN GET DIAGNOSTICS @n = NUMBER; GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT; SELECT "End of Result Set found!"; SELECT @err_no, @err_txt; END; WHILE TRUE DO FETCH c INTO v; END WHILE; END; CLOSE c; SELECT a INTO @foo FROM t1 LIMIT 1; # Clear warning stack END
DELIMITER
SHOW FUNCTION CODE testf_bug11763507
SHOW FUNCTION CODE TESTF_bug11763507
CREATE PROCEDURE p1() BEGIN DECLARE x1 INT DEFAULT (SELECT 1 + 2); DECLARE x2 INT DEFAULT (SELECT * FROM (SELECT 1 + 2) t1); DECLARE x3 INT DEFAULT (SELECT * FROM t1); DECLARE x4 INT DEFAULT (SELECT * FROM t2); DECLARE x5 INT DEFAULT (SELECT * FROM t3); DECLARE x6 INT DEFAULT (SELECT f()); DECLARE c1 CURSOR FOR SELECT (1 + 2) FROM dual; DECLARE c2 CURSOR FOR SELECT * FROM (SELECT 1 + 2) t1; DECLARE c3 CURSOR FOR SELECT * FROM t1; DECLARE c4 CURSOR FOR SELECT * FROM t2; DECLARE c5 CURSOR FOR SELECT * FROM t3; DECLARE c6 CURSOR FOR SELECT f(); IF (SELECT 1 + 2) THEN SET @dummy = 1; END IF; IF (SELECT * FROM (SELECT 1 + 2) t1) THEN SET @dummy = 1; END IF; IF (SELECT * FROM t1) THEN SET @dummy = 1; END IF; IF (SELECT * FROM t2) THEN SET @dummy = 1; END IF; IF (SELECT * FROM t3) THEN SET @dummy = 1; END IF; IF (SELECT f()) THEN SET @dummy = 1; END IF; SET x1 = (SELECT 1 + 2); SET x1 = (SELECT * FROM (SELECT 1 + 2) t1); SET x1 = (SELECT * FROM t1); SET x1 = (SELECT * FROM t2); SET x1 = (SELECT * FROM t3); SET x1 = (SELECT f()); CASE WHEN (SELECT 1 + 2) = 1                     THEN SET @dummy = 1; WHEN (SELECT * FROM (SELECT 1 + 2) t1) = 2  THEN SET @dummy = 1; WHEN (SELECT * FROM t1) = 3                 THEN SET @dummy = 1; WHEN (SELECT * FROM t2) = 3                 THEN SET @dummy = 1; WHEN (SELECT * FROM t3) = 3                 THEN SET @dummy = 1; WHEN (SELECT f()) = 3                       THEN SET @dummy = 1; END CASE; CASE (SELECT 1 + 2) WHEN 1 THEN SET @dummy = 1; ELSE SET @dummy = 1; END CASE; CASE (SELECT * FROM (SELECT 1 + 2) t1) WHEN 1 THEN SET @dummy = 1; ELSE SET @dummy = 1; END CASE; CASE (SELECT * FROM t1) WHEN 1 THEN SET @dummy = 1; ELSE SET @dummy = 1; END CASE; CASE (SELECT * FROM t2) WHEN 1 THEN SET @dummy = 1; ELSE SET @dummy = 1; END CASE; CASE (SELECT * FROM t3) WHEN 1 THEN SET @dummy = 1; ELSE SET @dummy = 1; END CASE; CASE (SELECT f()) WHEN 1 THEN SET @dummy = 1; ELSE SET @dummy = 1; END CASE; WHILE (SELECT 1 - 1) DO SET @dummy = 1; END WHILE; WHILE (SELECT * FROM (SELECT 1 - 1) t1) DO SET @dummy = 1; END WHILE; WHILE (SELECT * FROM t1) - 10 DO SET @dummy = 1; END WHILE; WHILE (SELECT * FROM t2) - 10 DO SET @dummy = 1; END WHILE; WHILE (SELECT * FROM t3) - 10 DO SET @dummy = 1; END WHILE; WHILE (SELECT f()) - 1 DO SET @dummy = 1; END WHILE; REPEAT SET @dummy = 1; UNTIL (SELECT 1 - 1) END REPEAT; REPEAT SET @dummy = 1; UNTIL (SELECT * FROM (SELECT 1 - 1) t1) END REPEAT; REPEAT SET @dummy = 1; UNTIL (SELECT * FROM t1) - 10 END REPEAT; REPEAT SET @dummy = 1; UNTIL (SELECT * FROM t2) - 10 END REPEAT; REPEAT SET @dummy = 1; UNTIL (SELECT * FROM t3) - 10 END REPEAT; REPEAT SET @dummy = 1; UNTIL (SELECT f()) - 1 END REPEAT; END
SHOW FUNCTION CODE f1
SHOW FUNCTION CODE f2
SHOW FUNCTION CODE f3
SHOW FUNCTION CODE f4
SHOW FUNCTION CODE f5
SHOW FUNCTION CODE f6
LOCK TABLES v1 WRITE
UNLOCK TABLES
select * from t2 left join t1 ignore index(primary) on t1.fooID = t2.fooID and t1.fooID = 30
PREPARE prep_stmt FROM ' SELECT 1 AS f FROM t1 LEFT JOIN t1 t2 RIGHT JOIN t1 t3 JOIN t1 t4 ON 1 ON 1 ON 1 GROUP BY f'
EXECUTE prep_stmt
EXECUTE prep_stmt
ON 0 WHERE t1.a OR t3.a
(t2 LEFT JOIN (t3 LEFT JOIN t4 ON 1) ON t2.a) ON 0 WHERE t1.a OR t4.a
PREPARE prep_stmt_9846 FROM ' SELECT alias1.pk AS field1 FROM t1 AS alias1 LEFT JOIN ( t1 AS alias2 RIGHT  JOIN ( t1 AS alias3 JOIN t1 AS alias4 ON 1 ) ON 1 ) ON 1 GROUP BY field1'
execute prep_stmt_9846
execute prep_stmt_9846
deallocate prepare prep_stmt_9846
SELECT MAX( t2.i2 ) FROM t3 RIGHT JOIN t2 ON ( t2.i3 = 2 ) WHERE t2.i3 <> t1.i1 ) AS field1 FROM t1
FROM t6 AS t6a LEFT JOIN ( t2 RIGHT JOIN ( ( t1 LEFT JOIN ( t4 JOIN t3 ON t4.col_int ) ON t4.col_int_key = t1.pk ) LEFT JOIN ( t5 JOIN t6 AS t6b ON t5.col_varchar_10_utf8_key = t6b.col_varchar_10_latin1_key ) ON t1.pk = t5.col_int ) ON t4.col_varchar_10_latin1_key = t1.col_varchar_10_latin1_key AND t5.col_varchar_10_utf8_key = 0 ) ON t6a.pk IS TRUE WHERE t6b.col_int_key IS TRUE
SET @a:=(SELECT ROW(1, 2)= ROW((SELECT 1 FROM t1 LEFT JOIN t1 t2 ON 1), 1))
$query
FROM where_subselect_table WHERE (9) IN ( $query ) /* TRANSFORM_OUTCOME_UNORDERED_MATCH */
FROM where_subselect_table WHERE (9) IN ( $query ) /* TRANSFORM_OUTCOME_UNORDERED_MATCH */
WHERE t1.name LIKE 'A%'
EXECUTE stmt
DEALLOCATE PREPARE stmt
WHERE t1.name LIKE 'A%' OR 'ASDFGH' IS NULL
EXECUTE stmt
DEALLOCATE PREPARE stmt
WHERE 0 OR 0
EXECUTE stmt
DEALLOCATE PREPARE stmt
WHERE 1 OR 0
EXECUTE stmt
DEALLOCATE PREPARE stmt
WHERE NOT(NOT (0)) OR 1
EXECUTE stmt
DEALLOCATE PREPARE stmt
WHERE NOT(NOT (0)) OR 0 = 1
EXECUTE stmt
DEALLOCATE PREPARE stmt
WHERE 1 IS NOT TRUE AND 0 IS TRUE
EXECUTE stmt
WHERE 'a' LIKE 1 OR 2 LIKE '2%'
EXECUTE stmt
WHERE 1 IS NOT NULL
EXECUTE stmt
WHERE (1<2 AND 2<3) OR (1>1 AND 2<3)
EXECUTE stmt
WHERE (1>=1 AND 2<=2) OR (1=1 AND 2<3)
EXECUTE stmt
WHERE (1<>1 AND 2=2) OR (1 BETWEEN 0 AND 2)
EXECUTE stmt
PREPARE prep_stmt FROM " SELECT 1 FROM ( ( SELECT * FROM t1 WHERE col_varchar >= 1 )  AS table1 RIGHT JOIN t2 ON ( ( NULL < NULL ) IS NULL OR 1 = 0 ) ) "
EXECUTE prep_stmt
EXECUTE prep_stmt
t3.col_int, t4.col_int, t3.col_int = t4.col_int or t4.col_int IS NULL FROM (t1 LEFT JOIN t2 ON t1.col_int_key = t2.col_int_key AND t1.col_int_unique = t2.col_int_unique LEFT JOIN t3 ON t3.col_char_16_unique = t2.col_char_16_unique LEFT JOIN t4 ON t4.col_int = t3.col_int AND    #Note, this pred term t4.col_int_unique = t1.col_int_unique ) WHERE t1.col_int_unique = 5
lock table t1 read
flush table t1
unlock tables
lock table t1 write
flush table t1
unlock tables
lock table t1 write
send lock table t1 read
sleep 2
flush table t1
unlock tables
reap
unlock tables
lock table t1 write
send lock table t1 write
sleep 2
flush table t1
unlock tables
reap
unlock tables
handler t1 open as a1
handler t1 open as a2
handler t2 open
handler a1 read first limit 9
handler a2 read first limit 9
handler t2 read first limit 9
handler a1 read first limit 9
handler a2 read first limit 9
handler t2 read first limit 9
handler t1 open as a1
handler t1 open as a2
handler t2 open
handler a1 read first limit 9
handler a2 read first limit 9
handler t2 read first limit 9
flush table t1
handler a1 read first limit 9
handler a2 read first limit 9
handler t2 read first limit 9
flush table t2
handler t2 close
handler t1 open
handler t1 read first limit 1
handler t1 read next limit 1
handler t1 read next limit 1
flush table t1
handler t1 read next limit 1
handler t1 read next limit 1
handler t1 close
UNLOCK TABLES
CREATE PROCEDURE p1() BEGIN DECLARE export INT; END
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
FLUSH TABLE export FOR EXPORT
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
FLUSH TABLE t1 FOR EXPORT
UNLOCK TABLES
FLUSH TABLE t1 FOR EXPORT
UNLOCK TABLES
UNLOCK TABLES
FLUSH TABLE db1.t1 FOR EXPORT
UNLOCK TABLES
FLUSH TABLE db1.t1 FOR EXPORT
FLUSH TABLE db1.t1 FOR EXPORT
FLUSH TABLE db1.t1 FOR EXPORT
FLUSH TABLE db1.t1 FOR EXPORT
FLUSH TABLE t1 FOR EXPORT
FLUSH TABLE t2 FOR EXPORT
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLE t1 READ
FLUSH TABLE t1 FOR EXPORT
UNLOCK TABLES
UNLOCK TABLES
FLUSH TABLE t1 FOR EXPORT
LOCK TABLE t1 READ
UNLOCK TABLES
UNLOCK TABLES
FLUSH TABLE t1 FOR EXPORT
FLUSH TABLE t1 FOR EXPORT
FLUSH TABLE t1 FOR EXPORT
UNLOCK TABLES
UNLOCK TABLE
UNLOCK TABLES
UNLOCK TABLE
LOCK TABLES test.t1 READ
UNLOCK TABLES
LOCK TABLES test.t1 WRITE
LOCK TABLES test.t1 READ
LOCK TABLES test.t1 WRITE
UNLOCK TABLES
CALL mtr.add_suppression('Disk is full writing')
CALL mtr.add_suppression('Retry in 60 secs')
INSERT INTO t1 VALUES (1, REPEAT("a", 8192))
INSERT INTO t1 VALUES (2, REPEAT("b", 8192))
INSERT INTO t1 VALUES (3, REPEAT("c", 8192))
HANDLER t1 OPEN
HANDLER t1 READ FIRST
HANDLER t1 OPEN
HANDLER t1 READ FIRST
HANDLER t1 OPEN
HANDLER t1 READ a FIRST
HANDLER t1 READ a NEXT
HANDLER t1 CLOSE
HANDLER t1 OPEN
HANDLER t1 READ FIRST
HANDLER t1 READ `PRIMARY` NEXT
HANDLER t1 READ ab NEXT
HANDLER t1 READ b NEXT
HANDLER t1 READ NEXT
HANDLER t1 CLOSE
HANDLER t1 OPEN
HANDLER t1 READ FIRST
HANDLER t1 READ NEXT
HANDLER t1 READ `PRIMARY` NEXT
HANDLER t1 READ `PRIMARY` NEXT
HANDLER t1 READ ab NEXT
HANDLER t1 READ ab NEXT
HANDLER t1 READ b NEXT
HANDLER t1 READ b NEXT
HANDLER t1 READ b NEXT
HANDLER t1 READ b NEXT
HANDLER t1 READ b NEXT
HANDLER t1 READ NEXT
HANDLER t1 READ NEXT
HANDLER t1 READ NEXT
HANDLER t1 READ NEXT
HANDLER t1 READ NEXT
HANDLER t1 CLOSE
HANDLER t1 OPEN
HANDLER t1 READ FIRST
HANDLER t1 READ `PRIMARY` PREV
HANDLER t1 READ `PRIMARY` PREV
HANDLER t1 READ b PREV
HANDLER t1 READ b PREV
HANDLER t1 CLOSE
HANDLER t1 OPEN
HANDLER t1 READ FIRST
HANDLER t1 READ `PRIMARY` PREV LIMIT 3
HANDLER t1 READ b NEXT LIMIT 5
HANDLER t1 CLOSE
HANDLER t1 OPEN
HANDLER t1 READ FIRST
HANDLER t1 OPEN
HANDLER t1 READ FIRST
HANDLER t1 OPEN
HANDLER t1 READ FIRST
HANDLER t1 OPEN
HANDLER t1 READ FIRST
HANDLER t1 OPEN
HANDLER t1 READ FIRST
HANDLER t1 OPEN
HANDLER t1 READ FIRST
HANDLER t1 OPEN
HANDLER t1 READ FIRST
HANDLER t1 OPEN
HANDLER t1 READ FIRST
HANDLER t1 OPEN
HANDLER t1 READ FIRST
HANDLER t1 OPEN
HANDLER t1 READ FIRST
HANDLER t1 OPEN
HANDLER t1 READ FIRST
HANDLER t1 OPEN
HANDLER t1 READ FIRST
INSERT INTO t VALUES (REPEAT('a', 128)), (REPEAT('b', 128)), (REPEAT('c', 128)), (REPEAT('d', 128))
SHOW GRANTS FOR 'user3'@'%'
call mtr.add_suppression("Some of the user accounts with SUPER")
call mtr.add_suppression("perform the MySQL upgrade procedure")
call mtr.add_suppression("For complete")
call mtr.add_suppression("User entry .B19011337")
call mtr.add_suppression("Column count of mysql.* is wrong. " "Expected .*, found .*. " "The table is probably corrupted")
call mtr.add_suppression("The plugin 'mysql_old_password' used to authenticate user 'user_old_pass_wp'@'%' is not loaded. Nobody can currently login using this account.")
call mtr.add_suppression("Some of the user accounts with SUPER")
call mtr.add_suppression("1. Stop")
call mtr.add_suppression("2. Run")
call mtr.add_suppression("3. Restart")
call mtr.add_suppression("For complete")
call mtr.add_suppression("User entry 'user_old_pass_pn'@'%' has an empty plugin value. The user will be ignored and no one can login with this user anymore.")
call mtr.add_suppression("User entry 'su_old_pass_pn'@'%' has an empty plugin value. The user will be ignored and no one can login with this user anymore.")
call mtr.add_suppression("User entry 'B20614545'@'localhost' has an empty plugin value. The user will be ignored and no one can login with this user anymore.")
SHOW GRANTS FOR root@localhost
SHOW GRANTS FOR root@localhost
SHOW GRANTS FOR u1
SHOW GRANTS FOR root@localhost
SHOW GRANTS FOR u1
SHOW GRANTS FOR root@localhost
SHOW GRANTS FOR u1
SHOW GRANTS FOR u1
SHOW GRANTS FOR u2
SHOW GRANTS FOR u1
SHOW GRANTS FOR u2
SHOW GRANTS FOR root@localhost
SHOW GRANTS FOR user1
SHOW GRANTS FOR root@localhost
SHOW GRANTS FOR user1
SHOW GRANTS FOR root@localhost
SHOW GRANTS FOR root@localhost
SHOW GRANTS FOR u1
SHOW GRANTS FOR root@localhost
SHOW GRANTS FOR u1
SHOW GRANTS FOR root@localhost
SHOW GRANTS FOR u1
SHOW GRANTS FOR root@localhost
SHOW GRANTS FOR root@localhost
SHOW GRANTS FOR u1
SHOW GRANTS FOR root@localhost
SHOW GRANTS FOR u1
SHOW GRANTS FOR root@localhost
SHOW GRANTS FOR u1
SHOW GRANTS FOR root@localhost
SHOW GRANTS FOR sheldon
SHOW GRANTS FOR root@localhost
SHOW GRANTS FOR sheldon
LOCK TABLE m1 WRITE, m2 WRITE
UNLOCK TABLES
LOCK TABLE m1 WRITE, m2 WRITE
UNLOCK TABLES
LOCK TABLE m1 WRITE, m2 WRITE
UNLOCK TABLES
LOCK TABLE m1 WRITE, m2 WRITE
UNLOCK TABLES
create table t1( bool_col bool, boolean_col boolean, bit_col bit(5), tiny tinyint, tiny_uns tinyint unsigned, small smallint, small_uns smallint unsigned, medium mediumint, medium_uns mediumint unsigned, int_col int, int_col_uns int unsigned, big bigint, big_uns bigint unsigned, decimal_col decimal(10,5), numeric_col numeric(10), fixed_col fixed(10), dec_col dec(10), decimal_col_uns decimal(10,5) unsigned, fcol float, fcol_uns float unsigned, dcol double, double_precision_col double precision, dcol_uns double unsigned, date_col date, time_col time, timestamp_col timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, year_col year, datetime_col datetime, char_col char(5), varchar_col varchar(10), binary_col binary(10), varbinary_col varbinary(10), tinyblob_col tinyblob, blob_col blob, mediumblob_col mediumblob, longblob_col longblob, text_col text, mediumtext_col mediumtext, longtext_col longtext, enum_col enum("A","B","C"), set_col set("F","E","D") )
CALL mtr.add_suppression('Following users were specified in CREATE USER IF NOT EXISTS but they already exist')
CALL mtr.add_suppression('Following users were specified in ALTER USER IF EXISTS but they do not exist')
LET old_log_output=          `select @@global.log_output`
LET old_general_log=         `select @@global.general_log`
LET old_general_log_file=    `select @@global.general_log_file`
set charset default,@dummy='A'
CHANGE REPLICATION SOURCE TO SOURCE_PASSWORD='azundris3'
ALTER  USER test_user9 IDENTIFIED WITH 'caching_sha2_password' BY ''
INTO TABLE test_log FIELDS TERMINATED BY '\n' LINES TERMINATED BY '\n'
SELECT TRIM(LEADING '\t' FROM MID(argument,LOCATE('Query',argument)+5)) FROM test_log WHERE (argument LIKE '%BY %' OR argument LIKE '%AS %' OR argument LIKE '%PASSWORD %') AND argument NOT LIKE '%Prepare%'
SET @sql='SELECT command_type, argument FROM mysql.general_log WHERE argument LIKE "%Bug#16953758%"'
PREPARE stmt FROM @sql
EXECUTE stmt
DEALLOCATE PREPARE stmt
SET @sql='DROP TABLE 18616826_does_not_exist'
PREPARE stmt FROM @sql
EXECUTE stmt
DEALLOCATE PREPARE stmt
PARTITION BY LIST(MOD(i, 2)) SUBPARTITION BY KEY(i) (PARTITION p1 VALUES IN (-1) (SUBPARTITION sp1, SUBPARTITION sp2), PARTITION p2 VALUES IN (0)  (SUBPARTITION sp3, SUBPARTITION sp5), PARTITION p3 VALUES IN (1)  (SUBPARTITION sp4, SUBPARTITION sp6))
PARTITION BY LIST(MOD(i, 2)) SUBPARTITION BY KEY(i) (PARTITION $too_long_name VALUES IN (-1) (SUBPARTITION sp1, SUBPARTITION sp2), PARTITION p2 VALUES IN (0)  (SUBPARTITION sp3, SUBPARTITION sp5), PARTITION p3 VALUES IN (1)  (SUBPARTITION sp4, SUBPARTITION sp6))
PARTITION BY LIST(MOD(i, 2)) SUBPARTITION BY KEY(i) (PARTITION p1 VALUES IN (-1) (SUBPARTITION sp1, SUBPARTITION $too_long_name), PARTITION p2 VALUES IN (0)  (SUBPARTITION sp3, SUBPARTITION sp5), PARTITION p3 VALUES IN (1)  (SUBPARTITION sp4, SUBPARTITION sp6))
PARTITION BY LIST(MOD(i, 2)) SUBPARTITION BY KEY(i) (PARTITION $long_name_2 VALUES IN (-1) (SUBPARTITION $long_name_3, SUBPARTITION sp2), PARTITION p2 VALUES IN (0) (SUBPARTITION sp3, SUBPARTITION sp5), PARTITION p3 VALUES IN (1) (SUBPARTITION sp4, SUBPARTITION sp6))
prepare stmt1 from 'select a from t1 where a rlike ? order by a'
execute stmt1 using @a
execute stmt1 using @a
deallocate prepare stmt1
PREPARE stmt1 FROM "SELECT a FROM t1 WHERE a=1 AND '7.0' REGEXP b LIMIT 1"
EXECUTE stmt1
EXECUTE stmt1
EXECUTE stmt1
EXECUTE stmt1
DEALLOCATE PREPARE stmt1
DO 1 regexp (multilinestring(point(1,1)))
SELECT '1' RLIKE RPAD('1', 10000, '(')
SELECT REGEXP_INSTR(e, 'pattern') FROM (VALUES ROW('Find pattern'), ROW(NULL), ROW('Find pattern')) AS v(e)
SELECT REGEXP_LIKE(e, 'pattern') FROM (VALUES ROW('Find pattern'), ROW(NULL), ROW('Find pattern')) AS v(e)
SELECT REGEXP_REPLACE(e, 'pattern', 'xyz') FROM (VALUES ROW('Find pattern'), ROW(NULL), ROW('Find pattern')) AS v(e)
SELECT REGEXP_SUBSTR(e, 'pattern') FROM (VALUES ROW('Find pattern'), ROW(NULL), ROW('Find pattern')) AS v(e)
LET $MYSQLD_DATADIR = `select @@datadir`
LET $INNODB_PAGE_SIZE = `select @@innodb_page_size`
LET $data_directory = DATA DIRECTORY='$MYSQL_TMP_DIR/alternate_dir/data'
LET $data_directory2 = DATA DIRECTORY='$MYSQL_TMP_DIR/alternate_dir/data2'
LET $index_directory = INDEX DIRECTORY='$MYSQL_TMP_DIR/alternate_dir/data'
LET $innodb_file_per_table_orig=`select @@global.innodb_file_per_table`
LET $innodb_strict_mode_orig=`select @@session.innodb_strict_mode`
(PARTITION p0 engine=InnoDB $data_directory $index_directory, PARTITION p1 engine=InnoDB $data_directory $index_directory)
(PARTITION p0 engine=InnoDB $data_directory, PARTITION p1 engine=InnoDB $data_directory2)
RENAME TABLE t1 TO t11
ENGINE = InnoDB PARTITION BY HASH (a) (PARTITION p0 engine=InnoDB $data_directory, PARTITION p1 engine=InnoDB $data_directory2)"
EXECUTE stmt1
DEALLOCATE PREPARE stmt1
PARTITION BY RANGE( YEAR(purchased) ) SUBPARTITION BY HASH( TO_DAYS(purchased) ) ( PARTITION p0 VALUES LESS THAN (1990) ( SUBPARTITION s0 $data_directory, SUBPARTITION s1 $data_directory2 ), PARTITION p1 VALUES LESS THAN (2000) ( SUBPARTITION s2 $data_directory, SUBPARTITION s3 $data_directory2 ), PARTITION p2 VALUES LESS THAN MAXVALUE ( SUBPARTITION s4 $data_directory, SUBPARTITION s5 $data_directory2 ) )
engine = innodb row_format = dynamic PARTITION BY RANGE( YEAR(purchased) ) SUBPARTITION BY HASH( TO_DAYS(purchased) ) ( PARTITION p0 VALUES LESS THAN (1990) ( SUBPARTITION s0 $data_directory, SUBPARTITION s1 $data_directory2 ), PARTITION p1 VALUES LESS THAN (2000) ( SUBPARTITION s2 $data_directory, SUBPARTITION s3 $data_directory2 ), PARTITION p2 VALUES LESS THAN MAXVALUE ( SUBPARTITION s4 $data_directory, SUBPARTITION s5 $data_directory2 ) )
ENGINE = InnoDB DATA DIRECTORY = '$MYSQL_TMP_DIR/alternate_dir/data_table' PARTITION BY RANGE (a) SUBPARTITION BY HASH (a) SUBPARTITIONS 3 (PARTITION p0 VALUES LESS THAN (10) (SUBPARTITION sp0, SUBPARTITION sp1 DATA DIRECTORY='$MYSQL_TMP_DIR/alternate_dir/data_subpart', SUBPARTITION sp2), PARTITION p1 VALUES LESS THAN (20) DATA DIRECTORY = '$MYSQL_TMP_DIR/alternate_dir/data_part' (SUBPARTITION sp3, SUBPARTITION sp4 DATA DIRECTORY='$MYSQL_TMP_DIR/alternate_dir/data_subpart', SUBPARTITION sp5), PARTITION p2 VALUES LESS THAN (30) (SUBPARTITION sp6, SUBPARTITION sp7 DATA DIRECTORY='$MYSQL_TMP_DIR/alternate_dir/data_subpart', SUBPARTITION sp8))
(a int not null, primary key (a)) ENGINE=InnoDB PARTITION BY KEY (a) (PARTITION p0 DATA DIRECTORY '$MYSQL_TMP_DIR/alternate_dir/data_part', PARTITION p1)
EVAL SET GLOBAL innodb_file_per_table=$innodb_file_per_table_orig
EVAL SET SESSION innodb_strict_mode=$innodb_strict_mode_orig
EVAL SET @@default_storage_engine=$old_default_storage_engine
perl
my $search_file=     $ENV{'SEARCH_FILE'}     or die "SEARCH_FILE not set"
my $search_pattern=  $ENV{'SEARCH_PATTERN'}  or die "SEARCH_PATTERN not set"
my $search_pattern1= $ENV{'SEARCH_PATTERN1'}  or die "SEARCH_PATTERN1 not set"
my $minimum_matches= $ENV{'MINIMUM_MATCHES'} or die "MINIMUM_MATCHES not set"
open(FILE, "$search_file") or die("Unable to open '$search_file': $!\n")
my $count = 0
while (<FILE>) { if (m{$search_pattern}) { ++$count; } if (m{$search_pattern1}) { die ("# ERROR: The file '$search_file' contains \n". "#        the unexpected pattern '$search_pattern1' at $_\n")
} } close(FILE)
if ( $count < $minimum_matches ) { die("# ERROR: The file '$search_file' does not contain \n". "#        the expected pattern '$search_pattern' often enough.\n". "#        Found: $count    Expected: >= $minimum_matches")
} set default_storage_engine=innodb
source 'include/function_defaults.inc'
call mtr.add_suppression('Failed to open optimizer cost constant tables')
RENAME TABLE mysql.engine_cost TO mysql.engine_cost_renamed
RENAME TABLE mysql.engine_cost_renamed TO mysql.engine_cost
call mtr.add_suppression('Unknown cost constant "lunch_cost" in mysql.server_cost table')
call mtr.add_suppression('Invalid value for cost constant "row_evaluate_cost" in mysql.server_cost table: -1.0')
call mtr.add_suppression('Invalid value for cost constant "key_compare_cost" in mysql.server_cost table: 0.0')
call mtr.add_suppression('Invalid value for cost constant "io_block_read_cost" for "default" storage engine and device type 0 in mysql.engine_cost table: 0.0')
call mtr.add_suppression('Unknown storage engine "Falcon" in mysql.engine_cost table')
call mtr.add_suppression('Invalid device type -1 for "InnoDB" storage engine for cost constant "io_block_read_cost" in mysql.engine_cost table')
call mtr.add_suppression('Unknown cost constant "lunch_cost" in mysql.engine_cost table')
CREATE TABLE t1 (i int, KEY USING HASH (i)) ENGINE=MEMORY
CREATE TABLE t1 (i int, KEY USING BTREE (i)) ENGINE=MEMORY
CREATE TABLE t1 (i int, KEY USING BTREE (i)) ENGINE=MyISAM
CREATE TABLE t1 (i int, KEY USING BTREE (i)) ENGINE=MyISAM
disable_query_log
enable_query_log
INSERT IGNORE INTO t1 SELECT REPEAT('a',11)
CREATE TABLE t1 AS SELECT REPEAT(' ', 16) AS a LIMIT 0
CREATE TABLE t1 AS SELECT REPEAT(' ', 10) AS a LIMIT 0
CREATE TABLE t1 AS SELECT REPEAT (' ', 10) AS a LIMIT 0
CREATE TABLE t1 AS SELECT REPEAT (' ', 10) AS a LIMIT 0
CREATE TABLE t1 AS SELECT REPEAT(' ', 10) AS a LIMIT 0
perl
my $outf= $ENV{'OUTF'} or die "OUTF not set"
open(FILE, "$outf") or die("Unable to open $outf: $!\n")
my $count_error= grep(/\[ERROR\] \[[^]]*\] \[[^]]*\] Syntax error at '\[strength tertiary\]'/gi,<FILE>)
print "Occurances : $count_error\n"
close(FILE)
select _rowid,t1._rowid,skey,sval from t1
select * from t1 ignore index (primary) where tt like 'Aa%'
select * from t1 ignore index (primary) where tt like 'AA%'
CREATE TABLE t1 ENGINE=INNODB AS SELECT repeat('a', 5) AS s1 LIMIT 0
CREATE TABLE t1 ENGINE=FALCON AS SELECT repeat('a', 5) AS s1 LIMIT 0
CREATE TABLE t1 ENGINE=MARIA AS SELECT repeat('a', 5) AS s1 LIMIT 0
call mtr.add_suppression(".*The system table mysql.global_grants.*")
call mtr.add_suppression("ACL table mysql.global_grants missing. Some operations may fail.")
call mtr.add_suppression("An empty or illegal privilege identifier was ignored when global privileges were read from disk.")
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR u2@localhost
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR `u1`@`%`
SHOW GRANTS FOR `u1`@`%`
SHOW GRANTS FOR `u1`@`localhost`
SHOW GRANTS FOR `u1`@`localhost`
SHOW GRANTS FOR u1
SHOW GRANTS FOR u1@localhost
SHOW GRANTS FOR u1
SHOW GRANTS FOR u1
CONNECTION default
CONNECTION default
CONNECTION default
DISCONNECT con_admin_test
CONNECTION default
SHOW GRANTS FOR u1@localhost
CONNECTION default
CONNECTION default
DISCONNECT con_admin_test
CONNECTION default
SHOW GRANTS FOR u1@localhost
CONNECTION default
CONNECTION con_admin_test
DISCONNECT con_admin_test
CONNECTION default
SHOW GRANTS FOR u1 using r1
SHOW GRANTS FOR u1 using r2
SHOW GRANTS FOR u1 using r1
SHOW GRANTS FOR u1
SHOW GRANTS FOR u1
STOP SLAVE
DISCONNECT con_rep_slave_test
CONNECTION default
DISCONNECT con_rep_slave_test
CONNECTION default
CONNECTION default
SHOW GRANTS FOR u1
SHOW GRANTS FOR u2
SHOW GRANTS FOR u1
SHOW GRANTS FOR u1
SHOW GRANTS FOR u1
SHOW GRANTS FOR u1
SHOW GRANTS FOR u1
SHOW GRANTS FOR u1
SHOW GRANTS FOR u1
SHOW GRANTS FOR u1
SHOW GRANTS FOR u1
SHOW GRANTS FOR u1
SHOW GRANTS FOR u1
SHOW GRANTS FOR u1
SET @old_50915_lc_time_names := @@lc_time_names
query_vertical SELECT host,user,plugin,authentication_string,account_locked FROM mysql.user WHERE USER='user1'
query_vertical SELECT host,user,plugin,authentication_string,account_locked FROM mysql.user WHERE USER='user1'
query_vertical SELECT host,user,plugin,authentication_string,account_locked FROM mysql.user WHERE USER='user2'
query_vertical SELECT host,user,plugin,authentication_string,account_locked FROM mysql.user WHERE USER='user2'
query_vertical SELECT host,user,plugin,authentication_string,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='user3'
query_vertical SELECT host,user,plugin,authentication_string,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='user4'
query_vertical SELECT host,user,plugin,authentication_string,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='user3'
query_vertical SELECT host,user,plugin,authentication_string,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='user4'
query_vertical SELECT user,plugin,authentication_string,account_locked FROM mysql.user WHERE USER='u1'
query_vertical SELECT user,plugin,authentication_string,account_locked FROM mysql.user WHERE USER='u1'
query_vertical SELECT user,plugin,authentication_string,account_locked FROM mysql.user WHERE USER='u2'
query_vertical SELECT user,plugin,authentication_string,account_locked FROM mysql.user WHERE USER='u2'
query_vertical SELECT user,plugin,authentication_string,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='u3'
ALTER USER u3@localhost IDENTIFIED WITH 'sha256_password' ACCOUNT LOCK ACCOUNT UNLOCK
query_vertical SELECT user,plugin,authentication_string,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='u3'
query_vertical SELECT user,plugin,authentication_string,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='u4'
ALTER USER u4@localhost IDENTIFIED WITH 'sha256_password' BY 'auth_string' ACCOUNT UNLOCK
query_vertical SELECT user,plugin,authentication_string,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='u4'
query_vertical SELECT user,plugin,authentication_string,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='user4'
query_vertical SELECT user,plugin,authentication_string,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='user6'
ALTER USER user6@localhost IDENTIFIED WITH 'mysql_native_password' ACCOUNT LOCK ACCOUNT UNLOCK
query_vertical SELECT user,plugin,authentication_string,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='user6'
query_vertical SELECT user,plugin,authentication_string,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='user7'
ALTER USER user7@localhost IDENTIFIED WITH 'sha256_password' BY 'auth_string_sha256' PASSWORD EXPIRE NEVER ACCOUNT LOCK
query_vertical SELECT user,plugin,authentication_string,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='user7'
query_vertical SELECT user,plugin,authentication_string,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='user8'
ALTER USER user8@localhost IDENTIFIED WITH 'mysql_native_password' BY 'new_auth_string' ACCOUNT UNLOCK PASSWORD EXPIRE
query_vertical SELECT user,plugin,authentication_string,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='user8'
query_vertical SELECT user,plugin,authentication_string,ssl_type,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='u5'
query_vertical SELECT user,plugin,authentication_string,ssl_type,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='u6'
query_vertical SELECT user,plugin,authentication_string,ssl_type,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='u6'
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,password_expired,password_lifetime,account_locked FROM mysql.user WHERE USER='u7'
ALTER USER u7@localhost IDENTIFIED WITH 'mysql_native_password' PASSWORD EXPIRE DEFAULT ACCOUNT LOCK
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,password_expired,password_lifetime,account_locked FROM mysql.user WHERE USER='u7'
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,password_expired,password_lifetime,account_locked FROM mysql.user WHERE USER='u8'
ALTER USER u8@localhost IDENTIFIED WITH 'sha256_password' BY 'auth_string' REQUIRE ISSUER '/C=SE/ST=Stockholm/L=Stockholm/O=Oracle/OU=MySQL/CN=CA' PASSWORD EXPIRE NEVER ACCOUNT LOCK
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,password_expired,password_lifetime,account_locked FROM mysql.user WHERE USER='u8'
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,password_expired,password_lifetime,account_locked FROM mysql.user WHERE USER='u9'
ALTER USER u9@localhost IDENTIFIED WITH 'sha256_password' BY 'auth_string' ACCOUNT UNLOCK
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,password_expired,password_lifetime,account_locked FROM mysql.user WHERE USER='u9'
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,password_expired,password_lifetime,account_locked FROM mysql.user WHERE USER='u10'
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,password_expired,password_lifetime,account_locked FROM mysql.user WHERE USER='u10'
query_vertical SELECT user,plugin,authentication_string,max_questions,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='u11'
query_vertical SELECT user,plugin,authentication_string,max_questions,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='u11'
query_vertical SELECT user,plugin,authentication_string,max_questions,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='u11'
query_vertical SELECT user,plugin,authentication_string,max_questions,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='u12'
query_vertical SELECT user,plugin,authentication_string,max_questions,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='u12'
query_vertical SELECT user,plugin,authentication_string,max_questions,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='u12'
query_vertical SELECT user,plugin,authentication_string,max_connections,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='u13'
query_vertical SELECT user,plugin,authentication_string,max_connections,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='u13'
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,max_user_connections,password_expired,password_lifetime,account_locked FROM mysql.user WHERE USER='u14'
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,max_user_connections,password_expired,password_lifetime,account_locked FROM mysql.user WHERE USER='u14'
query_vertical SELECT user,plugin,authentication_string,account_locked FROM mysql.user WHERE USER='u15'
query_vertical SELECT user,plugin,authentication_string,account_locked FROM mysql.user WHERE USER='u16'
query_vertical SELECT user,plugin,authentication_string,account_locked FROM mysql.user WHERE USER='u17'
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,max_questions,max_user_connections,password_expired,password_lifetime, account_locked FROM mysql.user WHERE USER='u18'
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,max_questions,max_user_connections,password_expired,password_lifetime, account_locked FROM mysql.user WHERE USER='u19'
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,max_questions,max_user_connections,password_expired,password_lifetime, account_locked FROM mysql.user WHERE USER='u20'
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,max_questions,max_user_connections,password_expired,password_lifetime, account_locked FROM mysql.user WHERE USER='u21'
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher, x509_issuer,x509_subject,max_questions,max_user_connections,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='u22'
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher, x509_issuer,x509_subject,max_questions,max_user_connections,password_expired, password_lifetime,account_locked FROM mysql.user WHERE USER='u23'
ALTER  USER u18@localhost, u19@localhost IDENTIFIED BY 'auth_string', u20@localhost IDENTIFIED WITH 'sha256_password', u21@localhost IDENTIFIED WITH 'sha256_password' BY 'auth_string', u22@localhost IDENTIFIED WITH 'mysql_native_password', u23@localhost IDENTIFIED WITH 'mysql_native_password' AS '*318C29553A414C4A571A077BC9E9A9F67D5E5634' REQUIRE CIPHER "DHE-RSA-AES256-SHA" ISSUER "/C=SE/ST=Stockholm/L=Stockholm/O=Oracle/OU=MySQL/CN=CA" ACCOUNT UNLOCK
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,max_questions,max_user_connections,password_expired,password_lifetime, account_locked FROM mysql.user WHERE USER='u18'
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,max_questions,max_user_connections,password_expired,password_lifetime, account_locked FROM mysql.user WHERE USER='u19'
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,max_questions,max_user_connections,password_expired,password_lifetime, account_locked FROM mysql.user WHERE USER='u20'
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,max_questions,max_user_connections,password_expired,password_lifetime, account_locked FROM mysql.user WHERE USER='u21'
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,max_questions,max_user_connections,password_expired,password_lifetime, account_locked FROM mysql.user WHERE USER='u22'
query_vertical SELECT user,plugin,authentication_string,ssl_type,ssl_cipher,x509_issuer, x509_subject,max_questions,max_user_connections,password_expired,password_lifetime, account_locked FROM mysql.user WHERE USER='u23'
CALL test.p1()
CALL test.p1()
CREATE TABLE t2 AS SELECT INSERT(1133,3,0,22) FROM t1
CREATE TABLE t2 AS SELECT REPEAT(1,2) FROM t1
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
KILL QUERY @thread_id
CREATE TABLE t1 (a INT) /*!50100 PARTITION BY HASH (a) /* Test of multi-line comment */ PARTITIONS 5 */
RENAME TABLE general_log TO renamed_general_log
RENAME TABLE test.bug49823 TO general_log
RENAME TABLE renamed_general_log TO general_log
SHOW GRANTS FOR some_user_name@host_1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890
GRANT PROXY ON root@localhost TO some_user_name@host_1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890
GRANT PROXY ON some_user_name@host_1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890 TO root@localhost
SHOW GRANTS FOR some_user_name@host_1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890
call mtr.add_suppression("2001:db8::6:6")
PREPARE stmt FROM "SHOW COLUMNS FROM t1"
EXECUTE stmt
EXECUTE stmt
EXECUTE stmt
DEALLOCATE PREPARE stmt
FROM performance_schema.status_by_thread WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0 AND THREAD_ID IN (SELECT thread_id from test.thread_to_monitor)
CREATE TABLE t3 (a int DEFAULT 10, b varchar(64) DEFAULT "Default", c varchar(64) DEFAULT "Default", d int unsigned DEFAULT 9, e varchar(255) DEFAULT "Default-filler.filler.filler.", PRIMARY KEY (a,b,c,d)) charset latin1 PARTITION BY RANGE COLUMNS (a, b) SUBPARTITION BY LINEAR KEY (d, c) SUBPARTITIONS 4 (PARTITION pNeg VALUES LESS THAN (0, ""), PARTITION `p0-9` VALUES LESS THAN (9, MAXVALUE), PARTITION p10 VALUES LESS THAN (10, MAXVALUE), PARTITION `p11-100` VALUES LESS THAN (99, MAXVALUE))
LOCK TABLES t3 WRITE
UNLOCK TABLES
CREATE PROCEDURE sp_insert_partition(p CHAR(16), a INT, b CHAR(16)) BEGIN SET @str = CONCAT("INSERT INTO test.t1 PARTITION(", p, ") VALUES (?, ?)"); SET @x = a, @y = b; PREPARE stmt FROM @str; EXECUTE stmt USING @x, @y; DEALLOCATE PREPARE stmt; END
CREATE PROCEDURE sp_select_partition(p CHAR(16)) BEGIN SET @str = CONCAT("SELECT * FROM test.t1 PARTITION(", p, ")"); PREPARE stmt FROM @str; EXECUTE stmt; DEALLOCATE PREPARE stmt; END
DO (SELECT a FROM t1)
DO (SELECT @x:= b FROM t1 WHERE a = 5)
DO (SELECT @x:= b FROM t1 WHERE a = 5 or a = 1 ORDER BY b LIMIT 1)
INTO OUTFILE '$MYSQLTEST_VARDIR/tmp/t1.part1'
PREPARE stmt FROM 'UPDATE t1 AS P1 INNER JOIN (SELECT N FROM t1 GROUP BY N HAVING COUNT(M) > 1) AS P2 ON P1.N = P2.N SET P1.M = 2'
EXECUTE stmt
DEALLOCATE PREPARE stmt
PREPARE stmt FROM 'SELECT * FROM t1 WHERE N = 2'
EXECUTE stmt
CREATE FUNCTION sf_a_from_t1b_d(s varchar(128)) RETURNS INT DETERMINISTIC BEGIN DECLARE i INT; SELECT a INTO i FROM t1 where b = s; RETURN i; END
CREATE FUNCTION sf_a_from_t1b(s varchar(128)) RETURNS INT BEGIN DECLARE i INT; SELECT a INTO i FROM t1 where b = s; RETURN i; END
performance_schema.data_locks WHERE OBJECT_SCHEMA='mysql' AND OBJECT_NAME='tables' and LOCK_STATUS='WAITING'
load index into cache t1, t2 key (primary,b) ignore leaves
load index into cache t3, t2 key (primary,b)
rename table t1 to t1_1, t9 to t9_1
rename table t1 to t1_2, t9 to t9_2
SELECT VARIANCE(b) over w `var`, AVG(b) OVER w `avg`, SUM(b) OVER w `sum`, b, COUNT(b) OVER w count FROM t1 WINDOW w as (ORDER BY b ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)
SELECT VARIANCE(b) over w `var`, AVG(b) OVER w `avg`, SUM(b) OVER w `sum`, b, count(b) OVER w count FROM t1 WINDOW w as (ORDER BY b ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)
SELECT VARIANCE(b) over w `var`, AVG(b) OVER w `avg`, SUM(b) OVER w `sum`, b, count(b) OVER w count, LAST_VALUE(b) OVER w lastval FROM t1 WINDOW w as (ORDER BY b ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)
SELECT VARIANCE(b) over w `var`, FIRST_VALUE(b) over w fv, AVG(b) OVER w `avg`, SUM(b) OVER w `sum`, b, count(b) OVER w count FROM t1 WINDOW w as (ORDER BY b ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING)
DO ST_CROSSES(@g,SUM(SHA(@g))OVER())
DO UNHEX(SUM(@g)OVER())
DO BIT_LENGTH(AVG(@f)OVER())
DO COMPRESS(SUM(' >')OVER())
DO LTRIM(AVG(LOG2(@c))OVER())
DO (~(SUM(@f)OVER()))
DO IS_UUID(SUM(@e)OVER())
DO TO_BASE64(AVG(@d)OVER())
PREPARE stmt FROM 'SELECT NTILE(39) OVER w1 FROM t WINDOW w1 AS(ORDER BY a)'
EXECUTE stmt
PREPARE stmt FROM 'SELECT NTILE(39) OVER w1 FROM t WINDOW w1 AS(ORDER BY b)'
EXECUTE stmt
SELECT JSON_ARRAY(JSON_ARRAYAGG(CAST('' AS JSON)) OVER (), '')
PREPARE stmt FROM "SELECT RANK() OVER (ORDER BY a) FROM t1 GROUP BY a"
EXECUTE stmt
EXECUTE stmt
CREATE TABLE t1(id INT) PARTITION BY RANGE (id) (PARTITION p0 VALUES LESS THAN (100), PARTITION pmax VALUES LESS THAN (MAXVALUE))
load data infile '../../std_data/loaddata1.dat' ignore into table t1 fields terminated by ','
load data infile '../../std_data/loaddata1.dat' into table t1 fields terminated by ',' IGNORE 2 LINES
load data infile '../../std_data/loaddata1.dat' ignore into table t1 fields terminated by ',' LINES STARTING BY ',' (b,c,d)
load data infile '../../std_data/loaddata2.dat' ignore into table t1 fields terminated by ',' enclosed by ''''
load data infile '../../std_data/loaddata3.dat' ignore into table t1 fields terminated by '' enclosed by '' ignore 1 lines
load data infile '../../std_data/loaddata4.dat' ignore into table t1 fields terminated by '' enclosed by '' lines terminated by '' ignore 1 lines
disable_query_log
enable_query_log
remove_file $MYSQLTEST_VARDIR/tmp/t1
disable_query_log
FIELDS TERMINATED BY '' OPTIONALLY ENCLOSED BY '' LINES TERMINATED BY '\r\n' FROM t1
FIELDS TERMINATED BY '' OPTIONALLY ENCLOSED BY '' LINES TERMINATED BY '\r\n'
enable_query_log
remove_file $MYSQLTEST_VARDIR/tmp/t1
load data infile '../../std_data/loaddata_dq.dat' into table t1 fields terminated by ',' enclosed by '"' escaped by '"' (a,b)
cat_file $MYSQLTEST_VARDIR/tmp/t1
remove_file $MYSQLTEST_VARDIR/tmp/t1
load data infile '../../std_data/rpl_loaddata.dat' into table t1 (a, @b) set b=@b+10, c=concat("b=",@b)
load data infile '../../std_data/rpl_loaddata.dat' into table t1 (a, @b) set c= if(a is null,"oops",a)
set @c:=123
load data infile '../../std_data/rpl_loaddata.dat' into table t1 (@a, b) set c= if(@a is null,@c,b)
load data infile '../../std_data/rpl_loaddata.dat' into table t1 (@a, @b)
load data infile '../../std_data/rpl_loaddata.dat' ignore into table t1 set c=b
load data infile '../../std_data/loaddata5.dat' into table t1 fields terminated by '' enclosed by '' (a, b) set c="Wow"
load data infile '../../std_data/loaddata5.dat' into table t1 fields terminated by '' enclosed by '' (a, b) set c=concat(a,"+",b,"+",@c,"+",b,"+",if(c is null,"NIL",c))
load data infile '../../std_data/loaddata5.dat' into table t1 fields terminated by '' enclosed by '' (a, @b)
load data infile '../../std_data/rpl_loaddata.dat' into table t1 (@dummy,@n) set a= @n, c= (select str from t2 where num=@n)
disable_query_log
enable_query_log
remove_file $MYSQLTEST_VARDIR/tmp/t1
disable_query_log
enable_query_log
remove_file $MYSQLTEST_VARDIR/tmp/t2
disable_query_log
FIELDS TERMINATED BY '' OPTIONALLY ENCLOSED BY '' LINES TERMINATED BY '\r\n' FROM t2
FIELDS TERMINATED BY '' OPTIONALLY ENCLOSED BY '' LINES TERMINATED BY '\r\n'
enable_query_log
remove_file $MYSQLTEST_VARDIR/tmp/t2
cat_file $MYSQLTEST_VARDIR/tmp/t1
echo EOF
remove_file $MYSQLTEST_VARDIR/tmp/t1
LOAD DATA INFILE '../../std_data/bug35469.dat' INTO TABLE v1 FIELDS ESCAPED BY '\\' TERMINATED BY ',' ENCLOSED BY '"' LINES TERMINATED BY '\n' (c1, c2)
LOAD DATA INFILE '../../std_data/bug35469.dat' INTO TABLE v2 FIELDS ESCAPED BY '\\' TERMINATED BY ',' ENCLOSED BY '"' LINES TERMINATED BY '\n' (c1, c2)
LOAD DATA INFILE '../../std_data/bug35469.dat' INTO TABLE v2 FIELDS ESCAPED BY '\\' TERMINATED BY ',' ENCLOSED BY '"' LINES TERMINATED BY '\n' (c0, c2)
LOAD DATA INFILE '../../std_data/bug35469.dat' INTO TABLE v3 FIELDS ESCAPED BY '\\' TERMINATED BY ',' ENCLOSED BY '"' LINES TERMINATED BY '\n' (d1, d2)
LOAD DATA INFILE 't-1' INTO TABLE t1
LOAD DATA INFILE 't-1' INTO TABLE t1
remove_file $MYSQLD_DATADIR/test/t-1
LOAD DATA INFILE 't1.txt' IGNORE INTO TABLE t1 SET col0=col0
remove_file $MYSQLD_DATADIR/test/t1.txt
dirty_close con1
EVAL SELECT 0xE1C330 INTO OUTFILE 't1.dat'
LOAD DATA INFILE 't1.dat' IGNORE INTO TABLE t1 CHARACTER SET utf8
remove_file $MYSQLD_DATADIR/test/t1.dat
LOAD DATA LOCAL INFILE '' REPLACE INTO TABLE v1
FIELDS TERMINATED BY 't' LINES TERMINATED BY ''
LOAD DATA INFILE '../../std_data/bug20683959loaddata.txt' INTO TABLE t1
LOAD DATA INFILE '../../std_data/bug20683959loaddata.txt' INTO TABLE t1
LOAD DATA INFILE 'test.dat' INTO TABLE v(a, d)
LOAD DATA INFILE 'test.dat' INTO TABLE v(@a, @d) SET a= @a, d= @d
LOAD DATA INFILE '../../std_data/loaddata_utf8.dat' INTO TABLE t1 CHARACTER SET utf8mb4
LOAD DATA INFILE '../../std_data/loaddata7.dat' INTO TABLE t1 CHARACTER SET gb18030
LOAD DATA INFILE '../../std_data/loaddata_utf8.dat' INTO TABLE t1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
LOAD DATA INFILE '../../std_data/loaddata_utf8.dat' INTO TABLE t1 ()
LOAD DATA INFILE '../../std_data/loaddata_incomplete_mb.dat' INTO TABLE t1 IGNORE 20 LINES
LOAD DATA INFILE '../../std_data/loaddata_incomplete_escape.dat' INTO TABLE t1 IGNORE 20 LINES
CREATE PROCEDURE p1() LOAD DATA INFILE '../../std_data/loaddata_utf8.dat' INTO TABLE t1
LOAD DATA LOCAL INFILE '../../std_data/loaddata_utf8.dat' INTO TABLE t1
LOAD DATA INFILE '../../std_data/loaddata_utf8.dat' INTO TABLE t2 FIELDS TERMINATED BY '' LINES TERMINATED BY ''
LOAD DATA INFILE '../../std_data/loaddata_utf8.dat' INTO TABLE t3 (a) SET i = NULL
LOAD DATA INFILE '../../std_data/x_y_data.csv' INTO TABLE t1 FIELDS TERMINATED BY ',' (x, y)
LOAD DATA INFILE '../../std_data/x_y_data.csv' INTO TABLE t1 FIELDS TERMINATED BY ',' (x, y) SET g = ST_SRID(POINT(x, y), 4326)
CREATE TABLE t1 ( json_col JSON , KEY json_col ((CAST(json_col -> '$' AS UNSIGNED ARRAY))) )
SHOW CREATE DATABASE mysqltest1
SHOW CREATE DATABASE mysqltest2
show create database mysqltest2
ALTER DATABASE `` DEFAULT CHARACTER SET latin2
UNLOCK TABLES
LOAD DATA INFILE '../../std_data/wl6030_2.dat' INTO TABLE t1 FIELDS TERMINATED BY ',' ENCLOSED BY '"'
LOAD DATA INFILE '../../std_data/wl6030_2.dat' IGNORE INTO TABLE t1 FIELDS TERMINATED BY ',' ENCLOSED BY '"'
LOAD DATA INFILE '../../std_data/rpl_loaddata.dat' INTO TABLE t2 (a, @b) SET b= @b + 2
prepare stmt from " SELECT (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((( (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((( (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((( 1 )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) "
execute stmt
create function func_overflow() returns int BEGIN DECLARE x int default 0; BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN SET x=x+1; SET x=x+2; SET x=x+3; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; return x; END
create trigger trigger_overflow before insert on table_overflow for each row BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN BEGIN SET NEW.b := NEW.a; SET NEW.b := NEW.b + 1; SET NEW.b := NEW.b + 2; SET NEW.b := NEW.b + 3; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END;  END; END
CREATE PROCEDURE proc_35577() BEGIN DECLARE z_done INT DEFAULT 0; DECLARE t_done VARCHAR(5000); outer_loop: LOOP IF t_done=1  THEN LEAVE outer_loop; END IF; inner_block:BEGIN DECLARE z_done INT DEFAULT  0; SET z_done = 0; inner_loop: LOOP IF z_done=1  THEN LEAVE inner_loop; END IF; IF (t_done = 'a') THEN IF (t_done <> 0) THEN IF ( t_done > 0) THEN IF (t_done = 'a') THEN SET t_done = 'a'; ELSEIF (t_done = 'a') THEN SET t_done = 'a'; ELSEIF(t_done = 'a') THEN SET t_done = 'a'; ELSEIF(t_done = 'a') THEN SET t_done = 'a'; ELSEIF(t_done = 'a') THEN SET t_done = 'a'; ELSEIF(t_done = 'a') THEN SET t_done = 'a'; ELSEIF(t_done = 'a') THEN SET t_done = 'a'; ELSEIF(t_done = 'a') THEN SET t_done = 'a'; END IF; END IF; END IF; END IF; END LOOP inner_loop; END inner_block; END LOOP outer_loop; END
create procedure p_37269() begin declare done int default 0; declare varb int default 0; declare vara int default 0; repeat select now(); until done end repeat; while varb do select now(); begin select now(); repeat select now(); until done end repeat; if vara then select now(); repeat select now(); loop select now(); end loop; repeat select now(); label1: while varb do select now(); end while label1; if vara then select now(); repeat select now(); until done end repeat; begin select now(); while varb do select now(); label1: while varb do select now(); end while label1; if vara then select now(); while varb do select now(); loop select now(); end loop; repeat select now(); loop select now(); while varb do select now(); end while; repeat select now(); label1: loop select now(); if vara then select now(); end if; end loop label1; until done end repeat; end loop; until done end repeat; end while; end if; end while; end; end if; until done end repeat; until done end repeat; end if; end; end while; end
create procedure p_37228 () BEGIN DECLARE v INT DEFAULT 123; IF (v > 1) THEN SET v = 1; ELSEIF (v < 10) THEN SET v = 10; ELSEIF (v < 11) THEN SET v = 11; ELSEIF (v < 12) THEN SET v = 12; ELSEIF (v < 13) THEN SET v = 13; ELSEIF (v < 14) THEN SET v = 14; ELSEIF (v < 15) THEN SET v = 15; ELSEIF (v < 16) THEN SET v = 16; ELSEIF (v < 17) THEN SET v = 17; ELSEIF (v < 18) THEN SET v = 18; ELSEIF (v < 19) THEN SET v = 19; ELSEIF (v < 20) THEN SET v = 20; ELSEIF (v < 21) THEN SET v = 21; ELSEIF (v < 22) THEN SET v = 22; ELSEIF (v < 23) THEN SET v = 23; ELSEIF (v < 24) THEN SET v = 24; ELSEIF (v < 25) THEN SET v = 25; ELSEIF (v < 26) THEN SET v = 26; ELSEIF (v < 27) THEN SET v = 27; ELSEIF (v < 28) THEN SET v = 28; ELSEIF (v < 29) THEN SET v = 29; ELSEIF (v < 30) THEN SET v = 30; ELSEIF (v < 31) THEN SET v = 31; ELSEIF (v < 32) THEN SET v = 32; ELSEIF (v < 33) THEN SET v = 33; ELSEIF (v < 34) THEN SET v = 34; ELSEIF (v < 35) THEN SET v = 35; ELSEIF (v < 36) THEN SET v = 36; ELSEIF (v < 37) THEN SET v = 37; ELSEIF (v < 38) THEN SET v = 38; ELSEIF (v < 39) THEN SET v = 39; END IF; END
call mtr.add_suppression("filter_rules: *")
call mtr.add_suppression(".*No error message, or error message of non-string type. This is almost certainly a bug!")
call mtr.add_suppression(".*using log_message.. with .*")
call mtr.add_suppression(".*System schema directory does not exist.")
call mtr.add_suppression(".* Simulated")
call mtr.add_suppression(".*aaaaaaaaaaaaa")
perl
use File::stat
my $file= $ENV{'GREP_FILE'} or die("grep file not set")
my $pattern="^20"
my $stime= $ENV{'GREP_START'}
open(FILE, "$file") or die("Unable to open $file: $!")
while (<FILE>) { my $line = $_
my $ts = 0
if ($stime == 0) { print "$line"
} elsif ($line =~ /$pattern/) { $line =~ /([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])T([0-9][0-9]):([0-9][0-9]):([0-9][0-9])\.([0-9][0-9][0-9][0-9][0-9][0-9])[-+Z][0-9:]* *[0-9]* *?(\[.*)
$ts=$1.$2.$3.$4.$5.$6.$7
if ($ts >= $stime) { $stime= 0
} } } close(FILE)
perl
use File::stat
my $file= $ENV{'GREP_FILE'} or die("grep file not set")
open(FILE, "$file") or die("Unable to open $file: $!")
while (<FILE>) { my $line = $_
$line =~ s/"source_line" : \d+, //
$line =~ s/"err_code" : \d+, //
print "$line"
} close(FILE)
perl
use File::stat
my $file= $ENV{'GREP_FILE'} or die("grep file not set")
open(FILE, "$file") or die("Unable to open $file: $!")
while (<FILE>) { my $line = $_
$line =~ s/"source_line" : \d+, //
$line =~ s/"err_code" : \d+, //
print "$line"
} close(FILE)
perl
use File::stat
my $file= $ENV{'GREP_FILE'} or die("grep file not set")
my $second_run=0
my $seen_inno=0
my $post_inno=0
open(FILE, "$file") or die("Unable to open $file: $!")
while (<FILE>) { my $line = $_
if ($line =~ /"ER_SERVER_SHUTDOWN_COMPLETE"/) { $second_run=1; } if ($second_run > 0) { if (!($line =~ /"buffered" : /) && ($line =~ /"subsystem" : "InnoDB"/)) { $seen_inno++; } if (($line =~ /"buffered" : /) && ($seen_inno > 0)) { $post_inno++; }}} close(FILE)
if ($post_inno > 0) { print "FAIL: $post_inno buffered lines seen after $seen_inno unbuffered ones.\n"; } else { print "SUCCESS!\n"; } CREATE TABLE t1 ( i1 INTEGER, i2 INTEGER, i3 INTEGER, KEY(i1,i2) ) ENGINE=InnoDB
SET cost_value=$row_evaluate_cost WHERE cost_name="row_evaluate_cost"
SET cost_value=$key_compare_cost WHERE cost_name="key_compare_cost"
SET cost_value=$memory_temptable_create_cost WHERE cost_name="memory_temptable_create_cost"
SET cost_value=$memory_temptable_row_cost WHERE cost_name="memory_temptable_row_cost"
SET cost_value=$disk_temptable_create_cost WHERE cost_name="disk_temptable_create_cost"
SET cost_value=$disk_temptable_row_cost WHERE cost_name="disk_temptable_row_cost"
SET cost_value=$memory_block_read_cost WHERE cost_name="memory_block_read_cost"
SET cost_value=$io_block_read_cost WHERE cost_name="io_block_read_cost"
SET cost_value=$row_evaluate_cost WHERE cost_name="row_evaluate_cost"
SET cost_value=$key_compare_cost WHERE cost_name="key_compare_cost"
SET cost_value=$memory_temptable_create_cost WHERE cost_name="memory_temptable_create_cost"
SET cost_value=$memory_temptable_row_cost WHERE cost_name="memory_temptable_row_cost"
SET cost_value=$disk_temptable_create_cost WHERE cost_name="disk_temptable_create_cost"
SET cost_value=$disk_temptable_row_cost WHERE cost_name="disk_temptable_row_cost"
SET cost_value=$memory_block_read_cost WHERE cost_name="memory_block_read_cost"
SET cost_value=$io_block_read_cost WHERE cost_name="io_block_read_cost"
INSERT INTO t4 SELECT c31, CONCAT(c32, REPEAT('a', @max_allowed_packet-1)) FROM t3
UPDATE t3 SET c32= CONCAT(c32, REPEAT('a', @max_allowed_packet-1))
SHOW GRANTS FOR 'user2'@'%'
SHOW GRANTS FOR 'user2'@'%'
create table t1 ( c1 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c2 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c3 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c4 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c5 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c6 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c7 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c8 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c9 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c10 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c11 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c12 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c13 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c14 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c15 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c16 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c17 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c18 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c19 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c20 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c21 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c22 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c23 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c24 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c25 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c26 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c27 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c28 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c29 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c30 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c31 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c32 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c33 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c34 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c35 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c36 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c37 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c38 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c39 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c40 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c41 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c42 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c43 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c44 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c45 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c46 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c47 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c48 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c49 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c50 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c51 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c52 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c53 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c54 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c55 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c56 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c57 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c58 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c59 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c60 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c61 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', c62 INTEGER COMMENT 'abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij', create table t1 (a int) engine=myisam
create table `t``1`(a int) engine=myisam
drop table `t``1`, `t 1`
RETURNS STRING SONAME "$UDF_EXAMPLE_LIB"
RETURNS REAL SONAME "$UDF_EXAMPLE_LIB"
WHERE udf_library='$UDF_EXAMPLE_LIB' ORDER BY UDF_NAME
prepare s from "select myfunc_double(?)"
execute s using @one
deallocate prepare s
CREATE PROCEDURE `XXX2`() begin declare testval varchar(10); set testval = 'hello'; select metaphon(testval); end
CREATE DEFINER=CURRENT_USER() FUNCTION should_not_parse CREATE DEFINER=someone@somewhere FUNCTION should_not_parse create table t1(f1 int)
CREATE FUNCTION fn(a int) RETURNS int DETERMINISTIC BEGIN RETURN a; END |
SELECT myfunc_int(a AS attr_name) FROM t1
EXPLAIN SELECT myfunc_int(a AS attr_name) FROM t1
SELECT a, fn(MIN(b) xx) as c FROM t1 GROUP BY a
SELECT myfunc_int(fn(MIN(b) xx)) as c FROM t1 GROUP BY a
SELECT myfunc_int(fn(MIN(b)) xx) as c FROM t1 GROUP BY a
SELECT myfunc_int(test.fn(MIN(b)) xx) as c FROM t1 GROUP BY a
EXPLAIN SELECT myfunc_int(MIN(b) xx) as c FROM t1 GROUP BY a
EXPLAIN SELECT test.fn(MIN(b)) as c FROM t1 GROUP BY a
EXPLAIN SELECT myfunc_int(test.fn(MIN(b))) as c FROM t1 GROUP BY a
SELECT myfunc_int(MIN(b) xx) as c FROM t1 GROUP BY a
SELECT test.fn(MIN(b)) as c FROM t1 GROUP BY a
SELECT myfunc_int(test.fn(MIN(b))) as c FROM t1 GROUP BY a
select myfunc_double(3 AS three)
select myfunc_double(abs(3) AS named_param)
select abs(myfunc_double(3 AS three))
select myfunc_double(abs(3 AS wrong))
select abs(myfunc_double(3) AS wrong)
CREATE PROCEDURE check_const_len_sp (IN str_const VARCHAR(4000)) BEGIN DECLARE result VARCHAR(4000); SET result = check_const_len(str_const); insert into const_len_bug values(str_const, result, ""); END
select test.metaphon("Hello")
UNLOCK TABLES
UNLOCK TABLES
RETURNS INTEGER SONAME "$UDF_EXAMPLE_LIB"
execute ps
execute ps
DEALLOCATE PREPARE ps
SONAME "$UDF_EXAMPLE_LIB"
SONAME "$UDF_EXAMPLE_LIB"
create table t1 (t1 timestamp not null default now(), t2 datetime, t3 timestamp NOT NULL DEFAULT '0000-00-00 00:00:00')
create table t1 (t1 timestamp not null default '2003-01-01 00:00:00' on update now(), t2 datetime)
create table t1 (t1 timestamp not null default now() on update now(), t2 datetime)
CALL mtr.add_suppression("Plugin test_plugin_server reported: 'Wrong password supplied for plug_dest'")
query_vertical SELECT PLUGIN_STATUS, PLUGIN_TYPE, PLUGIN_DESCRIPTION FROM INFORMATION_SCHEMA.PLUGINS WHERE PLUGIN_NAME='test_plugin_server'
REVOKE SELECT on test_grant_db.* FROM joro REVOKE SELECT on test_grant_db.* FROM joro REVOKE SELECT on test_grant_db.* FROM joro DROP DATABASE test_grant_db
GRANT PROXY ON ''@'' TO grant_plug
GRANT PROXY ON grant_plug_dest@localhost TO grant_plug WITH GRANT OPTION
GRANT PROXY ON ''@'' TO grant_plug
GRANT PROXY ON ''@'' TO proxy_admin WITH GRANT OPTION
SHOW GRANTS FOR grant_plug
SHOW GRANTS FOR grant_plug
SHOW GRANTS FOR test_drop@localhost
GRANT PROXY ON bug12818542_dest@localhost TO bug12818542@localhost
GRANT PROXY ON bug12818542_dest@localhost TO bug12818542@localhost
GRANT PROXY ON 'employee'@'localhost' TO 'empl_external'@'localhost'
GRANT PROXY ON 'employee'@'localhost' TO 'empl_external'@'localhost'
CREATE USER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_ÑŽÐ·ÐµÑ€__ IDENTIFIED WITH 'test_plugin_server' AS 'Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_Ð´ÐµÑÑ‚__'
CREATE USER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_Ð´ÐµÑÑ‚__ IDENTIFIED BY 'plug_dest_passwd'
GRANT PROXY ON Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_Ð´ÐµÑÑ‚__ TO Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_ÑŽÐ·ÐµÑ€__
DROP USER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_ÑŽÐ·ÐµÑ€__
DROP USER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_Ð´ÐµÑÑ‚__
CREATE USER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_ÑŽÐ·ÐµÑ€__@localhost IDENTIFIED WITH 'sha256_password' BY 'auth_string'
DROP USER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_ÑŽÐ·ÐµÑ€__@localhost
CREATE USER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_ÑŽÐ·ÐµÑ€__@localhost IDENTIFIED WITH 'mysql_native_password' BY 'auth_string'
DROP USER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_ÑŽÐ·ÐµÑ€__@localhost
CREATE USER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_ÑŽÐ·ÐµÑ€__@localhost IDENTIFIED WITH 'cleartext_plugin_server' AS 'auth_string'
DROP USER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_ÑŽÐ·ÐµÑ€__@localhost
CREATE USER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_ÑŽÐ·ÐµÑ€__@localhost IDENTIFIED WITH 'sha256_password' BY 'auth_string' REQUIRE SSL
DROP USER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_ÑŽÐ·ÐµÑ€__@localhost
CREATE USER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_ÑŽÐ·ÐµÑ€__@localhost IDENTIFIED WITH 'mysql_native_password' BY 'auth_string' REQUIRE SSL
DROP USER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_ÑŽÐ·ÐµÑ€__@localhost
CREATE USER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_ÑŽÐ·ÐµÑ€__@localhost IDENTIFIED WITH 'cleartext_plugin_server' AS 'auth_string' REQUIRE SSL
DROP USER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_ÑŽÐ·ÐµÑ€__@localhost
query_vertical SELECT * FROM information_schema.columns WHERE table_schema = 'information_schema' AND table_name   = 'ROUTINES' ORDER BY ordinal_position
CREATE FUNCTION test_func1 (s char(20) RETURNS CHAR(50) SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = 'i_s_routines_test' AND ROUTINE_NAME = 'test_func1'
delimiter \
LOAD DATA INFILE '../../std_data/inconsistent_scan.csv' INTO TABLE t1 COLUMNS TERMINATED BY "," IGNORE 1 LINES
send
CALL mtr.add_suppression("--character-set-server: 'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.")
write_file $BOOTSTRAP_SQL
disable_query_log
enable_query_log
disable_query_log
enable_query_log
show grants for mysqltest_1@localhost
show grants for mysqltest_1@localhost
CALL mtr.add_suppression('Failed to set up SSL because of the following SSL library error')
CALL mtr.add_suppression('Failed to initialize TLS for channel: mysql_main')
INSERT INTO t1 VALUES(default(col1),default(col2))
insert into t1 (charcol) values (repeat('x',256))
insert into t1 (varcharcol) values (repeat('x',256))
insert into t1 (binarycol) values (repeat('x',256))
insert into t1 (varbinarycol) values (repeat('x',256))
insert into t1 (tinytextcol) values (repeat('x',256))
insert into t1 (tinyblobcol) values (repeat('x',256))
INSERT INTO t1 VALUES (DEFAULT(i))
INSERT INTO t1 SET j = 1, i = DEFAULT(i)
INSERT INTO t1 VALUES (DEFAULT(i))
INSERT INTO t1 SET j = 1, i = DEFAULT(i)
CREATE PROCEDURE p2() BEGIN DECLARE EXIT HANDLER FOR SQLSTATE '23000' # (ER_DUP_ENTRY) BEGIN SELECT 'Duplication handled!'; END; CALL p1(); END
CREATE TRIGGER t1_BI BEFORE INSERT ON t1 FOR EACH ROW SET NEW.id := -1
lock table t1 write
lock table t1 read
unlock tables
lock table t1 read
unlock tables
send drop procedure p1
where state='Waiting for stored procedure metadata lock' and info='drop procedure p1'
send select f1()
where state='Waiting for stored procedure metadata lock' and info='select f1()'
reap
reap
send create procedure p1() begin end
where state='Waiting for stored procedure metadata lock' and info='create procedure p1() begin end'
send select f1()
where state='Waiting for stored procedure metadata lock' and info='select f1()'
reap
reap
send alter procedure p1 contains sql
where state='Waiting for stored procedure metadata lock' and info='alter procedure p1 contains sql'
send select f1()
where state='Waiting for stored procedure metadata lock' and info='select f1()'
reap
reap
send drop function f1
where state='Waiting for stored function metadata lock' and info='drop function f1'
send select f1()
where state='Waiting for stored function metadata lock' and info='select f1()'
reap
reap
send create function f1() returns int return 2
where state='Waiting for stored function metadata lock' and info='create function f1() returns int return 2'
send select f1()
where state='Waiting for stored function metadata lock' and info='select f1()'
reap
reap
send alter function f1 contains sql
where state='Waiting for stored function metadata lock' and info='alter function f1 contains sql'
send select f1()
where state='Waiting for stored function metadata lock' and info='select f1()'
reap
reap
send drop function f1
where state='Waiting for stored function metadata lock' and info='drop function f1'
reap
send drop function f1
where state='Waiting for stored function metadata lock' and info='drop function f1'
reap
create function f1() returns int begin declare v_out int; call p1(v_out); return v_out; end
send drop procedure p1
where state='Waiting for stored procedure metadata lock' and info='drop procedure p1'
reap
send drop function f2
where state='Waiting for stored function metadata lock' and info='drop function f2'
reap
lock table v1 read
send drop function f1
where state='Waiting for stored function metadata lock' and info='drop function f1'
send drop function f2
where state='Waiting for stored function metadata lock' and info='drop function f2'
reap
unlock tables
reap
create procedure p1() begin select f1() into @var; execute stmt; end
prepare stmt from "select f2()"
send alter function f1 comment "comment"
where state='Waiting for stored function metadata lock' and info like 'alter function f1 comment%'
send call p1()
where state='Waiting for stored function metadata lock' and info='select f1() into @var'
reap
reap
deallocate prepare stmt
send alter function f1 comment "comment"
where state='Waiting for stored function metadata lock' and info like 'alter function f1 comment%'
send call p1()
where state='Waiting for stored function metadata lock' and info='select f1() into @var'
reap
reap
create function f3() returns varchar(255) begin declare res varchar(255); declare c cursor for select routine_name from information_schema.routines where routine_name='f1'; select f1() into @var; open c; fetch c into res; close c; select f2() into @var; return res; end
send select f3()
where state='User lock' and info='select f1() into @var'
reap
create procedure p1() begin create view v1 as select 1; drop view v1; select f1() into @var; set @exec_count=@exec_count+1; end
CREATE PROCEDURE p1() BEGIN SHOW CREATE PROCEDURE p1; SELECT get_lock("test", 100000); SHOW CREATE PROCEDURE p1; END
WHERE state='User lock' and info='SELECT get_lock("test", 100000)'
SELECT db1.f1()
WHERE state= 'Waiting for stored function metadata lock' AND info='DROP DATABASE db1'
CREATE FUNCTION f1() RETURNS INTEGER BEGIN CALL db1.p1(); RETURN 1; END
WHERE state= 'Waiting for stored procedure metadata lock' AND info='DROP DATABASE db1'
SELECT db1.f1()
WHERE state= 'Waiting for stored function metadata lock' AND info='DROP DATABASE db1'
SELECT db1.f2()
WHERE state= 'Waiting for stored function metadata lock' AND info='DROP DATABASE db1'
WHERE state= 'Waiting for schema metadata lock' AND info='ALTER FUNCTION db1.f1 COMMENT "test"'
set @a=repeat(' ',20)
disable_query_log
enable_query_log
create table t1 (v varchar(10), c char(10), t varchar(50), key using btree (v), key using btree (c), key using btree (t(10))) charset latin1
disable_query_log
enable_query_log
create table t1 (a char(10), unique using btree (a)) charset latin1 engine=heap
insert into t1 values(repeat('a',65530))
select length(v) from t1 where v=repeat('a',65530)
INSERT INTO t1 VALUES('a','aa',REPEAT('a', 256)),('a','aa',REPEAT('a',256))
SELECT COUNT(*) FROM t1 WHERE c=REPEAT('a',256)
call mtr.add_suppression("\\[Warning\\] \\[[^]]*\\] Server shutdown in progress")
query_vertical SELECT host,user,plugin FROM mysql.user WHERE USER='user1'
query_vertical SELECT host,user,plugin FROM mysql.user WHERE USER='user2'
query_vertical SELECT User,plugin FROM mysql.user WHERE USER='u1'
query_vertical SELECT User,plugin FROM mysql.user WHERE USER='u2'
query_vertical SELECT User,plugin FROM mysql.user WHERE USER='u3'
query_vertical SELECT User,plugin FROM mysql.user WHERE USER='u4'
query_vertical SELECT User,plugin FROM mysql.user WHERE USER='user4'
query_vertical SELECT User,plugin FROM mysql.user WHERE USER='user6'
query_vertical SELECT User,plugin FROM mysql.user WHERE USER='user7'
query_vertical SELECT User,plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='user8'
query_vertical SELECT User,plugin,password_expired, password_expired FROM mysql.user WHERE USER='tu1'
query_vertical SELECT User,plugin,password_expired FROM mysql.user WHERE USER='tu2'
query_vertical SELECT User,plugin,password_expired FROM mysql.user WHERE USER='tu3'
query_vertical SELECT User,plugin,ssl_type FROM mysql.user WHERE USER='u5'
query_vertical SELECT User,plugin,ssl_type FROM mysql.user WHERE USER='u6'
query_vertical SELECT User,plugin,ssl_type FROM mysql.user WHERE USER='tu4'
query_vertical SELECT User,plugin,ssl_type FROM mysql.user WHERE USER='tu5'
query_vertical SELECT User,plugin,ssl_type,ssl_cipher, x509_issuer,x509_subject FROM mysql.user WHERE USER='u7'
query_vertical SELECT User,plugin,ssl_type,ssl_cipher,x509_issuer, x509_subject,password_expired,password_lifetime FROM mysql.user WHERE USER='u8'
query_vertical SELECT User,plugin,ssl_type,ssl_cipher, x509_issuer,x509_subject FROM mysql.user WHERE USER='u9'
query_vertical SELECT User,plugin,ssl_type,ssl_cipher,x509_issuer, x509_subject,password_expired,password_lifetime FROM mysql.user WHERE USER='u10'
query_vertical SELECT User,plugin,ssl_type,ssl_cipher,x509_issuer, x509_subject,max_questions,max_user_connections FROM mysql.user WHERE USER='tu6'
query_vertical SELECT User,plugin,max_questions FROM mysql.user WHERE USER='u11'
query_vertical SELECT User,plugin,max_questions, password_expired,password_lifetime FROM mysql.user WHERE USER='u12'
query_vertical SELECT User,plugin,max_connections FROM mysql.user WHERE USER='u13'
query_vertical SELECT User,plugin,max_user_connections, password_expired,password_lifetime FROM mysql.user WHERE USER='u14'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired,password_lifetime FROM mysql.user WHERE USER='u15'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired,password_lifetime FROM mysql.user WHERE USER='u16'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired,password_lifetime FROM mysql.user WHERE USER='u17'
query_vertical SELECT User,plugin,ssl_type,ssl_cipher, x509_issuer,x509_subject,max_questions,max_user_connections,password_expired, password_lifetime FROM mysql.user WHERE USER='u18'
query_vertical SELECT User,plugin,ssl_type,ssl_cipher, x509_issuer,x509_subject,max_questions,max_user_connections,password_expired, password_lifetime FROM mysql.user WHERE USER='u19'
query_vertical SELECT User,plugin,ssl_type,ssl_cipher, x509_issuer,x509_subject,max_questions,max_user_connections,password_expired, password_lifetime FROM mysql.user WHERE USER='u20'
query_vertical SELECT User,plugin,ssl_type,ssl_cipher, x509_issuer,x509_subject,max_questions,max_user_connections,password_expired, password_lifetime FROM mysql.user WHERE USER='u21'
query_vertical SELECT User,plugin,ssl_type,ssl_cipher, x509_issuer,x509_subject,max_questions,max_user_connections,password_expired, password_lifetime FROM mysql.user WHERE USER='u22'
query_vertical SELECT User,plugin,ssl_type,ssl_cipher, x509_issuer,x509_subject,max_questions,max_user_connections,password_expired, password_lifetime FROM mysql.user WHERE USER='u23'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u1'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u1'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u2'
ALTER USER u2@localhost IDENTIFIED WITH 'mysql_native_password' PASSWORD EXPIRE NEVER
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u2'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u3'
ALTER USER u3@localhost IDENTIFIED WITH 'mysql_native_password' AS '*67092806AE91BFB6BE72DE6C7BE2B7CCA8CFA9DF'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u3'
ALTER USER u3@localhost IDENTIFIED WITH 'test_plugin_server' BY 'auth_string'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u3'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u3'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u4'
ALTER USER u4@localhost IDENTIFIED WITH 'mysql_native_password' BY 'auth_string'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u4'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u5'
ALTER USER u5@localhost IDENTIFIED WITH 'sha256_password'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u5'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u6'
ALTER USER u6@localhost IDENTIFIED WITH 'test_plugin_server' AS 'new_auth_string' REQUIRE SSL
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u6'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u7'
ALTER USER u7@localhost IDENTIFIED WITH 'sha256_password' BY 'new_auth_string' REQUIRE ISSUER '/C=SE/ST=Stockholm/L=Stockholm/O=Oracle/OU=MySQL/CN=CA'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u7'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u8'
ALTER USER u8@localhost IDENTIFIED WITH 'sha256_password' BY 'auth_string' REQUIRE CIPHER "DHE-RSA-AES256-SHA"
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u8'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='tu1'
ALTER USER tu1@localhost IDENTIFIED WITH 'sha256_password' REQUIRE CIPHER "DHE-RSA-AES256-SHA"
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='tu1'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u9'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u9'
ALTER USER u9@localhost IDENTIFIED WITH 'test_plugin_server' BY 'auth_string77hg' REQUIRE ISSUER "/C=SE/ST=Stockholm/L=Stockholm/O=Oracle/OU=MySQL/CN=CA"
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u9'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u10'
ALTER USER u10@localhost IDENTIFIED WITH 'sha256_password' BY 'auth_string' REQUIRE SSL
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u10'
query_vertical SELECT User,max_questions FROM mysql.user WHERE USER='u11'
query_vertical SELECT User,max_questions FROM mysql.user WHERE USER='u11'
query_vertical SELECT User,max_questions FROM mysql.user WHERE USER='u12'
ALTER USER u12@localhost IDENTIFIED WITH 'sha256_password' WITH MAX_QUERIES_PER_HOUR 8
query_vertical SELECT User,max_questions FROM mysql.user WHERE USER='u12'
ALTER USER u12@localhost IDENTIFIED WITH 'test_plugin_server' WITH MAX_QUERIES_PER_HOUR 1000
query_vertical SELECT User,max_questions FROM mysql.user WHERE USER='u12'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u13'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u13'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired,max_user_connections, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u14'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired,max_user_connections, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u14'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired,max_user_connections,max_questions, password_last_changed,password_lifetime FROM mysql.user WHERE USER='tu2'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired,max_user_connections,max_questions, password_last_changed,password_lifetime FROM mysql.user WHERE USER='tu2'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired,password_lifetime FROM mysql.user WHERE USER='u15'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired,password_lifetime FROM mysql.user WHERE USER='u16'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired,password_lifetime FROM mysql.user WHERE USER='u17'
ALTER USER u15@localhost IDENTIFIED WITH 'sha256_password', u16@localhost, u17@localhost IDENTIFIED BY 'new_auth_string' PASSWORD EXPIRE DEFAULT
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired,password_lifetime FROM mysql.user WHERE USER='u15'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired,password_lifetime FROM mysql.user WHERE USER='u16'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired,password_lifetime FROM mysql.user WHERE USER='u17'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired,max_user_connections, max_questions,password_last_changed,password_lifetime FROM mysql.user WHERE USER BETWEEN 'u18' AND 'u23' order by 1
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired,max_user_connections, max_questions,password_last_changed,password_lifetime FROM mysql.user WHERE USER BETWEEN 'u18' AND 'u23' order by 1
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_last_changed,password_lifetime FROM mysql.user WHERE USER='u2'
ALTER USER u10@localhost IDENTIFIED WITH 'sha256_password' BY 'auth_string' REQUIRE CIPHER "DHE-RSA-AES256-SHA" AND SUBJECT "/C=SE/ST=Stockholm/L=Stockholm/O=Oracle/OU=MySQL/CN=Client" ISSUER "/C=SE/ST=Stockholm/L=Stockholm/O=Oracle/OU=MySQL/CN=CA" WITH MAX_CONNECTIONS_PER_HOUR 1000 MAX_USER_CONNECTIONS 20 MAX_QUERIES_PER_HOUR 60 MAX_UPDATES_PER_HOUR 100
ALTER USER u15@localhost IDENTIFIED WITH 'mysql_native_password' BY 'auth_string' WITH MAX_CONNECTIONS_PER_HOUR 1000 MAX_USER_CONNECTIONS 20 MAX_QUERIES_PER_HOUR 60 MAX_UPDATES_PER_HOUR 100
query_vertical SELECT user,plugin,ssl_type,ssl_cipher, x509_issuer,x509_subject,max_user_connections, max_questions,max_updates,max_connections FROM mysql.user WHERE USER='user1'
SHOW GRANTS FOR user1@localhost
SHOW GRANTS FOR user1@localhost
query_vertical SELECT user,plugin,ssl_type,password_expired, password_lifetime FROM mysql.user where  user='user3'
query_vertical SELECT user,plugin,ssl_type, password_expired,password_lifetime FROM mysql.user where  user='user4'
query_vertical SELECT user,plugin,ssl_type, password_expired,password_lifetime FROM mysql.user where  user='user5'
query_vertical SELECT user,plugin,ssl_type, password_expired,password_lifetime FROM mysql.user where  user='user4'
query_vertical SELECT user,plugin, password_expired FROM mysql.user WHERE USER='user6'
ALTER USER user6@localhost IDENTIFIED WITH 'sha256_password'
query_vertical SELECT user,plugin, password_expired FROM mysql.user WHERE USER='user6'
query_vertical SELECT user,plugin FROM mysql.user WHERE USER='user6'
ALTER USER u10@localhost IDENTIFIED WITH 'mysql_native_password' BY 'auth_string' REQUIRE SSL
ALTER USER user11@localhost IDENTIFIED WITH 'sha256_password' REQUIRE CIPHER "DHE-RSA-AES256-SHA" AND SUBJECT "/C=SE/ST=Stockholm/L=Stockholm/O=Oracle/OU=MySQL/CN=Client" ISSUER "/C=SE/ST=Stockholm/L=Stockholm/O=Oracle/OU=MySQL/CN=CA" PASSWORD EXPIRE  DEFAULT ACCOUNT UNLOCK
ALTER USER user12@localhost IDENTIFIED WITH 'mysql_native_password' AS '*67092806AE91BFB6BE72DE6C7BE2B7CCA8CFA9DF' ACCOUNT UNLOCK PASSWORD  EXPIRE INTERVAL 90 DAY
ALTER USER u10@localhost IDENTIFIED WITH 'mysql_native_password' BY 'auth_string' REQUIRE SSL
ALTER USER user11@localhost IDENTIFIED WITH 'sha256_password' REQUIRE CIPHER "DHE-RSA-AES256-SHA" AND SUBJECT "/C=SE/ST=Stockholm/L=Stockholm/O=Oracle/OU=MySQL/CN=Client" ISSUER "/C=SE/ST=Stockholm/L=Stockholm/O=Oracle/OU=MySQL/CN=CA" PASSWORD EXPIRE  DEFAULT ACCOUNT UNLOCK
ALTER USER user12@localhost IDENTIFIED WITH 'mysql_native_password' AS '*67092806AE91BFB6BE72DE6C7BE2B7CCA8CFA9DF' ACCOUNT UNLOCK PASSWORD  EXPIRE INTERVAL 90 DAY
ALTER USER u1 IDENTIFIED WITH 'invalid_plugin'
ALTER USER u1 IDENTIFIED WITH 'invalid_plugin' BY 'secret'
ALTER USER u1 IDENTIFIED WITH 'invalid_plugin' AS 'secret'
GRANT PROXY ON bug20364862_dest@localhost TO bug20364862_user@localhost
CREATE USER user1@47.9.9.9 IDENTIFIED BY 'pass1'
SHOW CREATE USER user1@47.9.9.9
SHOW CREATE USER user1@47.9.9.9
SHOW GRANTS FOR user1@localhost
SHOW CREATE USER user1@47.9.9.9
SHOW GRANTS FOR user1@localhost
SHOW GRANTS FOR user1@localhost
SHOW CREATE USER user1@47.9.9.9
GRANT PROXY ON bug20625566_dest@localhost TO bug20625566_user@localhost
DROP USER user1@localhost, user1@47.9.9.9, user2, bug20625566_user@localhost, bug20625566_dest@localhost
CONNECTION con1
CONNECTION default
CONNECTION con1
CONNECTION default
DISCONNECT con1
perl
use File::stat
my $file= $ENV{'GREP_FILE'} or die("grep file not set")
my $pattern="^20"
my $stime= $ENV{'GREP_START'}
open(FILE, "$file") or die("Unable to open $file: $!")
while (<FILE>) { my $line = $_
my $ts = 0
if ($stime == 0) { $line =~ s/"source_line" : \d+, //
$line =~ s/"err_code" : \d+, //
print "$line"
} elsif ($line =~ /$pattern/) { $line =~ /([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])T([0-9][0-9]):([0-9][0-9]):([0-9][0-9])\.([0-9][0-9][0-9][0-9][0-9][0-9])[-+Z][0-9:]* *[0-9]* *?(\[.*)
$ts=$1.$2.$3.$4.$5.$6.$7
if ($ts >= $stime) { $stime= 0
} } } close(FILE)
send INSERT INTO t1 VALUES (1)
sleep 1
UNLOCK TABLES
reap
unlock tables
reap
write_file $BOOTSTRAP_SQL
remove_file $MYSQLD_LOG
remove_file $BOOTSTRAP_SQL
CALL mtr.add_suppression("file *  was not purged because it is the active log file.")
purge master logs before (select adddate(current_timestamp(), interval -4 day))
purge master logs before adddate(current_timestamp(), interval -4 day)
CREATE VIEW v1 (a) AS SELECT f1 IN (SELECT f1 FROM t1) FROM t1
handler t1 open as t1
handler t1 read a=(1)
handler t1 close
INSERT INTO t1 VALUES (b'', b'')
CREATE TABLE IF NOT EXISTS t1 ( f1 bit(2) NOT NULL default b'' ) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci
INSERT INTO t1 VALUES (b'')
show create database `mysqltest1`
show create database `mysqltest-1`
show create database `#mysql50#mysqltest-1`
show create database `mysqltest1`
show create database `#mysql50#mysqltest-1`
ENGINE $ENGINE PARTITION BY HASH (i) PARTITIONS 2
ENGINE $ENGINE PARTITION BY LIST (i) SUBPARTITION BY HASH (i) (PARTITION p0 VALUES IN (0) (SUBPARTITION s0, SUBPARTITION s1, SUBPARTITION s2), PARTITION p1 VALUES IN (1) (SUBPARTITION s3, SUBPARTITION s4, SUBPARTITION s5))
ENGINE $ENGINE
ENGINE $ENGINE
PARTITION BY HASH (i) PARTITIONS 2
reap
reap
CHANGE REPLICATION SOURCE TO SOURCE_PASSWORD='azundris3', SOURCE_BIND = 'eth4n', SOURCE_TLS_CIPHERSUITES = '' FOR CHANNEL 'chan_jackie'
CHANGE REPLICATION SOURCE TO SOURCE_PASSWORD='azundris3', SOURCE_CONNECT_RETRY = 1, SOURCE_HEARTBEAT_PERIOD = 1.01, SOURCE_LOG_FILE = 'master_log_name', SOURCE_LOG_POS = 0, SOURCE_SSL = 0, SOURCE_SSL_CA = 'ca_file_name', SOURCE_SSL_CAPATH = 'ca_directory_name', SOURCE_SSL_CERT = 'cert_file_name', SOURCE_SSL_KEY = 'key_file_name', SOURCE_SSL_CIPHER = 'cipher_list', SOURCE_SSL_VERIFY_SERVER_CERT = 1, SOURCE_SSL_CRL = 'crl_file_name', SOURCE_SSL_CRLPATH = 'crl_directory_name', IGNORE_SERVER_IDS = (99,100), SOURCE_TLS_VERSION = 'TLSv1.2', SOURCE_TLS_CIPHERSUITES = NULL, SOURCE_BIND = 'eth4n', SOURCE_RETRY_COUNT = 7, SOURCE_DELAY = 4711, SOURCE_AUTO_POSITION = 0 FOR CHANNEL 'chan_jackie'
INTO TABLE test_log FIELDS TERMINATED BY '\n' LINES TERMINATED BY '\n'
HANDLER t1 OPEN
FLUSH TABLE t1
CREATE PROCEDURE p_install() BEGIN INSTALL PLUGIN no_such_plugin SONAME 'no_such_object'; END
change_user
WHERE INFO='UNINSTALL PLUGIN example' and STATE='System lock'
SELECT @@GLOBAL.example_signed_long_var IN (-2147483648, -9223372036854775808)
SELECT @@GLOBAL.example_signed_long_var IN (2147483647, 9223372036854775807)
SELECT @@GLOBAL.example_signed_long_var IN (2147483647, 9223372036854775807)
SELECT @@GLOBAL.example_signed_long_var IN (2147483647, 9223372036854775807)
SELECT @@SESSION.example_signed_long_thdvar IN (-2147483648, -9223372036854775808)
SELECT @@SESSION.example_signed_long_thdvar IN (2147483647, 9223372036854775807)
SELECT @@SESSION.example_signed_long_thdvar IN (2147483647, 9223372036854775807)
SELECT @@SESSION.example_signed_long_thdvar IN (2147483647, 9223372036854775807)
call mtr.add_suppression("Plugin .* is not to be used as an .early. plugin")
call mtr.add_suppression("Couldn't load plugin named .* with soname ")
CREATE PROCEDURE proc3() BEGIN DECLARE x CHAR(36); SET x=UUID(); END
UNLOCK TABLES
LOCK TABLES t1 WRITE
UNLOCK TABLES
LOCK TABLE t1 WRITE, t2 WRITE
UNLOCK TABLES
LOCK TABLE t1 WRITE
UNLOCK TABLES
CREATE TABLE t1(j json, INDEX mv_idx((CAST(j AS UNSIGNED ARRAY))))
HANDLER table10_innodb_int_autoinc OPEN AS alias1
HANDLER alias1 READ `PRIMARY` NEXT WHERE `col_int_not_null_key` <= 'j' LIMIT 8
show function code foo
call mtr.add_suppression("\\[ERROR\\] .*MY-\\d+.* Operating system error number .* in a file operation")
call mtr.add_suppression("\\[ERROR\\] .*MY-\\d+.* The error means the system cannot find the path specified")
call mtr.add_suppression("\\[ERROR\\] .*MY-\\d+.* Cannot open datafile for read-only")
call mtr.add_suppression("\\[ERROR\\] .*MY-\\d+.* Cannot delete tablespace .* because it is not found in the tablespace memory cache")
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1.ibd'
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1.ibd'
call mtr.add_suppression("Dictionary file not specified")
SELECT @@global.validate_password.policy, @@global.validate_password.length
SELECT @@global.validate_password.policy
SELECT @@global.validate_password.length
CALL mtr.add_suppression("currently unknown variable 'validate_password*")
CALL mtr.add_suppression("currently unknown variable 'validate_password*")
CALL mtr.add_suppression('Following users were specified in CREATE USER IF NOT EXISTS but they already exist')
CALL mtr.add_suppression('Following users were specified in ALTER USER IF EXISTS but they do not exist')
query_vertical SELECT User,plugin,authentication_string,ssl_type, password_expired,password_lifetime FROM mysql.user WHERE USER='user2'
query_vertical SELECT User,plugin,authentication_string,ssl_type, password_expired,password_lifetime FROM mysql.user WHERE USER='user2'
ALTER USER IF EXISTS user2@localhost IDENTIFIED WITH 'mysql_native_password' AS '*67092806AE91BFB6BE72DE6C7BE2B7CCA8CFA9DF'
query_vertical SELECT User,plugin,authentication_string,ssl_type, password_expired,password_lifetime FROM mysql.user WHERE USER='user2'
ALTER USER IF EXISTS ne_user2@localhost IDENTIFIED WITH 'mysql_native_password' BY 'auth_string#%y'
ALTER USER IF EXISTS user1@localhost,ne_user3@localhost IDENTIFIED WITH 'mysql_native_password' BY 'auth_string#%y'
ALTER USER IF EXISTS ne_user2@localhost IDENTIFIED WITH 'mysql_native_password' BY 'auth_string#%y'
ALTER USER IF EXISTS user1@localhost,ne_user3@localhost IDENTIFIED WITH 'mysql_native_password' BY 'auth_string#%y'
PREPARE stmt1 FROM "EXPLAIN SELECT /*+ NO_SEMIJOIN(@subq1 FIRSTMATCH, LOOSESCAN) NO_SEMIJOIN(@subq2 FIRSTMATCH, LOOSESCAN) */ * FROM t1 WHERE t1.a IN (SELECT /*+ QB_NAME(subq1) */ a FROM t3) AND t1.b IN (SELECT /*+ QB_NAME(subq2) */ a FROM t2)"
EXECUTE stmt1
EXECUTE stmt1
DEALLOCATE PREPARE stmt1
PREPARE stmt1 FROM "EXPLAIN SELECT /*+ NO_SEMIJOIN(@subq1) SEMIJOIN(@subq2 LOOSESCAN) */ * FROM t1 WHERE t1.a IN (SELECT /*+ QB_NAME(subq1) */ a FROM t3 WHERE t3.b IN (SELECT /*+ QB_NAME(subq2) */ a FROM t2))"
EXECUTE stmt1
EXECUTE stmt1
DEALLOCATE PREPARE stmt1
PREPARE stmt1 FROM "EXPLAIN SELECT /*+ NO_SEMIJOIN(@subq1 FIRSTMATCH, LOOSESCAN) NO_SEMIJOIN(@subq2 FIRSTMATCH, LOOSESCAN) */ * FROM t1 WHERE t1.a IN (SELECT /*+ QB_NAME(subq1) */ a FROM t3) AND t1.b IN (SELECT /*+ QB_NAME(subq2) */ a FROM t2)"
EXECUTE stmt1
EXECUTE stmt1
EXECUTE stmt1
DEALLOCATE PREPARE stmt1
EXPLAIN SELECT a, a IN (SELECT a FROM t1) FROM t2
EXPLAIN SELECT a, a IN (SELECT /*+ SUBQUERY(MATERIALIZATION) */ a FROM t1) FROM t2
EXPLAIN SELECT /*+ SUBQUERY(@subq MATERIALIZATION) */ a, a IN (SELECT /*+ QB_NAME(subq) */ a FROM t1) FROM t2
PREPARE stmt1 FROM "EXPLAIN SELECT /*+ SUBQUERY(@subq1 MATERIALIZATION) SUBQUERY(@subq2 INTOEXISTS) */ * FROM t1 WHERE t1.a IN (SELECT /*+ QB_NAME(subq1) */ a FROM t3) AND t1.b IN (SELECT /*+ QB_NAME(subq2) */ a FROM t2)"
EXECUTE stmt1
EXECUTE stmt1
DEALLOCATE PREPARE stmt1
EXPLAIN SELECT a, a IN (SELECT a FROM t1) FROM t2
EXPLAIN SELECT /*+ SUBQUERY(@subq INTOEXISTS) */ a, a IN (SELECT /*+ QB_NAME(subq) */ a FROM t1) FROM t2
source include/xplugin_wait_for_interfaces.inc
WHERE USER != 'event_scheduler'`
CALL mtr.add_suppression("==[0-9]*== Warning: set address range perms: large range")
reap
reap
SELECT @@global.default.key_buffer_size
SELECT @@global.default.`key_buffer_size`
SELECT @@global.`default`.`key_buffer_size`
SELECT @@default.key_buffer_size
cache index t1,t2 in default
call mtr.add_suppression("\\[Warning\\] \\[[^]]*\\] \\[[^]]*\\] You need to use --log-bin to make --binlog-format work.")
SHOW RELAYLOG EVENTS
STOP SLAVE
CHANGE REPLICATION SOURCE TO SOURCE_CONNECT_RETRY = 1, SOURCE_HEARTBEAT_PERIOD = 1.01
CHANGE REPLICATION FILTER REPLICATE_DO_DB=(db1)
CHANGE REPLICATION FILTER REPLICATE_IGNORE_DB=(db1)
CHANGE REPLICATION FILTER REPLICATE_DO_TABLE=(db1.t1)
CHANGE REPLICATION FILTER REPLICATE_IGNORE_TABLE=(db1.t1)
CHANGE REPLICATION FILTER REPLICATE_WILD_DO_TABLE=('db1.t%')
CHANGE REPLICATION FILTER REPLICATE_WILD_IGNORE_TABLE=('db1.t%')
CHANGE REPLICATION FILTER REPLICATE_REWRITE_DB=((db1,db2))
SHOW SLAVE HOSTS
SHOW GRANTS FOR 'kristofer'@'localhost'
SHOW GRANTS FOR 'kristofer'@'localhost'
WHERE state='Waiting for table metadata lock' AND info='OPTIMIZE TABLE t1'
LOCK TABLE t1 WRITE
UNLOCK TABLES
create procedure p() begin declare utf8_var VARCHAR(128) CHARACTER SET UTF8; set utf8_var = concat(repeat('A', 128), 'X'); show warnings; select length(utf8_var), utf8_var; end
create procedure p2() begin declare msg VARCHAR(129) CHARACTER SET UTF8; set msg = concat(repeat('A', 128), 'X'); select length(msg), msg; signal sqlstate '55555' set message_text = msg; end
create procedure p3() begin declare name VARCHAR(65) CHARACTER SET UTF8; set name = concat(repeat('A', 64), 'X'); select length(name), name; signal sqlstate '55555' set message_text = 'Message', table_name = name; end
create procedure p() begin declare utf8_var VARCHAR(128) CHARACTER SET UTF8; set utf8_var = concat(repeat('A', 128), 'X'); select length(utf8_var), utf8_var; end
create procedure p2() begin declare msg VARCHAR(129) CHARACTER SET UTF8; set msg = concat(repeat('A', 128), 'X'); select length(msg), msg; signal sqlstate '55555' set message_text = msg; end
create procedure p3() begin declare name VARCHAR(65) CHARACTER SET UTF8; set name = concat(repeat('A', 64), 'X'); select length(name), name; signal sqlstate '55555' set message_text = 'Message', table_name = name; end
call mtr.add_suppression("\\[Warning\\] \\[[^]]*\\] \\[[^]]*\\] option 'persisted_globals_load': boolean value 'NULL' was not recognized. Set to OFF.")
call mtr.add_suppression("\\[Warning\\] option 'persisted_globals_load': boolean value 'NULL' was not recognized. Set to OFF.")
disable_query_log
enable_query_log
select mail_id,  if(folder.f_description!='', folder.f_description, folder.f_name) as folder_name,  date, address_id, phrase, address,  subject from folder, (select  mail.mail_id as mail_id,  date_format(mail.h_date, '%b %e, %Y %h:%i') as date,  mail.folder_id,  sender.address_id as address_id,  sender.phrase as phrase, sender.address as address,    mail.h_subject as subject from    mail left join mxa as mxa_sender on mail.mail_id=mxa_sender.mail_id and mxa_sender.type='from' left join address as sender on mxa_sender.address_id=sender.address_id  mxa as mxa_recipient,   address as recipient, where 1     and mail.mail_id=mxa_recipient.mail_id   and mxa_recipient.address_id=recipient.address_id   and mxa_recipient.type='to'  and  match(sender.phrase, sender.address, sender.comment) against ('jeremy' in boolean mode)   and  match(recipient.phrase, recipient.address, recipient.comment) against ('monty' in boolean mode) order by mail.h_date desc limit 0, 25 ) as query where query.folder_id=folder.folder_id
delete from (select * from t1)
delete from (select * from t1) as t1, t1 as t2
insert into  (select * from t1) values (5)
JOIN t3 ON tt.f22=t3.f3
SELECT SHA(pk) IN (SELECT * FROM (SELECT '' FROM t2) a) FROM t1
PREPARE s1 FROM 'SELECT * FROM v'
PREPARE s2 FROM 'SELECT * FROM (SELECT * FROM t) AS dt'
EXECUTE s1
EXECUTE s2
DEALLOCATE PREPARE s1
DEALLOCATE PREPARE s2
execute s
deallocate prepare s
execute s
deallocate prepare s
t1_inv_date FROM t1 LEFT JOIN (SELECT curr.t2_end_date As end_date, (SELECT prev.t2_end_date FROM t2 AS prev WHERE prev.t2_end_date < curr.t2_end_date ORDER BY prev.t2_end_date DESC LIMIT 1) AS prev_end_date FROM t2 AS curr WHERE curr.t2_end_date >= 's:1' ) AS periods ON periods.prev_end_date < t1_inv_date AND periods.end_date >= t1_inv_date
EXECUTE xx
EXECUTE xx
EXECUTE xx
EXECUTE yy
EXECUTE yy
EXECUTE yy
prepare s from " SELECT field1 FROM (SELECT alias1.c1 AS field1, alias1.c2 AS field2 FROM t1 AS alias1 RIGHT JOIN t2 AS alias2 ON alias1.pk = alias2.c1 ORDER BY field2) as dt"
execute s
execute s
PREPARE s FROM " SELECT dtaa.c AS c FROM (SELECT 1 AS c FROM (SELECT 1 AS c FROM t AS ta RIGHT JOIN t AS tb ON ta.u  <= ? WHERE 1 OR ? GROUP BY ta.u ) AS dta INNER JOIN t AS tbb ON dta.c = tbb.h ) AS dtaa RIGHT JOIN t AS tbbb ON dtaa.c or w"
SET @a:='77777'
EXECUTE s USING @a,@a
SET @a:='-77777'
EXECUTE s USING @a,@a
DEALLOCATE PREPARE s
call mtr.add_suppression("Column count of mysql.* is wrong. " "Expected .*, found .*. " "The table is probably corrupted")
CALL mtr.add_suppression("Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT")
send SELECT id FROM t1 WHERE id IN (SELECT DISTINCT a.id FROM t2 a, t2 b, t2 c, t2 d GROUP BY ACOS(1/a.id), b.id, c.id, d.id HAVING a.id BETWEEN 10 AND 20)
source include/show_binlog_events.inc
source include/show_binlog_events.inc
PREPARE s FROM 'UPDATE t1 AS a NATURAL JOIN t1 AS b SET a.col_int = 9, b.col_int = 9'
EXECUTE s
EXECUTE s
DEALLOCATE PREPARE s
LOCK INSTANCE FOR BACKUP
UNLOCK INSTANCE
LOCK INSTANCE FOR BACKUP
LOCK INSTANCE FOR BACKUP
UNLOCK INSTANCE
UNLOCK INSTANCE
LET $ID= `SELECT connection_id()`
LET $ID= `SELECT connection_id()`
LET $ID= `SELECT connection_id()`
source include/search_pattern.inc
GET DIAGNOSTICS @n = NUMBER
GET DIAGNOSTICS CONDITION 1 @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT
GET DIAGNOSTICS @n = NUMBER
GET DIAGNOSTICS CONDITION 1 @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT
CREATE PROCEDURE p2_declare_variable_clears () BEGIN DECLARE CONTINUE HANDLER FOR NOT FOUND BEGIN /* DECLARE a variable. This will clear the diagnostics area, so the subsequent GET DIAGNOSTICS will fail. It in turn will flag a warning (not an exception), which will remain unseen, as it in turn gets cleared by the next statement (SELECT). */ DECLARE v1 INT; GET DIAGNOSTICS @n2 = NUMBER; GET DIAGNOSTICS CONDITION 1 @e2 = MYSQL_ERRNO, @t2 = MESSAGE_TEXT; END; SET @n2 = 0, @e2 = 0, @t2 = 'handler was not run or GET DIAGNOSTICS failed'; SIGNAL SQLSTATE '02000' SET MESSAGE_TEXT = 'signal message'; /* Show handler was called, and DA was NOT read intact because of DECLARE VARIABLE. */ SELECT @n2, @e2, @t2; END
CREATE PROCEDURE p5_declare_variable_clears () BEGIN DECLARE CONTINUE HANDLER FOR NOT FOUND BEGIN /* DECLARE a VARIABLE with a broken DEFAULT. This will throw a warning at runtime, which GET DIAGNOSTICS will see instead of the previous condition (the SIGNAL). */ DECLARE v1 INT DEFAULT 'meow'; GET DIAGNOSTICS @n5 = NUMBER; GET DIAGNOSTICS CONDITION 1 @e5= MYSQL_ERRNO, @t5 = MESSAGE_TEXT; END; SET @n5 = 0, @e5 = 0, @t5 = 'handler was not run or GET DIAGNOSTICS failed'; SIGNAL SQLSTATE '02000' SET MESSAGE_TEXT = 'signal message'; /* Show handler was called, and DA was NOT read intact because of DECLARE VARIABLE. */ SELECT @n5, @e5, @t5; SELECT "still here, we got a warning, not an exception!"; END
CREATE PROCEDURE p7_show_warnings () BEGIN SHOW VARIABLES LIKE 'foo'; SHOW WARNINGS; SELECT "(SHOW WARNINGS does not have to come last)"; END
CREATE PROCEDURE p8b_show_warnings () BEGIN SHOW WARNINGS; END
CREATE FUNCTION f4_show_warnings() RETURNS TEXT BEGIN SHOW WARNINGS; RETURN "yeah, not so much"; END
PREPARE stmt1 FROM 'create table if not exists t1 (f1 int)'
EXECUTE stmt1
EXECUTE stmt1
DEALLOCATE PREPARE stmt1
PREPARE stmt1 FROM 'create table if not exists t1 (f1 int)'
EXECUTE stmt1
CREATE PROCEDURE p10_ps_with_warning () BEGIN DECLARE CONTINUE HANDLER FOR 1050 SELECT "a warn place"; EXECUTE stmt1; END
DEALLOCATE PREPARE stmt1
PREPARE stmt1 FROM 'create table if not exists t1 (f1 year)'
EXECUTE stmt1
EXECUTE stmt1
DEALLOCATE PREPARE stmt1
PREPARE stmt1 FROM @sql1
PREPARE stmt2 FROM 'SHOW WARNINGS'
PREPARE stmt2 FROM 'SHOW ERRORS'
PREPARE stmt2 FROM 'SHOW COUNT(*) WARNINGS'
PREPARE stmt2 FROM 'SHOW COUNT(*) ERRORS'
PREPARE stmt2 FROM 'SELECT @@warning_count'
PREPARE stmt2 FROM 'SELECT @@error_count'
CREATE PROCEDURE peter1 () BEGIN DECLARE v INTEGER DEFAULT 1234; DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN SHOW WARNINGS; SELECT "handler done: ",v; END; CREATE TABLE gg (smallint_column SMALLINT); CALL peter2(v); END
CREATE PROCEDURE peter2 (INOUT v INTEGER) BEGIN INSERT INTO gg (smallint_column) VALUES (32769); GET DIAGNOSTICS v = ROW_COUNT; END
CREATE PROCEDURE peter3(a DECIMAL(2,2)) BEGIN DECLARE b DECIMAL(2,2) DEFAULT @var; END
CREATE PROCEDURE bug15231_1() BEGIN DECLARE xid INTEGER; DECLARE xdone INTEGER DEFAULT 0; DECLARE CONTINUE HANDLER FOR NOT FOUND SET xdone = 1; SET xid=NULL; CALL bug15231_2a(xid); SELECT "1,0", xid, xdone; SET xid=NULL; CALL bug15231_2b(xid); SELECT "NULL, 1", xid, xdone; END
CREATE PROCEDURE bug15231_2a(INOUT ioid INTEGER) BEGIN SELECT "Before NOT FOUND condition is triggered" AS '1'; SELECT id INTO ioid FROM t3 WHERE id=ioid; SELECT "After NOT FOUND condtition is triggered" AS '2'; IF ioid IS NULL THEN SET ioid=1; END IF; END
CREATE PROCEDURE bug15231_2b(INOUT ioid INTEGER) BEGIN SELECT id INTO ioid FROM t3 WHERE id=ioid; END
CREATE PROCEDURE bug15231_4() BEGIN DECLARE x DECIMAL(2,1); SET x = 'zap'; SHOW WARNINGS; END
CREATE PROCEDURE bug15231_6() BEGIN DECLARE x DECIMAL(2,1); SET x = 'zap'; SELECT id FROM t3; END
(`$MYSQL_BINLOG --raw --read-from-remote-server --stop-never --user=root --host=127.0.0.1 --port=$MASTER_MYPORT --result-file=$MYSQL_TMP_DIR/ binlog.000001 ; [ $? -le 1 ]` && $MYSQL -e "use test; INSERT INTO raw_mode_exit VALUES (1);") < /dev/null > /dev/null 2>&1 & SELECT ((@id := id) - id) from information_schema.processlist where processlist.command like '%Binlog%' and state like '%Source has sent%'
kill @id
echo $mysql_errno before test
echo $mysql_errname before test
echo $mysql_errname
echo $mysql_errname
echo $mysql_errname
echo $mysql_errname
echo $mysql_errname
echo $mysql_errname
echo $mysql_errname
echo $mysql_errname
prepare stmt from "select 3 from t1"
echo $mysql_errname
prepare stmt from "select 3 from t1"
echo $mysql_errname
execute stmt
echo $mysql_errname
execute stmt
echo $mysql_errname
execute __stmt_
echo $mysql_errname
deallocate prepare stmt
echo $mysql_errname
deallocate prepare __stmt_
echo $mysql_errname
echo $mysql_errname
echo $mysql_errname
echo $empty is empty
echo $empty is empty
echo $mysql_errname
garbage
echo $empty is empty
echo $empty is empty
echo $var2
echo $var2
echo $var
echo $var
echo $var
echo $var
echo $var1
sleep 4 show status
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
sleep 7 remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
disable_query_log
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
disable_query_log
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
echo $x
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
echo MySQL
echo "MySQL"
echo MySQL: The world''s most popular open source database
echo "MySQL: The world's most popular open source database"
echo MySQL: The world''s most popular open source database
echo # MySQL: The world''s echo - MySQL: The world''s - most popular open - source database
echo - MySQL: The world''s echo # MySQL: The - source database
echo "MySQL: The world's most popular; open source database"
echo "MySQL: The world's most popular ; open source database"
echo "MySQL: The world's most popular ;open source database"
echo echo message echo message
echo
exec $MYSQL test -e "select 1"
exec $MYSQL test -e "select 2"
as X
exec $MYSQL test -e "$query"
echo $message
echo $message
world''s most popular open source database
echo $message
echo $message
echo $message
- world''s most echo $message
echo '$message'
echo "$message"
echo $1
echo $1
echo $1
echo $2
echo $5
echo $6
echo $where
echo $where2
echo $where3
echo $where3
echo $novar1
echo banana = $cat
echo Not a banana: $cat
echo $escape
echo $escape
echo $tick
echo # <whatever> success: $success
echo $success
echo var2: $var2
echo var3: $var3
echo var1
echo $var1
echo var2
echo $var2
echo var2 again
echo $var2
echo var3 two columns with same name
echo $var3
echo var4 from query that returns NULL
echo var5 from query that returns no row
echo failing query in let
echo $var2
echo $a
echo $a
echo $a
remove_file $MYSQLTEST_VARDIR/tmp/let.sql
remove_file $MYSQLTEST_VARDIR/tmp/recursive.sql
remove_file $MYSQLTEST_VARDIR/tmp/error.sql
echo here is the sourced script
echo "hello"
source $MYSQLTEST_VARDIR/tmp/$x.inc
source $x/tmp/sourced.inc
sleep 0.5
sleep 1
sleep $sleep_var
inc $i
echo $i
inc $i
echo $i
inc $i
echo $i
inc $i; inc $i; inc $i; --echo $i echo $i
dec $d
echo $d
dec $d
echo $d
echo teststop delimiter ;stop echo test2
echo test3stop echo test4
echo outer
echo true-outer/ delimiter ;/ echo Counter should still be 10, is $counter
remove_file $MYSQL_TMP_DIR/mysqltest.sql
remove_file $MYSQL_TMP_DIR/mysqltest.sql
remove_file $MYSQL_TMP_DIR/mysqltest.sql
SELECT s.Id FROM s WHERE Id=1 AND u IS NULL)ORDER BY Id DESC
SELECT s.Id FROM s WHERE Id=1 AND u IS NOT NULL) ORDER BY Id DESC
SELECT s1.Id FROM s1 WHERE Id=1 AND u IS NOT NULL) ORDER BY Id DESC
SELECT s1.Id FROM s1 WHERE Id=1 AND u != 1) ORDER BY Id DESC
SELECT s.Id FROM s2 s WHERE Id=1 AND u IS NULL) ORDER BY Id DESC
SELECT s.Id FROM s3 s WHERE Id=1 AND u IS NOT NULL) ORDER BY Id DESC
PREPARE prep_stmt FROM "SELECT t2.f1 FROM (t2 LEFT JOIN t1 ON (1 = ANY (SELECT f1 FROM t1 WHERE 1 IS NULL)))"
EXECUTE prep_stmt
PREPARE prep_stmt FROM " SELECT t2.f1 FROM t2 LEFT OUTER JOIN (SELECT  * FROM t2 WHERE ('y',1) IN (SELECT alias1.f1 , 0 FROM t1 AS alias1 LEFT JOIN t2 ON 0)) AS alias ON 0"
EXECUTE prep_stmt
PREPARE prep_stmt FROM " SELECT t2.f1 FROM (t2 LEFT OUTER JOIN (SELECT  * FROM t2 WHERE ('y',1) IN (SELECT alias1.f1 , 0 FROM (t1 INNER JOIN  (t1 AS alias1 LEFT JOIN t2 ON 0) ON 0))) AS alias ON 0)"
EXECUTE prep_stmt
PREPARE prep_stmt FROM "SELECT t2.f1 FROM (t2 LEFT JOIN t1 ON 1 IN (SELECT f1 FROM t1 WHERE FALSE))"
EXECUTE prep_stmt
SELECT t2.pk FROM t4 RIGHT JOIN t3 ON t4.col_int_key = t3.pk RIGHT JOIN t2 ON t3.col_int_key <> t2.pk )
SELECT t2.f2 FROM t1 JOIN ( t1 AS t2 LEFT JOIN t1 AS t3 USING (f2) ) ON t3.f2 = t2.f2 WHERE t2.f1 > table1.f2 ) FROM t1 AS table1
PREPARE st FROM "DELETE outr1.* FROM t1 AS outr1 RIGHT OUTER JOIN t2 AS outr2 ON outr1.col_int = outr2.col_int WHERE (0, 3) NOT IN (SELECT innr1.pk AS x, innr1.col_int AS y FROM t2 AS innr1 WHERE outr1.col_int = 25)"
EXECUTE st
EXECUTE st
DEALLOCATE PREPARE st
SELECT * FROM t AS upper JOIN LATERAL (SELECT DISTINCT ROW_NUMBER() OVER () AS rn FROM t WHERE (t.a > upper.a)) der
PREPARE ps FROM ' SELECT (SELECT SUM(sq1_t1.col_int) AS sq1_field1 FROM t3 AS sq1_t1 INNER JOIN t1 AS sq1_t2 ON sq1_t2.col_varchar_key = sq1_t1.col_varchar_key WHERE sq1_t2.col_varchar < sq1_t2.col_varchar OR sq1_t2.col_varchar <>  ? ) AS field1 FROM t5 AS table1 LEFT OUTER JOIN t4 AS table2 ON table2.col_int_key = table1.col_int WHERE table1.pk > ANY (SELECT sq2_t1.pk AS sq2_field1 FROM t3 AS sq2_t1 STRAIGHT_JOIN t2 AS sq2_t2 ON sq2_t2.col_int_key = sq2_t1.pk WHERE sq2_t2.col_varchar >= table2.col_varchar AND sq2_t2.col_varchar <= table1.col_varchar_key ) AND table1.pk = ?'
EXECUTE ps USING @var1, @var2
EXECUTE ps USING @var1, @var2
EXISTS (SELECT 1 FROM  t1 AS b WHERE b.c2 = a.c2 LIMIT 1,1)
EXISTS (SELECT 1 FROM  t1 AS b WHERE b.c2 = a.c2 LIMIT 0,1)
EXISTS (SELECT 1 FROM  t1 AS b WHERE b.c2 = a.c2 LIMIT ?,1)
EXECUTE explain_stmt USING @offset_value
EXECUTE stmt USING @offset_value
EXISTS (SELECT 1 FROM  t1 AS b WHERE b.c2 = a.c2 LIMIT 0,0)
SET @b := _latin1 'a'
SELECT t1.a FROM t1, LATERAL ( SELECT t1.a FROM t1 AS inner_t1 LIMIT 1 ) AS d1 WHERE 1 IN ( SELECT a FROM t1 ) ORDER BY a
SELECT * FROM ( SELECT a, JSON_ARRAYAGG(a) OVER () AS b FROM t1 ) AS d1 WHERE (a,b) IN ( SELECT a, JSON_ARRAYAGG(a) OVER () AS b FROM t1 )
create table t1 (a int) partition by key(a) partitions 0.2+e1
create table t1 (a int) partition by key(a) partitions -1
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by key (a) partitions 3 (partition x1 nodegroup 0, partition x2 nodegroup 1, partition x3 nodegroup 2)
LOCK TABLES t1 WRITE
UNLOCK TABLES
CREATE TABLE t1 (c1 INT, c2 INT, PRIMARY KEY USING BTREE (c1,c2)) PARTITION BY KEY(c2,c1) PARTITIONS 4
create table t1 (a int, b int) partition by range (a) subpartition by hash(a) (partition p0 values less than (0) (subpartition sp0), create table t1 (a int, b int) partition by range (a) subpartition by hash(a) (partition p0 values less than (0), create table t1 (a int, b int) partition by list (a) subpartition by hash(a) (partition p0 values in (0), create table t1 (a int) partition by hash (a) (partition p0 (subpartition sp0))
prepare stmt1 from 'create table t1 (s1 int) partition by hash (s1)'
execute stmt1
execute stmt1
BEGIN DECLARE CONTINUE HANDLER FOR sqlexception BEGIN END; DROP TABLE IF EXISTS t1; CREATE TABLE t1 (num INT,PRIMARY KEY(num)); START TRANSACTION; INSERT INTO t1 VALUES(i); savepoint t1_save; INSERT INTO t1 VALUES (14); ROLLBACK to savepoint t1_save; COMMIT; END
CALL test.p1(12)
CALL test.p1(13)
create procedure mysqltest_1 () begin begin declare continue handler for sqlexception begin end; update ignore t1 set a = 1 where a = 0; end; prepare stmt1 from 'alter table t1'; execute stmt1; end
INSERT INTO t1 VALUES (1, REPEAT('a', 10))
LOCK TABLES t1 WRITE, t1 b READ
UNLOCK TABLES
LOCK TABLES t1 WRITE, t1 b READ
UNLOCK TABLES
FLUSH TABLE t1
lock tables t1 write, t1 as a read, t1 as b read
unlock tables
CALL mtr.add_suppression(".ERROR.  Operating system error number")
CALL mtr.add_suppression(".ERROR.  The error means mysqld does not have the access")
partition by range (a) subpartition by hash (a) (partition p0 VALUES LESS THAN (1) DATA DIRECTORY = '$MYSQL_TMP_DIR' (SUBPARTITION subpart00, SUBPARTITION subpart01))
(partition p1 VALUES LESS THAN (1) DATA DIRECTORY = '$MYSQL_TMP_DIR' (SUBPARTITION subpart10, SUBPARTITION subpart11), partition p2 VALUES LESS THAN (2) DATA DIRECTORY = '$MYSQL_TMP_DIR' (SUBPARTITION subpart20, SUBPARTITION subpart21))
disable_query_log
partition by range (i) ( partition p01 values less than (1000) data directory='$MYSQL_TMP_DIR' index directory='$MYSQL_TMP_DIR' )
enable_query_log
PARTITION BY KEY (a) (PARTITION p0 DATA DIRECTORY '$MYSQLD_DATADIR/test')
PARTITION BY KEY (a) (PARTITION p0 INDEX DIRECTORY '$MYSQLD_DATADIR/test')
PARTITION BY RANGE(YEAR(purchased)) SUBPARTITION BY HASH(TO_DAYS(purchased)) ( PARTITION p0 VALUES LESS THAN (1990) ( SUBPARTITION s0a DATA DIRECTORY = '$MYSQLD_DATADIR/test', SUBPARTITION s0b DATA DIRECTORY = '$MYSQLD_DATADIR/test' ))
PARTITION BY RANGE(YEAR(purchased)) SUBPARTITION BY HASH(TO_DAYS(purchased)) ( PARTITION p0 VALUES LESS THAN (1990) ( SUBPARTITION s0a INDEX DIRECTORY = '$MYSQLD_DATADIR/test', SUBPARTITION s0b INDEX DIRECTORY = '$MYSQLD_DATADIR/test' ))
`ID_EXAMPLE` int(10) unsigned NOT NULL AUTO_INCREMENT, `DESCRIPTION` varchar(30) NOT NULL, `LEVEL` smallint(5) unsigned DEFAULT NULL, PRIMARY KEY (`ID_EXAMPLE`) ) PARTITION BY HASH(ID_EXAMPLE)( PARTITION p0 DATA DIRECTORY = '$MYSQL_TMP_DIR/p0Data', PARTITION p1 DATA DIRECTORY = '$MYSQL_TMP_DIR/p1Data', PARTITION p2 DATA DIRECTORY = '$MYSQL_TMP_DIR/p2Data', PARTITION p3 DATA DIRECTORY = '$MYSQL_TMP_DIR/p3Data' )
LOCK TABLES t1 WRITE, t1 b READ
UNLOCK TABLES
SELECT 10,10.0,10.,.1e+2,100.0e-1
SELECT 1e1,1.e1,1.0e1,1e+1,1.e+1,1.0e+1,1e-1,1.e-1,1.0e-1
EXECUTE stmt1
99999999999999999999999999999999999999999999999999999999999999999
($nine_65)) into @a
CREATE PROCEDURE p1(IN a FLOAT(255,0), OUT b DOUBLE(12,3)) BEGIN SELECT 1 INTO b; END|
CREATE PROCEDURE p1(IN a FLOAT UNSIGNED, OUT b DOUBLE UNSIGNED) BEGIN SELECT 1 INTO b; END|
PREPARE stmt FROM "SELECT t1.id1 AS id, t5.id1 AS ngroupbynsa FROM t1 INNER JOIN t2 ON t2.id2 = t1.id1 LEFT OUTER JOIN (t3 INNER JOIN t4 ON t4.id1 = t3.id2 INNER JOIN t5 ON t4.id2 = t5.id1) ON t3.id2 IS NOT NULL WHERE t1.id1=2"
EXECUTE stmt
EXECUTE stmt
EXECUTE stmt
EXECUTE stmt
EXECUTE stmt
EXECUTE stmt
EXECUTE stmt
EXECUTE stmt
select 5'abcd
delimiter ;'abcd
show status like 'Slow_queries'|||
drop table t1|||
insert into t1 values (repeat(0x201f, 10))
insert into t1 values (repeat(0x2020, 10))
insert into t1 values (repeat(0x2021, 10))
INSERT INTO t1 VALUES (1, REPEAT('a',59), REPEAT('a',512))
INSERT INTO t1 VALUES (2, REPEAT('a',59), REPEAT('a',512))
select extract(YEAR_MONTH FROM "1999-01-02")
select extract(DAY_HOUR FROM "1999-01-02 10:11:12")
select extract(DAY_MINUTE FROM "02 10:11:12")
select extract(DAY_SECOND FROM "225 10:11:12")
select extract(HOUR_MINUTE FROM "10:11:12")
select extract(HOUR_SECOND FROM "10:11:12")
select extract(MINUTE_SECOND FROM "10:11:12")
select strcmp(date_format(date_sub(localtimestamp(), interval 3 hour),"%T"), utc_time())=0
select strcmp(date_format(date_sub(localtimestamp(), interval 3 hour),"%Y-%m-%d"), utc_date())=0
select strcmp(date_format(utc_timestamp(),"%T"), utc_time())=0
select strcmp(date_format(utc_timestamp(),"%Y-%m-%d"), utc_date())=0
select strcmp(concat(utc_date(),' ',utc_time()),utc_timestamp())=0
explain select period_add("9602",-12),period_diff(199505,"9404"),from_days(to_days("960101")),dayofmonth("1997-01-02"), month("1997-01-02"), monthname("1972-03-04"),dayofyear("0000-00-00"),HOUR("1997-03-03 23:03:22"),MINUTE("23:03:22"),SECOND(230322),QUARTER(980303),WEEK("1998-03-03"),yearweek("2000-01-01",1),week(19950101,1),year("98-02-03"),weekday(curdate())-weekday(now()),dayname("1962-03-03"),unix_timestamp(),sec_to_time(time_to_sec("0:30:47")/6.21),curtime(),utc_time(),curdate(),utc_date(),utc_timestamp(),date_format("1997-01-02 03:04:05", "%M %W %D %Y %y %m %d %h %i %s %w"),from_unixtime(unix_timestamp("1994-03-02 10:11:12")),"1997-12-31 23:59:59" + INTERVAL 1 SECOND,"1998-01-01 00:00:00" - INTERVAL 1 SECOND,INTERVAL 1 DAY + "1997-12-31", extract(YEAR FROM "1999-01-02 10:11:12"),date_add("1997-12-31 23:59:59",INTERVAL 1 SECOND)
create procedure t_sysdate() begin select sysdate() into @a; do sleep(2); select sysdate() into @b; select @a != @b; end;
DO  STR_TO_DATE((''), FROM_DAYS(@@GLOBAL.SQL_MODE))
DO WEEK((DATE_ADD((CAST(0 AS DATE)), INTERVAL 1 YEAR_MONTH)), 5)
query_vertical SELECT DATE('20091000'), STR_TO_DATE('200910','%Y%m'), LAST_DAY('2009-10-00'), LAST_DAY(DATE('2009-10-00')), LAST_DAY(DATE'2009-10-00'), LAST_DAY(STR_TO_DATE('200910','%Y%m')), WEEK('2009-10-00'), WEEK(DATE('2009-10-00')), WEEK(DATE'2009-10-00'), WEEK(STR_TO_DATE('200910','%Y%m')), WEEKOFYEAR('2009-10-00'), WEEKOFYEAR(DATE('2009-10-00')), WEEKOFYEAR(DATE'2009-10-00'), WEEKOFYEAR(STR_TO_DATE('200910','%Y%m')), DAYOFYEAR('2009-10-00'), DAYOFYEAR(DATE('2009-10-00')), DAYOFYEAR(DATE'2009-10-00'), DAYOFYEAR(STR_TO_DATE('200910','%Y%m')), WEEKDAY('2009-10-00'), WEEKDAY(DATE('2009-10-00')), WEEKDAY(DATE'2009-10-00'), WEEKDAY(STR_TO_DATE('200910','%Y%m')), TO_DAYs('2009-10-00'), TO_DAYs(DATE('2009-10-00')), TO_DAYs(DATE'2009-10-00'), TO_DAYs(STR_TO_DATE('200910','%Y%m'))
query_vertical SELECT DATE('00000100'), STR_TO_DATE('000001','%Y%m'), LAST_DAY('0000-01-00'), LAST_DAY(DATE('0000-01-00')), LAST_DAY(DATE'0000-01-00'), LAST_DAY(STR_TO_DATE('000001','%Y%m')), WEEK('0000-01-00'), WEEK(DATE('0000-01-00')), WEEK(DATE'0000-01-00'), WEEK(STR_TO_DATE('000001','%Y%m')), WEEKOFYEAR('0000-01-00'), WEEKOFYEAR(DATE('0000-01-00')), WEEKOFYEAR(DATE'0000-01-00'), WEEKOFYEAR(STR_TO_DATE('000001','%Y%m')), DAYOFYEAR('0000-01-00'), DAYOFYEAR(DATE('0000-01-00')), DAYOFYEAR(DATE'0000-01-00'), DAYOFYEAR(STR_TO_DATE('000001','%Y%m')), WEEKDAY('0000-01-00'), WEEKDAY(DATE('0000-01-00')), WEEKDAY(DATE'0000-01-00'), WEEKDAY(STR_TO_DATE('000001','%Y%m')), TO_DAYs('0000-01-00'), TO_DAYs(DATE('0000-01-00')), TO_DAYs(DATE'0000-01-00'), TO_DAYs(STR_TO_DATE('000001','%Y%m'))
DO MBRContains(1, if(0, coalesce(NULL), now()))
DO maketime(~0, 49, 0.123456789)
DO is_used_lock(ifnull(now(), CASE 1 WHEN 1 THEN NULL END))
CREATE VIEW v1 AS SELECT NOW(6), CURTIME(4), LOCALTIME(3), CURRENT_TIME(2), CURRENT_TIMESTAMP(0), LOCALTIMESTAMP(1), UTC_TIME(4), UTC_TIMESTAMP(4)
DO DAYOFYEAR(SEC_TO_TIME((~(((RELEASE_ALL_LOCKS())-((1)))))))
DO DAYOFYEAR(((MBRDISJOINT(0xbc,1))OR(WEEK(SEC_TO_TIME(419824656)))))
DO DAYOFYEAR(SEC_TO_TIME(OCT(BIT_AND(JSON_REPLACE((23533),'key3',NULL)))))
DO DAYOFYEAR(MAKETIME(((0x965a)^((@g :=(1 IS NULL)))), EXP(39988664861.65638662152600787509), ((STD(@f))LIKE(1))))
DO DAYOFYEAR(MAKETIME('1981-06-27 11:16:09.211343', (((NOT(ST_DISTANCE_SPHERE(POINT(4472,28027), POINT(28061,-9007199254740996),-644021130))))<=>(@c)),(1)))
DO DAYOFYEAR(MAKETIME(ROUND(-23797,'6588-01-08'), COERCIBILITY(BIT_COUNT(RTRIM((~( INET6_NTOA(0xa04810f0839d318fa075bd)))))), ((ST_ASWKT(1))OR(1))))
UNLOCK TABLES
send SELECT * FROM t1 FOR UPDATE; # blocked by con1 sleep 1
send FLUSH TABLES WITH READ LOCK; # blocked by con2 COMMIT; # should not be blocked by con3 reap
reap
UNLOCK TABLES
SHOW CREATE DATABASE test
CALL mtr.add_suppression("Enabling keys got errno")
exec echo 1 > $MYSQLD_DATADIR/test/t1.MYI
LOCK TABLES t1 READ
UNLOCK TABLES
select repeat('a',2000)
select length(repeat('a',2000))
UPDATE t1 SET c12= REPEAT('ab', @max_allowed_packet)
UPDATE IGNORE t1 SET c12= REPEAT('ab', @max_allowed_packet)
UPDATE t1, t2 SET c12= REPEAT('ab', @max_allowed_packet), c22= 'ab'
UPDATE IGNORE t1, t2 SET c12= REPEAT('ab', @max_allowed_packet), c22= 'ab'
INSERT INTO t1 VALUES (101, REPEAT('ab', @max_allowed_packet))
INSERT INTO t1 SELECT 101, REPEAT('ab', @max_allowed_packet)
INSERT IGNORE INTO t1 SELECT 101, REPEAT('ab', @max_allowed_packet)
REPLACE INTO t1 VALUES (102, REPEAT('ab', @max_allowed_packet))
REPLACE INTO t1 SET c11= 102, c12= REPEAT('ab', @max_allowed_packet)
REPLACE INTO t1 SELECT 102, REPEAT('ab', @max_allowed_packet)
DELETE FROM t1 WHERE c12 <=> REPEAT('ab', @max_allowed_packet)
DELETE FROM t1, t2 USING t1 INNER JOIN t2 WHERE t1.c11 = t2.c21 AND t2.c22 <=> REPEAT('ab', @max_allowed_packet)
DELETE IGNORE FROM t1, t2 USING t1 INNER JOIN t2 WHERE t1.c11 = t2.c21 AND t2.c22 <=> REPEAT('ab', @max_allowed_packet)
UPDATE t1 SET c12= REPEAT('ab', @max_allowed_packet)
INSERT INTO t1 VALUES (101, REPEAT('ab', @max_allowed_packet))
INSERT INTO t1 SELECT 102, REPEAT('ab', @max_allowed_packet)
DELETE FROM t1 WHERE c12 <=> REPEAT('ab', @max_allowed_packet)
LOCK TABLES t1 WRITE, t2 WRITE
UNLOCK TABLES
LOCK TABLES t1 WRITE, t2 WRITE
UNLOCK TABLES
LOCK TABLES t1 WRITE, t2 WRITE
UNLOCK TABLES
LOCK TABLE t4 WRITE
UNLOCK TABLES
LOCK TABLES t2 WRITE, t1 WRITE
UNLOCK TABLES
query_get_value(SHOW EXTENDED TABLES FROM test, Tables_in_test, 1)
source include/show_binlog_events.inc
select * from t1 where MATCH(a,b) AGAINST ("indexes" IN BOOLEAN MODE WITH QUERY EXPANSION)
lock tables t1 write
unlock tables
remove_file $MYSQLTEST_VARDIR/tmp/bug21412.sql; DELIMITER \ remove_file $MYSQLTEST_VARDIR/tmp/bug21412.sql; DELIMITER
remove_file $MYSQLTEST_VARDIR/tmp/bug21412.sql; ï»¿select "This is a file starting with UTF8 BOM 0xEFBBBF"; remove_file $MYSQLTEST_VARDIR/tmp/bug29323.sql; delimiter || select 2 |
remove_file $MYSQLTEST_VARDIR/tmp/bug38158.sql; ;DELIMITER DELIMITER ; SELECT 1DELIMITER DELIMITER ; SELECT 1
remove_file $MYSQLTEST_VARDIR/tmp/bug31060.sql
remove_file $MYSQLTEST_VARDIR/tmp/bug27884.sql
CONNECT test
resetconnection
PREPARE x FROM 'INSERT INTO t1 VALUES (1), (2)'
EXECUTE x
resetconnection
EXECUTE x
[client] database=db1 remove_file $MYSQLTEST_VARDIR/tmp/bug10608.cnf
[client] loose-database=db2 remove_file $MYSQLTEST_VARDIR/tmp/bug10608.cnf
[client] host = 127.0.0.1 [client] host = 127.0.0.1 CREATE USER testadmin_user1
write_file $file
!includedir /nonexistent write_file $file2
!include /nonexistent exec $MYSQLADMIN --defaults-file=$file -uroot -h localhost --password="" -S $MASTER_MYSOCK -P $MASTER_MYPORT --show-warnings ping 2>&1
exec $MYSQLADMIN --defaults-file=$file2 -uroot -h localhost --password="" -S $MASTER_MYSOCK -P $MASTER_MYPORT --show-warnings ping 2>&1
remove_file $file
remove_file $file2
call mtr.add_suppression("Plugin validate_password reported: .Dictionary file not specified.")
source $passwd_file
remove_file $PASSWD_FILE
remove_file $MYSQLD_LOG
CREATE PROCEDURE sp1() BEGIN DECLARE v1, v2, v3, v4 DECIMAL(28,12); DECLARE v3_2, v4_2 DECIMAL(28, 12); DECLARE counter INT; SET v1 = 1; SET v2 = 2; SET v3 = 1000000000000; SET v4 = 2000000000000; SET counter = 0; WHILE counter < 100000 DO SET v1 = v1 + 0.000000000001; SET v2 = v2 - 0.000000000001; SET v3 = v3 + 1; SET v4 = v4 - 1; SET counter = counter + 1; END WHILE; SET v3_2 = v3 * 0.000000000001; SET v4_2 = v4 * 0.000000000001; SELECT v1, v2, v3, v3_2, v4, v4_2; END
DO version_tokens_set('vt1=11;vt2=22;vt3=33;vt4=44;vt5=55')
DO version_tokens_lock_exclusive('vt3', 'vt5', 'vt1', 0)
DO version_tokens_lock_exclusive('vt3', 'vt5', 'vt1', 4)
DO version_tokens_unlock()
delimiter
SELECT @@global.syseventlog.tag
SELECT @@global.syseventlog.tag
SELECT @@global.syseventlog.tag
SELECT @@global.syseventlog.tag
set global init_connect="create procedure p1(x int)\ begin\ select count(*) from t1;\ select * from t1;\ set @x = x
end"
create procedure p1(out sum int) begin declare n int default 0; declare c cursor for select * from t1; declare exit handler for not found begin close c; set sum = n; end; open c; loop begin declare x int; fetch c into x; if x > 3 then set n = n + x; end if; end; end loop; end
create procedure p1(tbl char(10), v int) begin set @s = concat('insert into ', tbl, ' values (?)'); set @v = v; prepare stmt1 from @s; execute stmt1 using @v; deallocate prepare stmt1; end
create function f1() returns int begin declare n int; select count(*) into n from t1; return n; end
call mtr.add_suppression("\\[Warning\\] \\[.*\\] init_connect variable is ignored for user:.* host: localhost due to expired password.")
CALL mtr.add_suppression("Failed to initialize TLS for channel: mysql_admin")
CALL mtr.add_suppression("Failed to set up SSL because of the following SSL library error")
source include/func_aes_block.inc
CREATE FUNCTION round_to_step(i INT, n INT) RETURNS INT BEGIN DECLARE step INT; SELECT * INTO step FROM t_step; RETURN FLOOR((i % (step * n) + 0.1) / step); END
CREATE FUNCTION f1(comment CHAR(80)) RETURNS INT BEGIN DECLARE orig_tz CHAR(64); DECLARE unix_time INT; DECLARE local_now DATETIME; DECLARE utc_now DATETIME; DECLARE local_time INT; SET unix_time= UNIX_TIMESTAMP(); SET local_now= FROM_UNIXTIME(unix_time); SET orig_tz= @@TIME_ZONE; SET TIME_ZONE = '+00:00'; SET utc_now= FROM_UNIXTIME(unix_time); SET TIME_ZONE= orig_tz; SET local_time = unix_time + TIMESTAMPDIFF(SECOND, utc_now, local_now); SET unix_time= round_to_step(unix_time, 6); SET local_time= round_to_step(local_time, 6); INSERT INTO t1 VALUES ((SELECT count FROM t2), unix_time, local_time, comment); RETURN 0; END
STARTS FROM_UNIXTIME($now - @step) DO INSERT INTO t1 VALUES ("e1", NOW(), round_to_step(UNIX_TIMESTAMP() - $now, 4) - 1)
STARTS FROM_UNIXTIME($now + @step) DO INSERT INTO t1 VALUES ("e2", NOW(), round_to_step(UNIX_TIMESTAMP() - $now, 4) - 1)
ENGINE = $type
prepare stmt1 from ' select s from t2 where match (s) against (?) '
execute stmt1 using @arg00
prepare stmt1 from ' SELECT s FROM t2 where match (s) against (concat(?,''digger'')) '
execute stmt1 using @arg00
PREPARE x FROM 'INSERT INTO t1 VALUES (1), (2)'
EXECUTE x
EXECUTE x
set @a:=1
LOCK TABLE t1 WRITE
call mtr.add_suppression("Failed to set up SSL because of the following SSL library error")
call mtr.add_suppression("Failed to initialize TLS for channel: mysql_main")
LOCK TABLES t1 WRITE
UNLOCK TABLES
LOCK TABLES t3 WRITE
UNLOCK TABLES
create table t2 (primary key (auto)) select auto+1 as auto,1 as t1, 'a' as t2, repeat('a',256) as t3, binary repeat('b',256) as t4, repeat('a',4096) as t5, binary repeat('b',4096) as t6, '' as t7, binary '' as t8 from t1
'$MYSQLD_DATADIR/mysqltest_db1/t1.TRG' FROM patch
TYPE=TRIGGERNAME trigger_table=t1 TYPE=TRIGGERNAME trigger_table=t1 TYPE=TRIGGERNAME trigger_table=t1 TYPE=TRIGGERNAME trigger_table=t1 TYPE=TRIGGERNAME trigger_table=t1 TYPE=TRIGGERS triggers='CREATE DEFINER=`root`@`localhost` TRIGGER tr11 BEFORE INSERT ON t1 FOR EACH ROW DELETE FROM t3' 'CREATE DEFINER=`root`@`localhost` TRIGGER tr12 AFTER INSERT ON t1 FOR EACH ROW DELETE FROM t3' 'CREATE DEFINER=`root`@`localhost` TRIGGER tr13 BEFORE DELETE ON t1 FOR EACH ROW DELETE FROM t1 a USING t1 a' 'CREATE DEFINER=`root`@`localhost` TRIGGER tr14 AFTER DELETE ON t1 FOR EACH ROW DELETE FROM non_existing_table' 'CREATE DEFINER=`root`@`localhost` TRIGGER tr15 BEFORE UPDATE ON t1 FOR EACH ROW DELETE FROM non_existing_table a USING non_existing_table a' sql_modes=0 0 0 0 0 definers='root@localhost' 'root@localhost' 'root@localhost' 'root@localhost' 'root@localhost' TYPE=TRIGGERS triggers='Not allowed syntax here, and trigger name cant be extracted either.' sql_modes=0 definers='root@localhost' FLUSH TABLE t1
FLUSH TABLE t2
show grants for mysqltest_1@localhost
show grants for mysqltest_2@localhost
show grants for mysqltest_1@localhost
show grants for 'mysqltest_1'
show grants for 'mysqltest_2'
show grants for 'mysqltest_1'
show grants for 'mysqltest_1'
show grants for 'mysqltest_1'
show grants for 'mysqltest_1'
show grants for 'mysqltest_1'
show grants for '%@b'@'b'
show grants for '%@b'@'b'
show grants for '%@b'@'b'
show grants for '%@a'@'a'
lock table mysql.user write
send flush privileges
send grant all on *.* to 'mysqltest_1'@'localhost'
unlock tables
reap
reap
lock table mysql.user write
send set password for 'mysqltest_1'@'localhost' = ''
send revoke all on *.* from 'mysqltest_1'@'localhost'
unlock tables
reap
reap
CREATE FUNCTION f2 () RETURNS INT BEGIN DECLARE v INT; SELECT s1 FROM t2 INTO v; RETURN v; END
CREATE TEMPORARY TABLE t6(a INT) ENGINE = MERGE UNION = ()
ALTER TABLE t6 UNION = ()
SET @a := (SELECT COUNT(*) FROM t1)
LOCK TABLES t1 READ
UNLOCK TABLES
RENAME TABLE t3 TO t3_1
HANDLER t1 OPEN
HANDLER t1 READ NEXT
HANDLER t1 CLOSE
DO (SELECT COUNT(*) FROM t1)
PREPARE stmt1 FROM 'SELECT * FROM t1 ORDER BY a'
PREPARE stmt2 FROM 'SELECT * FROM t2 ORDER BY a'
EXECUTE stmt1
EXECUTE stmt2
DEALLOCATE PREPARE stmt1
DEALLOCATE PREPARE stmt2
ALTER TABLE mysqltest_db2.t2_2 UNION = ()
INSERT INTO all_types VALUES ( NULL,     # BOOLEAN NULL,     # BIT NULL,     # TINYINT NULL,     # SMALLINT NULL,     # MEDIUMINT NULL,     # INTEGER NULL,     # BIGINT NULL,     # TINYINT_UNSIGNED NULL,     # SMALLINT_UNSIGNED NULL,     # MEDIUMINT_UNSIGNED NULL,     # INTEGER_UNSIGNED NULL,     # BIGINT_UNSIGNED NULL,     # FLOAT NULL,     # DOUBLE NULL,     # DECIMAL(65, 2) NULL,     # DATE NULL,     # TIME NULL,     # YEAR NULL,     # DATETIME NULL,     # TIMESTAMP NULL,     # CHAR NULL,     # VARCHAR NULL,     # TINYTEXT NULL,     # TEXT NULL,     # MEDIUMTEXT NULL,     # LONGTEXT NULL,     # BINARY NULL,     # VARBINARY NULL,     # TINYBLOB NULL,     # BLOB NULL,     # MEDIUMBLOB NULL,     # LONGBLOB NULL,     # ENUM NULL);    # SET INSERT INTO all_types VALUES ( FALSE,                                                               # BOOLEAN b'0000000000000000000000000000000000000000000000000000000000000000', # BIT -128,                                                                # TINYINT -32768,                                                              # SMALLINT -8388608,                                                            # MEDIUMINT -2147483648,                                                         # INTEGER -9223372036854775808,                                                # BIGINT 0,                                                                   # TINYINT_UNSIGNED 0,                                                                   # SMALLINT_UNSIGNED 0,                                                                   # MEDIUMINT_UNSIGNED 0,                                                                   # INTEGER_UNSIGNED 0,                                                                   # BIGINT_UNSIGNED -3.402823466E+38,                                                    # FLOAT -1.7976931348623157E+308,                                            # DOUBLE -999999999999999999999999999999999999999999999999999999999999999.99, # DECIMAL(65, 2) '1000-01-01',                                                        # DATE '-838:59:59.000000',                                                 # TIME 1901,                                                                # YEAR '1000-01-01 00:00:00',                                               # DATETIME '1970-01-02 00:00:01',                                               # TIMESTAMP '',                                                                  # CHAR '',                                                                  # VARCHAR '',                                                                  # TINYTEXT '',                                                                  # TEXT '',                                                                  # MEDIUMTEXT '',                                                                  # LONGTEXT '',                                                                  # BINARY '',                                                                  # VARBINARY '',                                                                  # TINYBLOB '',                                                                  # BLOB '',                                                                  # MEDIUMBLOB '',                                                                  # LONGBLOB 'red',                                                               # ENUM '');                                                                 # SET INSERT INTO all_types VALUES ( TRUE,                                                                # BOOLEAN b'1111111111111111111111111111111111111111111111111111111111111111', # BIT 127,                                                                 # TINYINT 32767,                                                               # SMALLINT 8388607,                                                             # MEDIUMINT 2147483647,                                                          # INTEGER 9223372036854775807,                                                 # BIGINT 255,                                                                 # TINYINT_UNSIGNED 65535,                                                               # SMALLINT_UNSIGNED 16777215,                                                            # MEDIUMINT_UNSIGNED 4294967295,                                                          # INTEGER_UNSIGNED 18446744073709551615,                                                # BIGINT_UNSIGNED 3.402823466E+38,                                                     # FLOAT 1.7976931348623157E+308,                                             # DOUBLE 999999999999999999999999999999999999999999999999999999999999999.99,  # DECIMAL(65, 2) '9999-12-31',                                                        # DATE '838:59:59.000000',                                                  # TIME 2155,                                                                # YEAR '9999-12-31 23:59:59',                                               # DATETIME '2038-01-19 03:14:07',                                               # TIMESTAMP 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',                     # CHAR 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',                     # VARCHAR 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',                     # TINYTEXT 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',                     # TEXT 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',                     # MEDIUMTEXT 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',                     # LONGTEXT 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',                     # BINARY 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',                     # VARBINARY 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',                     # TINYBLOB 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',                     # BLOB 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',                     # MEDIUMBLOB 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',                     # LONGBLOB 'purple',                                                            # ENUM 'three');                                                            # SET SELECT COUNT(*) AS should_be_0 FROM information_schema.COLUMN_STATISTICS
LOCK TABLES t2 READ
UNLOCK TABLES
LOCK TABLES t2 READ
UNLOCK TABLES
RENAME TABLE t1 TO t1_renamed
RENAME TABLE t1 TO t1_renamed
PREPARE ps FROM 'ANALYZE TABLE t UPDATE HISTOGRAM ON x WITH 10 BUCKETS'
EXECUTE ps
EXECUTE ps
RENAME TABLE foo.tbl TO bar.tbl2
CREATE TRIGGER ai AFTER INSERT ON t1 FOR EACH ROW SET @a:= NEW.at
LOCK INSTANCE FOR BACKUP
UNLOCK INSTANCE
source include/restart_mysqld.inc
drop table if exists t1,t2,t3,t4,t9,`t1a``b`,v1,v2,v3,v4,v5,v6
drop view if exists t1,t2,`t1a``b`,v1,v2,v3,v4,v5,v6
create view v1 (c,d,e,f) as select a,b, a in (select a+2 from t1), a = all (select a from t1) from t1
create view v1 (c,d,e,f) as select a,b, a in (select a+2 from t1), a = all (select a from t1) from t1
create or replace view v1 (c,d,e,f) as select a,b, a in (select a+2 from t1), a = all (select a from t1) from t1
create table `t1a``b` (col1 char(2))
drop table `t1a``b`
PREPARE stmt FROM 'UPDATE v1 SET a = ?'
EXECUTE stmt USING @v0
DEALLOCATE PREPARE stmt
PREPARE stmt FROM 'insert into v1 values (?)'
EXECUTE stmt USING @v0
DEALLOCATE PREPARE stmt
PREPARE stmt FROM 'insert into v1 (a) values (?)'
EXECUTE stmt USING @v0
DEALLOCATE PREPARE stmt
prepare stmt1 from "select distinct a from v1 limit 2"
execute stmt1
execute stmt1
deallocate prepare stmt1
create function `f``1` () returns int return 5
create view v1 as select test.`f``1` ()
drop function `f``1`
rename table v1 to mysqltest.v1
rename table v1 to v2
rename table v3 to v1, v2 to t1
handler v1 open as xx
prepare stmt1 from "update v1,t1 set v1.s1=? where t1.s1=v1.s1"
execute stmt1 using @arg
execute stmt1 using @arg
deallocate prepare stmt1
lock tables t1 read, v1 read
unlock tables
prepare stmt1 from "select * from v2;"
execute stmt1
execute stmt1
deallocate prepare stmt1
load data infile '../../std_data/loaddata2.dat' into table v1 fields terminated by ',' enclosed by ''''
load data infile '../../std_data/loaddata2.dat' ignore into table v1 fields terminated by ',' enclosed by ''''
load data infile '../../std_data/loaddata3.dat' into table v1 fields terminated by '' enclosed by '' ignore 1 lines
load data infile '../../std_data/loaddata3.dat' ignore into table v1 fields terminated by '' enclosed by '' ignore 1 lines
load data infile '../../std_data/loaddata2.dat' into table v1 fields terminated by ',' enclosed by ''''
load data infile '../../std_data/loaddata2.dat' ignore into table v1 fields terminated by ',' enclosed by ''''
prepare stmt1 from "select * from t3 left join v4 on (t3.a = v4.a);"
execute stmt1
execute stmt1
deallocate prepare stmt1
prepare stmt1 from "update v3 set a= ? where a=?"
execute stmt1 using @a,@b
execute stmt1 using @a,@b
deallocate prepare stmt1
prepare stmt1 from "insert into v3(a) values (?);"
execute stmt1 using @a
execute stmt1 using @a
deallocate prepare stmt1
prepare stmt1 from "insert into v3(a) select ?;"
execute stmt1 using @a
execute stmt1 using @a
deallocate prepare stmt1
create table t1 (a timestamp default now())
create table t2 (b timestamp default now())
CREATE PROCEDURE p1 ( ) BEGIN DO (SELECT  @next := IFNULL(max(bug_table_seq),0) + 1 FROM v1); INSERT INTO t1 VALUES (1); END
create procedure p1() create view v1 as select * from t1
prepare stmt1 from "select count(*) from v1 where x = ?"
execute stmt1 using @parm1
execute stmt1 using @parm1
create procedure p1 () deterministic begin create view v1 as select 1; end;
CREATE FUNCTION f1() RETURNS INTEGER BEGIN DECLARE retn INTEGER; SELECT Meaning FROM v1 INTO retn; RETURN retn; END
rename table v2 to t1
create function f1() returns int begin declare mx int; select max(a) from t1 into mx; return mx; end
rename table v2 to t1
SELECT TRIM(BOTH 'y' FROM s) FROM t1
CREATE VIEW v1 AS SELECT TRIM(BOTH 'y' FROM s) FROM t1
SELECT TRIM(LEADING 'y' FROM s) FROM t1
CREATE VIEW v1 AS SELECT TRIM(LEADING 'y' FROM s) FROM t1
SELECT TRIM(TRAILING 'y' FROM s) FROM t1
CREATE VIEW v1 AS SELECT TRIM(TRAILING 'y' FROM s) FROM t1
PREPARE t FROM 'UPDATE v1 SET c=3'
EXECUTE t
EXECUTE t
PREPARE t FROM 'UPDATE v2 SET c=3'
EXECUTE t
EXECUTE t
CREATE VIEW v1 AS SELECT * FROM t1 FORCE KEY (PRIMARY,b) ORDER BY a
CREATE VIEW v2 AS SELECT * FROM t1 USE KEY () ORDER BY a
prepare stmt from "select * from v2 where a = 1"
execute stmt
SELECT * FROM t1 USE INDEX (PRIMARY) WHERE c1=2
SELECT * FROM v1 USE INDEX (PRIMARY) WHERE c1=2
SELECT * FROM v1 FORCE INDEX (PRIMARY) WHERE c1=2
SELECT * FROM v1 IGNORE INDEX (PRIMARY) WHERE c1=2
RENAME TABLE `t-1` TO `t-2`
RENAME TABLE `v-1` TO `v-2`
create procedure p() begin declare continue handler for sqlexception begin end; create view a as select 1; end
CREATE VIEW v1 AS SELECT 1 FROM t1 GROUP BY SUBSTRING(1 FROM (SELECT 3 FROM t1 WHERE a >= ANY(SELECT 1)))
CREATE VIEW v1 AS SELECT 1 IN (1 LIKE 2,0) AS f
UNLOCK TABLES
INSERT INTO t2 VALUES ( NULL, repeat('x', 600), 3, repeat('y', 600), repeat('z', 600) )
(SELECT * FROM t2) AS dt
(SELECT * FROM t1 WHERE b=a*10) AS dt
(SELECT a, SUM(b) AS s, COUNT(*) AS c FROM t1 GROUP BY a ORDER BY a) AS dt
(SELECT DISTINCT a FROM t1) AS dt
(SELECT * FROM t1 LIMIT 3 OFFSET 3) AS dt
(SELECT DISTINCT a FROM t1 UNION ALL SELECT a FROM t2) AS dt
(SELECT * FROM t1 WHERE (SELECT a FROM t1 LIMIT 1) = b/10) AS dt
(SELECT * FROM t1 WHERE a IN (SELECT a FROM t2 WHERE a % 2 = 0)) AS dt
(SELECT a, (SELECT a FROM t2 WHERE a=t1.a) FROM t1 WHERE b IN (SELECT a*10 FROM t2)) AS dt
(SELECT a, (SELECT a FROM t2) FROM t1 WHERE b=a*10) AS dt
(SELECT a, b FROM t1 WHERE b IN (SELECT a*10 FROM t2)) AS dt
SELECT a, b, a IN (SELECT 1 FROM t2 WHERE a=6) AS s FROM t1
SELECT a, b, a IN (SELECT COUNT(*) FROM t2) AS c FROM t1
SELECT a IN (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s FROM t1
SELECT COUNT(*) AS a, a IN (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s FROM t1
SELECT a, COUNT(*) AS c, a IN (SELECT a FROM t2 WHERE a=COUNT(t1.a)) AS s FROM t1 GROUP BY a
PREPARE s FROM "set @a:=(SELECT 1 FROM t1,v2);"
EXECUTE s
EXECUTE s
PREPARE s1 FROM "SELECT (SELECT MAX(i)) AS field1 FROM (SELECT * FROM t) AS table1"
EXECUTE s1
PREPARE s2 FROM "SELECT (SELECT MAX(i)) AS field1 FROM v AS table1"
EXECUTE s2
DEALLOCATE PREPARE s1
DEALLOCATE PREPARE s2
PREPARE X FROM 'CREATE VIEW bug22108567_v1 AS SELECT 1 FROM (SELECT 1) AS D1'
EXECUTE X
RENAME TABLE t1 TO t2, v1 TO v2
RENAME TABLE t3 TO t1, t4 TO t2
PREPARE stmt FROM "CREATE VIEW v1 AS SELECT * FROM JSON_TABLE('[]', '$[*]' COLUMNS (c1 INT PATH '$.x')) AS jt"
EXECUTE stmt
EXECUTE stmt
EXECUTE stmt
DEALLOCATE PREPARE stmt
PREPARE stmt FROM "CREATE VIEW v1 AS WITH RECURSIVE cte (n) AS ( SELECT 1 UNION ALL SELECT n + 1 FROM cte WHERE n < 5 ) SELECT * FROM cte"
EXECUTE stmt
EXECUTE stmt
EXECUTE stmt
DEALLOCATE PREPARE stmt
call sys.create_synonym_db("INFORMATION_SCHEMA", "I_S")
CREATE VIEW v AS SELECT INSERT('a', 1, 1, YEAR(UNHEX('w'))) AS c
ENGINE $ENGINE PARTITION BY HASH (i) PARTITIONS 2
ENGINE $ENGINE PARTITION BY LIST (i) SUBPARTITION BY HASH (i) (PARTITION p0 VALUES IN (0) (SUBPARTITION s0, SUBPARTITION s1, SUBPARTITION s2), PARTITION p1 VALUES IN (1) (SUBPARTITION s3, SUBPARTITION s4, SUBPARTITION s5))
ENGINE $ENGINE
ENGINE $ENGINE
PARTITION BY HASH (i) PARTITIONS 2
source include/not_windows.inc
exec $MYSQLD --defaults-file=/path/with/no/extension --print-defaults 2>$MDF_LOG
exec $MYSQLD --defaults-file=/path/with.ext --print-defaults 2>$MDF_LOG
exec $MYSQLD --defaults-file=relative/path/with.ext --print-defaults 2>$MDF_LOG
exec $MYSQLD --defaults-file=relative/path/without/extension --print-defaults 2>$MDF_LOG
exec $MYSQLD --defaults-file=with.ext --print-defaults 2>$MDF_LOG
exec $MYSQLD --defaults-file=no_extension --print-defaults 2>$MDF_LOG
perl
my $dir = $ENV{'MYSQLTEST_VARDIR'}
open ( OUTPUT, ">$dir/tmp/zoneinfocheck.inc")
@path=()
close (OUTPUT)
begin $body end
call test.longprocedure(@value); select @value
create procedure p1() begin declare done integer default 0; declare vf1 char(100) ; declare vf2 mediumint; declare vf3 int ; declare vf4 real ; declare vf5 numeric ; declare cur1 cursor for select f1,f2,f3,f4,f5 from t1; declare continue handler for sqlstate '02000' set done = 1; open cur1; while done <> 1 do fetch cur1 into vf1, vf2, vf3, vf4, vf5; if not done then insert into t2 values (vf1, vf2, vf3, vf4, vf5); end if; end while; close cur1; end
create trigger trg before insert on t1 for each row set @a:=1
set @a:=0
create trigger trg before insert on t1 for each row set @a:=new.i
create trigger trg before insert on t1 for each row begin if isnull(new.j) then set new.j:= new.i * 10; end if; end
create trigger trg after insert on t1 for each row set @a:= if(@a,concat(@a, ":", new.i), new.i)
set @a:=""
create trigger trg before update on t1 for each row begin declare loc_err varchar(255); if abs(new.balance - old.balance) > 1000 then set new.balance:= old.balance; set loc_err := concat("Too big change for aid = ", new.aid); set @update_failed:= if(@update_failed, concat(@a, ":", loc_err), loc_err); end if; end
set @update_failed:=""
create trigger trg after update on t1 for each row set @total_change:=@total_change + new.i - old.i
set @total_change:=0
create trigger trg before delete on t1 for each row set @del_sum:= @del_sum + old.i
set @del_sum:= 0
create trigger trg after delete on t1 for each row set @del:= 1
set @del:= 0
create trigger trg1 before insert on t1 for each row begin if new.j > 10 then set new.j := 10; end if; end
create trigger trg2 before update on t1 for each row begin if old.i % 2 = 0 then set new.j := -1; end if; end
create trigger trg3 after update on t1 for each row begin if new.j = -1 then set @fired:= "Yes"; end if; end
set @fired:=""
create trigger t1_bi before insert on t1 for each row set @log:= concat(@log, "(BEFORE_INSERT: new=(id=", new.id, ", data=", new.data,"))")
create trigger t1_ai after insert on t1 for each row set @log:= concat(@log, "(AFTER_INSERT: new=(id=", new.id, ", data=", new.data,"))")
create trigger t1_bu before update on t1 for each row set @log:= concat(@log, "(BEFORE_UPDATE: old=(id=", old.id, ", data=", old.data, ") new=(id=", new.id, ", data=", new.data,"))")
create trigger t1_au after update on t1 for each row set @log:= concat(@log, "(AFTER_UPDATE: old=(id=", old.id, ", data=", old.data, ") new=(id=", new.id, ", data=", new.data,"))")
create trigger t1_bd before delete on t1 for each row set @log:= concat(@log, "(BEFORE_DELETE: old=(id=", old.id, ", data=", old.data,"))")
create trigger t1_ad after delete on t1 for each row set @log:= concat(@log, "(AFTER_DELETE: old=(id=", old.id, ", data=", old.data,"))")
set @log:= ""
set @log:= ""
set @log:= ""
set @log:= ""
set @log:= ""
create trigger t1_bi before insert on t1 for each row begin if new.id > f1() then set new.id:= f1(); end if; end
create trigger trg before insert on t1 for each row set @a:= old.i
create trigger trg before delete on t1 for each row set @a:= new.i
create trigger trg before update on t1 for each row set old.i:=1
create trigger trg before delete on t1 for each row set new.i:=1
create trigger trg after update on t1 for each row set new.i:=1
create trigger trg before update on t1 for each row set new.j:=1
create trigger trg before update on t1 for each row set @a:=old.j
create trigger trg before insert on t2 for each row set @a:=1
create trigger trg before insert on t1 for each row set @a:=1
create trigger trg after insert on t1 for each row set @a:=1
create trigger trg before insert on t3 for each row set @a:=1
create trigger trg2 before insert on t3 for each row set @a:=1
create trigger trg before insert on v1 for each row set @a:=1
create trigger trg before insert on t1 for each row set @a:=1
create trigger trg1 before delete on t1 for each row set @del_before:= @del_before + old.i
create trigger trg2 after delete on t1 for each row set @del_after:= @del_after + old.i
set @del_before:=0, @del_after:= 0
create trigger trg1 before insert on t1 for each row set @a:= 1
create trigger trg1 before insert on mysqltest.t1 for each row set @a:= 1
create trigger test.trg1 before insert on t1 for each row set @a:= 1
create trigger trg1 before update on t1 for each row set @a:= @a + new.j - old.j
create trigger trg2 after update on t1 for each row set @b:= "Fired"
set @a:= 0, @b:= ""
set @a:= 0, @b:= ""
create trigger trg3 before delete on t1 for each row set @c:= @c + old.j
create trigger trg4 before delete on t2 for each row set @d:= @d + old.i
create trigger trg5 after delete on t1 for each row set @e:= "After delete t1 fired"
create trigger trg6 after delete on t2 for each row set @f:= "After delete t2 fired"
set @c:= 0, @d:= 0, @e:= "", @f:= ""
create trigger trg1 before insert on t1 for each row begin if new.i = 1 then set new.j := 1; end if; end
create trigger trg2 after insert on t1 for each row set @a:= 1
set @a:= 0
create trigger trg2 after insert on t1 for each row set @b:= "Fired"
set @b:=""
load data infile '../../std_data/rpl_loaddata.dat' into table t1 (@a, i)
set @b:=""
load data infile '../../std_data/loaddata5.dat' into table t1 fields terminated by '' enclosed by '' (i, j)
create trigger bi before insert on t1 for each row set @a:= new.bt
create trigger bu before update on t1 for each row set @a:= new.bt
create trigger bd before delete on t1 for each row set @a:= old.bt
load data infile '../../std_data/loaddata5.dat' into table t1 fields terminated by '' enclosed by '' (i, k)
create trigger t1_ai after insert on t1 for each row reset master
create trigger t1_ai after insert on t1 for each row reset slave
create trigger t1_ai after insert on t1 for each row flush hosts
create trigger t1_ai after insert on t1 for each row flush tables with read lock
create trigger t1_ai after insert on t1 for each row flush logs
create trigger t1_ai after insert on t1 for each row flush status
create trigger t1_ai after insert on t1 for each row flush user_resources
create trigger t1_ai after insert on t1 for each row flush tables
create trigger t1_ai after insert on t1 for each row flush privileges
create procedure p1() flush tables
create procedure p1() reset master
create procedure p1() reset slave
create procedure p1() flush hosts
create procedure p1() flush privileges
create procedure p1() flush tables with read lock
create procedure p1() flush tables
create procedure p1() flush logs
create procedure p1() flush status
create procedure p1() flush user_resources
create trigger t1_whoupdated before update on t1 for each row begin declare user varchar(32); declare i int; select user() into user; set NEW.username = user; select count(*) from ((select 1) union (select 2)) as d1 into i; end
lock tables t2 write
send insert into t1 values ((select max(id) from t2)), (2)
create trigger t1_trg before insert on t1 for each row set NEW.id:= 1
unlock tables
reap
lock tables t2 write
send insert into t1 values ((select max(id) from t2)), (4)
unlock tables
reap
lock tables t2 write
send insert into t1 values ((select max(f) from v1)), (6)
unlock tables
reap
lock tables t2 write
send update t1, t2 set t1.id=10 where t1.id=t2.id
unlock tables
reap
lock tables t2 write
send update v1 set id1= 11
unlock tables
reap
prepare stmt1 from "insert into t1 values (10)"
execute stmt1
deallocate prepare stmt1
prepare stmt1 from "insert into t1 values (10)"
execute stmt1
deallocate prepare stmt1
create trigger trg before insert on t1 for each row begin declare done int default 0; set done= not done; end
create trigger t1_bi before insert on test.t1 for each row set @a:=0
create trigger test.t1_bi before insert on t1 for each row set @a:=0
create trigger t1_bi before insert on t1 for each row set @a:=new.id
create trigger t1_ai after insert on test.t1 for each row set @b:=new.id
rename table t1 to t2
create trigger t1_bi before insert on t1 for each row set @a:=new.id
rename table t1 to test.t2
create trigger t1_ai after insert on t1 for each row set @a:= (select max(a) from t1)
create trigger t2_ai after insert on t2 for each row set @a:= (select max(a) from t2)
load data infile '../../std_data/words.dat' into table t1 (a)
load data infile '../../std_data/words.dat' into table t1 (a) set b:= f1()
create trigger t1_ai after insert on t1 for each row begin declare sn numeric(15,2); select sum(n) into sn from t1 where i=new.i; replace into t2 values(new.i, sn); end
create trigger wont_work after update on mysql.user for each row begin set @a:= 1; end
create trigger wont_work after update on event for each row begin set @a:= 1; end
create trigger t4_bi before insert on t4 for each row set @t4_bi_called:=1
create trigger t4_bu before update on t4 for each row set @t4_bu_called:=1
set @a:=1/0
create trigger t1_bi before insert on t1 for each row set @a:=1/0
create trigger t1_bi before insert on t1 for each row begin insert into t2 values (new.id, new.v); update t2 set v=v+1 where id= new.id; replace t3 values (new.id, 0); update t2, t3 set t2.v=new.v, t3.v=new.v where t2.id=t3.id; create temporary table t5 select * from t1; delete from t5; insert into t5 select * from t1; insert into t4 values (0); set @check= (select count(*) from t5); update t4 set c= @check; drop temporary table t5; set @a:=1/0; end
set @check=0, @t4_bi_called=0, @t4_bu_called=0
select @check, @t4_bi_called, @t4_bu_called
create trigger t1_bi before insert on t1 for each row set @a:= f1() + 10
create trigger t1_bi before insert on t1 for each row set NEW.b := "In trigger t1_bi"
CREATE PROCEDURE bug22580_proc_2() BEGIN DROP TABLE IF EXISTS bug22580_tmp; CREATE TEMPORARY TABLE bug22580_tmp (a INT); DROP TABLE bug22580_tmp; END|
CREATE PROCEDURE bug22580_proc_1() BEGIN CALL bug22580_proc_2(); END|
CREATE TRIGGER t1bu BEFORE UPDATE ON bug22580_t1 FOR EACH ROW BEGIN CALL bug22580_proc_1(); END|
create trigger t1_ai after insert on t1 for each row set @a := 7
set @a:=""
lock table t1 write
unlock tables
lock tables t1 read
unlock tables
lock tables t1 read
unlock tables
lock tables t1 write
unlock tables
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN DECLARE a CHAR; SELECT 'ab' INTO a; SELECT 'ab' INTO a; SELECT 'a' INTO a; END
CREATE TRIGGER trg1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN DECLARE trg1 CHAR; SELECT 'ab' INTO trg1; END
CREATE TRIGGER trg2 AFTER INSERT ON t1 FOR EACH ROW BEGIN DECLARE trg2 CHAR; SELECT 'ab' INTO trg2; END
create trigger t1_bi before insert on t1 for each row set @a:=1
CREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW BEGIN DECLARE v TEXT; SET v = 'aaa'; SET NEW.c = v; END
CREATE TRIGGER t1_au AFTER UPDATE ON t1 FOR EACH ROW START SLAVE
CREATE TRIGGER t1_au AFTER UPDATE ON t1 FOR EACH ROW STOP SLAVE
CREATE TRIGGER t1_au AFTER UPDATE ON t1 FOR EACH ROW CREATE SERVER s FOREIGN DATA WRAPPER mysql OPTIONS (USER 'Remote', HOST '192.168.1.106', DATABASE 'test')
CREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROW ALTER SERVER s OPTIONS (password '1')
CREATE TRIGGER tr1 AFTER UPDATE ON t1 FOR EACH ROW DROP SERVER IF EXISTS s
CREATE TRIGGER tr1 AFTER UPDATE ON t1 FOR EACH ROW ALTER DATABASE db1 CHARACTER SET latin1
CREATE TRIGGER tr1 AFTER UPDATE ON t1 FOR EACH ROW ALTER USER 'u1'@'localhost' PASSWORD EXPIRE
CREATE TRIGGER tr1 AFTER UPDATE ON t1 FOR EACH ROW CHANGE REPLICATION SOURCE TO SOURCE_SSL = 0
RENAME TABLE t1 TO t1Renamed
LOCK TABLE s1.v1 WRITE
UNLOCK TABLES
SHOW GRANTS FOR mysqltest_u1@localhost
lock tables t1 write
unlock tables
unlock tables
set @a:=0
CREATE TRIGGER trigger_for_normal_insert BEFORE INSERT ON t1 FOR EACH ROW SET @x:= NEW.a
CREATE TABLE t1(a DATETIME NOT NULL DEFAULT NOW(), b INT)
CREATE TRIGGER trigger_for_insert_select BEFORE INSERT ON t1 FOR EACH ROW SET @x:= NEW.a
CREATE TRIGGER trigger_for_normal_replace BEFORE INSERT ON t1 FOR EACH ROW SET @x:= NEW.a
CREATE TABLE t1(a DATETIME NOT NULL DEFAULT NOW(), b INT)
CREATE TRIGGER trigger_for_replace_select BEFORE INSERT ON t1 FOR EACH ROW SET @x:= NEW.a
CREATE TABLE t1( a TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE NOW(), b INT DEFAULT 1 )
CREATE TRIGGER trigger_before_update BEFORE UPDATE ON t1 FOR EACH ROW SET @x:= NEW.a
CREATE TRIGGER trigger_before_update BEFORE UPDATE ON t1 FOR EACH ROW SET @x:= NEW.a
CREATE TRIGGER trigger_before_update_with_join BEFORE UPDATE ON t1 FOR EACH ROW SET @x:= NEW.a
CREATE TABLE t1( a TIMESTAMP NOT NULL DEFAULT NOW(), b INT )
CREATE TRIGGER trigger_for_load_infile BEFORE INSERT ON t1 FOR EACH ROW SET @x:= NEW.a
LOAD DATA INFILE 't1.dat' INTO TABLE t1(b)
remove_file $MYSQLD_DATADIR/test/t1.dat
CREATE TRIGGER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_e BEFORE INSERT ON t1 FOR EACH ROW SET @sum= @sum + NEW.f1
CREATE TRIGGER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_Ã© BEFORE INSERT ON t1 FOR EACH ROW SET @sum= @sum + NEW.f1
CREATE TRIGGER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_E BEFORE INSERT ON t1 FOR EACH ROW SET @sum= @sum + NEW.f1
SHOW CREATE TRIGGER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_Ã©
DROP TRIGGER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ð°Ñ_ÑÑ‚Ñ€Ð¾ÐºÐ°_Ã©
write_file $INIT_SQL
enable_connect_log
enable_reconnect
enable_reconnect
replace_result $MYSQLD_LOG MYSQLD_LOG $INIT_SQL INIT_SQL
source include/restart_mysqld.inc
source include/wait_until_connected_again.inc
replace_result $MYSQLD_LOG MYSQLD_LOG $INIT_SQL INIT_SQL
source include/restart_mysqld.inc
source include/wait_until_connected_again.inc
replace_result $MYSQLD_LOG MYSQLD_LOG $INIT_SQL INIT_SQL
source include/restart_mysqld.inc
source include/wait_until_connected_again.inc
replace_result $MYSQLD_LOG MYSQLD_LOG $INIT_SQL INIT_SQL
source include/restart_mysqld.inc
source include/wait_until_connected_again.inc
source include/search_pattern.inc
copy_file $MYSQLTEST_VARDIR/std_data/upgrade/data_$VERSION.zip $MYSQL_TMP_DIR/data_$VERSION.zip
file_exists $MYSQL_TMP_DIR/data_$VERSION.zip
exec unzip -qo $MYSQL_TMP_DIR/data_$VERSION.zip -d $MYSQL_TMP_DIR
replace_result $MYSQLD_LOG MYSQLD_LOG $MYSQLD_DATADIR MYSQLD_DATADIR
source include/restart_mysqld.inc
source include/wait_until_connected_again.inc
source include/shutdown_mysqld.inc
force-rmdir $MYSQL_TMP_DIR/data_$VERSION
exec unzip -qo $MYSQL_TMP_DIR/data_$VERSION.zip -d $MYSQL_TMP_DIR
replace_result $MYSQLD_LOG MYSQLD_LOG $MYSQLD_DATADIR MYSQLD_DATADIR
source include/start_mysqld.inc
source include/wait_until_connected_again.inc
source include/shutdown_mysqld.inc
force-rmdir $MYSQL_TMP_DIR/data_$VERSION
exec unzip -qo $MYSQL_TMP_DIR/data_$VERSION.zip -d $MYSQL_TMP_DIR
replace_result $MYSQLD_LOG MYSQLD_LOG $MYSQLD_DATADIR MYSQLD_DATADIR
source include/start_mysqld.inc
source include/wait_until_connected_again.inc
source include/shutdown_mysqld.inc
force-rmdir $MYSQL_TMP_DIR/data_$VERSION
exec unzip -qo $MYSQL_TMP_DIR/data_$VERSION.zip -d $MYSQL_TMP_DIR
exec $MYSQLD --datadir=$MYSQLD_DATADIR --innodb-read-only=1 --log-error=$MYSQLD_LOG --secure-file-priv=""
source include/search_pattern.inc
force-rmdir $MYSQL_TMP_DIR/data_$VERSION
remove_file $MYSQL_TMP_DIR/data_$VERSION.zip
copy_file $MYSQLTEST_VARDIR/std_data/upgrade/data_$VERSION.zip $MYSQL_TMP_DIR/data_$VERSION.zip
file_exists $MYSQL_TMP_DIR/data_$VERSION.zip
exec unzip -qo $MYSQL_TMP_DIR/data_$VERSION.zip -d $MYSQL_TMP_DIR
replace_result $MYSQLD_LOG MYSQLD_LOG $MYSQLD_DATADIR MYSQLD_DATADIR
source include/start_mysqld.inc
source include/wait_until_connected_again.inc
source include/shutdown_mysqld.inc
force-rmdir $MYSQL_TMP_DIR/data_$VERSION
exec unzip -qo $MYSQL_TMP_DIR/data_$VERSION.zip -d $MYSQL_TMP_DIR
replace_result $MYSQLD_LOG MYSQLD_LOG $MYSQLD_DATADIR MYSQLD_DATADIR
source include/start_mysqld.inc
source include/wait_until_connected_again.inc
source include/shutdown_mysqld.inc
force-rmdir $MYSQL_TMP_DIR/data_$VERSION
exec unzip -qo $MYSQL_TMP_DIR/data_$VERSION.zip -d $MYSQL_TMP_DIR
replace_result $MYSQLD_LOG MYSQLD_LOG $MYSQLD_DATADIR MYSQLD_DATADIR
source include/start_mysqld.inc
source include/wait_until_connected_again.inc
source include/shutdown_mysqld.inc
force-rmdir $MYSQL_TMP_DIR/data_$VERSION
exec unzip -qo $MYSQL_TMP_DIR/data_$VERSION.zip -d $MYSQL_TMP_DIR
exec $MYSQLD --datadir=$MYSQLD_DATADIR --innodb-read-only=1 --log-error=$MYSQLD_LOG --secure-file-priv=""
source include/search_pattern.inc
force-rmdir $MYSQL_TMP_DIR/data_$VERSION
remove_file $MYSQL_TMP_DIR/data_$VERSION.zip
exec $MYSQLD --datadir=$MYSQLD_DATADIR --read-only=1 --log-error=$MYSQLD_LOG --initialize-insecure
force-rmdir $MYSQL_TMP_DIR/data_$VERSION
exec $MYSQLD --datadir=$MYSQLD_DATADIR --super-read-only=1 --log-error=$MYSQLD_LOG --initialize-insecure
force-rmdir $MYSQL_TMP_DIR/data_$VERSION
exec $MYSQLD --datadir=$MYSQLD_DATADIR --transaction-read-only=1 --log-error=$MYSQLD_LOG --initialize-insecure
force-rmdir $MYSQL_TMP_DIR/data_$VERSION
exec $MYSQLD --datadir=$MYSQLD_DATADIR --innodb-read-only=1 --log-error=$MYSQLD_LOG --initialize-insecure
source include/search_pattern.inc
force-rmdir $MYSQL_TMP_DIR/data_$VERSION
enable_reconnect
source include/start_mysqld.inc
source include/wait_until_connected_again.inc
remove_file $INIT_SQL
RENAME TABLE t1 to t2
RENAME TABLE t2 to t1
echo "WL6369 Explain for Connection"
source include/func_aes_block.inc
SHOW GRANTS FOR some_user_name@host_1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890X
SHOW GRANTS FOR some_user_name@host_1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890
SHOW GRANTS FOR some_user_name@host_1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890
SHOW GRANTS FOR some_user_name@host_1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890
GRANT PROXY ON root@localhost TO some_user_name@host_1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890
GRANT PROXY ON some_user_name@host_1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890 TO root@localhost
TYPE=VIEW query=select 1 AS `a123456789012345678901234567890123456789012345678901234567890123456789` md5=fc83a6c1fde1c4183a3c24c91751f36f updatable=0 algorithm=0 definer_user=root definer_host=localhost suid=2 with_check_option=0 timestamp=2017-10-20 06:39:41 create-version=1 source=select 1 client_cs_name=utf8 view_body_utf8=select 1 AS `a123456789012345678901234567890123456789012345678901234567890123456789` drop table if exists t1
lock tables t1 write
unlock tables
lock tables t1 write
unlock tables
analyze table t1 extended
optimize table t1 extended
CREATE PROCEDURE p() ANALYZE TABLE v UPDATE HISTOGRAM ON w
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE >0
select c,table_name from v1 inner join information_schema.TABLES v2 on (v1.c=v2.table_name) where v1.c rlike "t[1-5]{1}$" order by c
select c,table_name from v1 left join information_schema.TABLES v2 on (v1.c=v2.table_name) where v1.c rlike "t[1-5]{1}$" order by c
select c, v2.table_name from v1 right join information_schema.TABLES v2 on (v1.c=v2.table_name) where v1.c rlike "t[1-5]{1}$" order by c
select table_name from information_schema.TABLES where table_schema = "mysqltest" and table_name rlike "t[1-5]{1}$" order by table_name
select * from information_schema.views where TABLE_SCHEMA != 'sys' and TABLE_NAME rlike "v[0-4]{1}$" order by table_name
create procedure px5 () begin declare v int; declare c cursor for select version from information_schema.tables where table_schema <> 'information_schema'; open c; fetch c into v; select v; close c; end;
create trigger trg1 before insert on t1 for each row begin if new.j > 10 then set new.j := 10; end if; end
create trigger trg2 before update on t1 for each row begin if old.i % 2 = 0 then set new.j := -1; end if; end
create trigger trg3 after update on t1 for each row begin if new.j = -1 then set @fired:= "Yes"; end if; end
show create database information_schema
set @a:= '.'
CREATE FUNCTION get_value() RETURNS TEXT DETERMINISTIC BEGIN DECLARE col1, col2, col3, col4, col6 CHAR(255); DECLARE default_val VARCHAR(65532) CHARACTER SET latin1; DECLARE done INT DEFAULT 0; DECLARE cur1 CURSOR FOR SELECT COLUMN_NAME, COLUMN_TYPE, IS_NULLABLE, COLUMN_KEY, COLUMN_DEFAULT, EXTRA FROM INFORMATION_SCHEMA.COLUMNS where TABLE_NAME='bug23037'; DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1; OPEN cur1; FETCH cur1 INTO col1, col2, col3, col4, default_val, col6; CLOSE cur1; RETURN default_val; end
send select * from information_schema.tables where 1=sleep(100000)
where state='User sleep' and info='select * from information_schema.tables where 1=sleep(100000)'
disable_query_log
enable_query_log
where state='User sleep' and info='select * from information_schema.tables where 1=sleep(100000)'
send select * from information_schema.columns where 1=sleep(100000)
where state='User sleep' and info='select * from information_schema.columns where 1=sleep(100000)'
disable_query_log
enable_query_log
where state='User sleep' and info='select * from information_schema.columns where 1=sleep(100000)'
lock table t2 read
unlock tables
create view information_schema.v1
RENAME TABLE v1 to v2, information_schema.processlist to t2
LOCK TABLES t1 READ, information_schema.processlist READ
lock table t1 read
send flush tables
unlock tables
reap
lock tables t2 read
rename table t0 to t4
unlock tables
CREATE PROCEDURE information_schema.is() BEGIN END
CREATE USER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_ÑŽÐ·ÐµÑ€__@localhost
GRANT SELECT ON *.* TO Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_ÑŽÐ·ÐµÑ€__@localhost
DROP USER Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð¾Ñ‡ÐµÐ½ÑŒ_Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹_ÑŽÐ·ÐµÑ€__@localhost
LOCK TABLE v1 READ
send FLUSH TABLES
UNLOCK TABLES
reap
PREPARE stmt FROM 'SELECT CAN_ACCESS_TABLE("test", "t1") AS f1, COLUMN_NAME AS F2  FROM INFORMATION_SCHEMA.COLUMNS'
LOCK TABLES t1 WRITE
UNLOCK TABLES
LOCK TABLE mysql.user READ
UNLOCK TABLES
UNLOCK TABLES
create trigger t1_bi before insert on t1 for each row begin set new.a := upper(new.a); set new.b := new.b + 3; end
LOCK INSTANCE FOR BACKUP
CREATE TABLESPACE testtablespace ADD DATAFILE 'ts.ibd' ENGINE=InnoDB
UNLOCK INSTANCE
CREATE TABLESPACE testtablespace ADD DATAFILE 'ts.ibd' ENGINE=InnoDB
LOCK INSTANCE FOR BACKUP
UNLOCK INSTANCE
change_user test_nopw
change_user test_newpw, newpw
change_user root
change_user test_nopw,,test
change_user test_newpw,newpw,test
change_user root,,test
echo Value of com_select did not change
PREPARE stmt1 FROM ' EXPLAIN SELECT a FROM t1 ORDER BY b '
EXECUTE stmt1
PREPARE stmt1 FROM ' EXPLAIN SELECT a FROM t1 WHERE a > ? ORDER BY b '
EXECUTE stmt1 USING @arg00
( a INT, b VARCHAR(30), PRIMARY KEY(a) ) ENGINE = $type
( c1  tinYINT, c2  SMALLINT, c3  MEDIUMINT, c4  INT, c5  INTEGER, c6  BIGINT, c7  FLOAT, c8  DOUBLE, c9  DOUBLE PRECISION, c10 REAL, c11 DECIMAL(7, 4), c12 NUMERIC(8, 4), c13 DATE, c14 DATETIME, c15 TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, c16 TIME, c17 YEAR, c18 TINYINT, c19 BOOL, c20 CHAR, c21 CHAR(10), c22 VARCHAR(30), c23 VARCHAR(100), c24 VARCHAR(100), c25 VARCHAR(100), c26 VARCHAR(100), c27 VARCHAR(100), c28 VARCHAR(100), c29 VARCHAR(100), c30 VARCHAR(100), c31 ENUM('one', 'two', 'three'), c32 SET('monday', 'tuesday', 'wednesday'), PRIMARY KEY(c1) ) ENGINE = $type
RENAME TABLE t1 TO t1_1, t9 TO t9_1
RENAME TABLE t1 TO t1_2, t9 TO t9_2
send update t1 set n = 2 and get_lock('mysqltest_lock', 100)
send update low_priority t1 set n = 4
send select n from t1
reap
reap
reap
send select n from t1 where get_lock('mysqltest_lock', 100)
send update low_priority t1 set n = 4
reap
reap
lock table t1 read
unlock tables
lock table t2 read
unlock tables
lock table t1 read
lock tables t1 read, t2 write
unlock tables
unlock tables
lock table t1 write, t2 write
send insert t1 select * from t2
unlock tables
reap
lock table t1 write, t2 write, t1 as t1_2 write, t2 as t2_2 write
send insert t1 select * from t2
unlock tables
reap
lock tables t1 write
unlock tables
LOCK TABLES columns_priv WRITE, db WRITE, user WRITE
send SELECT user.Select_priv FROM user, db WHERE user.user = db.user LIMIT 1
UNLOCK TABLES
reap
LOCK TABLE t1 WRITE
send FLUSH TABLES WITH READ LOCK
UNLOCK TABLES
reap
UNLOCK TABLES
LOCK TABLE t1 WRITE
send FLUSH TABLES WITH READ LOCK
UNLOCK TABLES
reap
UNLOCK TABLES
send DROP DATABASE mysqltest_1
UNLOCK TABLES
reap
lock tables t1 write
send alter table t1 auto_increment=0
send alter table t1 auto_increment=0
unlock tables
reap
reap
lock tables t1 write
send flush tables with read lock
send select * from t2 for update
unlock tables
unlock tables
send update t2 set a = 1
flush table t2
unlock tables
send lock tables t2 write
flush table t2
unlock tables
unlock tables
send select * from t1 where get_lock('mysqltest_lock', 100)
send update t1 set i= 10
send select * from t1
where state = "Waiting for table level lock" and info = "update t1 set i= 10"`
handler t1 open
lock tables t1 write
unlock tables
unlock tables
lock tables t1 write
unlock tables
send select * from t1 where get_lock('mysqltest_lock', 100)
send update t1 set a= 2
lock tables t1 write
LOCK TABLES v1 WRITE, t1 READ
FLUSH TABLE t1
LOCK TABLES t1 WRITE
FLUSH TABLE t1;                                    # Assertion happened here UNLOCK TABLES
LOCK TABLES t1 WRITE, v1 READ
FLUSH TABLE t1
LOCK TABLES t1 WRITE
FLUSH TABLE t1;                                    # Assertion happened here DROP TABLE t1
LOCK TABLE t1 WRITE
UNLOCK TABLES
LOCK TABLE t1 READ
UNLOCK TABLES
LOCK TABLE t1 READ
UNLOCK TABLES
LOCK TABLE t2 WRITE
UNLOCK TABLES
lock table t3 read
unlock tables
LOCK TABLE t1 WRITE
UNLOCK TABLES
CREATE TRIGGER bi_t5 BEFORE INSERT ON t5 FOR EACH ROW SET @a:= (SELECT COUNT(*) FROM t1)
CREATE TRIGGER bi_t6 BEFORE INSERT ON t6 FOR EACH ROW SET @a:= (SELECT COUNT(*) FROM t2)
LOCK TABLE t1 READ, t2 READ
UNLOCK TABLES
LOCK TABLES t1 READ, t2 READ
UNLOCK TABLES
LOCK TABLE t1 READ, t2 READ
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t1 READ
UNLOCK TABLES
LOCK TABLES t2 READ
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t1 READ, t2 READ
LOCK TABLES t1 READ, t2 READ
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t1 READ
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t2 READ
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t1 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t2 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLE t1 WRITE
UNLOCK TABLES
LOCK TABLE t2 WRITE
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLE t1 WRITE, t2 WRITE
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t1 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t2 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLE v1 READ, v2 READ
UNLOCK TABLES
LOCK TABLES v1 READ, v2 READ
UNLOCK TABLES
LOCK TABLE v1 READ, v2 READ
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES v1 READ
UNLOCK TABLES
LOCK TABLES v2 READ
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t1 READ, t2 READ
LOCK TABLES v1 READ, v2 READ
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES v1 READ
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES v2 READ
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t1 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t2 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES v3 WRITE, v4 WRITE
UNLOCK TABLES
LOCK TABLES v3 WRITE, v4 WRITE
UNLOCK TABLES
LOCK TABLES v3 WRITE, v4 WRITE
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES v3 WRITE
UNLOCK TABLES
LOCK TABLES v4 WRITE
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t1 READ, t2 READ
LOCK TABLES v3 WRITE, v4 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES v3 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES v4 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t1 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t2 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLE v1 WRITE
UNLOCK TABLES
LOCK TABLE v2 WRITE
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLE v1 WRITE, v2 WRITE
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES v1 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES v2 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t5 WRITE, t6 WRITE
UNLOCK TABLES
LOCK TABLES v3 WRITE, t6 WRITE
UNLOCK TABLES
LOCK TABLES t5 WRITE, t6 WRITE
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t5 WRITE
UNLOCK TABLES
LOCK TABLES t6 WRITE
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t1 READ, t2 READ
LOCK TABLES t5 WRITE, t6 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t5 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t6 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t1 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t2 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLE t7 WRITE
UNLOCK TABLES
LOCK TABLE t8 WRITE
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLE t7 WRITE, t8 WRITE
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t7 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t8 WRITE
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLE t1 READ LOCAL
UNLOCK TABLES
LOCK TABLE v1 READ LOCAL
UNLOCK TABLES
LOCK TABLE v2 READ LOCAL
UNLOCK TABLES
LOCK TABLE v2 READ LOCAL
UNLOCK TABLES
LOCK TABLE t2 READ LOCAL
UNLOCK TABLES
LOCK TABLE t2 READ LOCAL
UNLOCK TABLES
LOCK TABLE v3 READ LOCAL
UNLOCK TABLES
LOCK TABLE v3 READ LOCAL
UNLOCK TABLES
UNLOCK TABLES
UNLOCK TABLES
lock tables t1 write, t3 read
unlock tables
disable_warnings
enable_warnings
exec $MYSQL_BINLOG suite/binlog/std_data/bug32407.001 | $MYSQL
error ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT
error 1
exec $MYSQL_BINLOG --base64-output=never suite/binlog/std_data/bug32407.001
error 1149
error ER_UNKNOWN_ERROR
call mtr.add_suppression("Slave SQL.*master suffers from this bug: http:..bugs.mysql.com.bug.php.id=37426.* Error_code: MY-013127")
call mtr.add_suppression("Slave SQL.*Table definition on master and slave does not match: Column 1 size mismatch.* Error_code: 1535")
call mtr.add_suppression("Slave SQL.*Column 1 of table .test.char128_utf8. cannot be converted.* Error_code: MY-013146")
query_vertical SELECT User,plugin FROM mysql.user WHERE USER='u1'
query_vertical SELECT User,plugin FROM mysql.user WHERE USER='u2'
query_vertical SELECT User,plugin FROM mysql.user WHERE USER='u3'
query_vertical SELECT User,plugin FROM mysql.user WHERE USER='u4'
query_vertical SELECT User,plugin,ssl_type FROM mysql.user WHERE USER='u5'
query_vertical SELECT User,plugin,ssl_type FROM mysql.user WHERE USER='u6'
query_vertical SELECT User,plugin,ssl_type, ssl_cipher,x509_issuer,x509_subject,password_expired,password_lifetime FROM mysql.user WHERE USER='u7'
query_vertical SELECT User,plugin,ssl_type,ssl_cipher,x509_issuer,x509_subject FROM mysql.user WHERE USER='u8'
query_vertical SELECT User,plugin,ssl_type,ssl_cipher,x509_issuer,x509_subject FROM mysql.user WHERE USER='u9'
query_vertical SELECT User,plugin,ssl_type,ssl_cipher,x509_issuer,x509_subject FROM mysql.user WHERE USER='u10'
query_vertical SELECT User,plugin,max_questions FROM mysql.user WHERE USER='u11'
query_vertical SELECT User,plugin,max_questions FROM mysql.user WHERE USER='u12'
query_vertical SELECT User,plugin,max_connections FROM mysql.user WHERE USER='u13'
query_vertical SELECT User,plugin,max_user_connections, password_expired,password_lifetime FROM mysql.user WHERE USER='u14'
query_vertical SELECT User,plugin,password_expired,password_lifetime FROM mysql.user WHERE USER BETWEEN 'u15' AND 'u17' ORDER BY User
query_vertical SELECT User,plugin,ssl_type,ssl_cipher,x509_issuer,x509_subject, max_questions,max_user_connections,password_expired,password_lifetime FROM mysql.user WHERE USER BETWEEN 'u18' AND 'u21' ORDER BY User
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u1'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u1'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u2'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u2'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u3'
ALTER USER u3@localhost IDENTIFIED WITH 'mysql_native_password'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u3'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u4'
ALTER USER u4@localhost IDENTIFIED WITH 'mysql_native_password' BY 'auth_string'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u4'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u5'
ALTER USER u5@localhost IDENTIFIED WITH 'sha256_password'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u5'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u6'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u6'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u7'
ALTER USER u7@localhost IDENTIFIED WITH 'mysql_native_password' REQUIRE ISSUER 'issuer'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u7'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u8'
ALTER USER u8@localhost IDENTIFIED WITH 'mysql_native_password' REQUIRE CIPHER "DHE-RSA-AES256-SHA"
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u8'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u9'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u9'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u10'
ALTER USER u10@localhost IDENTIFIED WITH 'sha256_password' BY 'auth_string' REQUIRE SSL
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u10'
query_vertical SELECT User,max_questions FROM mysql.user WHERE USER='u11'
query_vertical SELECT User,max_questions FROM mysql.user WHERE USER='u11'
query_vertical SELECT User,max_questions FROM mysql.user WHERE USER='u12'
ALTER USER u12@localhost IDENTIFIED WITH 'sha256_password' WITH MAX_QUERIES_PER_HOUR 8
query_vertical SELECT User,max_questions FROM mysql.user WHERE USER='u12'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u13'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER='u13'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired,max_user_connections, password_lifetime FROM mysql.user WHERE USER='u14'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired,max_user_connections, password_lifetime FROM mysql.user WHERE USER='u14'
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER BETWEEN 'u15' AND 'u17' order by 1
ALTER USER u15@localhost IDENTIFIED WITH 'sha256_password', u16@localhost, u17@localhost IDENTIFIED BY 'new_auth_string' PASSWORD EXPIRE DEFAULT
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired, password_lifetime FROM mysql.user WHERE USER BETWEEN 'u15' AND 'u17' order by 1
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired,max_user_connections, max_questions,password_lifetime FROM mysql.user WHERE USER BETWEEN 'u18' AND 'u21' order by 1
query_vertical SELECT User,ssl_type,ssl_cipher,x509_issuer,x509_subject, plugin,password_expired,max_user_connections, max_questions,password_lifetime FROM mysql.user WHERE USER BETWEEN 'u18' AND 'u21' order by 1
ALTER USER u2@localhost IDENTIFIED WITH 'sha256_password'
ALTER USER u8@localhost IDENTIFIED WITH 'mysql_native_password' BY 'auth_string'
ALTER USER 20553132_u2@localhost IDENTIFIED BY 'abcd', 20553132_u1@localhost IDENTIFIED WITH 'mysql_native_password' BY 'hijk' PASSWORD EXPIRE DEFAULT
ALTER USER u1 IDENTIFIED BY PASSWORD '*67092806AE91BFB6BE72DE6C7BE2B7CCA8CFA9DF' ALTER USER u1 IDENTIFIED BY PASSWORD '*67092806AE91BFB6BE72DE6C7BE2B7CCA8CFA9DF' ALTER USER u1 IDENTIFIED BY PASSWORD '*67092806AE91BFB6BE72DE6C7BE2B7CCA8CFA9DF' REQUIRE CIPHER "DHE-RSA-AES256-SHA" AND ALTER USER u1 IDENTIFIED BY PASSWORD '*67092806AE91BFB6BE72DE6C7BE2B7CCA8CFA9DF' DROP USER u1
explain select id, not (a=1 is true) from t1
select id, not (a=1 is true) from t1
explain select id, not (a=1 is false) from t1
select id, not (a=1 is false) from t1
explain select id, not (a=1 is unknown) from t1
select id, not (a=1 is unknown) from t1
write_file $BOOTSTRAP_SQL
remove_file $MYSQLD_LOG
remove_file $BOOTSTRAP_SQL
CALL mtr.add_suppression('You need to use --log-bin to make --binlog-format work.')
UNLOCK TABLES
IMPORT TABLE FROM 's2/t1*.sdi'
IMPORT TABLE FROM 't1_*.sdi'
IMPORT TABLE FROM 's1/t1_*.sdi'
IMPORT TABLE FROM 't1*.sdi'
IMPORT TABLE FROM 'pattern_which_matches_nothing'
IMPORT TABLE FROM 't1.MYD'
IMPORT TABLE FROM 't1.sdi'
UNLOCK TABLES
IMPORT TABLE FROM 't1_*.sdi'
IMPORT TABLE FROM 't1_*.sdi'
LOCK TABLES t1 WRITE
IMPORT TABLE FROM 't1_*.sdi'
UNLOCK TABLES
IMPORT TABLE FROM 't1_.sdi'
IMPORT TABLE FROM 's1/t1_*.sdi'
IMPORT TABLE FROM 's1/t1_*.sdi'
IMPORT TABLE FROM 't1_*.sdi'
IMPORT TABLE FROM 't1_*.sdi'
IMPORT TABLE FROM 't1_*.sdi'
IMPORT TABLE FROM 't1_*.sdi'
UNLOCK TABLES
IMPORT TABLE FROM 't1_*.sdi', 't2_*.sdi'
UNLOCK TABLES
IMPORT TABLE FROM 't1_.sdi'
UNLOCK TABLES
IMPORT TABLE FROM 's1/t1*.sdi'
UNLOCK TABLES
CALL mtr.add_suppression("Problem while dropping database. Can't remove database directory .* Please remove it manually.")
IMPORT TABLE FROM 's1/t1*.sdi'
UNLOCK TABLES
IMPORT TABLE FROM 't_case.sdi'
write_file $BOOTSTRAP_SQL
IMPORT TABLE FROM 't_case.sdi'
UNLOCK TABLES
IMPORT TABLE FROM 't1_*.sdi'
IMPORT TABLE FROM ''
UNLOCK TABLES
IMPORT TABLE FROM 't1_*.sdi'
IMPORT TABLE FROM 'test/t1*.sdi'
DO AVG((SELECT POINT(@x, POINT(115, 219)) IS NULL))
DO AVG((SELECT POINT(@x, POINT(115, 219)) IS NULL)) OVER ()
call mtr.add_suppression("\\[ERROR\\] .*MY-\\d+.* Table `test`.`t1` .* Partition.* InnoDB internal")
LOCK TABLE t1 WRITE
UNLOCK TABLES
SET @old_default_week_format := @@default_week_format
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(YEAR_MONTH FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(YEAR_MONTH FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(YEAR_MONTH FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(YEAR_MONTH FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(YEAR_MONTH FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(DAY_HOUR FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(DAY_HOUR FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(DAY_HOUR FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(DAY_HOUR FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(DAY_HOUR FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(DAY_MINUTE FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(DAY_MINUTE FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(DAY_MINUTE FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(DAY_MINUTE FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(DAY_MINUTE FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(DAY_SECOND FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(DAY_SECOND FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(DAY_SECOND FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(DAY_SECOND FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(DAY_SECOND FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(HOUR_MINUTE FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(HOUR_MINUTE FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(HOUR_MINUTE FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(HOUR_MINUTE FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(HOUR_MINUTE FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(HOUR_SECOND FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(HOUR_SECOND FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(HOUR_SECOND FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(HOUR_SECOND FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(HOUR_SECOND FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(MINUTE_SECOND FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(MINUTE_SECOND FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(MINUTE_SECOND FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(MINUTE_SECOND FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(MINUTE_SECOND FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(DAY_MICROSECOND FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(DAY_MICROSECOND FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(DAY_MICROSECOND FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(DAY_MICROSECOND FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(DAY_MICROSECOND FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(HOUR_MICROSECOND FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(HOUR_MICROSECOND FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(HOUR_MICROSECOND FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(HOUR_MICROSECOND FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(HOUR_MICROSECOND FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(MINUTE_MICROSECOND FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(MINUTE_MICROSECOND FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(MINUTE_MICROSECOND FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(MINUTE_MICROSECOND FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(MINUTE_MICROSECOND FROM a))
CREATE TABLE t1 (a TIME) PARTITION BY HASH (EXTRACT(SECOND_MICROSECOND FROM a))
CREATE TABLE t1 (a DATE) PARTITION BY HASH (EXTRACT(SECOND_MICROSECOND FROM a))
CREATE TABLE t1 (a DATETIME) PARTITION BY HASH (EXTRACT(SECOND_MICROSECOND FROM a))
CREATE TABLE t1 (a VARCHAR(10)) PARTITION BY HASH (EXTRACT(SECOND_MICROSECOND FROM a))
CREATE TABLE t1 (a INT) PARTITION BY HASH (EXTRACT(SECOND_MICROSECOND FROM a))
CREATE TABLE t1 (c TIMESTAMP) PARTITION BY RANGE (TO_DAYS(c)) (PARTITION p0 VALUES LESS THAN (10000), PARTITION p1 VALUES LESS THAN (MAXVALUE))
ALTER TABLE t2 PARTITION BY RANGE (TO_DAYS(c)) (PARTITION p0 VALUES LESS THAN (10000), PARTITION p1 VALUES LESS THAN (MAXVALUE))
CREATE TABLE t1 (c TIMESTAMP) PARTITION BY RANGE COLUMNS(c) (PARTITION p0 VALUES LESS THAN ('2000-01-01 00:00:00'), PARTITION p1 VALUES LESS THAN (MAXVALUE))
ALTER TABLE t2 PARTITION BY RANGE COLUMNS(c) (PARTITION p0 VALUES LESS THAN ('2000-01-01 00:00:00'), PARTITION p1 VALUES LESS THAN (MAXVALUE))
CREATE TABLE t1 (c TIMESTAMP) PARTITION BY RANGE (c) (PARTITION p0 VALUES LESS THAN ('2000-01-01 00:00:00'), PARTITION p1 VALUES LESS THAN (MAXVALUE))
CREATE TABLE t1 (c TIMESTAMP) PARTITION BY RANGE (UNIX_TIMESTAMP(c)) (PARTITION p0 VALUES LESS THAN ('2000-01-01 00:00:00'), PARTITION p1 VALUES LESS THAN (MAXVALUE))
CREATE TABLE t1 (c TIMESTAMP) PARTITION BY RANGE (UNIX_TIMESTAMP(c)) (PARTITION p0 VALUES LESS THAN (UNIX_TIMESTAMP('2000-01-01 00:00:00')), PARTITION p1 VALUES LESS THAN (MAXVALUE))
CREATE TABLESPACE ts1 ADD DATAFILE 'ts1.ibd'
CREATE TABLESPACE ts2 ADD DATAFILE 'ts2.ibd'
CREATE TABLESPACE ts3 ADD DATAFILE 'ts3.ibd'
CREATE TABLE t1 ( a int ) PARTITION BY RANGE (a) ( PARTITION p0 VALUES LESS THAN (1), PARTITION p1 VALU ES LESS THAN (2) partition by list (a) partitions 3 (partition x1 values in (1,2,9,4) tablespace ts1, partition x2 values in (3, 11, 5, 7) tablespace ts2, CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by list (a) partitions 2
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by key (a+2) partitions 3 (partition x1 tablespace ts1, partition x2 tablespace ts2, CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by key (a) partitions 3 (partition tablespace ts1, partition x2 tablespace ts2, CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by range columns (a,d) (partition x1 VALUES LESS THAN (1,1), partition x2 VALUES LESS THAN (2,2), partition x3 VALUES LESS THAN (3,3))
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by key (a) partitions 3 CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by hash (rand(a)) partitions 2 CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by range (rand(a)) partitions 2 CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by list (rand(a)) partitions 2 CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by hash (a) partitions 2 (partition x1 values less than (4), partition x2 values less than (5))
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by key (a) CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by key (a) subpartition by hash (sin(a+b)) (partition x1 (subpartition x11, subpartition x12), partition x2 (subpartition x21, subpartition x22))
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by range (a) subpartition by key (a+b) (partition x1 values less than (1) (subpartition x11, subpartition x12), CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by range (a) subpartition by key (a,d) (partition x1 values less than (1) (subpartition x11, subpartition x12), partition x2 values less than (2) (subpartition x21, subpartition x22))
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by range (a) partitions 2 (partition x1 values less than (4), CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by range (a) partitions 2 (partition x1 values in (4), partition x2)
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by list (a) partitions 2 (partition x1 values less than 4, CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by list (a) partitions 2 (partition x1 values less than (4), partition x2 values less than (5))
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by list (a) subpartition by hash (a+b) subpartitions 3 ( partition x1 values in (1,2,4) ( subpartition x11 nodegroup 0, subpartition x12 nodegroup 1), partition x2 values in (3,5,6) ( subpartition x21 nodegroup 0, subpartition x22 nodegroup 1) CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by list (a) subpartition by hash (a+b) ( partition x1 values in (1) ( subpartition x11 nodegroup 0, subpartition xextra, subpartition x12 nodegroup 1), partition x2 values in (2) ( subpartition x21 nodegroup 0, subpartition x22 nodegroup 1) CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by key (a) subpartition by list (a+b) ( partition x1 ( subpartition x11, subpartition x12), partition x2 ( subpartition x21, subpartition x22) CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key (a,b)) partition by key (a) subpartition by list (a+b) ( partition x1 ( subpartition x11 values in (0), subpartition x12 values in (1)), partition x2 ( subpartition x21 values in (0), subpartition x22 values in (1)) CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by list (a)
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by list (a) partitions 2 (partition x1 values in (4), CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by list (a) partitions 2 (partition x1 values in (4), partition x2 values less than (5))
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by list (a) partitions 2 (partition x1 values in (4,6), CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by list (a) partitions 2 (partition x1 values in (4, 12+9), partition x2 values in (3, 21))
CREATE TABLE t1 ( a int not null, b int not null, c int not null, primary key(a,b)) partition by list (a) partitions 2 (partition x1 values in 4, DROP TABLESPACE ts1
CALL mtr.add_suppression(" corrupted: row in wrong partition: ")
CREATE TABLE t1(a DATETIME) PARTITION BY HASH (EXTRACT(HOUR_MICROSECOND FROM a))
send UNINSTALL COMPONENT "file://component_example_component1", "file://component_example_component3", "file://component_example_component2"
lock tables t2 read
unlock tables
handler t1 open
handler t1 open t
handler t close
lock table t1 read
unlock tables
lock table t1 write
unlock tables
handler t1 close
rename table t2 to t1
handler t1 open
handler t1 close
handler t1 open
lock table t1 write
handler t1 close
unlock tables
handler t1 open
handler t1 close
lock table t1 read
unlock tables
lock table t1 write
unlock tables
rename table t2 to t1
lock table t1 write
unlock tables
handler t1 open
handler t1 close
lock table t1 read
unlock tables
unlock tables
rename table t2 to t1
handler t1 open
handler t1 close
unlock tables
unlock tables
rename table t2 to t1
handler t1 open
handler t1 close
unlock tables
unlock tables
rename table t2 to t1
handler t1 open
handler t1 close
lock tables t1 read
unlock tables
unlock tables
rename table t2 to t1
lock table t1 read
handler t1 open
handler t1 close
unlock tables
lock table t1 read
unlock tables
lock table t1 read
lock table t1 read
unlock tables
unlock tables
unlock tables
lock table t1 read
unlock tables
rename table t2 to t1
lock table t1 read
unlock tables
handler t1 open
handler t1 close
lock tables t1 read
unlock tables
unlock tables
rename table t2 to t1
lock table t1 write
handler t1 open
handler t1 close
unlock tables
lock table t1 write
unlock tables
lock table t1 write
unlock tables
lock table t1 write
unlock tables
lock table t1 write
unlock tables
unlock tables
lock table t1 write
unlock tables
unlock tables
lock table t1 write
unlock tables
rename table t2 to t1
lock tables t2 read
unlock tables
handler t1 close
lock tables t2 read
unlock tables
lock tables t2 read
unlock tables
lock tables t2 read
unlock tables
lock tables t2 read
unlock tables
lock tables t2 read
unlock tables
lock tables t2 read
unlock tables
unlock tables
lock tables t2 read
unlock tables
unlock tables
lock tables t2 read
unlock tables
rename table t3 to t1
lock table t1 read
handler t1 open t
handler t close
unlock tables
unlock tables
lock table t1 read
unlock tables
lock table t1 read
handler t1 open t
handler t close
lock table t1 read
unlock tables
unlock tables
handler t1 open t
handler t close
unlock tables
unlock tables
handler t1 open t
handler t close
handler t1 open t
handler t close
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
unlock tables
handler t1 close
unlock tables
handler t1 open
handler t1 close
unlock tables
lock table t2 write
unlock tables
lock table t2 write
unlock tables
unlock tables
unlock tables
rename table t3 to t2
rename table t3 to t2
handler t1 open
lock table t1 write
unlock tables
handler t1 close
handler t1 open
lock table t1 write, t2 read
send alter table t1 drop column j
handler t1 close
unlock tables
handler t1 open
lock table t1 write
handler t1 close
unlock tables
handler t1 open
lock table t1 write, t2 write
handler t1 close
unlock tables
handler t1 open
lock table t1 write, t2 read local
send alter table t1 add column j int
handler t1 close
unlock tables
handler t1 open
handler t2 open
lock table t1 write, t2 read local
unlock tables
handler t1 close
handler t2 close
lock table t1 write
unlock tables
unlock tables
send flush tables t1, t2 with read lock
reap
unlock tables
reap
send flush tables t1, t2 with read lock
send select * from t1 where i in (select j from t2 for update)
reap
unlock tables
reap
send select * from t2, t1
send flush tables t2 with read lock
send drop tables t1, t2
reap
unlock tables
reap
reap
unlock table
rename table t3 to t0, t2 to t3, t1 to t2, t0 to t1
send flush tables t1, t2 with read lock
send flush tables
reap
unlock tables
reap
lock tables t4 read
where state= 'Waiting for table metadata lock' and info='rename table t3 to t5, t4 to t3'
where state= 'Waiting for table metadata lock' and info='insert into t1 values (1)'
unlock tables
lock tables t1 read
unlock tables
unlock tables
lock tables t1 write
unlock tables
lock tables t1 write
unlock tables
lock tables t3 write
unlock tables
unlock tables
UNLOCK TABLES
UNLOCK TABLES
call mtr.add_suppression("Wait on a lock was aborted due to a pending exclusive lock")
HANDLER t1 OPEN
HANDLER t1 CLOSE
LOCK TABLES t1 WRITE
send TRUNCATE TABLE t1
send FLUSH TABLES t1
WHERE state='Waiting for table metadata lock' AND info='TRUNCATE TABLE t1'
reap
UNLOCK TABLES
reap
reap
WHERE state='Waiting for schema metadata lock' AND info='CREATE DATABASE db1'
WHERE state='Waiting for schema metadata lock' AND info='ALTER DATABASE db1 DEFAULT CHARACTER SET utf8'
WHERE state='Waiting for schema metadata lock' AND info='DROP DATABASE db1'
WHERE state='Waiting for schema metadata lock' AND info='DROP DATABASE db1'
WHERE state='Waiting for schema metadata lock' AND info='ALTER DATABASE db1 DEFAULT CHARACTER SET utf8'
WHERE state='Waiting for schema metadata lock' AND info='CREATE TABLE db1.t1 (a INT)'
WHERE state='Waiting for schema metadata lock' AND info='RENAME TABLE db1.t1 TO test.t1'
WHERE state='Waiting for schema metadata lock' AND info='RENAME TABLE test.t2 TO db1.t2'
WHERE state='Waiting for schema metadata lock' AND info='DROP TABLE db1.t1'
FLUSH TABLE WITH READ LOCK
WHERE state='Waiting for global read lock' AND info='CREATE TABLE db1.t2(a INT)'
UNLOCK TABLES
FLUSH TABLE WITH READ LOCK
WHERE state='Waiting for global read lock' AND info='ALTER DATABASE db1 DEFAULT CHARACTER SET utf8'
UNLOCK TABLES
FLUSH TABLE WITH READ LOCK
FLUSH TABLE WITH READ LOCK
UNLOCK TABLES
UNLOCK TABLES
LOCK TABLES t1 WRITE
UNLOCK TABLES
RENAME TABLE t1 TO T1
perl
my $log= $ENV{'MYSQLD_LOG'} or die
open(FILE, "$log") or die
my $c_w= grep(/Different lower_case_table_names settings/gi,<FILE>)
print "#    Found lower_case_table_names error $c_w times.\n"
close(FILE)
GRANT PROXY ON 'employee'@'localhost' TO 'empl_external'@'localhost'
create table `t``1`(a int) engine=myisam
drop table `t``1`, `t 1`
CREATE TABLE `t1` ( `a b` INT, `c"d` INT, `e``f` INT, PRIMARY KEY (`a b`, `c"d`, `e``f`) ) ENGINE=MyISAM DEFAULT CHARSET=latin1
CREATE PROCEDURE simpleproc1 (OUT param1 INT) BEGIN SELECT COUNT(*) INTO param1 FROM t1; END
CREATE PROCEDURE simpleproc2 (OUT param1 INT) BEGIN SELECT COUNT(*) INTO param1 FROM t2; END
CREATE EVENT e1 ON SCHEDULE EVERY 1 SECOND DO DROP DATABASE BUG52792
CREATE EVENT e2 ON SCHEDULE EVERY 1 SECOND DO DROP DATABASE BUG52792
PREPARE p FROM "SELECT id, sex, LEAD(id, ?) OVER () FROM t1"
EXECUTE p USING @p1
EXECUTE p USING @p1
EXECUTE p USING @p1
PREPARE p FROM "SELECT id, sex, LEAD(id+?, ?, ?) RESPECT NULLS OVER () FROM t1"
EXECUTE p USING @p1, @p2, @p3
EXECUTE p USING @p1, @p2, @p3
DROP PREPARE p
DO TO_SECONDS(LAG(POINT(2.804466E+307,-2032),75) OVER())
DO IS_IPV4(TIMESTAMP(LAG(-19131 ,188) OVER(),@F))
DO WEEKOFYEAR(LAG(-16726 ,247)RESPECT NULLS OVER())
DO DAYOFYEAR(LEAD(-6653420797178186265 ,29)OVER())
DO YEARWEEK(LEAD(FOUND_ROWS(),250)OVER())
DO DAYOFYEAR(LAG('] .| /= ',63) OVER())
DO IFNULL((DAYNAME(LEAD(STDDEV(@F),162) OVER())),(0xD73E))
DO TO_DAYS(LEAD(((LOCATE(0xA812,0xE8DE))OR(@G)),148)OVER())
DO WEEKOFYEAR(LEAD(('5183-10-18 06:15:35.076079')SOUNDS LIKE(0x9E335D89),68)OVER())
DO DAYOFYEAR(LEAD(ROW_COUNT(),177)OVER())
DO MONTHNAME(LAG(' =',74) OVER())
DO SHA(BIN(MONTHNAME(LEAD(UNCOMPRESSED_LENGTH(SHA1("")),224)OVER())))
DO (((NOT(1)))^(HOUR(MONTHNAME(LEAD(DATABASE(),89)OVER()))))
DO MONTHNAME(LEAD(CHARSET(CONVERT((MOD(CURTIME(4),STDDEV(NULL)))USING CP850)),12) OVER())
DO LAST_DAY(LAG(NULL,113) OVER())
DO LAST_DAY(LEAD(-2201 ,98)RESPECT NULLS OVER())
DO OCTET_LENGTH(((LAST_DAY(LEAD(-28178,163)OVER()))OR(COLLATION(@E))))
DO LAST_DAY(LAG('*',36)RESPECT NULLS OVER())
DO LAST_DAY(LEAD( _CP932 '',241)OVER(RANGE UNBOUNDED PRECEDING))
DO ((CAST((LEAD(NULL,152) OVER()) AS TIME))*(1))
DO CAST((LAG(SHA(STDDEV('-0E%_')),224) OVER()) AS TIME)
DO CAST((LAG(_UJIS '8CA} ',144) OVER()) AS TIME)
DO CAST((LAG(-16520,156) OVER()) AS TIME)
DO CAST((LEAD(-6011,202) OVER()) AS TIME)
DO CAST((LEAD(0x45,104) OVER())AS TIME)
DO CAST((LAG(POLYGON( LINESTRING( POINT(4099,17421), POINT(22259,-5875.0796), POINT(30179,6542), POINT(12331,-18840)), LINESTRING( POINT( 8162.2539,-29332), POINT(24157,-23393), POINT(268435459,-26835), POINT(3.933871E+307,-25808)), LINESTRING( POINT(30360,-1049), POINT(15405,5.816757E+307), POINT( 3717.3555,1.599730E+308), POINT(-23002,-19077))), 70) OVER()) AS DATETIME )
DO UNIX_TIMESTAMP( LAG(ROUND(((UTC_TIME()) OR ((NOT (INET6_ATON(IS_IPV4(((MAKETIME(-10966, 233, 2795.439453)) OR(MAKEDATE(-3030,19)))))))))), 140) OVER())
DO LAST_DAY(SQRT(CAST((LAG(REPEAT('B',64),91)OVER())AS DATETIME)))
DO CAST((LEAD(-197994311,60)OVER())AS DATETIME)
DO IFNULL((NULL ),(UNIX_TIMESTAMP(LEAD(NULL,12)RESPECT NULLS OVER())))
DO ((CONVERT((VARIANCE(-18951))USING CP866)) <= (JSON_ARRAY(LEAD(CAST((35184372088833)AS DATETIME),126)OVER())))
DO ((LAG(LAST_DAY("]<$*_#[DB!^+ : 3"),89) OVER (RANGE UNBOUNDED PRECEDING)) > (CONVERT(("1985-10-19 03:36:29.304455" - INTERVAL(0x1446C5A2627FB06D88DC63D66B36DF) DAY_MICROSECOND) USING BIG5)))
CREATE USER u1@192.129.12.11
CREATE DEFINER = u1@192.129.12.11 VIEW v3 as SELECT * FROM t1
DROP USER u1@192.129.12.11
SELECT @@global.syseventlog.tag
SELECT @@global.syseventlog.tag
SELECT @@global.syseventlog.tag
SELECT @@global.syseventlog.tag
CALL mtr.add_suppression("--character-set-server: 'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.")
DELIMITER
LOCK TABLES t1 WRITE
UNLOCK TABLES
